<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="LH_R"><title>解析Vue3patch核心算法patchKeyedChildren · LH'BLOG</title><meta name="description" content="解析Vue3patch核心算法patchKeyedChildren
locate：runtime-core &amp;gt; renderer &amp;gt; baseCreateRenderer &amp;gt; patchKeyedChildren
patchKeyedChildren是patch算法中较为复杂的一段"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.jpeg" style="width:220px; border-radius:110px" alt="favicon"><h3 title=""><a href="/">LH'BLOG</a></h3><div class="description"><p>keep learning</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/lhrun"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="noopener" href="https://segmentfault.com/u/lh_s"><i class="fa fa-segmentfault"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> LH_R</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>解析Vue3patch核心算法patchKeyedChildren</a></h3></div><div class="post-content"><p><h3 id="解析Vue3patch核心算法patchKeyedChildren"><a href="#解析Vue3patch核心算法patchKeyedChildren" class="headerlink" title="解析Vue3patch核心算法patchKeyedChildren"></a>解析Vue3patch核心算法patchKeyedChildren</h3><ul>
<li>locate：<code>runtime-core &gt; renderer &gt; baseCreateRenderer &gt; patchKeyedChildren</code></li>
<li>patchKeyedChildren是patch算法中较为复杂的一段，更是vue技术栈面试的高频点，最初我是在vue3.0 beta版本时大概看过源码，后来在《vue设计与分析》中看了霍春阳大佬的解析，本篇就简要分析一下做个记录</li>
<li>首先patchKeyedChildren是在子列表对比并且有key的情况会进入，并且逻辑大致分为5步，这个看源码官方注释就可以看出</li>
</ul>
<h4 id="第一步，从前向后遍历"><a href="#第一步，从前向后遍历" class="headerlink" title="第一步，从前向后遍历"></a>第一步，从前向后遍历</h4><p>这一步是从节点组头部向尾部遍历，如果遍历过程中遇到相似节点，就进行patch对比，否则就退出遍历，并记录当前遍历的最新下标</p>
<pre><code class="js">while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
  const n1 = c1[i]
  const n2 = (c2[i] = optimized
    ? cloneIfMounted(c2[i] as VNode)
    : normalizeVNode(c2[i]))
  if (isSameVNodeType(n1, n2)) &#123;
    patch(
      n1,
      n2,
      container,
      null,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; else &#123;
    break
  &#125;
  i++
&#125;
</code></pre>
<h4 id="第二步，从后向前遍历"><a href="#第二步，从后向前遍历" class="headerlink" title="第二步，从后向前遍历"></a>第二步，从后向前遍历</h4><p>从后向前遍历，如果遇到第一步记录的下标就停止，然后遍历过程中，如果遇到相似节点也是直接进行patch对比，如果不相同就是直接退出遍历，并且记录旧节点组和新节点组的尾指针</p>
<pre><code class="js">while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
  const n1 = c1[e1]
  const n2 = (c2[e2] = optimized
    ? cloneIfMounted(c2[e2] as VNode)
    : normalizeVNode(c2[e2]))
  if (isSameVNodeType(n1, n2)) &#123;
    patch(
      n1,
      n2,
      container,
      null,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; else &#123;
    break
  &#125;
  e1--
  e2--
&#125;
</code></pre>
<h4 id="第三步，检查旧节点组"><a href="#第三步，检查旧节点组" class="headerlink" title="第三步，检查旧节点组"></a>第三步，检查旧节点组</h4><p>这一步就是检查旧节点组在上两步的遍历后是否遍历完，如果遍历完，那么新节点组没有遍历完的就都是新的dom，可以全部当作新增节点进行挂载处理</p>
<pre><code class="js">if (i &gt; e1) &#123;
  if (i &lt;= e2) &#123;
    const nextPos = e2 + 1
    const anchor = nextPos &lt; l2 ? (c2[nextPos] as VNode).el : parentAnchor
    while (i &lt;= e2) &#123;
      // patch第一个参数为null，就是代表没有旧节点，直接将新节点插入
      patch(
        null,
        (c2[i] = optimized
          ? cloneIfMounted(c2[i] as VNode)
          : normalizeVNode(c2[i])),
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      )
      i++
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="第四步，检查新节点组"><a href="#第四步，检查新节点组" class="headerlink" title="第四步，检查新节点组"></a>第四步，检查新节点组</h4><p>如果上一步检查旧节点未遍历完，那么就检查新节点组是否遍历完，如果遍历完，那么旧的节点组剩余的节点说明都是要卸载的，因为都不需要了</p>
<pre><code class="js">else if (i &gt; e2) &#123;
  // 旧子节点未被遍历完
  while (i &lt;= e1) &#123;
    unmount(c1[i], parentComponent, parentSuspense, true)
    i++
  &#125;
&#125;
</code></pre>
<h4 id="第五步，未知序列"><a href="#第五步，未知序列" class="headerlink" title="第五步，未知序列"></a>第五步，未知序列</h4><ul>
<li>如果新旧节点组都未遍历完，说明存在未知序列，可能存在位移等情况，就需要进一步处理</li>
<li>首先创建一个数组，用于记录新旧节点的对应关系</li>
</ul>
<pre><code class="js">// toBePatched是新序列的节点数量 e2 - s2 + 1
const newIndexToOldIndexMap = new Array(toBePatched)
for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0
</code></pre>
<ul>
<li>然后会遍历旧节点组，这里会用两个变量记录<ul>
<li><code>let moved = false</code>：位移标识，用于判断是否需要位移</li>
<li><code>let patched = 0</code>：记录已执行patch的新节点数量，用于处理如果在更新时更新过的数量大于需要更新的节点数量，就卸载对应旧节点</li>
</ul>
</li>
</ul>
<pre><code class="js">for (i = s1; i &lt;= e1; i++) &#123;
  const prevChild = c1[i]
  // 如果已更新数量大于新节点数量，就卸载节点
  if (patched &gt;= toBePatched) &#123;
    unmount(prevChild, parentComponent, parentSuspense, true)
    continue
  &#125;
  let newIndex //新旧节点key相同的新节点index
  if (prevChild.key != null) &#123;
    newIndex = keyToNewIndexMap.get(prevChild.key)
  &#125; else &#123;
    for (j = s2; j &lt;= e2; j++) &#123;
      if (
        newIndexToOldIndexMap[j - s2] === 0 &amp;&amp;
        isSameVNodeType(prevChild, c2[j] as VNode)
      ) &#123;
        newIndex = j
        break
      &#125;
    &#125;
  &#125;
  // 如果newIndex为空，则说明未找到与旧节点对应的新节点，直接卸载
  if (newIndex === undefined) &#123;
    unmount(prevChild, parentComponent, parentSuspense, true)
  &#125; else &#123;
    // 更新新旧节点关系表
    newIndexToOldIndexMap[newIndex - s2] = i + 1
    /**
     * 这里的maxNexIndexSoFar是记录每次patch最大index
     * 也是用于判断是否产生了位移，因为如果新节点index比最大index小，就说明发生了位移
     * 例如：
     *  (a b) c
     *  (a c  b)
     * 在新旧序列对比b，c时，由于c最新的newIndex已经小于b对应的newIndex，因此会记录需要位移
     */
    if (newIndex &gt;= maxNewIndexSoFar) &#123;
      maxNewIndexSoFar = newIndex
    &#125; else &#123;
      moved = true
    &#125;
    patch(
      prevChild,
      c2[newIndex] as VNode,
      container,
      null,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
    patched++
  &#125;
&#125;
</code></pre>
<ul>
<li>遍历完旧序列后，就需要确定如何位移</li>
<li>首先是根据新旧节点关系表生成最长递增子序列(这个算法就不陈述了，较复杂，可以看<a target="_blank" rel="noopener" href="https://juejin.cn/post/6952674285311754276#comment">精读《DOM diff 最长上升子序列》</a>)，然后倒序遍历新子节点</li>
</ul>
<pre><code class="js">// 最长递增子序列
const increasingNewIndexSequence = moved
  ? getSequence(newIndexToOldIndexMap)
  : EMPTY_ARR
j = increasingNewIndexSequence.length - 1
// 从新序列尾部向前遍历，目的是为了使用上一个遍历的节点做锚点
for (i = toBePatched - 1; i &gt;= 0; i--) &#123;
  const nextIndex = s2 + i
  const nextChild = c2[nextIndex] as VNode
  // 如果是序列的最后一个节点，anchor就是父节点对应的anchor，否则就是上一个子节点
  const anchor =
    nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor
  // 如果newIndexToOldIndexMap[i]还是0，那么说明新节点没有对应的旧节点，说明是新节点，直接挂载
  if (newIndexToOldIndexMap[i] === 0) &#123;
    patch(
      null,
      nextChild,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; else if (moved) &#123;
    // 然后在moved为true的情况下，如果最长子序列为空或者最长子序列和当前访问的新节点index不同，说明就需要进行位移
    if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123;
      move(nextChild, container, anchor, MoveType.REORDER)
    &#125; else &#123;
      j--
    &#125;
  &#125;
&#125;
</code></pre>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>作者: LH_R</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-25</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>大约1377个字, 4分钟35秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2022/08/25/解析Vue3patch核心算法patchKeyedChildren/,LH'BLOG,解析Vue3patch核心算法patchKeyedChildren,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/08/27/Vue3-Vite3-SSR%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/" title="Vue3+Vite3 SSR基本搭建">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/08/24/pnpm%E7%9A%84node-modules%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/" title="pnpm的node_modules结构设计">下一篇</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>