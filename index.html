<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="LH_R"><title>LH'BLOG</title><meta name="description" content="keep learning"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.jpeg" style="width:220px; border-radius:110px" alt="favicon"><h3 title=""><a href="/">LH'BLOG</a></h3><div class="description"><p>keep learning</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/lhrun"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="noopener" href="https://segmentfault.com/u/lh_s"><i class="fa fa-segmentfault"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> LH_R</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/31/Vue3%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">Vue3模版编译原理</a></h3></div><div class="post-content"><div class="card"><p><h2 id="模版编译流程"><a href="#模版编译流程" class="headerlink" title="模版编译流程"></a>模版编译流程</h2><p>Vue3模版编译就是把template字符串编译成渲染函数</p>
<pre><code class="js">// template
&lt;div&gt;&lt;p&gt;&#123;&#123;LH_R&#125;&#125;&lt;/p&gt;&lt;/div&gt;

// render
import &#123; toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock &#125; from &quot;vue&quot;

export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;
  return (_openBlock(), _createElementBlock(&quot;div&quot;, null, [
    _createElementVNode(&quot;p&quot;, null, _toDisplayString(_ctx.LH_R), 1 /* TEXT */)
  ]))
&#125;
</code></pre>
<p>我会按照编译流程分3步分析</p>
<ol>
<li><strong>parse</strong>：将模版字符串转换成模版AST</li>
<li><strong>transform</strong>：将模版AST转换为用于描述渲染函数的AST</li>
<li><strong>generate</strong>：根据AST生成渲染函数</li>
</ol>
<pre><code class="ts">export function baseCompile(
  template: string | RootNode,
  options: CompilerOptions = &#123;&#125;
): CodegenResult &#123;
  // ...
  const ast = isString(template) ? baseParse(template, options) : template

  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(
    prefixIdentifiers
  )
  transform(
    ast,
    extend(&#123;&#125;, options, &#123;
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...(options.nodeTransforms || []) // user transforms
      ],
      directiveTransforms: extend(
        &#123;&#125;,
        directiveTransforms,
        options.directiveTransforms || &#123;&#125; // user transforms
      )
    &#125;)
  )

  return generate(
    ast,
    extend(&#123;&#125;, options, &#123;
      prefixIdentifiers
    &#125;)
  )
&#125;
</code></pre>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><ul>
<li>parse对模版字符串进行遍历，然后循环判断开始标签和结束标签把字符串分割成一个个<strong>token</strong>，存在一个token列表，然后扫描token列表并维护一个开始标签栈，每当扫描一个开始标签节点，就将其压入栈顶，栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有Token扫描完成后，即可构建成一颗树形AST</li>
<li>以下是简化版<strong>parseChildren</strong>源码，是parse的主入口</li>
</ul>
<pre><code class="ts">function parseChildren(
  context: ParserContext,
  mode: TextModes,
  ancestors: ElementNode[] // 节点栈结构，用于维护节点嵌套关系
): TemplateChildNode[] &#123;
  // 获取父节点
  const parent = last(ancestors)
  const ns = parent ? parent.ns : Namespaces.HTML
  const nodes: TemplateChildNode[] = [] // 存储解析出来的AST子节点

  // 遇到闭合标签结束解析
  while (!isEnd(context, mode, ancestors)) &#123;
    // 切割处理的模版字符串
    const s = context.source
    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined

    if (mode === TextModes.DATA || mode === TextModes.RCDATA) &#123;
      if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) &#123;
        // 解析插值表达式&#123;&#123;&#125;&#125;
        node = parseInterpolation(context, mode)
      &#125; else if (mode === TextModes.DATA &amp;&amp; s[0] === &#39;&lt;&#39;) &#123;
        if (s[1] === &#39;!&#39;) &#123;
          // 解析注释节点和文档声明...
        &#125; else if (s[1] === &#39;/&#39;) &#123;
          if (s[2] === &#39;&gt;&#39;) &#123;
            // 针对自闭合标签，前进三个字符
            advanceBy(context, 3)
            continue
          &#125; else if (/[a-z]/i.test(s[2])) &#123;
            // 解析结束标签
            parseTag(context, TagType.End, parent)
            continue
          &#125; else &#123;
            // 如果不符合上述情况，就作为伪注释解析
            node = parseBogusComment(context)
          &#125;
        &#125; else if (/[a-z]/i.test(s[1])) &#123;
          // 解析html开始标签，获得解析到的AST节点
          node = parseElement(context, ancestors)
        &#125;
      &#125;
    &#125;
    if (!node) &#123;
      // 普通文本节点
      node = parseText(context, mode)
    &#125;

    // 如果节点是数组，就遍历添加到nodes中
    if (isArray(node)) &#123;
      for (let i = 0; i &lt; node.length; i++) &#123;
        pushNode(nodes, node[i])
      &#125;
    &#125; else &#123;
      pushNode(nodes, node)
    &#125;
  &#125;
  return nodes
&#125;
</code></pre>
<ul>
<li>就拿<code>&lt;div&gt;&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;</code>流程举例</li>
</ul>
<ol>
<li>div开始标签入栈，context.source &#x3D; <code>&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;</code>，ancestors &#x3D; <code>[div]</code></li>
<li>p开始标签入栈，context.source &#x3D; <code>LH_R&lt;/p&gt;&lt;/div&gt;</code>，ancestors &#x3D; <code>[div, p]</code></li>
<li>解析文本<code>LH_R</code></li>
<li>解析p结束标签，p标签出栈</li>
<li>解析div结束标签，div标签出栈</li>
<li>栈空，模版解析完毕</li>
</ol>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul>
<li>transform采用深度优先的方式对AST进行遍历，在遍历过程中，对节点的操作与转换采用插件化架构，都封装为独立的函数，然后转换函数通过<code>context.nodeTransforms</code>来注册</li>
<li>转换过程是优先转换子节点，因为有的父节点的转换依赖子节点</li>
<li>以下是AST遍历<code>traverseNode</code>核心源码</li>
</ul>
<pre><code class="ts">/* 
  遍历AST节点树，通过node转换器对当前节点进行node转换
  子节点全部遍历完成后执行对应指令的onExit回调退出转换
*/
export function traverseNode(
  node: RootNode | TemplateChildNode,
  context: TransformContext
) &#123;
  // 记录当前正在遍历的节点
  context.currentNode = node

  /* 
    nodeTransforms：transformElement、transformExpression、transformText...
    transformElement：负责整个节点层面的转换
    transformExpression：负责节点中表达式的转化
    transformText：负责节点中文本的转换
  */
  const &#123; nodeTransforms &#125; = context
  const exitFns = []
  // 依次调用转换工具
  for (let i = 0; i &lt; nodeTransforms.length; i++) &#123;
    /* 
      转换器只负责生成onExit回调，onExit函数才是执行转换主逻辑的地方，为什么要推到栈中先不执行呢？
      因为要等到子节点都转换完成挂载gencodeNode后，也就是深度遍历完成后
      再执行当前节点栈中的onExit，这样保证了子节点的表达式全部生成完毕
    */
    const onExit = nodeTransforms[i](node, context)
    if (onExit) &#123;
      if (isArray(onExit)) &#123;
        // v-if、v-for为结构化指令，其onExit是数组形式
        exitFns.push(...onExit)
      &#125; else &#123;
        exitFns.push(onExit)
      &#125;
    &#125;
    if (!context.currentNode) &#123;
      // node was removed 节点被移除
      return
    &#125; else &#123;
      // node may have been replaced
      // 因为在转换的过程中节点可能被替换，恢复到之前的节点
      node = context.currentNode
    &#125;
  &#125;

  switch (node.type) &#123;
    case NodeTypes.COMMENT:
      if (!context.ssr) &#123;
        // inject import for the Comment symbol, which is needed for creating
        // comment nodes with `createVNode`
        // 需要导入createComment辅助函数
        context.helper(CREATE_COMMENT)
      &#125;
      break
    case NodeTypes.INTERPOLATION:
      // no need to traverse, but we need to inject toString helper
      if (!context.ssr) &#123;
        context.helper(TO_DISPLAY_STRING)
      &#125;
      break

    // for container types, further traverse downwards
    case NodeTypes.IF:
      // 对v-if生成的节点束进行遍历
      for (let i = 0; i &lt; node.branches.length; i++) &#123;
        traverseNode(node.branches[i], context)
      &#125;
      break
    case NodeTypes.IF_BRANCH:
    case NodeTypes.FOR:
    case NodeTypes.ELEMENT:
    case NodeTypes.ROOT:
      // 遍历子节点
      traverseChildren(node, context)
      break
  &#125;
  // 当前节点树遍历完成，依次执行栈中的指令退出回调onExit
  context.currentNode = node
  let i = exitFns.length
  while (i--) &#123;
    exitFns[i]()
  &#125;
&#125;
</code></pre>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>generate</code>生成代码大致分为3步</p>
<ol>
<li>创建代码生成上下文，因为该上下文对象是用于维护代码生成过程中程序的运行状态，如：</li>
</ol>
<ul>
<li><code>code</code>：最终生成的渲染函数</li>
<li><code>push</code>：拼接代码</li>
<li><code>indent</code>：代码缩进</li>
<li><code>deindent</code>：减少代码缩进</li>
<li>…</li>
</ul>
<ol start="2">
<li>生成渲染函数的前置预设部分<ul>
<li>module模式下：<code>genModulePreamble()</code></li>
<li>function模式下：<code>genFunctionPreamble</code></li>
<li>还有一些函数名，参数，作用域…</li>
</ul>
</li>
<li>生成渲染函数<ul>
<li>通过调用<code>genNode</code>，然后在<code>genNode</code>内部通过switch语句来匹配不同类型的节点，并调用对应的生成器函数</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023594560">Vue3 模板编译原理</a></li>
<li>《Vue.js设计与实现》</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-31</span><span class="leancloud_visitors"></span><span>大约1494个字, 4分钟58秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/27/Vue3-Vite3-SSR%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/">Vue3+Vite3 SSR基本搭建</a></h3></div><div class="post-content"><div class="card"><p>excerpt Vue3+Vite3 SSR基本搭建</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-27</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vite/" title="Vite">Vite </a><i class="fa fa-tag"></i><a class="tag" href="/tags/SSR/" title="SSR">SSR </a><span class="leancloud_visitors"></span><span>大约2162个字, 7分钟12秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/25/%E8%A7%A3%E6%9E%90Vue3patch%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95patchKeyedChildren/">解析Vue3patch核心算法patchKeyedChildren</a></h3></div><div class="post-content"><div class="card"><p>解析Vue3patch核心算法patchKeyedChildren</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-25</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>大约1377个字, 4分钟35秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/24/pnpm%E7%9A%84node-modules%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">pnpm的node_modules结构设计</a></h3></div><div class="post-content"><div class="card"><p>针对npm的现存问题分析pnpm的node_modules结构设计</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-24</span><i class="fa fa-tag"></i><a class="tag" href="/tags/pnpm/" title="pnpm">pnpm </a><span class="leancloud_visitors"></span><span>大约1070个字, 3分钟34秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%80%91%E5%B8%83%E6%B5%81%E5%92%8C%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/">微信小程序瀑布流和虚拟列表</a></h3></div><div class="post-content"><div class="card"><p>微信小程序瀑布流和虚拟列表</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/微信小程序/" title="微信小程序">微信小程序 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/瀑布流/" title="瀑布流">瀑布流 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/虚拟列表/" title="虚拟列表">虚拟列表 </a><span class="leancloud_visitors"></span><span>大约1234个字, 4分钟6秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/09/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/">微信小程序图片上传&amp;九宫格拖拽组件</a></h3></div><div class="post-content"><div class="card"><p>微信小程序图片上传&九宫格拖拽组件</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-09-08</span><i class="fa fa-tag"></i><a class="tag" href="/tags/微信小程序/" title="微信小程序">微信小程序 </a><span class="leancloud_visitors"></span><span>大约1262个字, 4分钟12秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%95%E6%8C%87%E6%8B%96%E6%8B%BD%E5%92%8C%E5%8F%8C%E6%8C%87%E7%BC%A9%E6%94%BE%E6%97%8B%E8%BD%AC/">微信小程序单指拖拽和双指缩放旋转</a></h3></div><div class="post-content"><div class="card"><p>微信小程序单指拖拽和双指缩放旋转</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-08-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/微信小程序/" title="微信小程序">微信小程序 </a><span class="leancloud_visitors"></span><span>大约751个字, 2分钟30秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/08/01/%E8%A7%A3%E6%9E%90reactive-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/">解析reactive---vue3响应式</a></h3></div><div class="post-content"><div class="card"><p>解析reactive---vue3响应式</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-08-01</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>大约2765个字, 9分钟13秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/07/17/%E8%A7%A3%E6%9E%90nextTick-vue3%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">解析nextTick---vue3任务调度</a></h3></div><div class="post-content"><div class="card"><p>解析nextTick---vue3任务调度</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-07-17</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>大约1215个字, 4分钟3秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/06/12/%E8%A7%A3%E5%86%B3react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-ReactQuery/">解决react状态管理---React Query</a></h3></div><div class="post-content"><div class="card"><p>解决react状态管理---React Query</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-06-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a><i class="fa fa-tag"></i><a class="tag" href="/tags/ReactQuery/" title="ReactQuery">ReactQuery </a><span class="leancloud_visitors"></span><span>大约897个字, 2分钟59秒读完</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>