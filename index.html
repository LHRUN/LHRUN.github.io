<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="LH_R"><title>LH'BLOG</title><meta name="description" content="keep learning"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a class="current" href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.jpeg" style="width:220px; border-radius:110px" alt="favicon"><h3 title=""><a href="/">LH'BLOG</a></h3><div class="description"><p>keep learning</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/lhrun"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="noopener" href="https://segmentfault.com/u/lh_s"><i class="fa fa-segmentfault"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> LH_R</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/27/Vue3-Vite3-SSR%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/">Vue3+Vite3 SSR基本搭建</a></h3></div><div class="post-content"><div class="card"><p><h2 id="Vue3-Vite3-SSR基本搭建"><a href="#Vue3-Vite3-SSR基本搭建" class="headerlink" title="Vue3+Vite3 SSR基本搭建"></a>Vue3+Vite3 SSR基本搭建</h2><ul>
<li>首先说明如果是生产使用强烈推荐Nuxt，但是如果想深入服务端渲染的运行原理，可以看本篇，会根据渲染流程搭建一个demo版ssr，源码在最后会贴上</li>
<li>主要技术栈：Vite3 + Vue3 + pinia + VueRouter4 + express</li>
<li>开始搭建之前，先说一下SSR渲染流程</li>
</ul>
<h3 id="SSR渲染流程"><a href="#SSR渲染流程" class="headerlink" title="SSR渲染流程"></a>SSR渲染流程</h3><ul>
<li>首先浏览器向服务器请求，然后服务器根据请求的路由，会匹配相关的路由组件，然后执行组件的自定义服务端生命周期(例：Nuxt的asyncData)或者自定义获取数据的hook，并且把执行后的数据收集起来，统一在window的属性中存储</li>
<li>然后vue的组件会被renderToString渲染成静态HTML字符串，替换掉index.html的提前指定的占位代码。然后index.html改变后的静态字符串发给客户端</li>
<li>客户端拿到后，首先对数据进行初始化，然后进行激活，因为当前html只是静态数据，激活主要做两件事<ul>
<li><ol>
<li>把页面中的DOM元素与虚拟DOM之间建立联系</li>
</ol>
</li>
<li><ol start="2">
<li>为页面中的DOM元素添加事件绑定</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><ul>
<li>首先用vite命令创建项目<code>pnpm create vite vue-ssr --template vue-ts</code><ul>
<li>安装相关依赖：<code>pnpm add express pinia vue-router@4</code></li>
</ul>
</li>
<li>创建三个文件 <code>touch server.js src src/entry-client.ts src/entry-server.js</code><ul>
<li>server.js：服务端启动文件</li>
<li>entry-client.ts：客户端入口，应用挂载元素</li>
<li>entry-server.js：服务端入口，处理服务端逻辑和静态资源</li>
</ul>
</li>
<li>修改<code>package.json</code>运行脚本<pre><code class="js">&quot;scripts&quot;: &#123;
  &quot;dev&quot;: &quot;node server&quot;, // 运行开发环境
&#125;
</code></pre>
</li>
<li>然后需要把应用创建都改为函数的方式进行调用创建，因为在SSR环境下，和纯客户端不一样，服务器只会初始化一次，所以为了防止状态污染，每次请求必须是全新的实例</li>
</ul>
<pre><code class="js">// src/main.ts
import &#123; createSSRApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;
import &#123; createRouter &#125; from &#39;./router&#39;
import &#123; createPinia &#125; from &#39;pinia&#39;

export function createApp() &#123;
  const app = createSSRApp(App)
  const router = createRouter()
  const pinia = createPinia()
  app.use(router)
  app.use(pinia)
  return &#123; app, router, pinia &#125;
&#125;
</code></pre>
<ul>
<li>roter同理</li>
</ul>
<pre><code class="js">// src/router/index
import &#123; createRouter as _createRrouter, createMemoryHistory, createWebHistory, RouteRecordRaw &#125; from &#39;vue-router&#39;

const routes: RouteRecordRaw[] = [
  ...
]

export function createRouter() &#123;
  return _createRrouter(&#123;
    history: import.meta.env.SSR ? createMemoryHistory() : createWebHistory(),
    routes,
  &#125;)
&#125;
</code></pre>
<ul>
<li>然后修改index.html，增加注释占位和客户端入口文件，在之后的服务端渲染时注入</li>
</ul>
<pre><code class="html">&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Vite + Vue + TS&lt;/title&gt;
    &lt;!-- 静态资源占位 .js .css ... --&gt;
    &lt;!--preload-links--&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 应用代码占位 --&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;!--ssr-outlet--&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;/src/main.ts&quot;&gt;&lt;/script&gt;
    &lt;!-- 引用客户端入口文件 --&gt;
    &lt;script type=&quot;module&quot; src=&quot;/src/entry-client.ts&quot; &gt;&lt;/script&gt;
    &lt;script&gt;
      // 服务端获取的数据统一挂载到window上
      window.__INITIAL_STATE__ = &#39;&lt;!--pinia-state--&gt;&#39;
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2-服务端启动文件"><a href="#2-服务端启动文件" class="headerlink" title="2. 服务端启动文件"></a>2. 服务端启动文件</h3><ul>
<li>创建项目后，就开始编写服务端启动文件，也就是项目根路径下的server.js文件</li>
<li>这个文件的功能是启动一个node服务，然后根据请求，读取html文件，处理资源后把注释进行替换，最后把html发送给客户端</li>
</ul>
<pre><code class="js">import fs from &#39;fs&#39;
import path from &#39;path&#39;
import &#123; fileURLToPath &#125; from &#39;url&#39;
import express from &#39;express&#39;

import &#123; createRequire &#125; from &#39;module&#39;;
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const require = createRequire(import.meta.url);
const resolve = (p) =&gt; path.resolve(__dirname, p);

const createServer = async () =&gt; &#123;
  // 创建node服务
  const app = express()

  /**
   * @官方解释
   * 以中间件模式创建vite应用，这将禁用vite自身的HTML服务逻辑
   * 并让上级服务器接管
   */
  const vite = await require(&#39;vite&#39;).createServer(&#123;
    server: &#123;
      middlewareMode: true,
    &#125;,
    appType: &#39;custom&#39;
  &#125;);
  app.use(vite.middlewares);
  
  app.use(&#39;*&#39;, async (req, res, next) =&gt; &#123;
    const url = req.originalUrl
    try &#123;
      // 读取index.html
      let template = fs.readFileSync(
        resolve(&#39;index.html&#39;),
        &#39;utf-8&#39;
      )
      // 应用vite html转换，会注入vite HMR
      template = await vite.transformIndexHtml(url, template)

      // 加载服务端入口
      const render = (await vite.ssrLoadModule(&#39;/src/entry-server.js&#39;)).render
      const [ appHtml, piniaState ] = await render(url)

      // 替换处理过后的模版
      const html = template
        .replace(`&lt;!--ssr-outlet--&gt;`, appHtml)
        .replace(`&lt;!--pinia-state--&gt;`, piniaState)
      res.status(200).set(&#123; &#39;Content-Type&#39;: &#39;text/html&#39; &#125;).end(html)
    &#125; catch (error) &#123;
      vite?.ssrFixStacktrace(error)
      next(e)
    &#125;
  &#125;)

  // 监听5100端口
  app.listen(5100)
&#125;

createServer();
</code></pre>
<h3 id="3-服务端入口文件"><a href="#3-服务端入口文件" class="headerlink" title="3. 服务端入口文件"></a>3. 服务端入口文件</h3><ul>
<li>服务端入口文件主要是调用SSR的renderToString和收集需要发送的资源和数据</li>
</ul>
<pre><code class="js">import &#123; renderToString &#125; from &#39;vue/server-renderer&#39;
import &#123; createApp &#125; from &#39;./main&#39;

export async function render(url, manifest) &#123;
  const &#123; app, router, pinia &#125; = createApp()

  router.push(url)
  await router.isReady()

  const ctx = &#123;&#125;
  const html = await renderToString(app, ctx)
  return [html, JSON.stringify(pinia.state.value)]
&#125;
</code></pre>
<h3 id="4-客户端入口文件"><a href="#4-客户端入口文件" class="headerlink" title="4. 客户端入口文件"></a>4. 客户端入口文件</h3><ul>
<li>客户端入口文件主要用于挂载节点和初始化数据</li>
</ul>
<pre><code class="js">import &#123; createApp &#125; from &#39;./main&#39;

const &#123; app, router, pinia &#125; = createApp()

router.isReady().then(() =&gt; &#123;
  if (window.__INITIAL_STATE__) &#123;
    pinia.state.value = JSON.parse(window.__INITIAL_STATE__);
  &#125;

  app.mount(&#39;#app&#39;)
&#125;)
</code></pre>
<h3 id="5-组件和页面"><a href="#5-组件和页面" class="headerlink" title="5. 组件和页面"></a>5. 组件和页面</h3><ul>
<li>组件和页面获取数据主要有两种方式，一种是增加一个<code>asyncData</code>选项，然后在enter-server.js的逻辑中增加遍历当前组件的逻辑，统一触发<code>asyncData</code>，但是现在都是用<code>script setup</code>的方式写业务代码，所以有点麻烦，</li>
</ul>
<pre><code class="js">&lt;script&gt;
  export defualt &#123;
    asyncData() &#123;
      // 服务端获取数据逻辑
    &#125;
  &#125;
&lt;/script&gt;

&lt;script setup lang=&#39;ts&#39;&gt;
  ...
&lt;/script&gt;
</code></pre>
<ul>
<li>另一种就是hook的方式，通过<code>import.meta.env.SSR</code>的方式进行判断</li>
<li>对于数据具体存储方式，大概有三种，一种是存在vuex或者pinia这种全局状态库中，一种是存在context上下文中，还有一种是自定义数据</li>
</ul>
<h3 id="6-生产环境"><a href="#6-生产环境" class="headerlink" title="6. 生产环境"></a>6. 生产环境</h3><h4 id="6-1-pacnakge-json"><a href="#6-1-pacnakge-json" class="headerlink" title="6.1 pacnakge.json"></a>6.1 pacnakge.json</h4><ul>
<li>增加构建脚本</li>
</ul>
<pre><code class="diff">&quot;scripts&quot;: &#123;
  &quot;dev&quot;: &quot;node server&quot;,
+ &quot;build&quot;: &quot;npm run build:client &amp;&amp; npm run build:server&quot;,
+  &quot;build:client&quot;: &quot;vite build --ssrManifest --outDir dist/client&quot;,
+  &quot;build:server&quot;: &quot;vite build --ssr src/entry-server.js --outDir dist/server&quot;,
+  &quot;serve&quot;: &quot;cross-env NODE_ENV=production node server&quot;
&#125;,
</code></pre>
<h4 id="6-2-服务端运行文件"><a href="#6-2-服务端运行文件" class="headerlink" title="6.2 服务端运行文件"></a>6.2 服务端运行文件</h4><ul>
<li>针对生产环境，需要启动静态资源服务，引用路径需要改为dist目录下</li>
</ul>
<pre><code class="diff">import fs from &#39;fs&#39;
import path from &#39;path&#39;
import &#123; fileURLToPath &#125; from &#39;url&#39;
import express from &#39;express&#39;

import &#123; createRequire &#125; from &#39;module&#39;;
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const require = createRequire(import.meta.url);
const resolve = (p) =&gt; path.resolve(__dirname, p);

const createServer = async (isProd = process.env.NODE_ENV === &#39;production&#39;) =&gt; &#123;
  const app = express()

-  const vite = await require(&#39;vite&#39;).createServer(&#123;
-    server: &#123;
-      middlewareMode: true,
-    &#125;,
-    appType: &#39;custom&#39;
-  &#125;);
-  app.use(vite.middlewares);

+  let vite;
+  if (isProd) &#123;
+    app.use(require(&#39;compression&#39;)());
+    app.use(
+      require(&#39;serve-static&#39;)(resolve(&#39;./dist/client&#39;), &#123;
+        index: false
+      &#125;)
+    );
+  &#125; else &#123;
+    vite = await require(&#39;vite&#39;).createServer(&#123;
+      server: &#123;
+        middlewareMode: true,
+      &#125;,
+      appType: &#39;custom&#39;
+    &#125;);
+    app.use(vite.middlewares);
+  &#125;
   // 通过bulid --ssrManifest命令生成的静态资源映射需要在生产环境下引用
+  const manifest = isProd ? fs.readFileSync(resolve(&#39;./dist/client/ssr-manifest.json&#39;), &#39;utf-8&#39;) :&#123;&#125;
  
  app.use(&#39;*&#39;, async (req, res, next) =&gt; &#123;
    const url = req.originalUrl
    try &#123;
-      let template = fs.readFileSync(
-        resolve(&#39;index.html&#39;),
-        &#39;utf-8&#39;
-      )
-      template = await vite.transformIndexHtml(url, template)
-      const render = (await vite.ssrLoadModule(&#39;/src/entry-server.js&#39;)).render
-      const [ appHtml, piniaState ] = await render(url)

+      let template, render
+      if (isProd) &#123;
+        template = fs.readFileSync(resolve(&#39;./dist/client/index.html&#39;), &#39;utf-8&#39;)
+        render = (await import(&#39;./dist/server/entry-server.js&#39;)).render
+      &#125; else &#123;
+        template = fs.readFileSync(
+          resolve(&#39;index.html&#39;),
+          &#39;utf-8&#39;
+        )
+        template = await vite.transformIndexHtml(url, template)
+        render = (await vite.ssrLoadModule(&#39;/src/entry-server.js&#39;)).render
+      &#125;
+      const [ appHtml, preloadLinks, piniaState ] = await render(url, manifest)
      const html = template
        .replace(`&lt;!--preload-links--&gt;`, preloadLinks)
        .replace(`&lt;!--ssr-outlet--&gt;`, appHtml)
+        .replace(`&lt;!--pinia-state--&gt;`, piniaState)
      res.status(200).set(&#123; &#39;Content-Type&#39;: &#39;text/html&#39; &#125;).end(html)
    &#125; catch (error) &#123;
      vite?.ssrFixStacktrace(error)
      next()
    &#125;
  &#125;)

  app.listen(5100)
&#125;

createServer();
</code></pre>
<h4 id="6-3-服务端入口文件"><a href="#6-3-服务端入口文件" class="headerlink" title="6.3 服务端入口文件"></a>6.3 服务端入口文件</h4><ul>
<li>服务端入口文件主要是增加了构建时生成的静态资源映射处理的逻辑</li>
</ul>
<pre><code class="diff">import &#123; basename &#125; from &#39;path&#39;
import &#123; renderToString &#125; from &#39;vue/server-renderer&#39;
import &#123; createApp &#125; from &#39;./main&#39;

export async function render(url, manifest) &#123;
  const &#123; app, router, pinia &#125; = createApp()

  router.push(url)
  await router.isReady()

  const ctx = &#123;&#125;
  const html = await renderToString(app, ctx)
+  const preloadLinks = renderPreloadLinks(ctx.modules, manifest)
+  return [html, preloadLinks, JSON.stringify(pinia.state.value)]
&#125;

 function renderPreloadLinks(modules, manifest) &#123;
   let links = &#39;&#39;
   const seen = new Set()
   modules.forEach((id) =&gt; &#123;
     const files = manifest[id]
     if (files) &#123;
       files.forEach((file) =&gt; &#123;
         if (!seen.has(file)) &#123;
           seen.add(file)
           const filename = basename(file)
           if (manifest[filename]) &#123;
             for (const depFile of manifest[filename]) &#123;
               links += renderPreloadLink(depFile)
               seen.add(depFile)
             &#125;
           &#125;
           links += renderPreloadLink(file)
         &#125;
       &#125;)
     &#125;
   &#125;)
   return links
 &#125;
 
 function renderPreloadLink(file) &#123;
   if (file.endsWith(&#39;.js&#39;)) &#123;
     return `&lt;link rel=&quot;modulepreload&quot; crossorigin href=&quot;$&#123;file&#125;&quot;&gt;`
   &#125; else if (file.endsWith(&#39;.css&#39;)) &#123;
     return `&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;file&#125;&quot;&gt;`
   &#125; else if (file.endsWith(&#39;.woff&#39;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;font&quot; type=&quot;font/woff&quot; crossorigin&gt;`
   &#125; else if (file.endsWith(&#39;.woff2&#39;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;`
   &#125; else if (file.endsWith(&#39;.gif&#39;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/gif&quot;&gt;`
   &#125; else if (file.endsWith(&#39;.jpg&#39;) || file.endsWith(&#39;.jpeg&#39;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/jpeg&quot;&gt;`
   &#125; else if (file.endsWith(&#39;.png&#39;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/png&quot;&gt;`
   &#125; else &#123;
     return &#39;&#39;
   &#125;
 &#125;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/LHRUN/vue-ssr">repo</a></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://vuejs.org/guide/scaling-up/ssr.html">Server-Side Rendering</a></li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-27</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vite/" title="Vite">Vite </a><i class="fa fa-tag"></i><a class="tag" href="/tags/SSR/" title="SSR">SSR </a><span class="leancloud_visitors"></span><span>大约2169个字, 7分钟13秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/25/%E8%A7%A3%E6%9E%90Vue3patch%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95patchKeyedChildren/">解析Vue3patch核心算法patchKeyedChildren</a></h3></div><div class="post-content"><div class="card"><p><h3 id="解析Vue3patch核心算法patchKeyedChildren"><a href="#解析Vue3patch核心算法patchKeyedChildren" class="headerlink" title="解析Vue3patch核心算法patchKeyedChildren"></a>解析Vue3patch核心算法patchKeyedChildren</h3><ul>
<li>locate：<code>runtime-core &gt; renderer &gt; baseCreateRenderer &gt; patchKeyedChildren</code></li>
<li>patchKeyedChildren是patch算法中较为复杂的一段，更是vue技术栈面试的高频点，最初我是在vue3.0 beta版本时大概看过源码，后来在《vue设计与分析》中看了霍春阳大佬的解析，本篇就简要分析一下做个记录</li>
<li>首先patchKeyedChildren是在子列表对比并且有key的情况会进入，并且逻辑大致分为5步，这个看源码官方注释就可以看出</li>
</ul>
<h4 id="第一步，从前向后遍历"><a href="#第一步，从前向后遍历" class="headerlink" title="第一步，从前向后遍历"></a>第一步，从前向后遍历</h4><p>这一步是从节点组头部向尾部遍历，如果遍历过程中遇到相似节点，就进行patch对比，否则就退出遍历，并记录当前遍历的最新下标</p>
<pre><code class="js">while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
  const n1 = c1[i]
  const n2 = (c2[i] = optimized
    ? cloneIfMounted(c2[i] as VNode)
    : normalizeVNode(c2[i]))
  if (isSameVNodeType(n1, n2)) &#123;
    patch(
      n1,
      n2,
      container,
      null,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; else &#123;
    break
  &#125;
  i++
&#125;
</code></pre>
<h4 id="第二步，从后向前遍历"><a href="#第二步，从后向前遍历" class="headerlink" title="第二步，从后向前遍历"></a>第二步，从后向前遍历</h4><p>从后向前遍历，如果遇到第一步记录的下标就停止，然后遍历过程中，如果遇到相似节点也是直接进行patch对比，如果不相同就是直接退出遍历，并且记录旧节点组和新节点组的尾指针</p>
<pre><code class="js">while (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
  const n1 = c1[e1]
  const n2 = (c2[e2] = optimized
    ? cloneIfMounted(c2[e2] as VNode)
    : normalizeVNode(c2[e2]))
  if (isSameVNodeType(n1, n2)) &#123;
    patch(
      n1,
      n2,
      container,
      null,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; else &#123;
    break
  &#125;
  e1--
  e2--
&#125;
</code></pre>
<h4 id="第三步，检查旧节点组"><a href="#第三步，检查旧节点组" class="headerlink" title="第三步，检查旧节点组"></a>第三步，检查旧节点组</h4><p>这一步就是检查旧节点组在上两步的遍历后是否遍历完，如果遍历完，那么新节点组没有遍历完的就都是新的dom，可以全部当作新增节点进行挂载处理</p>
<pre><code class="js">if (i &gt; e1) &#123;
  if (i &lt;= e2) &#123;
    const nextPos = e2 + 1
    const anchor = nextPos &lt; l2 ? (c2[nextPos] as VNode).el : parentAnchor
    while (i &lt;= e2) &#123;
      // patch第一个参数为null，就是代表没有旧节点，直接将新节点插入
      patch(
        null,
        (c2[i] = optimized
          ? cloneIfMounted(c2[i] as VNode)
          : normalizeVNode(c2[i])),
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      )
      i++
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="第四步，检查新节点组"><a href="#第四步，检查新节点组" class="headerlink" title="第四步，检查新节点组"></a>第四步，检查新节点组</h4><p>如果上一步检查旧节点未遍历完，那么就检查新节点组是否遍历完，如果遍历完，那么旧的节点组剩余的节点说明都是要卸载的，因为都不需要了</p>
<pre><code class="js">else if (i &gt; e2) &#123;
  // 旧子节点未被遍历完
  while (i &lt;= e1) &#123;
    unmount(c1[i], parentComponent, parentSuspense, true)
    i++
  &#125;
&#125;
</code></pre>
<h4 id="第五步，未知序列"><a href="#第五步，未知序列" class="headerlink" title="第五步，未知序列"></a>第五步，未知序列</h4><ul>
<li>如果新旧节点组都未遍历完，说明存在未知序列，可能存在位移等情况，就需要进一步处理</li>
<li>首先创建一个数组，用于记录新旧节点的对应关系</li>
</ul>
<pre><code class="js">// toBePatched是新序列的节点数量 e2 - s2 + 1
const newIndexToOldIndexMap = new Array(toBePatched)
for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0
</code></pre>
<ul>
<li>然后会遍历旧节点组，这里会用两个变量记录<ul>
<li><code>let moved = false</code>：位移标识，用于判断是否需要位移</li>
<li><code>let patched = 0</code>：记录已执行patch的新节点数量，用于处理如果在更新时更新过的数量大于需要更新的节点数量，就卸载对应旧节点</li>
</ul>
</li>
</ul>
<pre><code class="js">for (i = s1; i &lt;= e1; i++) &#123;
  const prevChild = c1[i]
  // 如果已更新数量大于新节点数量，就卸载节点
  if (patched &gt;= toBePatched) &#123;
    unmount(prevChild, parentComponent, parentSuspense, true)
    continue
  &#125;
  let newIndex //新旧节点key相同的新节点index
  if (prevChild.key != null) &#123;
    newIndex = keyToNewIndexMap.get(prevChild.key)
  &#125; else &#123;
    for (j = s2; j &lt;= e2; j++) &#123;
      if (
        newIndexToOldIndexMap[j - s2] === 0 &amp;&amp;
        isSameVNodeType(prevChild, c2[j] as VNode)
      ) &#123;
        newIndex = j
        break
      &#125;
    &#125;
  &#125;
  // 如果newIndex为空，则说明未找到与旧节点对应的新节点，直接卸载
  if (newIndex === undefined) &#123;
    unmount(prevChild, parentComponent, parentSuspense, true)
  &#125; else &#123;
    // 更新新旧节点关系表
    newIndexToOldIndexMap[newIndex - s2] = i + 1
    /**
     * 这里的maxNexIndexSoFar是记录每次patch最大index
     * 也是用于判断是否产生了位移，因为如果新节点index比最大index小，就说明发生了位移
     * 例如：
     *  (a b) c
     *  (a c  b)
     * 在新旧序列对比b，c时，由于c最新的newIndex已经小于b对应的newIndex，因此会记录需要位移
     */
    if (newIndex &gt;= maxNewIndexSoFar) &#123;
      maxNewIndexSoFar = newIndex
    &#125; else &#123;
      moved = true
    &#125;
    patch(
      prevChild,
      c2[newIndex] as VNode,
      container,
      null,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
    patched++
  &#125;
&#125;
</code></pre>
<ul>
<li>遍历完旧序列后，就需要确定如何位移</li>
<li>首先是根据新旧节点关系表生成最长递增子序列(这个算法就不陈述了，较复杂，可以看<a target="_blank" rel="noopener" href="https://juejin.cn/post/6952674285311754276#comment">精读《DOM diff 最长上升子序列》</a>)，然后倒序遍历新子节点</li>
</ul>
<pre><code class="js">// 最长递增子序列
const increasingNewIndexSequence = moved
  ? getSequence(newIndexToOldIndexMap)
  : EMPTY_ARR
j = increasingNewIndexSequence.length - 1
// 从新序列尾部向前遍历，目的是为了使用上一个遍历的节点做锚点
for (i = toBePatched - 1; i &gt;= 0; i--) &#123;
  const nextIndex = s2 + i
  const nextChild = c2[nextIndex] as VNode
  // 如果是序列的最后一个节点，anchor就是父节点对应的anchor，否则就是上一个子节点
  const anchor =
    nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor
  // 如果newIndexToOldIndexMap[i]还是0，那么说明新节点没有对应的旧节点，说明是新节点，直接挂载
  if (newIndexToOldIndexMap[i] === 0) &#123;
    patch(
      null,
      nextChild,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; else if (moved) &#123;
    // 然后在moved为true的情况下，如果最长子序列为空或者最长子序列和当前访问的新节点index不同，说明就需要进行位移
    if (j &lt; 0 || i !== increasingNewIndexSequence[j]) &#123;
      move(nextChild, container, anchor, MoveType.REORDER)
    &#125; else &#123;
      j--
    &#125;
  &#125;
&#125;
</code></pre>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-25</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>大约1377个字, 4分钟35秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/24/pnpm%E7%9A%84node-modules%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">pnpm的node_modules结构设计</a></h3></div><div class="post-content"><div class="card"><p><h2 id="pnpm的node-modules结构设计"><a href="#pnpm的node-modules结构设计" class="headerlink" title="pnpm的node_modules结构设计"></a>pnpm的node_modules结构设计</h2><p>分析pnpm之前，先说一下npm现在的一些问题</p>
<h3 id="npm的问题"><a href="#npm的问题" class="headerlink" title="npm的问题"></a>npm的问题</h3><ul>
<li><p>平时我们使用<code>npm install</code>命令后，node_modules就会呈现以下类似内容<br><img src="https://img-blog.csdnimg.cn/7396b28d86f84a21b15b4ef6026ddd45.png#pic_center" alt="npm_node_modules"></p>
</li>
<li><p>之所以出现这种扁平的结构，最初时初衷是好的，为了更好的利用资源，把每个依赖全部放到顶层，这样就不会造成每个依赖嵌套过深，导致很多重复依赖文件</p>
</li>
<li><p>但是随着这种文件结构逐步使用后，就会暴露出来两个问题</p>
<ul>
<li><strong>幽灵依赖</strong></li>
<li><strong>版本冲突</strong></li>
</ul>
</li>
<li><p>幽灵依赖就是你在引用npm包时，你会发现一些没有在<code>package.json</code>中出现的包也能引用，这个就是幽灵依赖，这是因为你在install下载npm包时，npm包也有它的依赖会下载，但是下载的依赖也会存在node_modules同一层级下，这样就会导致可以直接引用</p>
</li>
<li><p>版本冲突是因为不同的依赖可能依赖的包版本也不同，但是node_modules的同一层级只能存在一个包的一个版本号，如果有不同的版本号就只能存在依赖包的node_modules中，这样就会导致出现重复资源</p>
</li>
</ul>
<pre><code class="js">├── package-A @1.0
|── package-B @1.0
├── package-C @1.0
│   └── package-A @2.0
│   └── package-B @2.0
├── package-D @1.0
│   └── package-A @2.0
│   └── package-B @2.0
</code></pre>
<h3 id="pnpm的出现"><a href="#pnpm的出现" class="headerlink" title="pnpm的出现"></a>pnpm的出现</h3><ul>
<li><p>在所有前端苦npm久已时，pnpm出现了，并且在pnpm官网的简介上就简单说明了它的构造：<code>store + link</code><br><img src="https://img-blog.csdnimg.cn/20ef6cd68a0440c9841ea1450297c17a.jpeg#pic_center" alt="pnpm_node_modules"></p>
<ul>
<li>store就是依赖的实际存储位置，Mac&#x2F;linux在<code>&#123;home dir&#125;&gt;/.pnpm-store/v3</code>，windows在<code>当前盘/.pnpm-store/v3</code>。这样就会有个好处，你在多个项目使用的是同一个依赖时，就不用重复下载，这样就极大的减少存储空间</li>
<li>link是指符号链接(<code>SymbolicLink</code>)和硬链接(<code>HardLink</code>)<ul>
<li>SymbolicLink是一种特殊的文件，包含一条以绝对路径或者相对路径的形式指向其他文件或者目录的引用，它的存在不依赖于目标文件，如果目标文件被删除或者移动，指向目标文件的符号链接依然存在，但是它们会指向一个不复存在的文件</li>
<li>相比于SymbolicLink，HardLink不是引用文件，而是引用<strong>inode</strong>，inode是文件系统的一种数据结构，用于描述文件系统对象。所以你即使更改目标文件的内容或位置，HardLink仍然指向目标文件，因为inode指向该文件</li>
</ul>
</li>
</ul>
</li>
<li><p>然后拿react举例，当<code>pnpm add react</code>后，在node_modules终端输入<code>tree -a -L 3</code>会得到以下node_modules结构</p>
</li>
</ul>
<pre><code class="js">.
├── .modules.yaml
├── .pnpm
│   ├── js-tokens@4.0.0
│   │   └── node_modules
│   ├── lock.yaml
│   ├── loose-envify@1.4.0
│   │   └── node_modules
│   ├── node_modules
│   │   ├── .bin
│   │   ├── js-tokens -&gt; ../js-tokens@4.0.0/node_modules/js-tokens
│   │   └── loose-envify -&gt; ../loose-envify@1.4.0/node_modules/loose-envify
│   └── react@18.2.0
│       └── node_modules
└── react -&gt; .pnpm/react@18.2.0/node_modules/react
</code></pre>
<ul>
<li>node_modules下除了.pnpm外只有一个react，这个react只是一个SymbolicLink，当node.js解析时，会找到react的真实位置<code>node_modules/.pnpm/react@18.2.0/node_modules/react</code></li>
<li>.pnpm就是将所有依赖放在同一层文件夹中，每个包都可以通过<code>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</code>这种路径找到，然后通过<code>hand link</code>的方式在store中引用依赖文件</li>
<li>通过这种文件结构，pnpm就解决了npm的两个问题，首先node_modules下不会有你未在package.json中声明的依赖，这样就不会有幽灵依赖的问题。然后.pnpm下会有name+version的方式链接到store中，这样就不会出现因为版本冲突造成资源重复的问题</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.pnpm.cn/blog/2020/05/27/flat-node-modules-is-not-the-only-way">Flat node_modules is not the only way</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pnpm.cn/symlinked-node-modules-structure">Symlinked node_modules structure</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7043998041786810398">One For All：基于pnpm + lerna + typescript的最佳项目实践 - 理论篇</a></li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-24</span><i class="fa fa-tag"></i><a class="tag" href="/tags/pnpm/" title="pnpm">pnpm </a><span class="leancloud_visitors"></span><span>大约1070个字, 3分钟34秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2022/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%80%91%E5%B8%83%E6%B5%81%E5%92%8C%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/">微信小程序瀑布流和虚拟列表</a></h3></div><div class="post-content"><div class="card"><p><h2 id="微信小程序瀑布流和虚拟列表"><a href="#微信小程序瀑布流和虚拟列表" class="headerlink" title="微信小程序瀑布流和虚拟列表"></a>微信小程序瀑布流和虚拟列表</h2><p>首先声明虽然本篇是写的微信小程序的案例，但是也可用于H5，思路是想通的，只是有些api的差异，最后会贴代码片段<br><img src="https://img-blog.csdnimg.cn/40f9275783f14ed4a2a020ec733b3043.gif#pic_center" alt="example"></p>
<h3 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h3><ul>
<li>一般在做长列表优化时，特别是面试时，虚拟列表就是个高频词。这个名词听起来很高级，其实原理很简单</li>
<li>虚拟列表就是将需要渲染的数组数据改造成二维数组，然后通过监听DOM在合适的地方切换为占位元素，达到长列表无限滚动时减少DOM的优化</li>
<li>JS</li>
</ul>
<pre><code class="js">/**
 * 处理占位元素，就是在获取新的数据后
 * 通过SelectQuery获取当前数据的实际高度，然后把这个高度设置到占位元素上
 */
getCurrentItemHeight() &#123;
  const query = this.createSelectorQuery();
  const &#123; virtualId &#125; = this.data
  query.select(`#$&#123;virtualId&#125;`).boundingClientRect()
  query.exec((res) =&gt; &#123;
    this.setData(&#123;
      height: res[0].height
    &#125;, this.observePage())
  &#125;)
&#125;

/**
 * 监听元素与页面的相交
 * 可以选择指定元素为参照区域，也可以选择页面为参照元素，只是API不同
 * @doc https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html
 */
observePage() &#123;
  const &#123; virtualId, observeDistance, wrapId &#125; = this.data
  let IntersectionObserver = wx.createIntersectionObserver(this);
  (wrapId ? IntersectionObserver.relativeTo(`#$&#123;wrapId&#125;`) : IntersectionObserver.relativeToViewport(&#123; top: observeDistance, bottom: observeDistance &#125;))
  .observe(`#$&#123;virtualId&#125;`, (&#123; intersectionRatio &#125;) =&gt; &#123;
    this.setData(&#123;
      isShow: intersectionRatio &gt; 0,
    &#125;)
  &#125;)
&#125;
</code></pre>
<ul>
<li>html</li>
</ul>
<pre><code class="js">&lt;view id=&quot;&#123;&#123;virtualId&#125;&#125;&quot;&gt;
  &lt;block wx:if=&quot;&#123;&#123;isShow&#125;&#125;&quot;&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/block&gt;
  &lt;view wx:else style=&quot;height: &#123;&#123; height &#125;&#125;px&quot;&gt;&lt;/view&gt;
&lt;/view&gt;
</code></pre>
<h3 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h3><ul>
<li>瀑布流，又称瀑布流式布局。视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部</li>
<li>瀑布流有多种写法，有通过纯CSS完成的，也有借助JS完成的，方法很多，但是我为了接下来能与虚拟列表相结合，就采用JS的写法，就是通过列数把每一列分为一个单独的子元素，然后会记录每一列的高度，通过判断哪一列高度最小，然后将数据push到高度最小的那一列</li>
</ul>
<pre><code class="js">/**
 * 获取列表数据
 * @describe 瀑布流处理，哪列高度小，就往哪列push新数据
 */
getList() &#123;
  let &#123; listQuery: &#123; pageIndex, pageSize &#125;, columns, columnsHeight &#125; = this.data;
  for (let i = 0; i &lt; pageSize; i++) &#123;
    const height = Math.floor(Math.random() * 100)
    const item = height &lt; 50 ? height + 50 : height
    const position = this.computePosition(columnsHeight)
    columns[position].push(item)
    columnsHeight += item
  &#125;
  // 在html中双重遍历columns，然后通过flex：1均匀分布
  this.setData(&#123;
    columns,
  &#125;)
  this.data.columnsHeight = columnsHeight
&#125;

/**
 * 获取高度最小列下标
 */
computePosition(heights) &#123;
  const min = Math.min(...heights);
  return heights.findIndex((item) =&gt; item === min)
&#125;
</code></pre>
<h3 id="瀑布流结合虚拟列表"><a href="#瀑布流结合虚拟列表" class="headerlink" title="瀑布流结合虚拟列表"></a>瀑布流结合虚拟列表</h3><ul>
<li>让瀑布流有虚拟滚动的能力，思路很简单，就是计算每列的偏移量，因为瀑布流被我们分成了二维数组，所以每块子元素之间就会因为列高度的不一致产生空白区域，所以需要计算这个空白区域的大小，然后通过<code>margin-top</code>移动列元素达到视觉上的瀑布流衔接效果<br><img src="https://img-blog.csdnimg.cn/070e8c72d982470ca8808ad8121e6110.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<pre><code class="js">getList() &#123;
  let &#123; listQuery: &#123; pageIndex &#125;, column, columnsHeights &#125; = this.data;
  const columns = [];
  // 上一组的高度数据，用于计算偏移值
  const lastHeights = [...columnsHeights];
  // 获取数据
  const list = this.getListData();
  // 初始化当前屏数据
  for (let i = 0; i &lt; column; i++ ) &#123;
    columns.push([]);
  &#125;
  // 遍历新数据，分配至各列
  for (let i = 0; i &lt; list.length; i++) &#123;
    const position = this.computePosition(columnsHeights);
    columns[position].push(list[i]);
    columnsHeights[position] += Number(list[i].height);
  &#125;
  this.setData(&#123;
    [`listData[$&#123;pageIndex&#125;]`]: &#123;
      columns,
      columnOffset: this.computeOffset(lastHeights),
    &#125;
  &#125;);
  this.data.listQuery.pageIndex = pageIndex + 1;
  this.data.columnsHeights = columnsHeights;
&#125;,

/**
 * 获取列表数据
 */
getListData() &#123;
  const result = []
  for (let i = 0; i &lt; this.data.listQuery.pageSize; i++) &#123;
    const height = Math.floor(Math.random() * 300);
    const item = &#123;
      height: height &lt; 150 ? height + 150 : height,
      color: this.randomRgbColor(),
    &#125;;
    result.push(item);
  &#125;
  return result;
&#125;,

/**
 * 随机生成RGB颜色
 */
randomRgbColor() &#123;
  var r = Math.floor(Math.random() * 256); //随机生成256以内r值
  var g = Math.floor(Math.random() * 256); //随机生成256以内g值
  var b = Math.floor(Math.random() * 256); //随机生成256以内b值
  return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`; //返回rgb(r,g,b)格式颜色
&#125;,

/**
 * 获取最小高度列下标
 */
computePosition(heights) &#123;
  const min = Math.min(...heights);
  return heights.findIndex((item) =&gt; item === min);
&#125;,

/**
 * 计算偏移量
 */
computeOffset(heights) &#123;
  const max = Math.max(...heights);
  return heights.map((item) =&gt; max - item);
&#125;,

onScrollLower() &#123;
  this.getList();
&#125;
</code></pre>
<ul>
<li>WXML</li>
</ul>
<pre><code class="js">&lt;view&gt;
  &lt;scroll-view class=&quot;virtualScrollView&quot; eventhandle scroll-y bindscrolltolower=&quot;onScrollLower&quot;&gt;
    &lt;block wx:for=&quot;&#123;&#123; listData &#125;&#125;&quot; wx:key=&quot;screenIndex&quot; wx:for-index=&quot;screenIndex&quot; wx:for-item=&quot;screenItem&quot;&gt;
      &lt;VirtualItem virtualId=&quot;virtual_&#123;&#123;pageIndex&#125;&#125;&quot;&gt;
        &lt;view class=&quot;fall&quot;&gt;
          &lt;block wx:for=&quot;&#123;&#123; screenItem.columns &#125;&#125;&quot; wx:key=&quot;columnIndex&quot; wx:for-index=&quot;columnIndex&quot; wx:for-item=&quot;column&quot; &gt;
            &lt;view style=&quot;margin-top: -&#123;&#123;screenItem.columnOffset[columnIndex]&#125;&#125;px;&quot; class=&quot;fallCol&quot;&gt;
              &lt;view wx:for=&quot;&#123;&#123;column&#125;&#125;&quot; style=&quot;height: &#123;&#123; item.height &#125;&#125;px; background-color: &#123;&#123; item.color &#125;&#125;;&quot; wx:key=&quot;index&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot;&gt;
                screen: &#123;&#123; screenIndex &#125;&#125;, column: &#123;&#123; columnIndex &#125;&#125;
              &lt;/view&gt;
            &lt;/view&gt;
          &lt;/block&gt;
        &lt;/view&gt;
      &lt;/VirtualItem&gt;
    &lt;/block&gt;
  &lt;/scroll-view&gt;
&lt;/view&gt;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段：<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/s/5P3DpGmI7PBc">https://developers.weixin.qq.com/s/5P3DpGmI7PBc</a></li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-08-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/微信小程序/" title="微信小程序">微信小程序 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/瀑布流/" title="瀑布流">瀑布流 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/虚拟列表/" title="虚拟列表">虚拟列表 </a><span class="leancloud_visitors"></span><span>大约1234个字, 4分钟6秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/09/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/">微信小程序图片上传&amp;九宫格拖拽组件</a></h3></div><div class="post-content"><div class="card"><p><h2 id="微信小程序图片上传-amp-九宫格拖拽组件"><a href="#微信小程序图片上传-amp-九宫格拖拽组件" class="headerlink" title="微信小程序图片上传&amp;九宫格拖拽组件"></a>微信小程序图片上传&amp;九宫格拖拽组件</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>图片上传加九宫格拖拽是一个比较常用的组件，常用于发帖或者评论等内容上传模块，我这篇九宫格拖拽的思路是借鉴了<a target="_blank" rel="noopener" href="https://www.cnblogs.com/haha1212/p/11562944.html"><strong>一款优雅的小程序拖拽排序组件实现</strong></a>这篇文章</p>
</li>
<li><p>实现效果如下图<br><img src="https://img-blog.csdnimg.cn/cc8c84d6bc3049349e94b95f540916c7.gif" alt="请添加图片描述"></p>
</li>
<li><p>实现原理：新增图片时，为每一个图片增加一个key属性，和tranX、tranY属性，用于transform位移，然后这个九宫格的拖拽新增删除都是以key为标记来修改tranX和tranY，从而达到拖拽效果</p>
</li>
<li><p>使用了以下变量</p>
</li>
</ul>
<pre><code class="js">data: &#123;
  ITEM_SIZE: 100, // 图片大小 单位px
  dragImgList: [], // 图片列表 &#123; src: string, key: number, tranX: number, tranY: number &#125;[]
  containerRes: &#123;&#125;, // 拖拽容器属性
  currentKey: -1, // 正在拖拽图片的key
  currentIndex: -1, // 正在拖拽图片的index
  tranX: 0, // 正在拖拽图片移动的x距离
  tranY: 0, // 正在拖拽图片移动的y距离
  uploadPosition: &#123; // upload上传图标位移距离
    tranX: 0,
    tranY: 0,
  &#125;
&#125;,
</code></pre>
<h3 id="WXML-amp-WXSS"><a href="#WXML-amp-WXSS" class="headerlink" title="WXML &amp; WXSS"></a>WXML &amp; WXSS</h3><pre><code class="html">&lt;view class=&quot;drag-container&quot;&gt;
  &lt;view
    wx:for=&quot;&#123;&#123;dragImgList&#125;&#125;&quot; 
    wx:key=&quot;index&quot;
    style=&quot;transform: translate(&#123;&#123;index === currentIndex ? tranX : item.tranX&#125;&#125;px, &#123;&#123;index === currentIndex ? tranY : item.tranY&#125;&#125;px); z-index: &#123;&#123;index === currentIndex ? 10 : 1&#125;&#125;;&quot;
    class=&quot;darg-item item-transition&quot;
    mark:index=&quot;&#123;&#123;index&#125;&#125;&quot;
    mark:key=&quot;&#123;&#123;item.key&#125;&#125;&quot;
    catch:longpress=&quot;longPress&quot;
    catch:touchmove=&quot;touchMove&quot;
    catch:touchend=&quot;touchEnd&quot;
  &gt;
    &lt;image class=&quot;darg-item-img&quot; src=&quot;&#123;&#123;item.src&#125;&#125;&quot;/&gt;
    &lt;text catch:tap=&quot;deleteImg&quot; mark:key=&quot;&#123;&#123;item.key&#125;&#125;&quot; class=&quot;drag-item-delete&quot;&gt;×&lt;/text&gt;
  &lt;/view&gt;
  &lt;view
    bindtap=&quot;uploadImage&quot;
    class=&quot;darg-item drag-item-upload&quot;
    hidden=&quot;&#123;&#123;dragImgList.length >= 9&#125;&#125;&quot;
    style=&quot;transform: translate(&#123;&#123;uploadPosition.tranX&#125;&#125;px, &#123;&#123;uploadPosition.tranY&#125;&#125;px);&quot;
  &gt;+&lt;/view&gt;
&lt;/view&gt;
</code></pre>
<pre><code class="css">.drag-container&#123;
  position: relative;
  width: 300px;
  height: 300px;
&#125;
.item-transition &#123;
  transition: transform 0.1s
&#125;
.darg-item&#123;
  position: absolute;
  top: 0;
  left: 0;
  width: 100px;
  height: 100px;
&#125;
.darg-item-img&#123;
  width: 100%;
  height: 100%;
&#125;
.drag-item-delete&#123;
  position: absolute;
  top: 0;
  right: 0;
  width: 58rpx;
  height: 33rpx;
  background-color: rgba(0,0,0,0.7);
  font-size: 47rpx;
  line-height: 25rpx;
  text-align: center;
  border-radius: 0 0 0 64rpx;
  color: #fff;
&#125;
.drag-item-upload&#123;
  background-color: burlywood;
  font-size: 200rpx;
  text-align: center;
  color: white;
  line-height: 200rpx;
&#125;
</code></pre>
<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><ul>
<li>图片上传很简单，就是初始化上传的图片，然后拼接图片列表，最后修改上传图标位置即可</li>
</ul>
<pre><code class="js">uploadImage() &#123;
  let &#123; dragImgList, ITEM_SIZE &#125; = this.data
  wx.chooseImage(&#123;
    count: 9 - dragImgList.length,
    success: (res) =&gt; &#123;
      const imgList = res.tempFilePaths.map((item, index) =&gt; (&#123;
        tranX: ITEM_SIZE * ((dragImgList.length + index) % 3),
        tranY: Math.floor((dragImgList.length + index) / 3) * ITEM_SIZE,
        src: item,
        key: dragImgList.length + index
      &#125;))
      dragImgList = dragImgList.concat(imgList)
      // 修改上传图标位置
      this.setUploaPosition(dragImgList.length)
      this.setData(&#123;
        dragImgList,
      &#125;)
    &#125;
  &#125;)
&#125;,
</code></pre>
<pre><code class="js">setUploaPosition(listLength) &#123;
  const ITEM_SIZE = this.data.ITEM_SIZE
  const uploadPosition = &#123;
    tranX: listLength % 3 * ITEM_SIZE,
    tranY: Math.floor(listLength / 3) * ITEM_SIZE,
  &#125;
  this.setData(&#123;
    uploadPosition,
  &#125;)
&#125;,
</code></pre>
<h3 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h3><ul>
<li>首先从图片列表中删除所需图片，然后修改列表，把大于所选图片key的key全部减一，最后修改剩余图片位置和上传图标位置</li>
</ul>
<pre><code class="js">deleteImg(e) &#123;
  const key = e.mark.key
  // 删除图片
  const list = this.data.dragImgList.filter((item) =&gt; item.key !== key)
  // 修改key值
  list.forEach((item) =&gt; item.key &gt; key &amp;&amp; item.key--)
  // 修改剩余图片位置
  this.getListPosition(list)
  // 修改上传图标位置
  this.setUploaPosition(list.length)
&#125;
</code></pre>
<pre><code class="js">getListPosition(list) &#123;
  const ITEM_SIZE = this.data.ITEM_SIZE
  const dragImgList = list.map((item) =&gt; &#123;
    item.tranX = ITEM_SIZE * (item.key % 3);
    item.tranY = Math.floor(item.key / 3) * ITEM_SIZE;
    return item
  &#125;)
  this.setData(&#123;
    dragImgList,
  &#125;)

  // 向页面传递最新图片列表
  const urlList = [...dragImgList].sort((a, b) =&gt; a.key - b.key).map((item) =&gt; item.src)
  this.triggerEvent(&#39;updateImage&#39;, &#123;
    list: urlList
  &#125;)
&#125;,
</code></pre>
<h3 id="九宫格拖拽"><a href="#九宫格拖拽" class="headerlink" title="九宫格拖拽"></a>九宫格拖拽</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>初始化只需获取容器的位置信息即可，因为拖拽组件不一定是在页面的左上角，所以需要知道容器的位置信息</li>
</ul>
<pre><code class="js">lifetimes: &#123;
  ready() &#123;
    this.createSelectorQuery()
      .select(&quot;.drag-container&quot;)
      .boundingClientRect((res) =&gt; &#123;
        this.data.containerRes = res
      &#125;).exec();
  &#125;
&#125;,
</code></pre>
<h4 id="longPress"><a href="#longPress" class="headerlink" title="longPress"></a>longPress</h4><ul>
<li>这里采用longPress，而不是touchStart的原因，一是为了优化体验，二是touchStart与删除按钮冲突</li>
</ul>
<pre><code class="js">longPress(e) &#123;
  const index = e.mark.index
  const &#123; pageX, pageY &#125; = e.touches[0]
  const &#123; top, left &#125; = this.data.containerRes
  this.setData(&#123;
    currentIndex: index,
    tranX: pageX - 50 - left,
    tranY: pageY - 50 - top
  &#125;)
&#125;,
</code></pre>
<h4 id="touchMove"><a href="#touchMove" class="headerlink" title="touchMove"></a>touchMove</h4><ul>
<li>touchMove首先计算出位移距离，然后根据位移距离求出停放位置的key，如果不一样就修改位置</li>
</ul>
<pre><code class="js">touchMove(e) &#123;
  // 如果currentIndex &lt; 0，说明并没有触发longPress
  if (this.data.currentIndex &lt; 0) return
  const &#123; pageX, pageY &#125; = e.touches[0]
  const &#123; top, left &#125; = this.data.containerRes
  const tranX = pageX - 50 - left
  const tranY = pageY - 50 - top
  this.setData(&#123;
    tranX,
    tranY
  &#125;)
  // 对比当前移动的key和停放位置的key，如果不一样就修改位置
  const currentKey = e.mark.key
  const moveKey = this.getMoveKey(tranX, tranY)
  if (currentKey === moveKey || this.data.currentKey === currentKey) return
  this.data.currentKey = currentKey
  this.insert(currentKey, moveKey)
&#125;,
</code></pre>
<pre><code class="js">getMoveKey(tranX, tranY) &#123;
  const &#123; dragImgList: list, ITEM_SIZE &#125; = this.data
  const _getPositionNumber = (position) =&gt; &#123;
    const positionNumber = Math.round(position/ ITEM_SIZE)
    return positionNumber &gt; 2 ? 2 : positionNumber &lt; 0 ? 0 : positionNumber
  &#125;
  const endKey = 3 * _getPositionNumber(tranY) + _getPositionNumber(tranX)
  return endKey &gt;= list.length ? list.length - 1 : endKey
&#125;,
</code></pre>
<pre><code class="js">insert(origin, end) &#123;
  const dragImgList = this.data.dragImgList
  dragImgList.forEach((item) =&gt; &#123;
    if (origin &lt; end) &#123;
      // 如果起始key小于结束key，就把区间内的key全部减一
      if (item.key &gt; origin &amp;&amp; item.key &lt;= end) item.key--
      else if (item.key === origin) item.key = end
    &#125; else if (origin &gt; end) &#123;
      // 如果起始key大于结束key，就把区间内的key全部加一
      if (item.key &gt;= end &amp;&amp; item.key &lt; origin) item.key++
      else if (item.key === origin) item.key = end
    &#125;
  &#125;)
  this.getListPosition(dragImgList)
&#125;,
</code></pre>
<h4 id="touchEnd"><a href="#touchEnd" class="headerlink" title="touchEnd"></a>touchEnd</h4><ul>
<li>touchEnd用于重置数据</li>
</ul>
<pre><code class="js">touchEnd() &#123;
  this.setData(&#123;
    tranX: 0,
    tranY: 0,
    currentIndex: -1,
  &#125;)
  this.data.currentKey = -1
&#125;,
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/2rFIJamX7xty</code></li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-09-08</span><i class="fa fa-tag"></i><a class="tag" href="/tags/微信小程序/" title="微信小程序">微信小程序 </a><span class="leancloud_visitors"></span><span>大约1262个字, 4分钟12秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%95%E6%8C%87%E6%8B%96%E6%8B%BD%E5%92%8C%E5%8F%8C%E6%8C%87%E7%BC%A9%E6%94%BE%E6%97%8B%E8%BD%AC/">微信小程序单指拖拽和双指缩放旋转</a></h3></div><div class="post-content"><div class="card"><p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>小程序单指拖拽和双指操作是一个比较常用的功能，效果如下图<br><img src="https://img-blog.csdnimg.cn/babbbc7162d241e9b0fb01e0b18531eb.gif#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>实现这三个功能，主要用三个触摸事件<code>touchstart</code>、<code>touchmove</code>、<code>touchend</code></li>
</ul>
<pre><code class="html">&lt;view style=&quot;height: 100vh; width: 100vw&quot;&gt;
  &lt;image
    src=&quot;...&quot;
    style=&quot;transform: translate(&#123;&#123;translateX&#125;&#125;px, &#123;&#123;translateY&#125;&#125;px) scale(&#123;&#123;scale&#125;&#125;) rotate(&#123;&#123;rotate&#125;&#125;deg);&quot;
    catch:touchstart=&quot;touchStart&quot;
    catch:touchmove=&quot;touchMove&quot;
    catch:touchend=&quot;touchEnd&quot;
  /&gt;
&lt;/view&gt;
</code></pre>
<ul>
<li>用了以下变量</li>
</ul>
<pre><code class="ts">Page(&#123;
  data: &#123;
    translateX: 0, // 位移x坐标 单位px
    translateY: 0, // 位移y坐标 单位px
    distance: 0, // 双指接触点距离
    scale: 1, // 缩放倍数
    rotate: 0, // 旋转角度
    oldRotate: 0, // 上一次旋转停止后的角度
    startMove: &#123; // 起始位移距离
      x: 0,
      y: 0,
    &#125;,
    startTouches: [] // 起始点touch数组
  &#125;,
&#125;)
</code></pre>
<h3 id="单指拖拽"><a href="#单指拖拽" class="headerlink" title="单指拖拽"></a>单指拖拽</h3><ul>
<li>单指拖拽比较简单，只需要记录移动的点坐标，然后减去起始点坐标，就可以求出针对页面的移动距离</li>
<li><code>touchstart</code></li>
</ul>
<pre><code class="ts">touchStart(e) &#123;
  const touches = e.touches
  const &#123; translateX, translateY &#125; = this.data
  const &#123; pageX, pageY &#125; = touches[0]
  this.data.startMove = &#123;
    x: pageX - translateX,
    y: pageY - translateY
  &#125;
  this.data.startTouches = touches
&#125;,
</code></pre>
<ul>
<li><code>touchmove</code></li>
</ul>
<pre><code class="ts">touchMove(e) &#123;
  const touches = e.touches
  const &#123; pageX: onePageX, pageY: onePageY &#125; = touches[0]
  const &#123; startMove &#125; = this.data
  this.setData(&#123;
    translateX: onePageX - startMove.x,
    translateY: onePageY - startMove.y
  &#125;)
&#125;
</code></pre>
<h3 id="双指缩放"><a href="#双指缩放" class="headerlink" title="双指缩放"></a>双指缩放</h3><ul>
<li>双指缩放的原理是根据两点坐标求出距离(勾股定理)，然后在用移动坐标的距离比就可以求出缩放倍数</li>
<li><code>touchmove</code></li>
</ul>
<pre><code class="js">touchMove(e) &#123;
  const touches = e.touches
  const &#123; pageX: onePageX, pageY: onePageY &#125; = touches[0]
  const &#123; startMove, scale, distance: oldDistance, startTouches &#125; = this.data
  if (touches.length === 2 &amp;&amp; startTouches.length === 2) &#123;
      // 双指缩放
    const &#123; pageX: twoPageX, pageY: twoPageY &#125; = touches[1]
    // 求出当前双指距离
    const distance = Math.sqrt((twoPageX - onePageX) ** 2 + (twoPageY - onePageY) ** 2)
    this.data.distance = distance
    this.setData(&#123;
      scale: scale * (distance / (oldDistance || distance))
    &#125;)
  &#125; else if (startTouches.length !== 2) &#123;
      // 单指拖拽
    this.setData(&#123;
      translateX: onePageX - startMove.x,
      translateY: onePageY - startMove.y
    &#125;)
  &#125;
&#125;
</code></pre>
<ul>
<li><code>startTouches.length !== 2</code>这个判断的原因是防止图片跳动，因为如果你两个手指触摸，然后离开一个手指，我是禁止拖拽的，只有双指都离开后再次触摸才能单指拖拽</li>
</ul>
<h3 id="双指旋转"><a href="#双指旋转" class="headerlink" title="双指旋转"></a>双指旋转</h3><ul>
<li>双指旋转的原理是根据三角函数求出起始点的角度，然后再求出移动坐标的角度，相减然后加上上一次旋转的角度就等于你当前所需的选择角度</li>
<li><code>touchmove</code></li>
</ul>
<pre><code class="ts">touchMove(e) &#123;
  const touches = e.touches
  const &#123; pageX: onePageX, pageY: onePageY &#125; = touches[0]
  const &#123; startMove, scale, distance: oldDistance, startTouches, oldRotate &#125; = this.data
  if (touches.length === 2 &amp;&amp; startTouches.length === 2) &#123;
    const &#123; pageX: twoPageX, pageY: twoPageY &#125; = touches[1]
    const distance = Math.sqrt((twoPageX - onePageX) ** 2 + (twoPageY - onePageY) ** 2)
+   let rotate = this.getAngle(touches[0], touches[1]) - this.getAngle(startTouches[0], startTouches[1]) + oldRotate
    // 如果大于360度，就减去360
+   rotate = rotate &gt; 360 ? rotate - 360 : rotate
    this.data.distance = distance
    this.setData(&#123;
      scale: scale * (distance / (oldDistance || distance)),
+     rotate
    &#125;)
  &#125; else if (startTouches.length !== 2) &#123;
    this.setData(&#123;
      translateX: onePageX - startMove.x,
      translateY: onePageY - startMove.y
    &#125;)
  &#125;
&#125;,
</code></pre>
<ul>
<li><code>getAngle</code></li>
</ul>
<pre><code class="ts">getAngle(p1, p2) &#123;
  const x = p1.pageX - p2.pageX
  const y = p1.pageY- p2.pageY
  return Math.atan2(y, x) * 180 / Math.PI
&#125;
</code></pre>
<ul>
<li><code>touchend</code></li>
</ul>
<pre><code class="ts">touchEnd() &#123;
  // 保存当前旋转角度
  this.data.oldRotate = this.data.rotate
&#125;,
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/0nS1tImU7Rs5</code></li>
<li>H5原理一致，只需改一下语法即可</li>
<li>我这个只是基础版本，如果需要一些边界控制和还一些需求的限制，计算据边框距离即可，也可以用小程序的<code>boundingClientRect</code>API</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-08-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/微信小程序/" title="微信小程序">微信小程序 </a><span class="leancloud_visitors"></span><span>大约751个字, 2分钟30秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/08/01/%E8%A7%A3%E6%9E%90reactive-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/">解析reactive---vue3响应式</a></h3></div><div class="post-content"><div class="card"><p><ol>
<li>想要了解vue3的reactive模块，就要对<code>Proxy</code>和<code>Reflect</code>有所了解，关于这两个知识我推荐看阮一峰老师的<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#README">ES6入门教程</a></li>
<li>我对reactive模块有一个大致梳理，见下图<br><img src="https://img-blog.csdnimg.cn/83a41b1d8a3044d6b8135850ea972ed1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
</ol>
<ul>
<li>从上图可以大致理清一个值被创建响应式状态的过程，下面分四部分解析<ul>
<li>reactive文件：目标对象转化为proxy实例</li>
<li>baseHandler文件：基本类型处理器</li>
<li>collectionHandlers文件：Map、Set处理器</li>
<li>effect文件：收集触发依赖</li>
</ul>
</li>
</ul>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul>
<li><code>reactive</code>：将一个JS对象转为具有响应式的proxy实例</li>
</ul>
<pre><code class="ts">export function reactive(target: object) &#123;
  // 如果是只读数据，就直接返回
  if (target &amp;&amp; (target as Target)[ReactiveFlags.IS_READONLY]) &#123;
    return target
  &#125;
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
&#125;
</code></pre>
<ul>
<li><code>createReactiveObject</code></li>
</ul>
<pre><code class="ts">function createReactiveObject(
  target: Target, // 源对象
  isReadonly: boolean, // 是否只读
  baseHandlers: ProxyHandler&lt;any&gt;, // 基本类型的handlers
  collectionHandlers: ProxyHandler&lt;any&gt;, // 主要针对(set、map、weakSet、weakMap)的handlers
  proxyMap: WeakMap&lt;Target, any&gt;
) &#123;
  // 如果不是一个对象，直接返回
  if (!isObject(target)) &#123;
    if (__DEV__) &#123;
      console.warn(`value cannot be made reactive: $&#123;String(target)&#125;`)
    &#125;
    return target
  &#125;
  // 如果已经是响应式，直接返回
  if (
    target[ReactiveFlags.RAW] &amp;&amp;
    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])
  ) &#123;
    return target
  &#125;

  // 如果目标对象已经存在代理，直接返回
  const existingProxy = proxyMap.get(target)
  if (existingProxy) &#123;
    return existingProxy
  &#125;

  // 如果类型值不是Object、Array、Map、Set、WeakMap、WeakSet的，直接返回
  const targetType = getTargetType(target)
  if (targetType === TargetType.INVALID) &#123;
    return target
  &#125;

  // 根据不同的类型值赋予不同的handlers，就是我之前图上画的分开处理
  /* 
    把set、Map这种数据与基础数据分开处理，是因为Map、Set中存储的数据必须通过this进行访问
    但是被proxy劫持后，this就变成了proxy，
    所以需要特殊处理，把劫持方法进行重写
   */
  const proxy = new Proxy(
    target,
    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers
  )
  proxyMap.set(target, proxy)
  return proxy
&#125;
</code></pre>
<h3 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h3><ul>
<li><code>baseHandler</code>这个文件我主要分析reactive的处理器对象<code>mutableHandlers</code></li>
</ul>
<pre><code class="ts">// 对get set delete has onwKeys做了拦截处理
export const mutableHandlers: ProxyHandler&lt;object&gt; = &#123;
  get,
  set,
  deleteProperty,
  has,
  ownKeys
&#125;
</code></pre>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><pre><code class="ts">function createGetter(isReadonly = false, shallow = false) &#123;
  return function get(target: Target, key: string | symbol, receiver: object) &#123;
    // 访问标志位时的逻辑处理
    if (key === ReactiveFlags.IS_REACTIVE) &#123;
      return !isReadonly
    &#125; else if (key === ReactiveFlags.IS_READONLY) &#123;
      return isReadonly
    &#125; else if (
      key === ReactiveFlags.RAW &amp;&amp;
      receiver ===
        (isReadonly
          ? shallow
            ? shallowReadonlyMap
            : readonlyMap
          : shallow
            ? shallowReactiveMap
            : reactiveMap
        ).get(target)
    ) &#123;
      return target
    &#125;

    const targetIsArray = isArray(target)

    // 如果target是数组并且key属于一些数组的原始方法，即触发拦截hack
    if (!isReadonly &amp;&amp; targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;
      return Reflect.get(arrayInstrumentations, key, receiver)
    &#125;

    const res = Reflect.get(target, key, receiver)

    // 如果key是symbol的内置方法，或者是原型对象，直接返回
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123;
      return res
    &#125;

    // 只读对象不收集依赖，因为不会触发依赖更新
    if (!isReadonly) &#123;
      track(target, TrackOpTypes.GET, key)
    &#125;

    // 浅层响应立即返回，不递归转化
    if (shallow) &#123;
      return res
    &#125;

    // 如果是ref对象(数组除外)，返回真正的值，
    if (isRef(res)) &#123;
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)
      return shouldUnwrap ? res.value : res
    &#125;

    if (isObject(res)) &#123;
      // 由于proxy只能代理一层，所以target[key]的值如果是对象，就继续对其进行代理
      return isReadonly ? readonly(res) : reactive(res)
    &#125;
    return res
  &#125;
&#125;
</code></pre>
<p>数组方法拦截hack: 响应式系统对数组的两种原生方法进行了hack</p>
<ul>
<li>遍历查找的方法：includes、indexOf、lastIndexOf</li>
<li>改变数组长度的方法：push、pop、shift、unshift、splice</li>
</ul>
<pre><code class="ts">function createArrayInstrumentations() &#123;
  const instrumentations: Record&lt;string, Function&gt; = &#123;&#125;
  ;([&#39;includes&#39;, &#39;indexOf&#39;, &#39;lastIndexOf&#39;] as const).forEach(key =&gt; &#123;
    const method = Array.prototype[key] as any
    instrumentations[key] = function(this: unknown[], ...args: unknown[]) &#123;
      // 这一步是为了取原始实例，因为当前的this是receiver
      const arr = toRaw(this)
      // 搜集依赖
      for (let i = 0, l = this.length; i &lt; l; i++) &#123;
        track(arr, TrackOpTypes.GET, i + &#39;&#39;)
      &#125;
      // 触发方法，如果没有找到对应的值，就取原始值再遍历
      const res = method.apply(arr, args)
      if (res === -1 || res === false) &#123;
        return method.apply(arr, args.map(toRaw))
      &#125; else &#123;
        return res
      &#125;
    &#125;
  &#125;)
  /* 
    因为改变数组长度的方法，执行期间会触发length的get和set
    就回导致无限循环track和trigger
    所以就用pauseTracking()禁用依赖收集，触发方法后，
    再用resetTracking()恢复track
   */
  ;([&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;] as const).forEach(key =&gt; &#123;
    const method = Array.prototype[key] as any
    instrumentations[key] = function(this: unknown[], ...args: unknown[]) &#123;
      pauseTracking()
      const res = method.apply(this, args)
      resetTracking()
      return res
    &#125;
  &#125;)
  return instrumentations
&#125;
</code></pre>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code class="ts">function createSetter(shallow = false) &#123;
  return function set(
    target: object,
    key: string | symbol,
    value: unknown,
    receiver: object
  ): boolean &#123;
    let oldValue = (target as any)[key]
    if (!shallow) &#123;
      value = toRaw(value)
      oldValue = toRaw(oldValue)
      // 如果原来的值是ref，但新的值不是，则将新的值赋给oldValue.value
      if (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;
        oldValue.value = value
        return true
      &#125;
    &#125; else &#123;
      // in shallow mode, objects are set as-is regardless of reactive or not
    &#125;

    const hadKey =
      isArray(target) &amp;&amp; isIntegerKey(key)
        ? Number(key) &lt; target.length
        : hasOwn(target, key)
    const result = Reflect.set(target, key, value, receiver)
    
    // 判断receiver是当前对象的proxy实例，防止原型链上的proxy触发更新
    if (target === toRaw(receiver)) &#123;
      // 判断新增属性还是修改属性
      if (!hadKey) &#123;
        trigger(target, TriggerOpTypes.ADD, key, value)
      &#125; else if (hasChanged(value, oldValue)) &#123;
        trigger(target, TriggerOpTypes.SET, key, value, oldValue)
      &#125;
    &#125;
    return result
  &#125;
&#125;
</code></pre>
<h4 id="deleteProperty、has…"><a href="#deleteProperty、has…" class="headerlink" title="deleteProperty、has…"></a>deleteProperty、has…</h4><ul>
<li>deleteProperty、has、ownKeys的源码就不贴了，都是判断key的属性，然后选择触发或者收集依赖</li>
</ul>
<h3 id="collectionHandlers"><a href="#collectionHandlers" class="headerlink" title="collectionHandlers"></a>collectionHandlers</h3><ul>
<li>collection这个文件我主要分析reactive的重写方法对象mutableInstrumentations</li>
</ul>
<pre><code class="ts">// 主要对以下原生api进行了改写
const mutableInstrumentations: Record&lt;string, Function&gt; = &#123;
  get(this: MapTypes, key: unknown) &#123;
    return get(this, key)
  &#125;,
  get size() &#123;
    return size((this as unknown) as IterableCollections)
  &#125;,
  has,
  add,
  set,
  delete: deleteEntry,
  clear,
  forEach: createForEach(false, false)
&#125;
</code></pre>
<h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><pre><code class="ts">function get(
  target: MapTypes,
  key: unknown,
  isReadonly = false,
  isShallow = false
) &#123;
  // 获取原始值重新赋值给target
  target = (target as any)[ReactiveFlags.RAW]

  // 对target源对象和key进一步获取原始值
  const rawTarget = toRaw(target)
  const rawKey = toRaw(key)

  // 包装后的key和原始key均进行依赖收集(track)
  if (key !== rawKey) &#123;
    !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.GET, key)
  &#125;
  !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.GET, rawKey)
  const &#123; has &#125; = getProto(rawTarget)

  // 获取对应的转换函数
  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive
  /* 
    如果源对象有key对应的属性，就通过原生get方法取到值，
    并对该值进行响应式转换，返回转换后的响应式对象，
    如果没有，就去key原始值中去查找
  */
  if (has.call(rawTarget, key)) &#123;
    return wrap(target.get(key))
  &#125; else if (has.call(rawTarget, rawKey)) &#123;
    return wrap(target.get(rawKey))
  &#125; else if (target !== rawTarget) &#123;
    target.get(key)
  &#125;
&#125;
</code></pre>
<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><pre><code class="ts">// 对size属性做get拦截
function size(target: IterableCollections, isReadonly = false) &#123;
  target = (target as any)[ReactiveFlags.RAW]
  // 获取size和获取数组的length类似，都用专门的key做依赖收集
  !isReadonly &amp;&amp; track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)
  return Reflect.get(target, &#39;size&#39;, target)
&#125;
</code></pre>
<h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><pre><code class="ts">function set(this: MapTypes, key: unknown, value: unknown) &#123;
  // 获取value和this上下文的原始值
  value = toRaw(value)
  const target = toRaw(this)
  const &#123; has, get &#125; = getProto(target)

  /* 
    判断源对象是否已经存在key对应的属性
    1. 首先查找源对象是否已有key对应的属性
    2. 如果没有，再查找key对应的原始值在源对象的属性是否存在
  */
  let hadKey = has.call(target, key)
  if (!hadKey) &#123;
    key = toRaw(key)
    hadKey = has.call(target, key)
  &#125; else if (__DEV__) &#123;
    checkIdentityKeys(target, has, key)
  &#125;

  const oldValue = get.call(target, key)
  target.set(key, value)

  // 触发依赖，新增属性和修改属性分开进行trigger
  if (!hadKey) &#123;
    trigger(target, TriggerOpTypes.ADD, key, value)
  &#125; else if (hasChanged(value, oldValue)) &#123;
    trigger(target, TriggerOpTypes.SET, key, value, oldValue)
  &#125;
  return this
&#125;
</code></pre>
<h4 id="has、clear…"><a href="#has、clear…" class="headerlink" title="has、clear…"></a>has、clear…</h4><ul>
<li>其余重写方法我就不上代码了，不同点是单个属性触发单个的依赖，如果是遍历所有属性的方法就触发所有依赖</li>
</ul>
<h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><ul>
<li>effect文件作为响应式的核心，主要负责收集依赖，触发依赖</li>
</ul>
<h4 id="effect-1"><a href="#effect-1" class="headerlink" title="effect"></a>effect</h4><ul>
<li>effect函数主要是生成收集依赖所需的依赖函数</li>
</ul>
<pre><code class="ts">export function effect&lt;T = any&gt;(
  fn: () =&gt; T,
  options: ReactiveEffectOptions = EMPTY_OBJ
): ReactiveEffect&lt;T&gt; &#123;
  // 如果已经是effect函数，取得原来的fn
  if (isEffect(fn)) &#123;
    fn = fn.raw
  &#125;
  const effect = createReactiveEffect(fn, options)

  // 如果lazy为false，立即执行一次
  if (!options.lazy) &#123;
    effect()
  &#125;
  return effect
&#125;
</code></pre>
<ul>
<li><code>createReactiveEffect</code>：生成effect对象</li>
</ul>
<pre><code class="ts">function createReactiveEffect&lt;T = any&gt;(
  fn: () =&gt; T,
  options: ReactiveEffectOptions
): ReactiveEffect&lt;T&gt; &#123;
  const effect = function reactiveEffect(): unknown &#123;
    // 没有激活，已经调用stop函数停止监听
    if (!effect.active) &#123;
      return fn()
    &#125;
    // 判断effectStack中有没有effect，避免递归循环，effectStack是一个全局effect栈
    if (!effectStack.includes(effect)) &#123;
      // 清除effect依赖，保证当前effect的dep是最新且有效的
      cleanup(effect)
      try &#123;
        enableTracking() // 重新收集依赖
        effectStack.push(effect)
        activeEffect = effect
        return fn()
      &#125; finally &#123;
        /* 
          track将依赖函数activeEffect添加到对应的dep中，
          然后将activeEffect重置为上一个effect的值
        */
        effectStack.pop()
        resetTracking()
        activeEffect = effectStack[effectStack.length - 1]
      &#125;
    &#125;
  &#125; as ReactiveEffect
  effect.id = uid++ // 自增ID
  effect.allowRecurse = !!options.allowRecurse // 递归状态
  effect._isEffect = true // 用于标识方法是不是effect
  effect.active = true // 用于判断当前effect是否激活，有一个stop()来将它设为false
  effect.raw = fn // effect的执行函数
  effect.deps = [] // 用于收集依赖
  effect.options = options // 创建effect传入的options
  return effect
&#125;
</code></pre>
<ul>
<li>activeEffect就是标记track所需的依赖函数</li>
</ul>
<h4 id="track"><a href="#track" class="headerlink" title="track"></a>track</h4><ul>
<li>track就是baseHandler和collectionHandlers文件中频繁使用的收集依赖函数</li>
<li>首先需要看一个关键变量targetMap</li>
</ul>
<pre><code class="ts">// targetMap是依赖管理中心，收集依赖和触发依赖都依托于这个Map数据
// 下面是targetMap的定义(target -&gt; key -&gt; dep)
// target: 监听的对象源
// key: 监听的键值
// dep：依赖函数
type Dep = Set&lt;ReactiveEffect&gt;
type KeyToDepMap = Map&lt;any, Dep&gt;
const targetMap = new WeakMap&lt;any, KeyToDepMap&gt;()
// 格式大致为
targetMap = &#123;
  target: &#123;
    key1: &#123; fn1, fn2 &#125;
    key2: &#123; fn1, fn2 &#125;
  &#125;
&#125;
</code></pre>
<pre><code class="ts">/**
 * @param &#123;target&#125; 目标对象
 * @param &#123;type&#125; 收集类型
 * @param &#123;key&#125; 需要收集依赖的key
 */
export function track(target: object, type: TrackOpTypes, key: unknown) &#123;
  // activeEffect为空，就表示当前没有依赖，就没必要做依赖收集了
  if (!shouldTrack || activeEffect === undefined) &#123;
    return
  &#125;
  // 获取当前依赖数据
  let depsMap = targetMap.get(target)

  if (!depsMap) &#123;
    targetMap.set(target, (depsMap = new Map()))
  &#125;

  // 如果当前数据中没有所属的依赖key，就重新设置一个
  let dep = depsMap.get(key)
  if (!dep) &#123;
    depsMap.set(key, (dep = new Set()))
  &#125;
  // 添加依赖函数
  if (!dep.has(activeEffect)) &#123;
    dep.add(activeEffect)
    activeEffect.deps.push(dep)
    if (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;
      activeEffect.options.onTrack(&#123;
        effect: activeEffect,
        target,
        type,
        key
      &#125;)
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><pre><code class="ts">// 触发依赖
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown,
  oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;
) &#123;
  const depsMap = targetMap.get(target)
  // 如果没有收集过依赖，直接返回
  if (!depsMap) &#123;
    return
  &#125;

  const effects = new Set&lt;ReactiveEffect&gt;()
  const add = (effectsToAdd: Set&lt;ReactiveEffect&gt; | undefined) =&gt; &#123;
    if (effectsToAdd) &#123;
      effectsToAdd.forEach(effect =&gt; &#123;
        // 避免重复触发依赖
        if (effect !== activeEffect || effect.allowRecurse) &#123;
          effects.add(effect)
        &#125;
      &#125;)
    &#125;
  &#125;

  if (type === TriggerOpTypes.CLEAR) &#123;
    // 在清空前，将对应的依赖全部添加到局部Set
    depsMap.forEach(add)
  &#125; else if (key === &#39;length&#39; &amp;&amp; isArray(target)) &#123;
    // 当数组的length属性变化时触发
    depsMap.forEach((dep, key) =&gt; &#123;
      if (key === &#39;length&#39; || key &gt;= (newValue as number)) &#123;
        add(dep)
      &#125;
    &#125;)
  &#125; else &#123;
    // schedule runs for SET | ADD | DELETE
    // 往相应队列添加依赖
    if (key !== void 0) &#123;
      add(depsMap.get(key))
    &#125;

    // also run for iteration key on ADD | DELETE | Map.SET
    // 通过不同的TriggerOpTypes将depsMap的数据取出，添加到effects
    switch (type) &#123;
      case TriggerOpTypes.ADD:
        if (!isArray(target)) &#123;
          add(depsMap.get(ITERATE_KEY))
          if (isMap(target)) &#123;
            add(depsMap.get(MAP_KEY_ITERATE_KEY))
          &#125;
        &#125; else if (isIntegerKey(key)) &#123;
          // new index added to array -&gt; length changes
          add(depsMap.get(&#39;length&#39;))
        &#125;
        break
      case TriggerOpTypes.DELETE:
        if (!isArray(target)) &#123;
          add(depsMap.get(ITERATE_KEY))
          if (isMap(target)) &#123;
            add(depsMap.get(MAP_KEY_ITERATE_KEY))
          &#125;
        &#125;
        break
      case TriggerOpTypes.SET:
        if (isMap(target)) &#123;
          add(depsMap.get(ITERATE_KEY))
        &#125;
        break
    &#125;
  &#125;

  const run = (effect: ReactiveEffect) =&gt; &#123;
    if (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;
      effect.options.onTrigger(&#123;
        effect,
        target,
        key,
        type,
        newValue,
        oldValue,
        oldTarget
      &#125;)
    &#125;
    if (effect.options.scheduler) &#123;
      // 如果有调度属性，就通过scheduler处理执行
      effect.options.scheduler(effect)
    &#125; else &#123;
      effect()
    &#125;
  &#125;

  effects.forEach(run)
&#125;
</code></pre>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-08-01</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>大约2765个字, 9分钟13秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/07/17/%E8%A7%A3%E6%9E%90nextTick-vue3%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">解析nextTick---vue3任务调度</a></h3></div><div class="post-content"><div class="card"><p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><blockquote>
<p>定义：将回调推迟到下一个 DOM 更新周期之后执行，在更改了一些数据以等待 DOM 更新后立即使用它<br>在实际中使用这个方法一般是用于组件更新，你需要获取更新后的数据，所以使用nextTick等待DOM更新</p>
</blockquote>
<pre><code class="js">// vue3中的语法对比vue2做了一些改动
import &#123; createApp, nextTick &#125; from &#39;vue&#39;
const app = createApp(&#123;
  setup() &#123;
    const message = ref(&#39;Hello!&#39;)
    const changeMessage = async newMessage =&gt; &#123;
      message.value = newMessage
      // 这里的value是旧值
      await nextTick()
      // nextTick后获取的就是DOM更新后的value
      console.log(&#39;Now DOM is updated&#39;)
    &#125;
  &#125;
&#125;)
</code></pre>
<ul>
<li>这个api使用时相当简单，而且相当容易理解，但是为了知其意，还是要翻一下源码了解它的执行机制</li>
</ul>
<pre><code class="ts">export function nextTick(
  this: ComponentPublicInstance | void,
  fn?: () =&gt; void
): Promise&lt;void&gt; &#123;
  const p = currentFlushPromise || resolvedPromise
  return fn ? p.then(this ? fn.bind(this) : fn) : p
&#125;
</code></pre>
<ul>
<li>上面是vue源码中nextTick的实现，为了搞清楚实现逻辑，就必须搞懂<code>currentFlushPromise</code>这个变量的含义，所以要从任务的调度机制开始分析</li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>首先这个调度机制的功能在<code>runtime-core</code>的<code>scheduler</code>文件</p>
<ul>
<li>API</li>
</ul>
<pre><code class="ts">// 这个文件会抛出以下几个API函数
nextTick()&#123;&#125; // 将函数在任务队列清空后执行
queueJob()&#123;&#125; // 添加任务并开始执行任务队列
invalidateJob()&#123;&#125; // 删除任务
queuePreFlushCb()&#123;&#125; // 添加前置回调函数并开始执行任务队列
queuePostFlushCb()&#123;&#125; // 添加后置回调函数并开始执行任务队列
flushPreFlushCbs()&#123;&#125; // 执行前置回调函数
flushPostFlushCbs()&#123;&#125; // 执行后置回调函数
</code></pre>
<ul>
<li>我们首先要知道几个关键变量</li>
</ul>
<pre><code class="ts">let isFlushing = false // 是否正在清空任务队列
let isFlushPending = false // 清队任务已创建，等待清空状态
const queue: SchedulerJob[] = [] // 任务队列
let flushIndex = 0 // 当前正在执行的任务在任务队列中的索引
</code></pre>
<ul>
<li>然后我们从<code>queueJob</code>这个函数开始</li>
</ul>
<pre><code class="ts">/* 
  这个函数主要是将一个任务(job)进行入队操作
  然后在满足条件的情况下启动清空队列任务(queueFlush)
 */
export function queueJob(job: SchedulerJob) &#123;
  /**
   * 任务可入队逻辑
   * 1. 任务队列为空
   * 2. 待入队任务不能存在于任务队列中(按情况分析)
   */
  if (
    (!queue.length ||
      !queue.includes(
        job,
        /* 
          在正在清空队列且当前待入队任务是可以递归时，
          说明当前任务一定和当前正在执行任务是同一任务，所以+1，
          就是为了保证待入队任务和正在执行任务相同，但不能和后面待执行任务相同
         */
        isFlushing &amp;&amp; job.allowRecurse ? flushIndex + 1 : flushIndex
      )) &amp;&amp;
    job !== currentPreFlushParentJob
  ) &#123;
    // 二分查找任务在队列中的位置
    const pos = findInsertionIndex(job)
    if (pos &gt; -1) &#123;
      queue.splice(pos, 0, job)
    &#125; else &#123;
      queue.push(job)
    &#125;
    queueFlush()
  &#125;
&#125;
</code></pre>
<ul>
<li><code>queueFlush</code></li>
</ul>
<pre><code class="ts">function queueFlush() &#123;
  /**
    清队任务创建后禁止再次创建更多的清队任务
    因为在入队操作完成后，flushJobs会在一次递归中将任务队列全部清空，所以只需要一次清队任务即可
   */
  if (!isFlushing &amp;&amp; !isFlushPending) &#123;
    isFlushPending = true
    /* 
      清队任务创建成功，并记录下当前清队任务，这个标记可以用于nextTick创建自定义函数，
      说明nextTick的执行时机是在清队任务后的，其实从这个地方就可以理解nextTick的执行原理了
    */
    currentFlushPromise = resolvedPromise.then(flushJobs)
  &#125;
&#125;
</code></pre>
<ul>
<li><code>flushJobs</code></li>
</ul>
<pre><code class="ts">// 清空任务队列
function flushJobs(seen?: CountMap) &#123;
  isFlushPending = false // 关闭清队任务等待状态
  isFlushing = true // 开启正在清空队列状态
  if (__DEV__) &#123;
    seen = seen || new Map()
  &#125;

  // 清空前置回调任务队列
  flushPreFlushCbs(seen)

  /* 
    任务队列中的任务根据ID进行排序的原因
      1. 因为组件更新是从父组件到子组件的，而任务更新是在数据源更新时触发的，所以为了更新任务的顺序就需要进行排序
      2. 如果在父组件更新期间已经卸载了组件，那么子组件的更新任务就可以跳过
  */
  queue.sort((a, b) =&gt; getId(a) - getId(b))

  try &#123;
    // 遍历任务队列
    for (flushIndex = 0; flushIndex &lt; queue.length; flushIndex++) &#123;
      const job = queue[flushIndex]
      if (job &amp;&amp; job.active !== false) &#123;
        if (__DEV__ &amp;&amp; checkRecursiveUpdates(seen!, job)) &#123;
          continue
        &#125;
        // 执行当前任务
        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)
      &#125;
    &#125;
  &#125; finally &#123;
    // 重置当前任务索引
    flushIndex = 0
    // 清空任务队列
    queue.length = 0

    // 执行后置回调任务队列
    flushPostFlushCbs(seen)
    // 重置清队任务的状态
    isFlushing = false
    currentFlushPromise = null
    /* 
      因为清队任务执行期间也会有任务入队，所以为了清队执行完成
      就需要判断各任务队列的长度，然后递归执行
    */
    if (
      queue.length ||
      pendingPreFlushCbs.length ||
      pendingPostFlushCbs.length
    ) &#123;
      flushJobs(seen)
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>nextTick的执行时机是在任务队列(前置、主任务、后置)清除后的，<code>currentFlushPromise</code>是清队任务的promise标记</li>
<li>任务队列执行顺序：执行前置回调任务队列 -&gt; 执行主任务队列 -&gt; 执行后置回调任务队列</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-07-17</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><span class="leancloud_visitors"></span><span>大约1215个字, 4分钟3秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/06/12/%E8%A7%A3%E5%86%B3react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-ReactQuery/">解决react状态管理---React Query</a></h3></div><div class="post-content"><div class="card"><p><p><img src="https://img-blog.csdnimg.cn/20210612171112847.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="React Query"></p>
<h3 id="什么是React-Query"><a href="#什么是React-Query" class="headerlink" title="什么是React Query"></a>什么是React Query</h3><ul>
<li><code>react-query</code>是一个适用于react hooks的请求库，它可以为任何类型的异步数据提供React状态管理功能，使React中的获取、缓存、同步和更新服务器数据变得轻而易举</li>
<li><code>react-query</code>与一些传统的状态管理库如redux,mobx不同，它是负责管理服务器与客户端之间的状态，一些用户交互的中间状态，如loading状态，错误信息等都是通过hooks直接返回</li>
<li><a target="_blank" rel="noopener" href="https://react-query-v2.tanstack.com/">React Query官网</a></li>
</ul>
<h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><ol>
<li><code>yarn add react-query</code> or <code>npm i react-query</code>安装react-query</li>
<li>使用<code>QueryClientProvider</code>组件连接并提供一个<code>QueryClient</code>到你的应用程序</li>
</ol>
<pre><code class="js">import &#123; QueryClient, QueryClientProvider &#125; from &#39;react-query&#39;

&lt;QueryClientProvider client=&#123;new QueryClient()&#125;&gt;
  &#123; ... &#125;
&lt;/QueryClientProvider&gt;
</code></pre>
<h4 id="Devtools"><a href="#Devtools" class="headerlink" title="Devtools"></a>Devtools</h4><ul>
<li><code>yarn add react-query-devtools</code> or <code>npm i --save react-query-devtools</code>安装Devtools</li>
<li><code>react-query-devtools</code>是与<code>react-query</code>相匹配的开发工具</li>
<li>可在开发中实时查看缓存，手动获取和删除查询等等</li>
</ul>
<pre><code class="js">import &#123; ReactQueryDevtools &#125; from &#39;react-query-devtools&#39;

const App = () =&gt; &#123;
  return (
    &lt;&gt;    
      &#123; ... &#125;
      &lt;ReactQueryDevtools initialIsOpen=&#123;true&#125; /&gt;
    &lt;/&gt;
  );
&#125;;
</code></pre>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><ul>
<li>react-query最常用的两个hook，查询(<code>useQuery</code>)、增删改(<code>useMutation</code>)</li>
</ul>
<h4 id="useQuery"><a href="#useQuery" class="headerlink" title="useQuery"></a>useQuery</h4><ul>
<li><code>useQuery</code>：在<code>React Query</code>中，查询是对某些异步数据源的声明性依赖。查询可以与任何基于Promise的方法(GET)一起使用，从服务器获取数据</li>
</ul>
<pre><code class="js">const useTodos = (param) =&gt; &#123;
  const request = useHttp()

  /**
   * 第一个参数是QueryKey，是查询的关键，是一个独一无二的key，并在之后的增删改中需要，
   * 	如果需要动态的QueryKey，可以使用数组的方式，如[&#39;todos&#39;, params]
   * 第二个参数是用于获取数据的异步函数
   * useQuery的响应返回就是获取到的数据和一些中间状态，如isLoading，error，isIdle...
   */
  return useQuery(&#39;todos&#39;, () =&gt;
    request(&#39;todos&#39;, &#123; data: param &#125;)
  )
&#125;

// 在UI组件调用
const &#123; isLoading, error, data: todos &#125; = useTodos()
</code></pre>
<h4 id="useMutation"><a href="#useMutation" class="headerlink" title="useMutation"></a>useMutation</h4><ul>
<li><code>useMutation</code>：常用于创建&#x2F;更新&#x2F;删除数据或执行服务器副作用</li>
</ul>
<pre><code class="js">const useAddTodo = () =&gt; &#123;
  const request = useHttp()

  /**
   * 第一个参数是执行操作的异步函数，在返回的mutate中触发
   * 第二个参数是执行成功或者失败的一些配置函数，可用于一些处理缓存的操作，例如乐观更新
   */
  return useMutation(
    (data) =&gt;
      request(`todos`, &#123;
        data,
        method: &#39;POST&#39;,
      &#125;),
    &#123;
      onSuccess()&#123;&#125;
      onError()&#123;&#125;
      onSettled()&#123;&#125;
      ...
    &#125;
  )
&#125;

// 操作组件调用
const TodosAddBtn = () =&gt; &#123;
  ...
  const &#123; mutateAsync, isLoading, error &#125; = useAddTodo()
  return &lt;Button onClick=&#123;() =&gt; mutateAsync(todoData)&#125;&gt;add&lt;/Button&gt;
&#125;
</code></pre>
<h5 id="例：用第二个参数配置乐观更新"><a href="#例：用第二个参数配置乐观更新" class="headerlink" title="例：用第二个参数配置乐观更新"></a>例：用第二个参数配置乐观更新</h5><ul>
<li>乐观更新就是在一些请求或者数据处理没有结束的时候，提前给用户显示理想的结果，如果失败就回滚更新</li>
</ul>
<pre><code class="js">const useAddConfig = (queryKey) =&gt; &#123;
  // 获取当前QueryClient的实例
  const queryClient = useQueryClient()
  
  return &#123;
    // 当mutate被调用时触发
    async onMutate(target) &#123;
      // 获取当前数据快照，用于错误时回滚更新
      const previousItems = queryClient.getQueryData(queryKey)
      // 乐观更新为新值
      queryClient.setQueryData(queryKey, (old) =&gt; &#123;
        return (target, old) =&gt; (old ? [...old, target] : [])
      &#125;)

      // 这个返回值会作为最后一个参数传递给onError和onSettled
      return &#123; previousItems &#125;
    &#125;,
    // 成功回调 清除缓存
    onSuccess: () =&gt; queryClient.invalidateQueries(queryKey),
    // 失败回调
    onError(error, newItem, context) &#123;
      // 当前queryKey的数据回滚
      queryClient.setQueryData(
        queryKey,
        context.previousItems
      )
    &#125;,
    // 无论错误或者成功都会触发，此例子没有使用
    onSettled() &#123;&#125;
  &#125;
&#125;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>本地&#x2F;客户端中间状态<ul>
<li>redux与react-query都可，没有较大的优缺点</li>
</ul>
</li>
<li>服务端中间状态<ul>
<li>推荐react-query，将服务器状态从全局状态中解放出来，用更少的代码实现复杂的需求，让你的状态管理更优雅</li>
</ul>
</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-06-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/React/" title="React">React </a><i class="fa fa-tag"></i><a class="tag" href="/tags/ReactQuery/" title="ReactQuery">ReactQuery </a><span class="leancloud_visitors"></span><span>大约897个字, 2分钟59秒读完</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2021/06/10/H5%E8%B7%B3%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">H5跳转微信小程序</a></h3></div><div class="post-content"><div class="card"><p><h2 id="H5跳转微信小程序"><a href="#H5跳转微信小程序" class="headerlink" title="H5跳转微信小程序"></a>H5跳转微信小程序</h2><blockquote>
<p>H5跳转小程序有两个方法，需要根据浏览器环境判断<br>微信外使用<code>URL Scheme</code>，根据生成的一个link进行location跳转<br>微信内使用<code>wx-open-launch-weapp</code>开放标签进行跳转，实测ios系统微信内也可以使用<code>URL Scheme</code>，根据自己的需求选择</p>
</blockquote>
<h3 id="wx-open-launch-weapp"><a href="#wx-open-launch-weapp" class="headerlink" title="wx-open-launch-weapp"></a><code>wx-open-launch-weapp</code></h3><ul>
<li><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html">官方文档</a></li>
<li>注意事项：微信版本要求为：7.0.12及以上。 系统版本要求为：iOS 10.3及以上、Android 5.0及以上</li>
<li>绑定域名: 登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”  </li>
<li>引入SDK：官网推荐引入方法<code>&lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;</code>;，也可以使用第三方npm包<code>weixin-js-sdk</code>  </li>
<li>校验签名是否正确：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign">微信 JS 接口签名校验工具</a></li>
<li>如果开放标签需要绝对定位，就在外面包裹一个div进行定位，避免直接定位开放标签</li>
<li>调试：好多人在进行调试的时候认为非常麻烦，需要不断切换环境，我推荐一个我的调试方式，在开发过程中，使用SwitchHosts进行IP映射，把本地启动项目的域名映射到公众号平台设置的域名，然后在微信开发工具中调试，就非常轻松了</li>
</ul>
<pre><code class="html">// 普通H5的写法可参考官方文档，以下是我在vue中的写法
&lt;wx-open-launch-weapp
 username=&quot;小程序原始id&quot;
 path=&quot;页面路径及参数&quot;&gt;
  &lt;script type=&quot;text/wxtag-template&quot;&gt;           
    &lt;button class=&quot;wx-btn&quot;&gt;跳转小程序&lt;/button&gt;   
  &lt;/script&gt;
&lt;/wx-open-launch-weapp&gt;
&lt;script&gt;
...
async mounted() &#123;
  const wx = require(&#39;weixin-js-sdk&#39;)
  wx.config(&#123;
    debug: true, // 开启调试模式，会在移动端以alert的形式打印返回值
    appId: &#39;&#39;, // 必填，从服务端获取
    timestamp: , // 必填，生成签名的时间戳，从服务端获取
    nonceStr: &#39;&#39;, // 必填，生成签名的随机串，从服务端获取
    signature: &#39;&#39;,// 必填，签名，从服务端获取
    jsApiList: [], // 必填，需要使用的JS接口列表，这个随便填一个就行
    openTagList: [&#39;wx-open-launch-weapp&#39;]
  &#125;)
  wx.ready((e) =&gt; console.log(e))
  wx.error((e) =&gt; console.log(e))
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a><code>URL Scheme</code></h3><ul>
<li>注意事项：安卓不能直接跳转，需要H5中转，否则Android会出现无法访问</li>
<li>写法很简单，只需<code>location.href=&#39;URL Scheme&#39;</code>，在页面初始化时调用或者在按钮点击事件中调用</li>
</ul>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-06-10</span><i class="fa fa-tag"></i><a class="tag" href="/tags/H5/" title="H5">H5 </a><i class="fa fa-tag"></i><a class="tag" href="/tags/微信小程序/" title="微信小程序">微信小程序 </a><span class="leancloud_visitors"></span><span>大约672个字, 2分钟14秒读完</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/2/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>