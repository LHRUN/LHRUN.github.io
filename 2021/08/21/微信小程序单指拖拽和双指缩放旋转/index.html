<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>LH&#39;BLOG | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">LH&#39;BLOG</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            微信小程序单指拖拽和双指缩放旋转
        </div>
        <div class="post-meta">
            2021-08-21
        </div>
    

    <div class="post-md">
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>小程序单指拖拽和双指操作是一个比较常用的功能，效果如下图<br><img src="https://img-blog.csdnimg.cn/babbbc7162d241e9b0fb01e0b18531eb.gif#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>实现这三个功能，主要用三个触摸事件<code>touchstart</code>、<code>touchmove</code>、<code>touchend</code></li>
</ul>
<pre><code class="html">&lt;view style=&quot;height: 100vh; width: 100vw&quot;&gt;
  &lt;image
    src=&quot;...&quot;
    style=&quot;transform: translate(&#123;&#123;translateX&#125;&#125;px, &#123;&#123;translateY&#125;&#125;px) scale(&#123;&#123;scale&#125;&#125;) rotate(&#123;&#123;rotate&#125;&#125;deg);&quot;
    catch:touchstart=&quot;touchStart&quot;
    catch:touchmove=&quot;touchMove&quot;
    catch:touchend=&quot;touchEnd&quot;
  /&gt;
&lt;/view&gt;
</code></pre>
<ul>
<li>用了以下变量</li>
</ul>
<pre><code class="ts">Page(&#123;
  data: &#123;
    translateX: 0, // 位移x坐标 单位px
    translateY: 0, // 位移y坐标 单位px
    distance: 0, // 双指接触点距离
    scale: 1, // 缩放倍数
    rotate: 0, // 旋转角度
    oldRotate: 0, // 上一次旋转停止后的角度
    startMove: &#123; // 起始位移距离
      x: 0,
      y: 0,
    &#125;,
    startTouches: [] // 起始点touch数组
  &#125;,
&#125;)
</code></pre>
<h3 id="单指拖拽"><a href="#单指拖拽" class="headerlink" title="单指拖拽"></a>单指拖拽</h3><ul>
<li>单指拖拽比较简单，只需要记录移动的点坐标，然后减去起始点坐标，就可以求出针对页面的移动距离</li>
<li><code>touchstart</code></li>
</ul>
<pre><code class="ts">touchStart(e) &#123;
  const touches = e.touches
  const &#123; translateX, translateY &#125; = this.data
  const &#123; pageX, pageY &#125; = touches[0]
  this.data.startMove = &#123;
    x: pageX - translateX,
    y: pageY - translateY
  &#125;
  this.data.startTouches = touches
&#125;,
</code></pre>
<ul>
<li><code>touchmove</code></li>
</ul>
<pre><code class="ts">touchMove(e) &#123;
  const touches = e.touches
  const &#123; pageX: onePageX, pageY: onePageY &#125; = touches[0]
  const &#123; startMove &#125; = this.data
  this.setData(&#123;
    translateX: onePageX - startMove.x,
    translateY: onePageY - startMove.y
  &#125;)
&#125;
</code></pre>
<h3 id="双指缩放"><a href="#双指缩放" class="headerlink" title="双指缩放"></a>双指缩放</h3><ul>
<li>双指缩放的原理是根据两点坐标求出距离(勾股定理)，然后在用移动坐标的距离比就可以求出缩放倍数</li>
<li><code>touchmove</code></li>
</ul>
<pre><code class="js">touchMove(e) &#123;
  const touches = e.touches
  const &#123; pageX: onePageX, pageY: onePageY &#125; = touches[0]
  const &#123; startMove, scale, distance: oldDistance, startTouches &#125; = this.data
  if (touches.length === 2 &amp;&amp; startTouches.length === 2) &#123;
      // 双指缩放
    const &#123; pageX: twoPageX, pageY: twoPageY &#125; = touches[1]
    // 求出当前双指距离
    const distance = Math.sqrt((twoPageX - onePageX) ** 2 + (twoPageY - onePageY) ** 2)
    this.data.distance = distance
    this.setData(&#123;
      scale: scale * (distance / (oldDistance || distance))
    &#125;)
  &#125; else if (startTouches.length !== 2) &#123;
      // 单指拖拽
    this.setData(&#123;
      translateX: onePageX - startMove.x,
      translateY: onePageY - startMove.y
    &#125;)
  &#125;
&#125;
</code></pre>
<ul>
<li><code>startTouches.length !== 2</code>这个判断的原因是防止图片跳动，因为如果你两个手指触摸，然后离开一个手指，我是禁止拖拽的，只有双指都离开后再次触摸才能单指拖拽</li>
</ul>
<h3 id="双指旋转"><a href="#双指旋转" class="headerlink" title="双指旋转"></a>双指旋转</h3><ul>
<li>双指旋转的原理是根据三角函数求出起始点的角度，然后再求出移动坐标的角度，相减然后加上上一次旋转的角度就等于你当前所需的选择角度</li>
<li><code>touchmove</code></li>
</ul>
<pre><code class="ts">touchMove(e) &#123;
  const touches = e.touches
  const &#123; pageX: onePageX, pageY: onePageY &#125; = touches[0]
  const &#123; startMove, scale, distance: oldDistance, startTouches, oldRotate &#125; = this.data
  if (touches.length === 2 &amp;&amp; startTouches.length === 2) &#123;
    const &#123; pageX: twoPageX, pageY: twoPageY &#125; = touches[1]
    const distance = Math.sqrt((twoPageX - onePageX) ** 2 + (twoPageY - onePageY) ** 2)
+   let rotate = this.getAngle(touches[0], touches[1]) - this.getAngle(startTouches[0], startTouches[1]) + oldRotate
    // 如果大于360度，就减去360
+   rotate = rotate &gt; 360 ? rotate - 360 : rotate
    this.data.distance = distance
    this.setData(&#123;
      scale: scale * (distance / (oldDistance || distance)),
+     rotate
    &#125;)
  &#125; else if (startTouches.length !== 2) &#123;
    this.setData(&#123;
      translateX: onePageX - startMove.x,
      translateY: onePageY - startMove.y
    &#125;)
  &#125;
&#125;,
</code></pre>
<ul>
<li><code>getAngle</code></li>
</ul>
<pre><code class="ts">getAngle(p1, p2) &#123;
  const x = p1.pageX - p2.pageX
  const y = p1.pageY- p2.pageY
  return Math.atan2(y, x) * 180 / Math.PI
&#125;
</code></pre>
<ul>
<li><code>touchend</code></li>
</ul>
<pre><code class="ts">touchEnd() &#123;
  // 保存当前旋转角度
  this.data.oldRotate = this.data.rotate
&#125;,
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/0nS1tImU7Rs5</code></li>
<li>H5原理一致，只需改一下语法即可</li>
<li>我这个只是基础版本，如果需要一些边界控制和还一些需求的限制，计算据边框距离即可，也可以用小程序的<code>boundingClientRect</code>API</li>
</ul>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 LH&#39;BLOG</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>