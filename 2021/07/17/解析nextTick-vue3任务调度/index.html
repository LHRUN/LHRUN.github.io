<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="LH_R"><title>解析nextTick---vue3任务调度 · LH'BLOG</title><meta name="description" content="nextTick
定义：将回调推迟到下一个 DOM 更新周期之后执行，在更改了一些数据以等待 DOM 更新后立即使用它
在实际中使用这个方法一般是用于组件更新，你需要获取更新后的数据，所以使用nextTick等待DOM更新

import &amp;#123; createApp, nextTick &amp;#1"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/archives">归档</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo.jpeg" style="width:220px; border-radius:110px" alt="favicon"><h3 title=""><a href="/">LH'BLOG</a></h3><div class="description"><p>keep learning</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/lhrun"><i class="fa fa-github"></i></a></li><li><a target="_blank" rel="noopener" href="https://segmentfault.com/u/lh_s"><i class="fa fa-segmentfault"></i></a></li></ul></div><details class="ltr" open><summary>目录</summary><div class="tocmenu"><p><ol class="toclist"><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#nextTick"><span class="toclist-number">1.</span> <span class="toclist-text">nextTick</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toclist-number">2.</span> <span class="toclist-text">任务调度</span></a></li><li class="toclist-item toclist-level-3"><a class="toclist-link" href="#%E6%80%BB%E7%BB%93"><span class="toclist-number">3.</span> <span class="toclist-text">总结</span></a></li></ol></p></div></details></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> LH_R</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>解析nextTick---vue3任务调度</a></h3></div><div class="post-content"><p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><ul>
<li>定义：将回调推迟到下一个 DOM 更新周期之后执行，在更改了一些数据以等待 DOM 更新后立即使用它</li>
<li>在实际中使用这个方法一般是用于组件更新，你需要获取更新后的数据，所以使用nextTick等待DOM更新</li>
</ul>
<pre><code class="js">import &#123; createApp, nextTick &#125; from &#39;vue&#39;
const app = createApp(&#123;
    setup() &#123;
      const message = ref(&#39;Hello!&#39;)
      const changeMessage = async newMessage =&gt; &#123;
        message.value = newMessage
        // 这里的value是旧值
        await nextTick()
        // nextTick后获取的就是DOM更新后的value
        console.log(&#39;Now DOM is updated&#39;)
      &#125;
    &#125;
&#125;)
</code></pre>
<ul>
<li>这个api使用时相当简单，而且相当容易理解，但是为了知其意，还是要翻一下源码了解它的执行机制</li>
</ul>
<pre><code class="ts">export function nextTick(
  this: ComponentPublicInstance | void,
  fn?: () =&gt; void
): Promise&lt;void&gt; &#123;
  const p = currentFlushPromise || resolvedPromise
  return fn ? p.then(this ? fn.bind(this) : fn) : p
&#125;
</code></pre>
<ul>
<li>上面是vue源码中nextTick的实现，为了搞清楚实现逻辑，就必须搞懂<code>currentFlushPromise</code>这个变量的含义，所以要从任务的调度机制开始分析</li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>首先这个调度机制的功能在<code>runtime-core</code>的<code>scheduler</code>文件</p>
<ul>
<li>API</li>
</ul>
<pre><code class="ts">// 这个文件会抛出以下几个API函数
nextTick()&#123;&#125; // 将函数在任务队列清空后执行
queueJob()&#123;&#125; // 添加任务并开始执行任务队列
invalidateJob()&#123;&#125; // 删除任务
queuePreFlushCb()&#123;&#125; // 添加前置回调函数并开始执行任务队列
queuePostFlushCb()&#123;&#125; // 添加后置回调函数并开始执行任务队列
flushPreFlushCbs()&#123;&#125; // 执行前置回调函数
flushPostFlushCbs()&#123;&#125; // 执行后置回调函数
</code></pre>
<ul>
<li>我们首先要知道几个关键变量</li>
</ul>
<pre><code class="ts">let isFlushing = false // 是否正在清空任务队列
let isFlushPending = false // 清队任务已创建，等待清空状态
const queue: SchedulerJob[] = [] // 任务队列
let flushIndex = 0 // 当前正在执行的任务在任务队列中的索引
</code></pre>
<ul>
<li>然后我们从<code>queueJob</code>这个函数开始</li>
</ul>
<pre><code class="ts">/* 
  这个函数主要是将一个任务进行入队操作
  然后在满足条件的情况下启动queueFlush
 */
export function queueJob(job: SchedulerJob) &#123;
    /**
     * 任务可入队逻辑
     * 1. 任务队列为空
     * 2. 待入队任务不能存在于任务队列中(按情况分析)
     */
    if (
      (!queue.length ||
        !queue.includes(
          job,
          /* 
            在正在清空队列且当前待入队任务是可以递归时，
            说明当前任务一定和当前正在执行任务是同一任务，所以+1，
            就是为了保证待入队任务和正在执行任务相同，但不能和后面待执行任务相同
           */
          isFlushing &amp;&amp; job.allowRecurse ? flushIndex + 1 : flushIndex
        )) &amp;&amp;
      job !== currentPreFlushParentJob
    ) &#123;
      // 二分查找任务在队列中的位置
      const pos = findInsertionIndex(job)
      if (pos &gt; -1) &#123;
        queue.splice(pos, 0, job)
      &#125; else &#123;
        queue.push(job)
      &#125;
      queueFlush()
    &#125;
&#125;
</code></pre>
<ul>
<li><code>queueFlush</code></li>
</ul>
<pre><code class="ts">function queueFlush() &#123;
    /**
      清队任务创建后禁止再次创建更多的清队任务
      因为在入队操作完成后，flushJobs会在一次递归中将任务队列全部清空，所以只需要一次清队任务即可
     */
    if (!isFlushing &amp;&amp; !isFlushPending) &#123;
      isFlushPending = true
      /* 
        清队任务创建成功，并记录下当前清队任务，这个标记可以用于nextTick创建自定义函数，
        说明nextTick的执行时机是在清队任务后的，其实从这个地方就可以理解nextTick的执行原理了
      */
      currentFlushPromise = resolvedPromise.then(flushJobs)
    &#125;
&#125;
</code></pre>
<ul>
<li><code>flushJobs</code></li>
</ul>
<pre><code class="ts">// 清空任务队列
function flushJobs(seen?: CountMap) &#123;
    isFlushPending = false // 关闭清队任务等待状态
    isFlushing = true // 开启正在清空队列状态
    if (__DEV__) &#123;
      seen = seen || new Map()
    &#125;

    // 清空前置回调任务队列
    flushPreFlushCbs(seen)

    /* 
      任务队列中的任务根据ID进行排序的原因
        1. 因为组件更新是从父组件到子组件的，而任务更新是在数据源更新时触发的，所以为了更新任务的顺序就需要进行排序
        2. 如果在父组件更新期间已经卸载了组件，那么子组件的更新任务就可以跳过
    */
    queue.sort((a, b) =&gt; getId(a) - getId(b))

    try &#123;
      // 遍历任务队列
      for (flushIndex = 0; flushIndex &lt; queue.length; flushIndex++) &#123;
        const job = queue[flushIndex]
        if (job &amp;&amp; job.active !== false) &#123;
          if (__DEV__ &amp;&amp; checkRecursiveUpdates(seen!, job)) &#123;
            continue
          &#125;
          // 执行当前任务
          callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)
        &#125;
      &#125;
    &#125; finally &#123;
      // 重置当前任务索引
      flushIndex = 0
      // 清空任务队列
      queue.length = 0

      // 执行后置回调任务队列
      flushPostFlushCbs(seen)
        // 重置清队任务的状态
      isFlushing = false
      currentFlushPromise = null
      /* 
        因为清队任务执行期间也会有任务入队，所以为了清队执行完成
        就需要判断各任务队列的长度，然后递归执行
      */
      if (
        queue.length ||
        pendingPreFlushCbs.length ||
        pendingPostFlushCbs.length
      ) &#123;
        flushJobs(seen)
      &#125;
    &#125;
&#125;
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>nextTick的执行时机是在任务队列(前置、主任务、后置)清除后的，<code>currentFlushPromise</code>是清队任务的promise标记</li>
<li>任务队列执行顺序：执行前置回调任务队列 -&gt; 执行主任务队列 -&gt; 执行后置回调任务队列</li>
</ul>
</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-07-17</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue/" title="Vue">Vue </a><i class="fa fa-tag"></i><a class="tag" href="/tags/Vue3/" title="Vue3">Vue3 </a><span class="leancloud_visitors"></span><span>大约1194个字, 3分钟58秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://lhrun.github.io/2021/07/17/解析nextTick-vue3任务调度/,LH'BLOG,解析nextTick---vue3任务调度,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/08/01/%E8%A7%A3%E6%9E%90reactive-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/" title="vue3响应式分析">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/06/12/%E8%A7%A3%E5%86%B3react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-ReactQuery/" title="解决react状态管理---React Query">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'lhblog-1';
var disqus_identifier = '2021/07/17/解析nextTick-vue3任务调度/';
var disqus_title = '解析nextTick---vue3任务调度';
var disqus_url = 'https://lhrun.github.io/2021/07/17/解析nextTick-vue3任务调度/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="https://#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>