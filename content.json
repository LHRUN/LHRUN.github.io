{"pages":[{"title":"","text":"Github: https://github.com/LHRUN SegmentFault: https://segmentfault.com/u/lh_s CSDN: https://blog.csdn.net/weixin_44719258","link":"/about/index.html"}],"posts":[{"title":"H5跳转微信小程序","text":"H5跳转微信小程序 H5跳转小程序有两个方法，需要根据浏览器环境判断微信外使用URL Scheme，根据生成的一个link进行location跳转微信内使用wx-open-launch-weapp开放标签进行跳转，实测ios系统微信内也可以使用URL Scheme，根据自己的需求选择 wx-open-launch-weapp 官方文档 注意事项：微信版本要求为：7.0.12及以上。 系统版本要求为：iOS 10.3及以上、Android 5.0及以上 绑定域名: 登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名” 引入SDK：官网推荐引入方法&lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;;，也可以使用第三方npm包weixin-js-sdk 校验签名是否正确：微信 JS 接口签名校验工具 如果开放标签需要绝对定位，就在外面包裹一个div进行定位，避免直接定位开放标签 调试：好多人在进行调试的时候认为非常麻烦，需要不断切换环境，我推荐一个我的调试方式，在开发过程中，使用SwitchHosts进行IP映射，把本地启动项目的域名映射到公众号平台设置的域名，然后在微信开发工具中调试，就非常轻松了 // 普通H5的写法可参考官方文档，以下是我在vue中的写法 &lt;wx-open-launch-weapp username=&quot;小程序原始id&quot; path=&quot;页面路径及参数&quot;&gt; &lt;script type=&quot;text/wxtag-template&quot;&gt; &lt;button class=&quot;wx-btn&quot;&gt;跳转小程序&lt;/button&gt; &lt;/script&gt; &lt;/wx-open-launch-weapp&gt; &lt;script&gt; ... async mounted() { const wx = require('weixin-js-sdk') wx.config({ debug: true, // 开启调试模式，会在移动端以alert的形式打印返回值 appId: '', // 必填，从服务端获取 timestamp: , // 必填，生成签名的时间戳，从服务端获取 nonceStr: '', // 必填，生成签名的随机串，从服务端获取 signature: '',// 必填，签名，从服务端获取 jsApiList: [], // 必填，需要使用的JS接口列表，这个随便填一个就行 openTagList: ['wx-open-launch-weapp'] }) wx.ready((e) =&gt; console.log(e)) wx.error((e) =&gt; console.log(e)) } &lt;/script&gt; URL Scheme 注意事项：安卓不能直接跳转，需要H5中转，否则Android会出现无法访问 写法很简单，只需location.href='URL Scheme'，在页面初始化时调用或者在按钮点击事件中调用","link":"/2021/06/10/H5%E8%B7%B3%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"Vue3模版编译原理","text":"模版编译流程Vue3模版编译就是把template字符串编译成渲染函数 // template &lt;div&gt;&lt;p&gt;{{LH_R}}&lt;/p&gt;&lt;/div&gt; // render import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from &quot;vue&quot; export function render(_ctx, _cache, $props, $setup, $data, $options) { return (_openBlock(), _createElementBlock(&quot;div&quot;, null, [ _createElementVNode(&quot;p&quot;, null, _toDisplayString(_ctx.LH_R), 1 /* TEXT */) ])) } 我会按照编译流程分3步分析 parse：将模版字符串转换成模版AST transform：将模版AST转换为用于描述渲染函数的AST generate：根据AST生成渲染函数 export function baseCompile( template: string | RootNode, options: CompilerOptions = {} ): CodegenResult { // ... const ast = isString(template) ? baseParse(template, options) : template const [nodeTransforms, directiveTransforms] = getBaseTransformPreset( prefixIdentifiers ) transform( ast, extend({}, options, { prefixIdentifiers, nodeTransforms: [ ...nodeTransforms, ...(options.nodeTransforms || []) // user transforms ], directiveTransforms: extend( {}, directiveTransforms, options.directiveTransforms || {} // user transforms ) }) ) return generate( ast, extend({}, options, { prefixIdentifiers }) ) } parse parse对模版字符串进行遍历，然后循环判断开始标签和结束标签把字符串分割成一个个token，存在一个token列表，然后扫描token列表并维护一个开始标签栈，每当扫描一个开始标签节点，就将其压入栈顶，栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有Token扫描完成后，即可构建成一颗树形AST 以下是简化版parseChildren源码，是parse的主入口 function parseChildren( context: ParserContext, mode: TextModes, ancestors: ElementNode[] // 节点栈结构，用于维护节点嵌套关系 ): TemplateChildNode[] { // 获取父节点 const parent = last(ancestors) const ns = parent ? parent.ns : Namespaces.HTML const nodes: TemplateChildNode[] = [] // 存储解析出来的AST子节点 // 遇到闭合标签结束解析 while (!isEnd(context, mode, ancestors)) { // 切割处理的模版字符串 const s = context.source let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined if (mode === TextModes.DATA || mode === TextModes.RCDATA) { if (!context.inVPre &amp;&amp; startsWith(s, context.options.delimiters[0])) { // 解析插值表达式{{}} node = parseInterpolation(context, mode) } else if (mode === TextModes.DATA &amp;&amp; s[0] === '&lt;') { if (s[1] === '!') { // 解析注释节点和文档声明... } else if (s[1] === '/') { if (s[2] === '&gt;') { // 针对自闭合标签，前进三个字符 advanceBy(context, 3) continue } else if (/[a-z]/i.test(s[2])) { // 解析结束标签 parseTag(context, TagType.End, parent) continue } else { // 如果不符合上述情况，就作为伪注释解析 node = parseBogusComment(context) } } else if (/[a-z]/i.test(s[1])) { // 解析html开始标签，获得解析到的AST节点 node = parseElement(context, ancestors) } } } if (!node) { // 普通文本节点 node = parseText(context, mode) } // 如果节点是数组，就遍历添加到nodes中 if (isArray(node)) { for (let i = 0; i &lt; node.length; i++) { pushNode(nodes, node[i]) } } else { pushNode(nodes, node) } } return nodes } 就拿&lt;div&gt;&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;流程举例 div开始标签入栈，context.source = &lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;，ancestors = [div] p开始标签入栈，context.source = LH_R&lt;/p&gt;&lt;/div&gt;，ancestors = [div, p] 解析文本LH_R 解析p结束标签，p标签出栈 解析div结束标签，div标签出栈 栈空，模版解析完毕 transform transform采用深度优先的方式对AST进行遍历，在遍历过程中，对节点的操作与转换采用插件化架构，都封装为独立的函数，然后转换函数通过context.nodeTransforms来注册 转换过程是优先转换子节点，因为有的父节点的转换依赖子节点 以下是AST遍历traverseNode核心源码 /* 遍历AST节点树，通过node转换器对当前节点进行node转换 子节点全部遍历完成后执行对应指令的onExit回调退出转换 */ export function traverseNode( node: RootNode | TemplateChildNode, context: TransformContext ) { // 记录当前正在遍历的节点 context.currentNode = node /* nodeTransforms：transformElement、transformExpression、transformText... transformElement：负责整个节点层面的转换 transformExpression：负责节点中表达式的转化 transformText：负责节点中文本的转换 */ const { nodeTransforms } = context const exitFns = [] // 依次调用转换工具 for (let i = 0; i &lt; nodeTransforms.length; i++) { /* 转换器只负责生成onExit回调，onExit函数才是执行转换主逻辑的地方，为什么要推到栈中先不执行呢？ 因为要等到子节点都转换完成挂载gencodeNode后，也就是深度遍历完成后 再执行当前节点栈中的onExit，这样保证了子节点的表达式全部生成完毕 */ const onExit = nodeTransforms[i](node, context) if (onExit) { if (isArray(onExit)) { // v-if、v-for为结构化指令，其onExit是数组形式 exitFns.push(...onExit) } else { exitFns.push(onExit) } } if (!context.currentNode) { // node was removed 节点被移除 return } else { // node may have been replaced // 因为在转换的过程中节点可能被替换，恢复到之前的节点 node = context.currentNode } } switch (node.type) { case NodeTypes.COMMENT: if (!context.ssr) { // inject import for the Comment symbol, which is needed for creating // comment nodes with `createVNode` // 需要导入createComment辅助函数 context.helper(CREATE_COMMENT) } break case NodeTypes.INTERPOLATION: // no need to traverse, but we need to inject toString helper if (!context.ssr) { context.helper(TO_DISPLAY_STRING) } break // for container types, further traverse downwards case NodeTypes.IF: // 对v-if生成的节点束进行遍历 for (let i = 0; i &lt; node.branches.length; i++) { traverseNode(node.branches[i], context) } break case NodeTypes.IF_BRANCH: case NodeTypes.FOR: case NodeTypes.ELEMENT: case NodeTypes.ROOT: // 遍历子节点 traverseChildren(node, context) break } // 当前节点树遍历完成，依次执行栈中的指令退出回调onExit context.currentNode = node let i = exitFns.length while (i--) { exitFns[i]() } } generategenerate生成代码大致分为3步 创建代码生成上下文，因为该上下文对象是用于维护代码生成过程中程序的运行状态，如： code：最终生成的渲染函数 push：拼接代码 indent：代码缩进 deindent：减少代码缩进 … 生成渲染函数的前置预设部分 module模式下：genModulePreamble() function模式下：genFunctionPreamble 还有一些函数名，参数，作用域… 生成渲染函数 通过调用genNode，然后在genNode内部通过switch语句来匹配不同类型的节点，并调用对应的生成器函数 参考资料 Vue3 模板编译原理 《Vue.js设计与实现》","link":"/2022/08/31/Vue3%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"title":"Vue3+Vite3 SSR基本搭建","text":"首先说明如果是生产使用强烈推荐Nuxt，但是如果想深入服务端渲染的运行原理，可以看本篇，会根据渲染流程搭建一个demo版ssr，源码在最后会贴上 主要技术栈：Vite3 + Vue3 + pinia + VueRouter4 + express 开始搭建之前，先说一下SSR渲染流程 SSR渲染流程 首先浏览器向服务器请求，然后服务器根据请求的路由，会匹配相关的路由组件，然后执行组件的自定义服务端生命周期(例：Nuxt的asyncData)或者自定义获取数据的hook，并且把执行后的数据收集起来，统一在window的属性中存储 然后vue的组件会被renderToString渲染成静态HTML字符串，替换掉index.html的提前指定的占位代码。然后index.html改变后的静态字符串发给客户端 客户端拿到后，首先对数据进行初始化，然后进行激活，因为当前html只是静态数据，激活主要做两件事 把页面中的DOM元素与虚拟DOM之间建立联系 为页面中的DOM元素添加事件绑定 1. 创建项目 首先用vite命令创建项目pnpm create vite vue-ssr --template vue-ts 安装相关依赖：pnpm add express pinia vue-router@4 创建三个文件 touch server.js src src/entry-client.ts src/entry-server.js server.js：服务端启动文件 entry-client.ts：客户端入口，应用挂载元素 entry-server.js：服务端入口，处理服务端逻辑和静态资源 修改package.json运行脚本&quot;scripts&quot;: { &quot;dev&quot;: &quot;node server&quot;, // 运行开发环境 } 然后需要把应用创建都改为函数的方式进行调用创建，因为在SSR环境下，和纯客户端不一样，服务器只会初始化一次，所以为了防止状态污染，每次请求必须是全新的实例 // src/main.ts import { createSSRApp } from 'vue' import App from './App.vue' import { createRouter } from './router' import { createPinia } from 'pinia' export function createApp() { const app = createSSRApp(App) const router = createRouter() const pinia = createPinia() app.use(router) app.use(pinia) return { app, router, pinia } } roter同理 // src/router/index import { createRouter as _createRrouter, createMemoryHistory, createWebHistory, RouteRecordRaw } from 'vue-router' const routes: RouteRecordRaw[] = [ ... ] export function createRouter() { return _createRrouter({ history: import.meta.env.SSR ? createMemoryHistory() : createWebHistory(), routes, }) } 然后修改index.html，增加注释占位和客户端入口文件，在之后的服务端渲染时注入 &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Vite + Vue + TS&lt;/title&gt; &lt;!-- 静态资源占位 .js .css ... --&gt; &lt;!--preload-links--&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 应用代码占位 --&gt; &lt;div id=&quot;app&quot;&gt;&lt;!--ssr-outlet--&gt;&lt;/div&gt; &lt;script type=&quot;module&quot; src=&quot;/src/main.ts&quot;&gt;&lt;/script&gt; &lt;!-- 引用客户端入口文件 --&gt; &lt;script type=&quot;module&quot; src=&quot;/src/entry-client.ts&quot; &gt;&lt;/script&gt; &lt;script&gt; // 服务端获取的数据统一挂载到window上 window.__INITIAL_STATE__ = '&lt;!--pinia-state--&gt;' &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2. 服务端启动文件 创建项目后，就开始编写服务端启动文件，也就是项目根路径下的server.js文件 这个文件的功能是启动一个node服务，然后根据请求，读取html文件，处理资源后把注释进行替换，最后把html发送给客户端 import fs from 'fs' import path from 'path' import { fileURLToPath } from 'url' import express from 'express' import { createRequire } from 'module'; const __dirname = path.dirname(fileURLToPath(import.meta.url)) const require = createRequire(import.meta.url); const resolve = (p) =&gt; path.resolve(__dirname, p); const createServer = async () =&gt; { // 创建node服务 const app = express() /** * @官方解释 * 以中间件模式创建vite应用，这将禁用vite自身的HTML服务逻辑 * 并让上级服务器接管 */ const vite = await require('vite').createServer({ server: { middlewareMode: true, }, appType: 'custom' }); app.use(vite.middlewares); app.use('*', async (req, res, next) =&gt; { const url = req.originalUrl try { // 读取index.html let template = fs.readFileSync( resolve('index.html'), 'utf-8' ) // 应用vite html转换，会注入vite HMR template = await vite.transformIndexHtml(url, template) // 加载服务端入口 const render = (await vite.ssrLoadModule('/src/entry-server.js')).render const [ appHtml, piniaState ] = await render(url) // 替换处理过后的模版 const html = template .replace(`&lt;!--ssr-outlet--&gt;`, appHtml) .replace(`&lt;!--pinia-state--&gt;`, piniaState) res.status(200).set({ 'Content-Type': 'text/html' }).end(html) } catch (error) { vite?.ssrFixStacktrace(error) next(e) } }) // 监听5100端口 app.listen(5100) } createServer(); 3. 服务端入口文件 服务端入口文件主要是调用SSR的renderToString和收集需要发送的资源和数据 import { renderToString } from 'vue/server-renderer' import { createApp } from './main' export async function render(url, manifest) { const { app, router, pinia } = createApp() router.push(url) await router.isReady() const ctx = {} const html = await renderToString(app, ctx) return [html, JSON.stringify(pinia.state.value)] } 4. 客户端入口文件 客户端入口文件主要用于挂载节点和初始化数据 import { createApp } from './main' const { app, router, pinia } = createApp() router.isReady().then(() =&gt; { if (window.__INITIAL_STATE__) { pinia.state.value = JSON.parse(window.__INITIAL_STATE__); } app.mount('#app') }) 5. 组件和页面 组件和页面获取数据主要有两种方式，一种是增加一个asyncData选项，然后在enter-server.js的逻辑中增加遍历当前组件的逻辑，统一触发asyncData，但是现在都是用script setup的方式写业务代码，所以有点麻烦， &lt;script&gt; export defualt { asyncData() { // 服务端获取数据逻辑 } } &lt;/script&gt; &lt;script setup lang='ts'&gt; ... &lt;/script&gt; 另一种就是hook的方式，通过import.meta.env.SSR的方式进行判断 对于数据具体存储方式，大概有三种，一种是存在vuex或者pinia这种全局状态库中，一种是存在context上下文中，还有一种是自定义数据 6. 生产环境6.1 pacnakge.json 增加构建脚本 &quot;scripts&quot;: { &quot;dev&quot;: &quot;node server&quot;, + &quot;build&quot;: &quot;npm run build:client &amp;&amp; npm run build:server&quot;, + &quot;build:client&quot;: &quot;vite build --ssrManifest --outDir dist/client&quot;, + &quot;build:server&quot;: &quot;vite build --ssr src/entry-server.js --outDir dist/server&quot;, + &quot;serve&quot;: &quot;cross-env NODE_ENV=production node server&quot; }, 6.2 服务端运行文件 针对生产环境，需要启动静态资源服务，引用路径需要改为dist目录下 import fs from 'fs' import path from 'path' import { fileURLToPath } from 'url' import express from 'express' import { createRequire } from 'module'; const __dirname = path.dirname(fileURLToPath(import.meta.url)) const require = createRequire(import.meta.url); const resolve = (p) =&gt; path.resolve(__dirname, p); const createServer = async (isProd = process.env.NODE_ENV === 'production') =&gt; { const app = express() - const vite = await require('vite').createServer({ - server: { - middlewareMode: true, - }, - appType: 'custom' - }); - app.use(vite.middlewares); + let vite; + if (isProd) { + app.use(require('compression')()); + app.use( + require('serve-static')(resolve('./dist/client'), { + index: false + }) + ); + } else { + vite = await require('vite').createServer({ + server: { + middlewareMode: true, + }, + appType: 'custom' + }); + app.use(vite.middlewares); + } // 通过bulid --ssrManifest命令生成的静态资源映射需要在生产环境下引用 + const manifest = isProd ? fs.readFileSync(resolve('./dist/client/ssr-manifest.json'), 'utf-8') :{} app.use('*', async (req, res, next) =&gt; { const url = req.originalUrl try { - let template = fs.readFileSync( - resolve('index.html'), - 'utf-8' - ) - template = await vite.transformIndexHtml(url, template) - const render = (await vite.ssrLoadModule('/src/entry-server.js')).render - const [ appHtml, piniaState ] = await render(url) + let template, render + if (isProd) { + template = fs.readFileSync(resolve('./dist/client/index.html'), 'utf-8') + render = (await import('./dist/server/entry-server.js')).render + } else { + template = fs.readFileSync( + resolve('index.html'), + 'utf-8' + ) + template = await vite.transformIndexHtml(url, template) + render = (await vite.ssrLoadModule('/src/entry-server.js')).render + } + const [ appHtml, preloadLinks, piniaState ] = await render(url, manifest) const html = template .replace(`&lt;!--preload-links--&gt;`, preloadLinks) .replace(`&lt;!--ssr-outlet--&gt;`, appHtml) + .replace(`&lt;!--pinia-state--&gt;`, piniaState) res.status(200).set({ 'Content-Type': 'text/html' }).end(html) } catch (error) { vite?.ssrFixStacktrace(error) next() } }) app.listen(5100) } createServer(); 6.3 服务端入口文件 服务端入口文件主要是增加了构建时生成的静态资源映射处理的逻辑 import { basename } from 'path' import { renderToString } from 'vue/server-renderer' import { createApp } from './main' export async function render(url, manifest) { const { app, router, pinia } = createApp() router.push(url) await router.isReady() const ctx = {} const html = await renderToString(app, ctx) + const preloadLinks = renderPreloadLinks(ctx.modules, manifest) + return [html, preloadLinks, JSON.stringify(pinia.state.value)] } function renderPreloadLinks(modules, manifest) { let links = '' const seen = new Set() modules.forEach((id) =&gt; { const files = manifest[id] if (files) { files.forEach((file) =&gt; { if (!seen.has(file)) { seen.add(file) const filename = basename(file) if (manifest[filename]) { for (const depFile of manifest[filename]) { links += renderPreloadLink(depFile) seen.add(depFile) } } links += renderPreloadLink(file) } }) } }) return links } function renderPreloadLink(file) { if (file.endsWith('.js')) { return `&lt;link rel=&quot;modulepreload&quot; crossorigin href=&quot;${file}&quot;&gt;` } else if (file.endsWith('.css')) { return `&lt;link rel=&quot;stylesheet&quot; href=&quot;${file}&quot;&gt;` } else if (file.endsWith('.woff')) { return ` &lt;link rel=&quot;preload&quot; href=&quot;${file}&quot; as=&quot;font&quot; type=&quot;font/woff&quot; crossorigin&gt;` } else if (file.endsWith('.woff2')) { return ` &lt;link rel=&quot;preload&quot; href=&quot;${file}&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;` } else if (file.endsWith('.gif')) { return ` &lt;link rel=&quot;preload&quot; href=&quot;${file}&quot; as=&quot;image&quot; type=&quot;image/gif&quot;&gt;` } else if (file.endsWith('.jpg') || file.endsWith('.jpeg')) { return ` &lt;link rel=&quot;preload&quot; href=&quot;${file}&quot; as=&quot;image&quot; type=&quot;image/jpeg&quot;&gt;` } else if (file.endsWith('.png')) { return ` &lt;link rel=&quot;preload&quot; href=&quot;${file}&quot; as=&quot;image&quot; type=&quot;image/png&quot;&gt;` } else { return '' } } 总结 repo 参考资料 Server-Side Rendering","link":"/2022/08/27/Vue3-Vite3-SSR%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/"},{"title":"小程序滚动日历组件","text":"小程序滚动日历组件前段时间产品提出这个需求，要求做一个日历容器，并要求是滚动，不能是那种每个月切换的容器，所以我就在网上大概查找了一下类似组件，滚动的容器较少，于是我就自己写了这个组件，以下是大概的js思路，wxml和css就不附上了，每个UI都有不同的想法 在ready中初始化组件数据 /** * @description: 初始化 */ ready() { // 这两个数据是从页面中传过来的，起始时间和结束时间 // 数组类型 [year, month, day] const { endDate, startDate } = this.data let monthList = [] // 这个用于wxml中遍历，以每月为item // 未跨年 if ( endDate[0] === startDate[0]) { let rangeMonth = endDate[1] - startDate[1] for (let i = 0; i &lt;= rangeMonth; i++) { let date = [startDate[0], startDate[1] + i + 1] // monthInitData()初始化每月数据 let days = this.monthInitData(startDate[0], startDate[1] + i) monthList.push({ date, days, }) } } else { // 跨年前月份 for (let i = 0, lng = 12 - startDate[1]; i &lt; lng; i++) { let date = [startDate[0], startDate[1] + i + 1] let days = this.monthInitData(startDate[0], startDate[1] + i) monthList.push({ date, days, }) } // 跨年后月份 for (let i = 0; i &lt;= endDate[1]; i++) { let date = [endDate[0], i + 1] let days = this.monthInitData(endDate[0], i) monthList.push({ date, days, }) } } this.setData({ monthList, }) } 初始化每月数据: 逻辑是获取每个月第一天的星期数和每个月的最大天数，然后在之前和之后的空数据填充item占位然后遍历，根据不同的需求，在遍历中处理，最后在html中flex布局即可 /** * @description: 初始化每月数据 * @param: { number } year 年 * @param: { number } month 月 */ monthInitData(year, month) { let { calendarValue, startDate, endDate }= this.data, // 当前点击时间，起始时间，结束时间 firstWeek = new Date(year, month, 1).getDay(), // 本月的第一天的星期数 days = [], // 日期数组 max = this.getMonthMax(year, month + 1), // 每月最大天数 lastWeek = new Date(year, (month + 1), 0).getDay() // 本月的最后一天的星期数 // 填充每月一号之前的空数据 if (firstWeek &gt; 0) { for (let i = 0; i &lt; firstWeek; i++) { days.push({ day: 0 }) } } let currentTime = 0, startTime = 0, endTime = 0 if (calendarValue[0]) { currentTime = new Date(calendarValue[0], calendarValue[1], calendarValue[2]).getTime() } if (startDate[0]) { startTime = new Date(startDate[0], startDate[1], startDate[2]).getTime() } if (endDate[0]) { endTime = new Date(endDate[0], endDate[1], endDate[2]).getTime() } for (let i = 1; i &lt;= max; i++) { // 以下状态是需要在html中判断处理，根据自己需求改变 let current = false, // 当前点击状态 disabled = false, // 禁止状态 now = false, // 今天显示文案 time = new Date(year, month, i).getTime(), nowTime = [new Date().getFullYear(), new Date().getMonth(), new Date().getDate()] if (currentTime &amp;&amp; currentTime == time) current = true if (startTime &amp;&amp; startTime &gt; time) disabled = true if (endTime &amp;&amp; endTime &lt; time) disabled = true if (year === nowTime[0] &amp;&amp; month === nowTime[1] &amp;&amp; i === nowTime[2]) now = true days.push({ day: i, current, disabled, now, }) } // 填充每月最后一天之后的空数据 if (lastWeek != 6) { for (let i = 0, l = (6 - lastWeek); i &lt; l; i++) { days.push({ day: 0 }) } } return days }, /** * 获取一个月最大天数 * @method getMonthMax * @param: { number } year 年份 * @param: { number } month 月份 */ getMonthMax(year, month) { let max = 31 if (month == 4 || month == 6 || month == 9 || month == 11) { max = 30 } else if (month == 2) { if (((year % 4) == 0 &amp;&amp; (year % 100) &gt; 0) || (year % 400) == 0) { max = 29 } else { max = 28 } } return max }, 以上就是核心逻辑，像一些弹窗事件和一些点击事件就不附上来了","link":"/2021/04/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%BB%9A%E5%8A%A8%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6/"},{"title":"pnpm的node_modules结构设计","text":"pnpm的node_modules结构设计分析pnpm之前，先说一下npm现在的一些问题 npm的问题 平时我们使用npm install命令后，node_modules就会呈现以下类似内容 之所以出现这种扁平的结构，最初时初衷是好的，为了更好的利用资源，把每个依赖全部放到顶层，这样就不会造成每个依赖嵌套过深，导致很多重复依赖文件 但是随着这种文件结构逐步使用后，就会暴露出来两个问题 幽灵依赖 版本冲突 幽灵依赖就是你在引用npm包时，你会发现一些没有在package.json中出现的包也能引用，这个就是幽灵依赖，这是因为你在install下载npm包时，npm包也有它的依赖会下载，但是下载的依赖也会存在node_modules同一层级下，这样就会导致可以直接引用 版本冲突是因为不同的依赖可能依赖的包版本也不同，但是node_modules的同一层级只能存在一个包的一个版本号，如果有不同的版本号就只能存在依赖包的node_modules中，这样就会导致出现重复资源 ├── package-A @1.0 |── package-B @1.0 ├── package-C @1.0 │ └── package-A @2.0 │ └── package-B @2.0 ├── package-D @1.0 │ └── package-A @2.0 │ └── package-B @2.0 pnpm的出现 在所有前端苦npm久已时，pnpm出现了，并且在pnpm官网的简介上就简单说明了它的构造：store + link store就是依赖的实际存储位置，Mac/linux在{home dir}&gt;/.pnpm-store/v3，windows在当前盘/.pnpm-store/v3。这样就会有个好处，你在多个项目使用的是同一个依赖时，就不用重复下载，这样就极大的减少存储空间 link是指符号链接(SymbolicLink)和硬链接(HardLink) SymbolicLink是一种特殊的文件，包含一条以绝对路径或者相对路径的形式指向其他文件或者目录的引用，它的存在不依赖于目标文件，如果目标文件被删除或者移动，指向目标文件的符号链接依然存在，但是它们会指向一个不复存在的文件 相比于SymbolicLink，HardLink不是引用文件，而是引用inode，inode是文件系统的一种数据结构，用于描述文件系统对象。所以你即使更改目标文件的内容或位置，HardLink仍然指向目标文件，因为inode指向该文件 然后拿react举例，当pnpm add react后，在node_modules终端输入tree -a -L 3会得到以下node_modules结构 . ├── .modules.yaml ├── .pnpm │ ├── js-tokens@4.0.0 │ │ └── node_modules │ ├── lock.yaml │ ├── loose-envify@1.4.0 │ │ └── node_modules │ ├── node_modules │ │ ├── .bin │ │ ├── js-tokens -&gt; ../js-tokens@4.0.0/node_modules/js-tokens │ │ └── loose-envify -&gt; ../loose-envify@1.4.0/node_modules/loose-envify │ └── react@18.2.0 │ └── node_modules └── react -&gt; .pnpm/react@18.2.0/node_modules/react node_modules下除了.pnpm外只有一个react，这个react只是一个SymbolicLink，当node.js解析时，会找到react的真实位置node_modules/.pnpm/react@18.2.0/node_modules/react .pnpm就是将所有依赖放在同一层文件夹中，每个包都可以通过.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;这种路径找到，然后通过hand link的方式在store中引用依赖文件 通过这种文件结构，pnpm就解决了npm的两个问题，首先node_modules下不会有你未在package.json中声明的依赖，这样就不会有幽灵依赖的问题。然后.pnpm下会有name+version的方式链接到store中，这样就不会出现因为版本冲突造成资源重复的问题 参考资料 Flat node_modules is not the only way Symlinked node_modules structure One For All：基于pnpm + lerna + typescript的最佳项目实践 - 理论篇","link":"/2022/08/24/pnpm%E7%9A%84node-modules%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"title":"微信小程序单指拖拽和双指缩放旋转","text":"前言小程序单指拖拽和双指操作是一个比较常用的功能，效果如下图 实现这三个功能，主要用三个触摸事件touchstart、touchmove、touchend &lt;view style=&quot;height: 100vh; width: 100vw&quot;&gt; &lt;image src=&quot;...&quot; style=&quot;transform: translate({{translateX}}px, {{translateY}}px) scale({{scale}}) rotate({{rotate}}deg);&quot; catch:touchstart=&quot;touchStart&quot; catch:touchmove=&quot;touchMove&quot; catch:touchend=&quot;touchEnd&quot; /&gt; &lt;/view&gt; 用了以下变量 Page({ data: { translateX: 0, // 位移x坐标 单位px translateY: 0, // 位移y坐标 单位px distance: 0, // 双指接触点距离 scale: 1, // 缩放倍数 rotate: 0, // 旋转角度 oldRotate: 0, // 上一次旋转停止后的角度 startMove: { // 起始位移距离 x: 0, y: 0, }, startTouches: [] // 起始点touch数组 }, }) 单指拖拽 单指拖拽比较简单，只需要记录移动的点坐标，然后减去起始点坐标，就可以求出针对页面的移动距离 touchstart touchStart(e) { const touches = e.touches const { translateX, translateY } = this.data const { pageX, pageY } = touches[0] this.data.startMove = { x: pageX - translateX, y: pageY - translateY } this.data.startTouches = touches }, touchmove touchMove(e) { const touches = e.touches const { pageX: onePageX, pageY: onePageY } = touches[0] const { startMove } = this.data this.setData({ translateX: onePageX - startMove.x, translateY: onePageY - startMove.y }) } 双指缩放 双指缩放的原理是根据两点坐标求出距离(勾股定理)，然后在用移动坐标的距离比就可以求出缩放倍数 touchmove touchMove(e) { const touches = e.touches const { pageX: onePageX, pageY: onePageY } = touches[0] const { startMove, scale, distance: oldDistance, startTouches } = this.data if (touches.length === 2 &amp;&amp; startTouches.length === 2) { // 双指缩放 const { pageX: twoPageX, pageY: twoPageY } = touches[1] // 求出当前双指距离 const distance = Math.sqrt((twoPageX - onePageX) ** 2 + (twoPageY - onePageY) ** 2) this.data.distance = distance this.setData({ scale: scale * (distance / (oldDistance || distance)) }) } else if (startTouches.length !== 2) { // 单指拖拽 this.setData({ translateX: onePageX - startMove.x, translateY: onePageY - startMove.y }) } } startTouches.length !== 2这个判断的原因是防止图片跳动，因为如果你两个手指触摸，然后离开一个手指，我是禁止拖拽的，只有双指都离开后再次触摸才能单指拖拽 双指旋转 双指旋转的原理是根据三角函数求出起始点的角度，然后再求出移动坐标的角度，相减然后加上上一次旋转的角度就等于你当前所需的选择角度 touchmove touchMove(e) { const touches = e.touches const { pageX: onePageX, pageY: onePageY } = touches[0] const { startMove, scale, distance: oldDistance, startTouches, oldRotate } = this.data if (touches.length === 2 &amp;&amp; startTouches.length === 2) { const { pageX: twoPageX, pageY: twoPageY } = touches[1] const distance = Math.sqrt((twoPageX - onePageX) ** 2 + (twoPageY - onePageY) ** 2) + let rotate = this.getAngle(touches[0], touches[1]) - this.getAngle(startTouches[0], startTouches[1]) + oldRotate // 如果大于360度，就减去360 + rotate = rotate &gt; 360 ? rotate - 360 : rotate this.data.distance = distance this.setData({ scale: scale * (distance / (oldDistance || distance)), + rotate }) } else if (startTouches.length !== 2) { this.setData({ translateX: onePageX - startMove.x, translateY: onePageY - startMove.y }) } }, getAngle getAngle(p1, p2) { const x = p1.pageX - p2.pageX const y = p1.pageY- p2.pageY return Math.atan2(y, x) * 180 / Math.PI } touchend touchEnd() { // 保存当前旋转角度 this.data.oldRotate = this.data.rotate }, 总结 代码片段https://developers.weixin.qq.com/s/0nS1tImU7Rs5 H5原理一致，只需改一下语法即可 我这个只是基础版本，如果需要一些边界控制和还一些需求的限制，计算据边框距离即可，也可以用小程序的boundingClientRectAPI","link":"/2021/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%95%E6%8C%87%E6%8B%96%E6%8B%BD%E5%92%8C%E5%8F%8C%E6%8C%87%E7%BC%A9%E6%94%BE%E6%97%8B%E8%BD%AC/"},{"title":"微信小程序图片上传&九宫格拖拽组件","text":"微信小程序图片上传&amp;九宫格拖拽组件前言 图片上传加九宫格拖拽是一个比较常用的组件，常用于发帖或者评论等内容上传模块，我这篇九宫格拖拽的思路是借鉴了一款优雅的小程序拖拽排序组件实现这篇文章 实现效果如下图 实现原理：新增图片时，为每一个图片增加一个key属性，和tranX、tranY属性，用于transform位移，然后这个九宫格的拖拽新增删除都是以key为标记来修改tranX和tranY，从而达到拖拽效果 使用了以下变量 data: { ITEM_SIZE: 100, // 图片大小 单位px dragImgList: [], // 图片列表 { src: string, key: number, tranX: number, tranY: number }[] containerRes: {}, // 拖拽容器属性 currentKey: -1, // 正在拖拽图片的key currentIndex: -1, // 正在拖拽图片的index tranX: 0, // 正在拖拽图片移动的x距离 tranY: 0, // 正在拖拽图片移动的y距离 uploadPosition: { // upload上传图标位移距离 tranX: 0, tranY: 0, } }, WXML &amp; WXSS&lt;view class=&quot;drag-container&quot;&gt; &lt;view wx:for=&quot;{{dragImgList}}&quot; wx:key=&quot;index&quot; style=&quot;transform: translate({{index === currentIndex ? tranX : item.tranX}}px, {{index === currentIndex ? tranY : item.tranY}}px); z-index: {{index === currentIndex ? 10 : 1}};&quot; class=&quot;darg-item item-transition&quot; mark:index=&quot;{{index}}&quot; mark:key=&quot;{{item.key}}&quot; catch:longpress=&quot;longPress&quot; catch:touchmove=&quot;touchMove&quot; catch:touchend=&quot;touchEnd&quot; &gt; &lt;image class=&quot;darg-item-img&quot; src=&quot;{{item.src}}&quot;/&gt; &lt;text catch:tap=&quot;deleteImg&quot; mark:key=&quot;{{item.key}}&quot; class=&quot;drag-item-delete&quot;&gt;×&lt;/text&gt; &lt;/view&gt; &lt;view bindtap=&quot;uploadImage&quot; class=&quot;darg-item drag-item-upload&quot; hidden=&quot;{{dragImgList.length >= 9}}&quot; style=&quot;transform: translate({{uploadPosition.tranX}}px, {{uploadPosition.tranY}}px);&quot; &gt;+&lt;/view&gt; &lt;/view&gt; .drag-container{ position: relative; width: 300px; height: 300px; } .item-transition { transition: transform 0.1s } .darg-item{ position: absolute; top: 0; left: 0; width: 100px; height: 100px; } .darg-item-img{ width: 100%; height: 100%; } .drag-item-delete{ position: absolute; top: 0; right: 0; width: 58rpx; height: 33rpx; background-color: rgba(0,0,0,0.7); font-size: 47rpx; line-height: 25rpx; text-align: center; border-radius: 0 0 0 64rpx; color: #fff; } .drag-item-upload{ background-color: burlywood; font-size: 200rpx; text-align: center; color: white; line-height: 200rpx; } 图片上传 图片上传很简单，就是初始化上传的图片，然后拼接图片列表，最后修改上传图标位置即可 uploadImage() { let { dragImgList, ITEM_SIZE } = this.data wx.chooseImage({ count: 9 - dragImgList.length, success: (res) =&gt; { const imgList = res.tempFilePaths.map((item, index) =&gt; ({ tranX: ITEM_SIZE * ((dragImgList.length + index) % 3), tranY: Math.floor((dragImgList.length + index) / 3) * ITEM_SIZE, src: item, key: dragImgList.length + index })) dragImgList = dragImgList.concat(imgList) // 修改上传图标位置 this.setUploaPosition(dragImgList.length) this.setData({ dragImgList, }) } }) }, setUploaPosition(listLength) { const ITEM_SIZE = this.data.ITEM_SIZE const uploadPosition = { tranX: listLength % 3 * ITEM_SIZE, tranY: Math.floor(listLength / 3) * ITEM_SIZE, } this.setData({ uploadPosition, }) }, 图片删除 首先从图片列表中删除所需图片，然后修改列表，把大于所选图片key的key全部减一，最后修改剩余图片位置和上传图标位置 deleteImg(e) { const key = e.mark.key // 删除图片 const list = this.data.dragImgList.filter((item) =&gt; item.key !== key) // 修改key值 list.forEach((item) =&gt; item.key &gt; key &amp;&amp; item.key--) // 修改剩余图片位置 this.getListPosition(list) // 修改上传图标位置 this.setUploaPosition(list.length) } getListPosition(list) { const ITEM_SIZE = this.data.ITEM_SIZE const dragImgList = list.map((item) =&gt; { item.tranX = ITEM_SIZE * (item.key % 3); item.tranY = Math.floor(item.key / 3) * ITEM_SIZE; return item }) this.setData({ dragImgList, }) // 向页面传递最新图片列表 const urlList = [...dragImgList].sort((a, b) =&gt; a.key - b.key).map((item) =&gt; item.src) this.triggerEvent('updateImage', { list: urlList }) }, 九宫格拖拽初始化 初始化只需获取容器的位置信息即可，因为拖拽组件不一定是在页面的左上角，所以需要知道容器的位置信息 lifetimes: { ready() { this.createSelectorQuery() .select(&quot;.drag-container&quot;) .boundingClientRect((res) =&gt; { this.data.containerRes = res }).exec(); } }, longPress 这里采用longPress，而不是touchStart的原因，一是为了优化体验，二是touchStart与删除按钮冲突 longPress(e) { const index = e.mark.index const { pageX, pageY } = e.touches[0] const { top, left } = this.data.containerRes this.setData({ currentIndex: index, tranX: pageX - 50 - left, tranY: pageY - 50 - top }) }, touchMove touchMove首先计算出位移距离，然后根据位移距离求出停放位置的key，如果不一样就修改位置 touchMove(e) { // 如果currentIndex &lt; 0，说明并没有触发longPress if (this.data.currentIndex &lt; 0) return const { pageX, pageY } = e.touches[0] const { top, left } = this.data.containerRes const tranX = pageX - 50 - left const tranY = pageY - 50 - top this.setData({ tranX, tranY }) // 对比当前移动的key和停放位置的key，如果不一样就修改位置 const currentKey = e.mark.key const moveKey = this.getMoveKey(tranX, tranY) if (currentKey === moveKey || this.data.currentKey === currentKey) return this.data.currentKey = currentKey this.insert(currentKey, moveKey) }, getMoveKey(tranX, tranY) { const { dragImgList: list, ITEM_SIZE } = this.data const _getPositionNumber = (position) =&gt; { const positionNumber = Math.round(position/ ITEM_SIZE) return positionNumber &gt; 2 ? 2 : positionNumber &lt; 0 ? 0 : positionNumber } const endKey = 3 * _getPositionNumber(tranY) + _getPositionNumber(tranX) return endKey &gt;= list.length ? list.length - 1 : endKey }, insert(origin, end) { const dragImgList = this.data.dragImgList dragImgList.forEach((item) =&gt; { if (origin &lt; end) { // 如果起始key小于结束key，就把区间内的key全部减一 if (item.key &gt; origin &amp;&amp; item.key &lt;= end) item.key-- else if (item.key === origin) item.key = end } else if (origin &gt; end) { // 如果起始key大于结束key，就把区间内的key全部加一 if (item.key &gt;= end &amp;&amp; item.key &lt; origin) item.key++ else if (item.key === origin) item.key = end } }) this.getListPosition(dragImgList) }, touchEnd touchEnd用于重置数据 touchEnd() { this.setData({ tranX: 0, tranY: 0, currentIndex: -1, }) this.data.currentKey = -1 }, 总结 代码片段https://developers.weixin.qq.com/s/2rFIJamX7xty","link":"/2021/09/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/"},{"title":"微信小程序瀑布流和虚拟列表","text":"微信小程序瀑布流和虚拟列表首先声明虽然本篇是写的微信小程序的案例，但是也可用于H5，思路是想通的，只是有些api的差异，最后会贴代码片段 虚拟列表 一般在做长列表优化时，特别是面试时，虚拟列表就是个高频词。这个名词听起来很高级，其实原理很简单 虚拟列表就是将需要渲染的数组数据改造成二维数组，然后通过监听DOM在合适的地方切换为占位元素，达到长列表无限滚动时减少DOM的优化 JS /** * 处理占位元素，就是在获取新的数据后 * 通过SelectQuery获取当前数据的实际高度，然后把这个高度设置到占位元素上 */ getCurrentItemHeight() { const query = this.createSelectorQuery(); const { virtualId } = this.data query.select(`#${virtualId}`).boundingClientRect() query.exec((res) =&gt; { this.setData({ height: res[0].height }, this.observePage()) }) } /** * 监听元素与页面的相交 * 可以选择指定元素为参照区域，也可以选择页面为参照元素，只是API不同 * @doc https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html */ observePage() { const { virtualId, observeDistance, wrapId } = this.data let IntersectionObserver = wx.createIntersectionObserver(this); (wrapId ? IntersectionObserver.relativeTo(`#${wrapId}`) : IntersectionObserver.relativeToViewport({ top: observeDistance, bottom: observeDistance })) .observe(`#${virtualId}`, ({ intersectionRatio }) =&gt; { this.setData({ isShow: intersectionRatio &gt; 0, }) }) } html &lt;view id=&quot;{{virtualId}}&quot;&gt; &lt;block wx:if=&quot;{{isShow}}&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/block&gt; &lt;view wx:else style=&quot;height: {{ height }}px&quot;&gt;&lt;/view&gt; &lt;/view&gt; 瀑布流 瀑布流，又称瀑布流式布局。视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部 瀑布流有多种写法，有通过纯CSS完成的，也有借助JS完成的，方法很多，但是我为了接下来能与虚拟列表相结合，就采用JS的写法，就是通过列数把每一列分为一个单独的子元素，然后会记录每一列的高度，通过判断哪一列高度最小，然后将数据push到高度最小的那一列 /** * 获取列表数据 * @describe 瀑布流处理，哪列高度小，就往哪列push新数据 */ getList() { let { listQuery: { pageIndex, pageSize }, columns, columnsHeight } = this.data; for (let i = 0; i &lt; pageSize; i++) { const height = Math.floor(Math.random() * 100) const item = height &lt; 50 ? height + 50 : height const position = this.computePosition(columnsHeight) columns[position].push(item) columnsHeight += item } // 在html中双重遍历columns，然后通过flex：1均匀分布 this.setData({ columns, }) this.data.columnsHeight = columnsHeight } /** * 获取高度最小列下标 */ computePosition(heights) { const min = Math.min(...heights); return heights.findIndex((item) =&gt; item === min) } 瀑布流结合虚拟列表 让瀑布流有虚拟滚动的能力，思路很简单，就是计算每列的偏移量，因为瀑布流被我们分成了二维数组，所以每块子元素之间就会因为列高度的不一致产生空白区域，所以需要计算这个空白区域的大小，然后通过margin-top移动列元素达到视觉上的瀑布流衔接效果 getList() { let { listQuery: { pageIndex }, column, columnsHeights } = this.data; const columns = []; // 上一组的高度数据，用于计算偏移值 const lastHeights = [...columnsHeights]; // 获取数据 const list = this.getListData(); // 初始化当前屏数据 for (let i = 0; i &lt; column; i++ ) { columns.push([]); } // 遍历新数据，分配至各列 for (let i = 0; i &lt; list.length; i++) { const position = this.computePosition(columnsHeights); columns[position].push(list[i]); columnsHeights[position] += Number(list[i].height); } this.setData({ [`listData[${pageIndex}]`]: { columns, columnOffset: this.computeOffset(lastHeights), } }); this.data.listQuery.pageIndex = pageIndex + 1; this.data.columnsHeights = columnsHeights; }, /** * 获取列表数据 */ getListData() { const result = [] for (let i = 0; i &lt; this.data.listQuery.pageSize; i++) { const height = Math.floor(Math.random() * 300); const item = { height: height &lt; 150 ? height + 150 : height, color: this.randomRgbColor(), }; result.push(item); } return result; }, /** * 随机生成RGB颜色 */ randomRgbColor() { var r = Math.floor(Math.random() * 256); //随机生成256以内r值 var g = Math.floor(Math.random() * 256); //随机生成256以内g值 var b = Math.floor(Math.random() * 256); //随机生成256以内b值 return `rgb(${r},${g},${b})`; //返回rgb(r,g,b)格式颜色 }, /** * 获取最小高度列下标 */ computePosition(heights) { const min = Math.min(...heights); return heights.findIndex((item) =&gt; item === min); }, /** * 计算偏移量 */ computeOffset(heights) { const max = Math.max(...heights); return heights.map((item) =&gt; max - item); }, onScrollLower() { this.getList(); } WXML &lt;view&gt; &lt;scroll-view class=&quot;virtualScrollView&quot; eventhandle scroll-y bindscrolltolower=&quot;onScrollLower&quot;&gt; &lt;block wx:for=&quot;{{ listData }}&quot; wx:key=&quot;screenIndex&quot; wx:for-index=&quot;screenIndex&quot; wx:for-item=&quot;screenItem&quot;&gt; &lt;VirtualItem virtualId=&quot;virtual_{{pageIndex}}&quot;&gt; &lt;view class=&quot;fall&quot;&gt; &lt;block wx:for=&quot;{{ screenItem.columns }}&quot; wx:key=&quot;columnIndex&quot; wx:for-index=&quot;columnIndex&quot; wx:for-item=&quot;column&quot; &gt; &lt;view style=&quot;margin-top: -{{screenItem.columnOffset[columnIndex]}}px;&quot; class=&quot;fallCol&quot;&gt; &lt;view wx:for=&quot;{{column}}&quot; style=&quot;height: {{ item.height }}px; background-color: {{ item.color }};&quot; wx:key=&quot;index&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot;&gt; screen: {{ screenIndex }}, column: {{ columnIndex }} &lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;/VirtualItem&gt; &lt;/block&gt; &lt;/scroll-view&gt; &lt;/view&gt; 总结 代码片段：https://developers.weixin.qq.com/s/5P3DpGmI7PBc","link":"/2022/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%80%91%E5%B8%83%E6%B5%81%E5%92%8C%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/"},{"title":"微信小程序蓝牙控制开门","text":"小程序低功耗蓝牙控制开门整体流程 初始化蓝牙模块openBluetoothAdapter 获取本机蓝牙适配器状态getBluetoothAdapterState 搜索外围蓝牙设备startBluetoothDevicesDiscovery 监听寻找到新设备onBluetoothDeviceFound 连接蓝牙createBLEConnection 获取蓝牙设备的服务getBLEDeviceServices 获取服务中的特征值getBLEDeviceCharacteristics 启用特征值变化时的notify功能notifyBLECharacteristicValueChange 向蓝牙设备写入数据writeBLECharacteristicValue 关闭蓝牙模块closeBluetoothAdapter 1. 初始化蓝牙模块 初始化蓝牙模块使用的是：wx.openBluetoothAdapter，初始化之前对蓝牙功能做一个判断，看手机微信版本是否支持此功能 初始化之前需要关闭蓝牙模块：wx.closeBluetoothAdapter，否则容易搜索失败 var _this = this if (!wx.openBluetoothAdapter) { wx.showModal({ title: '提示', showCancel: false, content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试', }) } else { wx.closeBluetoothAdapter({ success: res =&gt; { wx.openBluetoothAdapter({ // 初始化蓝牙模块 success: res =&gt; { console.log('初始化蓝牙成功') _this.getBluetoothAdapterState() }, fail: err =&gt; { console.log(err) } }) }, }) } 2. 获取本机蓝牙适配器状态 获取本机蓝牙适配器状态使用的是wx.getBluetoothAdapterState，调用成功后，会返回两个参数 discovering判断是否正在搜索设备 available判断蓝牙适配器是否可用 getBluetoothAdapterState: function(){ var _this = this wx.getBluetoothAdapterState({ success: res =&gt; { if (res.available == false) { wx.showToast({ title: '设备无法开启蓝牙连接', icon: 'none', duration: 2000 }) wx.closeBluetoothAdapter() } else if (res.discovering == false) { _this.startBluetoothDevicesDiscovery() // 开启搜索外围设备 } else if (res.available){ _this.startBluetoothDevicesDiscovery() // 蓝牙适配器正常，去执行搜索外围设备 } } }) } 3. 搜索外围蓝牙设备 搜索外围蓝牙设备使用的是wx.startBluetoothDevicesDiscovery，连接设备后一定要使用wx.stopBluetoothDevicesDiscovery停止搜索 startBluetoothDevicesDiscovery: function(){ var _this = this wx.startBluetoothDevicesDiscovery({ allowDuplicatesKey: false, success: res =&gt; { if(!res.isDiscovering){ // 是否在搜索设备 _this.getBluetoothAdapterState() }else{ _this.onBluetoothDeviceFound() // 搜索成功后，执行监听设备的api } }, fail: err =&gt; { console.log(&quot;蓝牙搜寻失败&quot;) wx.stopBluetoothDevicesDiscovery() // 没有搜索到设备 wx.closeBluetoothAdapter() // 关闭蓝牙模块 } }) } 4. 监听寻找到新设备 监听寻找到新设备使用的是wx.onBluetoothDeviceFound，每搜到一个新设备就会触发一次，然后返回一个搜索到的设备列表，包含了设备名称和mac地址，一般都是使用设备名称和mac地址来匹配设备的 安卓和IOS返回的deviceId不一样，安卓返回的是mac地址，IOS返回的是UUID，如果想通过mac地址来匹配设备，可以让mac地址存储在advertisData数据段中，然后解析这个数据段得到mac地址 我使用的是通过设备名称来进行匹配 onBluetoothDeviceFound: function(){ var _this = this wx.onBluetoothDeviceFound(res =&gt; { for(let i=0; i&lt;res.devices.length; i++){ if(res.devices[i].name == &quot;设备名称&quot; || res.devices[i].localName == &quot;设备名称&quot;){ _this.setData({ deviceId: res.devices[i].deviceId // 把匹配设备的deviceId存到data中 }) wx.stopBluetoothDevicesDiscovery() // 匹配到设备后关闭搜索 _this.createBLEConnection() // 连接蓝牙 } } }) } 5. 连接蓝牙 连接蓝牙使用的是wx.createBLEConnection，连接蓝牙是通过deviceId连接，deviceId是通过wx.onBluetoothDeviceFound获取的 连接蓝牙容易失败，所以可以定一个变量count用来计算连接的次数，如果超出特定的次数就判断为连接失败，关闭蓝牙模块 createBLEConnection: function () { // 连接低功耗蓝牙 var _this = this wx.createBLEConnection({ deviceId: _this.data.deviceId, success: res =&gt; { _this.getBLEDeviceServices() }, fail: err =&gt; { console.log(&quot;连接失败&quot;) if( count &lt; 6 ){ count++ _this.createBLEConnection() }else{ wx.closeBluetoothAdapter() // 连接失败关闭蓝牙模块 } } }) } 6. 获取蓝牙设备的服务 获取蓝牙设备的服务列表使用的是wx.getBLEDeviceServices getBLEDeviceServices: function () { var _this = this wx.getBLEDeviceServices({ deviceId: _this.data.deviceId, success: res =&gt; { for(let i=0; i&lt;res.services.length; i++){ // 如果提前得知可以直接判断，如果不知道可以用蓝牙工具看一下服务所需的功能 if(res.services[i].uuid == _this.data.service){ _this.setData({ serviceId: res.services[i].uuid }) _this.getBLEDeviceCharacteristics() } } }, fail: err =&gt; { console.log(&quot;获取服务失败&quot;) wx.closeBluetoothAdapter() // 关闭蓝牙模块 } }) }, 7. 获取服务中的特征值 获取服务中的特征值使用的是wx.getBLEDeviceCharacteristics getBLEDeviceCharacteristics: function () { // 获取服务中的特征值 var _this = this wx.getBLEDeviceCharacteristics({ deviceId: _this.data.deviceId, serviceId: _this.data.serviceId, success: res =&gt; { for(let i=0; i&lt;res.characteristics.length; i++){ let model = res.characteristics[i] if ((model.properties.notify || model.properties.indicate) &amp;&amp; (model.properties.read &amp;&amp; model.properties.write)){ _this.setData({ characteristicId: model.uuid }) _this.notifyBLECharacteristicValueChange() } } }, fail: err =&gt; { console.log(&quot;获取服务中的特征值失败&quot;) wx.closeBluetoothAdapter() // 关闭蓝牙模块 } }) }, 8. 启用特征值变化时的notify功能 启用特征值变化时的notify功能使用的是wx.notifyBLECharacteristicValueChange notifyBLECharacteristicValueChange: function () { // 启用蓝牙特征值变化时的notify功能 var _this = this wx.notifyBLECharacteristicValueChange({ deviceId: _this.data.deviceId, serviceId: _this.data.serviceId, characteristicId: _thisa.characteristicId, state: true, success: res =&gt; { wx.onBLECharacteristicValueChange(res =&gt; { console.log(如果要打印需要从arraybuffer格式转为字符串或16进制) }) _this.writeBLECharacteristicValue() // 向蓝牙设备写入数据 }, fail: err =&gt; { console.log(&quot;启用BLE蓝牙特征值变化时的notify功能错误&quot;) wx.closeBluetoothAdapter() // 关闭蓝牙模块 } }) 9. 向蓝牙设备写入数据 向蓝牙设备写入数据wx.writeBLECharacteristicValue，这时候就是输入提前设定好的指令 writeBLECharacteristicValue: function () { // 向蓝牙设备写入数据 var _this = this wx.writeBLECharacteristicValue({ deviceId: _this.data.deviceId, serviceId: _this.data.serviceId, characteristicId: _this.data.characteristicId, value: buffer, // 这个输入的指令，需要转换成ArrayBuffer success: res =&gt; { console.log(&quot;成功&quot;) wx.closeBluetoothAdapter() // 关闭蓝牙模块 }, fail: err =&gt; { console.log(&quot;输入指令失败&quot;) wx.closeBluetoothAdapter() // 关闭蓝牙模块 } }) } 转换格式 字符串转为arraybuffer string2buffer: function (str) { // 首先将字符串转为16进制 let val = &quot;&quot; for (let i = 0; i &lt; str.length; i++) { if (val === '') { val = str.charCodeAt(i).toString(16) } else { val += ',' + str.charCodeAt(i).toString(16) } } // 将16进制转化为ArrayBuffer return new Uint8Array(val.match(/[\\da-f]{2}/gi).map(function (h) { return parseInt(h, 16) })).buffer } arraybuffer转为字符串 function ab2str(u,f) { var b = new Blob([u]); var r = new FileReader(); r.readAsText(b, 'utf-8'); r.onload = function (){if(f)f.call(null,r.result)} } 蓝牙遇见的坑 1.苹果手机有时候输入指令会显示发送成功，但是设备并没有反应 解决方法：把需要输入的指令改成每10毫秒输入一个字节 如果改成每10毫秒输入一个字节，安卓手机就会频繁出现10008错误 针对这个问题我用了一个不太好的方法，我判断了一下手机的类型，如果是ios的就分10毫秒输入，如果是安卓的就一次性输入 2.在调用wx.onBluetoothDeviceFound这个api时ios会监听两次，然后就会导致最后设备会有两次指令输入 解决方法：我在搜索蓝牙设备之前做了一个定时器，然后用getBluetoothDevices来查看所有已搜索到的蓝牙，在这个里面做判断来连接蓝牙设备 我上面的步骤没有把这些坑的解决步骤加上，如果碰见此类问题，可以自己在合适的位置修改一下 二维码我自己做了一个小程序的蓝牙调试器，下面是小程序码，欢迎大家体验","link":"/2020/01/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%93%9D%E7%89%99%E6%8E%A7%E5%88%B6%E5%BC%80%E9%97%A8/"},{"title":"解决react状态管理---React Query","text":"什么是React Query react-query是一个适用于react hooks的请求库，它可以为任何类型的异步数据提供React状态管理功能，使React中的获取、缓存、同步和更新服务器数据变得轻而易举 react-query与一些传统的状态管理库如redux,mobx不同，它是负责管理服务器与客户端之间的状态，一些用户交互的中间状态，如loading状态，错误信息等都是通过hooks直接返回 React Query官网 初步使用 yarn add react-query or npm i react-query安装react-query 使用QueryClientProvider组件连接并提供一个QueryClient到你的应用程序 import { QueryClient, QueryClientProvider } from 'react-query' &lt;QueryClientProvider client={new QueryClient()}&gt; { ... } &lt;/QueryClientProvider&gt; Devtools yarn add react-query-devtools or npm i --save react-query-devtools安装Devtools react-query-devtools是与react-query相匹配的开发工具 可在开发中实时查看缓存，手动获取和删除查询等等 import { ReactQueryDevtools } from 'react-query-devtools' const App = () =&gt; { return ( &lt;&gt; { ... } &lt;ReactQueryDevtools initialIsOpen={true} /&gt; &lt;/&gt; ); }; 增删改查 react-query最常用的两个hook，查询(useQuery)、增删改(useMutation) useQuery useQuery：在React Query中，查询是对某些异步数据源的声明性依赖。查询可以与任何基于Promise的方法(GET)一起使用，从服务器获取数据 const useTodos = (param) =&gt; { const request = useHttp() /** * 第一个参数是QueryKey，是查询的关键，是一个独一无二的key，并在之后的增删改中需要， * 如果需要动态的QueryKey，可以使用数组的方式，如['todos', params] * 第二个参数是用于获取数据的异步函数 * useQuery的响应返回就是获取到的数据和一些中间状态，如isLoading，error，isIdle... */ return useQuery('todos', () =&gt; request('todos', { data: param }) ) } // 在UI组件调用 const { isLoading, error, data: todos } = useTodos() useMutation useMutation：常用于创建/更新/删除数据或执行服务器副作用 const useAddTodo = () =&gt; { const request = useHttp() /** * 第一个参数是执行操作的异步函数，在返回的mutate中触发 * 第二个参数是执行成功或者失败的一些配置函数，可用于一些处理缓存的操作，例如乐观更新 */ return useMutation( (data) =&gt; request(`todos`, { data, method: 'POST', }), { onSuccess(){} onError(){} onSettled(){} ... } ) } // 操作组件调用 const TodosAddBtn = () =&gt; { ... const { mutateAsync, isLoading, error } = useAddTodo() return &lt;Button onClick={() =&gt; mutateAsync(todoData)}&gt;add&lt;/Button&gt; } 例：用第二个参数配置乐观更新 乐观更新就是在一些请求或者数据处理没有结束的时候，提前给用户显示理想的结果，如果失败就回滚更新 const useAddConfig = (queryKey) =&gt; { // 获取当前QueryClient的实例 const queryClient = useQueryClient() return { // 当mutate被调用时触发 async onMutate(target) { // 获取当前数据快照，用于错误时回滚更新 const previousItems = queryClient.getQueryData(queryKey) // 乐观更新为新值 queryClient.setQueryData(queryKey, (old) =&gt; { return (target, old) =&gt; (old ? [...old, target] : []) }) // 这个返回值会作为最后一个参数传递给onError和onSettled return { previousItems } }, // 成功回调 清除缓存 onSuccess: () =&gt; queryClient.invalidateQueries(queryKey), // 失败回调 onError(error, newItem, context) { // 当前queryKey的数据回滚 queryClient.setQueryData( queryKey, context.previousItems ) }, // 无论错误或者成功都会触发，此例子没有使用 onSettled() {} } } 总结 本地/客户端中间状态 redux与react-query都可，没有较大的优缺点 服务端中间状态 推荐react-query，将服务器状态从全局状态中解放出来，用更少的代码实现复杂的需求，让你的状态管理更优雅","link":"/2021/06/12/%E8%A7%A3%E5%86%B3react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-ReactQuery/"},{"title":"解析Vue3patch核心算法patchKeyedChildren","text":"解析Vue3patch核心算法patchKeyedChildren locate：runtime-core &gt; renderer &gt; baseCreateRenderer &gt; patchKeyedChildren patchKeyedChildren是patch算法中较为复杂的一段，更是vue技术栈面试的高频点，最初我是在vue3.0 beta版本时大概看过源码，后来在《vue设计与分析》中看了霍春阳大佬的解析，本篇就简要分析一下做个记录 首先patchKeyedChildren是在子列表对比并且有key的情况会进入，并且逻辑大致分为5步，这个看源码官方注释就可以看出 第一步，从前向后遍历这一步是从节点组头部向尾部遍历，如果遍历过程中遇到相似节点，就进行patch对比，否则就退出遍历，并记录当前遍历的最新下标 while (i &lt;= e1 &amp;&amp; i &lt;= e2) { const n1 = c1[i] const n2 = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) if (isSameVNodeType(n1, n2)) { patch( n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } else { break } i++ } 第二步，从后向前遍历从后向前遍历，如果遇到第一步记录的下标就停止，然后遍历过程中，如果遇到相似节点也是直接进行patch对比，如果不相同就是直接退出遍历，并且记录旧节点组和新节点组的尾指针 while (i &lt;= e1 &amp;&amp; i &lt;= e2) { const n1 = c1[e1] const n2 = (c2[e2] = optimized ? cloneIfMounted(c2[e2] as VNode) : normalizeVNode(c2[e2])) if (isSameVNodeType(n1, n2)) { patch( n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } else { break } e1-- e2-- } 第三步，检查旧节点组这一步就是检查旧节点组在上两步的遍历后是否遍历完，如果遍历完，那么新节点组没有遍历完的就都是新的dom，可以全部当作新增节点进行挂载处理 if (i &gt; e1) { if (i &lt;= e2) { const nextPos = e2 + 1 const anchor = nextPos &lt; l2 ? (c2[nextPos] as VNode).el : parentAnchor while (i &lt;= e2) { // patch第一个参数为null，就是代表没有旧节点，直接将新节点插入 patch( null, (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) i++ } } } 第四步，检查新节点组如果上一步检查旧节点未遍历完，那么就检查新节点组是否遍历完，如果遍历完，那么旧的节点组剩余的节点说明都是要卸载的，因为都不需要了 else if (i &gt; e2) { // 旧子节点未被遍历完 while (i &lt;= e1) { unmount(c1[i], parentComponent, parentSuspense, true) i++ } } 第五步，未知序列 如果新旧节点组都未遍历完，说明存在未知序列，可能存在位移等情况，就需要进一步处理 首先创建一个数组，用于记录新旧节点的对应关系 // toBePatched是新序列的节点数量 e2 - s2 + 1 const newIndexToOldIndexMap = new Array(toBePatched) for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0 然后会遍历旧节点组，这里会用两个变量记录 let moved = false：位移标识，用于判断是否需要位移 let patched = 0：记录已执行patch的新节点数量，用于处理如果在更新时更新过的数量大于需要更新的节点数量，就卸载对应旧节点 for (i = s1; i &lt;= e1; i++) { const prevChild = c1[i] // 如果已更新数量大于新节点数量，就卸载节点 if (patched &gt;= toBePatched) { unmount(prevChild, parentComponent, parentSuspense, true) continue } let newIndex //新旧节点key相同的新节点index if (prevChild.key != null) { newIndex = keyToNewIndexMap.get(prevChild.key) } else { for (j = s2; j &lt;= e2; j++) { if ( newIndexToOldIndexMap[j - s2] === 0 &amp;&amp; isSameVNodeType(prevChild, c2[j] as VNode) ) { newIndex = j break } } } // 如果newIndex为空，则说明未找到与旧节点对应的新节点，直接卸载 if (newIndex === undefined) { unmount(prevChild, parentComponent, parentSuspense, true) } else { // 更新新旧节点关系表 newIndexToOldIndexMap[newIndex - s2] = i + 1 /** * 这里的maxNexIndexSoFar是记录每次patch最大index * 也是用于判断是否产生了位移，因为如果新节点index比最大index小，就说明发生了位移 * 例如： * (a b) c * (a c b) * 在新旧序列对比b，c时，由于c最新的newIndex已经小于b对应的newIndex，因此会记录需要位移 */ if (newIndex &gt;= maxNewIndexSoFar) { maxNewIndexSoFar = newIndex } else { moved = true } patch( prevChild, c2[newIndex] as VNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) patched++ } } 遍历完旧序列后，就需要确定如何位移 首先是根据新旧节点关系表生成最长递增子序列(这个算法就不陈述了，较复杂，可以看精读《DOM diff 最长上升子序列》)，然后倒序遍历新子节点 // 最长递增子序列 const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR j = increasingNewIndexSequence.length - 1 // 从新序列尾部向前遍历，目的是为了使用上一个遍历的节点做锚点 for (i = toBePatched - 1; i &gt;= 0; i--) { const nextIndex = s2 + i const nextChild = c2[nextIndex] as VNode // 如果是序列的最后一个节点，anchor就是父节点对应的anchor，否则就是上一个子节点 const anchor = nextIndex + 1 &lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor // 如果newIndexToOldIndexMap[i]还是0，那么说明新节点没有对应的旧节点，说明是新节点，直接挂载 if (newIndexToOldIndexMap[i] === 0) { patch( null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } else if (moved) { // 然后在moved为true的情况下，如果最长子序列为空或者最长子序列和当前访问的新节点index不同，说明就需要进行位移 if (j &lt; 0 || i !== increasingNewIndexSequence[j]) { move(nextChild, container, anchor, MoveType.REORDER) } else { j-- } } }","link":"/2022/08/25/%E8%A7%A3%E6%9E%90Vue3patch%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95patchKeyedChildren/"},{"title":"解析nextTick---vue3任务调度","text":"nextTick 定义：将回调推迟到下一个 DOM 更新周期之后执行，在更改了一些数据以等待 DOM 更新后立即使用它在实际中使用这个方法一般是用于组件更新，你需要获取更新后的数据，所以使用nextTick等待DOM更新 // vue3中的语法对比vue2做了一些改动 import { createApp, nextTick } from 'vue' const app = createApp({ setup() { const message = ref('Hello!') const changeMessage = async newMessage =&gt; { message.value = newMessage // 这里的value是旧值 await nextTick() // nextTick后获取的就是DOM更新后的value console.log('Now DOM is updated') } } }) 这个api使用时相当简单，而且相当容易理解，但是为了知其意，还是要翻一下源码了解它的执行机制 export function nextTick( this: ComponentPublicInstance | void, fn?: () =&gt; void ): Promise&lt;void&gt; { const p = currentFlushPromise || resolvedPromise return fn ? p.then(this ? fn.bind(this) : fn) : p } 上面是vue源码中nextTick的实现，为了搞清楚实现逻辑，就必须搞懂currentFlushPromise这个变量的含义，所以要从任务的调度机制开始分析 任务调度首先这个调度机制的功能在runtime-core的scheduler文件 API // 这个文件会抛出以下几个API函数 nextTick(){} // 将函数在任务队列清空后执行 queueJob(){} // 添加任务并开始执行任务队列 invalidateJob(){} // 删除任务 queuePreFlushCb(){} // 添加前置回调函数并开始执行任务队列 queuePostFlushCb(){} // 添加后置回调函数并开始执行任务队列 flushPreFlushCbs(){} // 执行前置回调函数 flushPostFlushCbs(){} // 执行后置回调函数 我们首先要知道几个关键变量 let isFlushing = false // 是否正在清空任务队列 let isFlushPending = false // 清队任务已创建，等待清空状态 const queue: SchedulerJob[] = [] // 任务队列 let flushIndex = 0 // 当前正在执行的任务在任务队列中的索引 然后我们从queueJob这个函数开始 /* 这个函数主要是将一个任务(job)进行入队操作 然后在满足条件的情况下启动清空队列任务(queueFlush) */ export function queueJob(job: SchedulerJob) { /** * 任务可入队逻辑 * 1. 任务队列为空 * 2. 待入队任务不能存在于任务队列中(按情况分析) */ if ( (!queue.length || !queue.includes( job, /* 在正在清空队列且当前待入队任务是可以递归时， 说明当前任务一定和当前正在执行任务是同一任务，所以+1， 就是为了保证待入队任务和正在执行任务相同，但不能和后面待执行任务相同 */ isFlushing &amp;&amp; job.allowRecurse ? flushIndex + 1 : flushIndex )) &amp;&amp; job !== currentPreFlushParentJob ) { // 二分查找任务在队列中的位置 const pos = findInsertionIndex(job) if (pos &gt; -1) { queue.splice(pos, 0, job) } else { queue.push(job) } queueFlush() } } queueFlush function queueFlush() { /** 清队任务创建后禁止再次创建更多的清队任务 因为在入队操作完成后，flushJobs会在一次递归中将任务队列全部清空，所以只需要一次清队任务即可 */ if (!isFlushing &amp;&amp; !isFlushPending) { isFlushPending = true /* 清队任务创建成功，并记录下当前清队任务，这个标记可以用于nextTick创建自定义函数， 说明nextTick的执行时机是在清队任务后的，其实从这个地方就可以理解nextTick的执行原理了 */ currentFlushPromise = resolvedPromise.then(flushJobs) } } flushJobs // 清空任务队列 function flushJobs(seen?: CountMap) { isFlushPending = false // 关闭清队任务等待状态 isFlushing = true // 开启正在清空队列状态 if (__DEV__) { seen = seen || new Map() } // 清空前置回调任务队列 flushPreFlushCbs(seen) /* 任务队列中的任务根据ID进行排序的原因 1. 因为组件更新是从父组件到子组件的，而任务更新是在数据源更新时触发的，所以为了更新任务的顺序就需要进行排序 2. 如果在父组件更新期间已经卸载了组件，那么子组件的更新任务就可以跳过 */ queue.sort((a, b) =&gt; getId(a) - getId(b)) try { // 遍历任务队列 for (flushIndex = 0; flushIndex &lt; queue.length; flushIndex++) { const job = queue[flushIndex] if (job &amp;&amp; job.active !== false) { if (__DEV__ &amp;&amp; checkRecursiveUpdates(seen!, job)) { continue } // 执行当前任务 callWithErrorHandling(job, null, ErrorCodes.SCHEDULER) } } } finally { // 重置当前任务索引 flushIndex = 0 // 清空任务队列 queue.length = 0 // 执行后置回调任务队列 flushPostFlushCbs(seen) // 重置清队任务的状态 isFlushing = false currentFlushPromise = null /* 因为清队任务执行期间也会有任务入队，所以为了清队执行完成 就需要判断各任务队列的长度，然后递归执行 */ if ( queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length ) { flushJobs(seen) } } } 总结 nextTick的执行时机是在任务队列(前置、主任务、后置)清除后的，currentFlushPromise是清队任务的promise标记 任务队列执行顺序：执行前置回调任务队列 -&gt; 执行主任务队列 -&gt; 执行后置回调任务队列","link":"/2021/07/17/%E8%A7%A3%E6%9E%90nextTick-vue3%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"},{"title":"解析reactive---vue3响应式","text":"想要了解vue3的reactive模块，就要对Proxy和Reflect有所了解，关于这两个知识我推荐看阮一峰老师的ES6入门教程 我对reactive模块有一个大致梳理，见下图 从上图可以大致理清一个值被创建响应式状态的过程，下面分四部分解析 reactive文件：目标对象转化为proxy实例 baseHandler文件：基本类型处理器 collectionHandlers文件：Map、Set处理器 effect文件：收集触发依赖 reactive reactive：将一个JS对象转为具有响应式的proxy实例 export function reactive(target: object) { // 如果是只读数据，就直接返回 if (target &amp;&amp; (target as Target)[ReactiveFlags.IS_READONLY]) { return target } return createReactiveObject( target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap ) } createReactiveObject function createReactiveObject( target: Target, // 源对象 isReadonly: boolean, // 是否只读 baseHandlers: ProxyHandler&lt;any&gt;, // 基本类型的handlers collectionHandlers: ProxyHandler&lt;any&gt;, // 主要针对(set、map、weakSet、weakMap)的handlers proxyMap: WeakMap&lt;Target, any&gt; ) { // 如果不是一个对象，直接返回 if (!isObject(target)) { if (__DEV__) { console.warn(`value cannot be made reactive: ${String(target)}`) } return target } // 如果已经是响应式，直接返回 if ( target[ReactiveFlags.RAW] &amp;&amp; !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE]) ) { return target } // 如果目标对象已经存在代理，直接返回 const existingProxy = proxyMap.get(target) if (existingProxy) { return existingProxy } // 如果类型值不是Object、Array、Map、Set、WeakMap、WeakSet的，直接返回 const targetType = getTargetType(target) if (targetType === TargetType.INVALID) { return target } // 根据不同的类型值赋予不同的handlers，就是我之前图上画的分开处理 /* 把set、Map这种数据与基础数据分开处理，是因为Map、Set中存储的数据必须通过this进行访问 但是被proxy劫持后，this就变成了proxy， 所以需要特殊处理，把劫持方法进行重写 */ const proxy = new Proxy( target, targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers ) proxyMap.set(target, proxy) return proxy } baseHandler baseHandler这个文件我主要分析reactive的处理器对象mutableHandlers // 对get set delete has onwKeys做了拦截处理 export const mutableHandlers: ProxyHandler&lt;object&gt; = { get, set, deleteProperty, has, ownKeys } getfunction createGetter(isReadonly = false, shallow = false) { return function get(target: Target, key: string | symbol, receiver: object) { // 访问标志位时的逻辑处理 if (key === ReactiveFlags.IS_REACTIVE) { return !isReadonly } else if (key === ReactiveFlags.IS_READONLY) { return isReadonly } else if ( key === ReactiveFlags.RAW &amp;&amp; receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap ).get(target) ) { return target } const targetIsArray = isArray(target) // 如果target是数组并且key属于一些数组的原始方法，即触发拦截hack if (!isReadonly &amp;&amp; targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) { return Reflect.get(arrayInstrumentations, key, receiver) } const res = Reflect.get(target, key, receiver) // 如果key是symbol的内置方法，或者是原型对象，直接返回 if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) { return res } // 只读对象不收集依赖，因为不会触发依赖更新 if (!isReadonly) { track(target, TrackOpTypes.GET, key) } // 浅层响应立即返回，不递归转化 if (shallow) { return res } // 如果是ref对象(数组除外)，返回真正的值， if (isRef(res)) { const shouldUnwrap = !targetIsArray || !isIntegerKey(key) return shouldUnwrap ? res.value : res } if (isObject(res)) { // 由于proxy只能代理一层，所以target[key]的值如果是对象，就继续对其进行代理 return isReadonly ? readonly(res) : reactive(res) } return res } } 数组方法拦截hack: 响应式系统对数组的两种原生方法进行了hack 遍历查找的方法：includes、indexOf、lastIndexOf 改变数组长度的方法：push、pop、shift、unshift、splice function createArrayInstrumentations() { const instrumentations: Record&lt;string, Function&gt; = {} ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key =&gt; { const method = Array.prototype[key] as any instrumentations[key] = function(this: unknown[], ...args: unknown[]) { // 这一步是为了取原始实例，因为当前的this是receiver const arr = toRaw(this) // 搜集依赖 for (let i = 0, l = this.length; i &lt; l; i++) { track(arr, TrackOpTypes.GET, i + '') } // 触发方法，如果没有找到对应的值，就取原始值再遍历 const res = method.apply(arr, args) if (res === -1 || res === false) { return method.apply(arr, args.map(toRaw)) } else { return res } } }) /* 因为改变数组长度的方法，执行期间会触发length的get和set 就回导致无限循环track和trigger 所以就用pauseTracking()禁用依赖收集，触发方法后， 再用resetTracking()恢复track */ ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key =&gt; { const method = Array.prototype[key] as any instrumentations[key] = function(this: unknown[], ...args: unknown[]) { pauseTracking() const res = method.apply(this, args) resetTracking() return res } }) return instrumentations } setfunction createSetter(shallow = false) { return function set( target: object, key: string | symbol, value: unknown, receiver: object ): boolean { let oldValue = (target as any)[key] if (!shallow) { value = toRaw(value) oldValue = toRaw(oldValue) // 如果原来的值是ref，但新的值不是，则将新的值赋给oldValue.value if (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) { oldValue.value = value return true } } else { // in shallow mode, objects are set as-is regardless of reactive or not } const hadKey = isArray(target) &amp;&amp; isIntegerKey(key) ? Number(key) &lt; target.length : hasOwn(target, key) const result = Reflect.set(target, key, value, receiver) // 判断receiver是当前对象的proxy实例，防止原型链上的proxy触发更新 if (target === toRaw(receiver)) { // 判断新增属性还是修改属性 if (!hadKey) { trigger(target, TriggerOpTypes.ADD, key, value) } else if (hasChanged(value, oldValue)) { trigger(target, TriggerOpTypes.SET, key, value, oldValue) } } return result } } deleteProperty、has… deleteProperty、has、ownKeys的源码就不贴了，都是判断key的属性，然后选择触发或者收集依赖 collectionHandlers collection这个文件我主要分析reactive的重写方法对象mutableInstrumentations // 主要对以下原生api进行了改写 const mutableInstrumentations: Record&lt;string, Function&gt; = { get(this: MapTypes, key: unknown) { return get(this, key) }, get size() { return size((this as unknown) as IterableCollections) }, has, add, set, delete: deleteEntry, clear, forEach: createForEach(false, false) } getfunction get( target: MapTypes, key: unknown, isReadonly = false, isShallow = false ) { // 获取原始值重新赋值给target target = (target as any)[ReactiveFlags.RAW] // 对target源对象和key进一步获取原始值 const rawTarget = toRaw(target) const rawKey = toRaw(key) // 包装后的key和原始key均进行依赖收集(track) if (key !== rawKey) { !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.GET, key) } !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.GET, rawKey) const { has } = getProto(rawTarget) // 获取对应的转换函数 const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive /* 如果源对象有key对应的属性，就通过原生get方法取到值， 并对该值进行响应式转换，返回转换后的响应式对象， 如果没有，就去key原始值中去查找 */ if (has.call(rawTarget, key)) { return wrap(target.get(key)) } else if (has.call(rawTarget, rawKey)) { return wrap(target.get(rawKey)) } else if (target !== rawTarget) { target.get(key) } } size// 对size属性做get拦截 function size(target: IterableCollections, isReadonly = false) { target = (target as any)[ReactiveFlags.RAW] // 获取size和获取数组的length类似，都用专门的key做依赖收集 !isReadonly &amp;&amp; track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY) return Reflect.get(target, 'size', target) } setfunction set(this: MapTypes, key: unknown, value: unknown) { // 获取value和this上下文的原始值 value = toRaw(value) const target = toRaw(this) const { has, get } = getProto(target) /* 判断源对象是否已经存在key对应的属性 1. 首先查找源对象是否已有key对应的属性 2. 如果没有，再查找key对应的原始值在源对象的属性是否存在 */ let hadKey = has.call(target, key) if (!hadKey) { key = toRaw(key) hadKey = has.call(target, key) } else if (__DEV__) { checkIdentityKeys(target, has, key) } const oldValue = get.call(target, key) target.set(key, value) // 触发依赖，新增属性和修改属性分开进行trigger if (!hadKey) { trigger(target, TriggerOpTypes.ADD, key, value) } else if (hasChanged(value, oldValue)) { trigger(target, TriggerOpTypes.SET, key, value, oldValue) } return this } has、clear… 其余重写方法我就不上代码了，不同点是单个属性触发单个的依赖，如果是遍历所有属性的方法就触发所有依赖 effect effect文件作为响应式的核心，主要负责收集依赖，触发依赖 effect effect函数主要是生成收集依赖所需的依赖函数 export function effect&lt;T = any&gt;( fn: () =&gt; T, options: ReactiveEffectOptions = EMPTY_OBJ ): ReactiveEffect&lt;T&gt; { // 如果已经是effect函数，取得原来的fn if (isEffect(fn)) { fn = fn.raw } const effect = createReactiveEffect(fn, options) // 如果lazy为false，立即执行一次 if (!options.lazy) { effect() } return effect } createReactiveEffect：生成effect对象 function createReactiveEffect&lt;T = any&gt;( fn: () =&gt; T, options: ReactiveEffectOptions ): ReactiveEffect&lt;T&gt; { const effect = function reactiveEffect(): unknown { // 没有激活，已经调用stop函数停止监听 if (!effect.active) { return fn() } // 判断effectStack中有没有effect，避免递归循环，effectStack是一个全局effect栈 if (!effectStack.includes(effect)) { // 清除effect依赖，保证当前effect的dep是最新且有效的 cleanup(effect) try { enableTracking() // 重新收集依赖 effectStack.push(effect) activeEffect = effect return fn() } finally { /* track将依赖函数activeEffect添加到对应的dep中， 然后将activeEffect重置为上一个effect的值 */ effectStack.pop() resetTracking() activeEffect = effectStack[effectStack.length - 1] } } } as ReactiveEffect effect.id = uid++ // 自增ID effect.allowRecurse = !!options.allowRecurse // 递归状态 effect._isEffect = true // 用于标识方法是不是effect effect.active = true // 用于判断当前effect是否激活，有一个stop()来将它设为false effect.raw = fn // effect的执行函数 effect.deps = [] // 用于收集依赖 effect.options = options // 创建effect传入的options return effect } activeEffect就是标记track所需的依赖函数 track track就是baseHandler和collectionHandlers文件中频繁使用的收集依赖函数 首先需要看一个关键变量targetMap // targetMap是依赖管理中心，收集依赖和触发依赖都依托于这个Map数据 // 下面是targetMap的定义(target -&gt; key -&gt; dep) // target: 监听的对象源 // key: 监听的键值 // dep：依赖函数 type Dep = Set&lt;ReactiveEffect&gt; type KeyToDepMap = Map&lt;any, Dep&gt; const targetMap = new WeakMap&lt;any, KeyToDepMap&gt;() // 格式大致为 targetMap = { target: { key1: { fn1, fn2 } key2: { fn1, fn2 } } } /** * @param {target} 目标对象 * @param {type} 收集类型 * @param {key} 需要收集依赖的key */ export function track(target: object, type: TrackOpTypes, key: unknown) { // activeEffect为空，就表示当前没有依赖，就没必要做依赖收集了 if (!shouldTrack || activeEffect === undefined) { return } // 获取当前依赖数据 let depsMap = targetMap.get(target) if (!depsMap) { targetMap.set(target, (depsMap = new Map())) } // 如果当前数据中没有所属的依赖key，就重新设置一个 let dep = depsMap.get(key) if (!dep) { depsMap.set(key, (dep = new Set())) } // 添加依赖函数 if (!dep.has(activeEffect)) { dep.add(activeEffect) activeEffect.deps.push(dep) if (__DEV__ &amp;&amp; activeEffect.options.onTrack) { activeEffect.options.onTrack({ effect: activeEffect, target, type, key }) } } } trigger// 触发依赖 export function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt; ) { const depsMap = targetMap.get(target) // 如果没有收集过依赖，直接返回 if (!depsMap) { return } const effects = new Set&lt;ReactiveEffect&gt;() const add = (effectsToAdd: Set&lt;ReactiveEffect&gt; | undefined) =&gt; { if (effectsToAdd) { effectsToAdd.forEach(effect =&gt; { // 避免重复触发依赖 if (effect !== activeEffect || effect.allowRecurse) { effects.add(effect) } }) } } if (type === TriggerOpTypes.CLEAR) { // 在清空前，将对应的依赖全部添加到局部Set depsMap.forEach(add) } else if (key === 'length' &amp;&amp; isArray(target)) { // 当数组的length属性变化时触发 depsMap.forEach((dep, key) =&gt; { if (key === 'length' || key &gt;= (newValue as number)) { add(dep) } }) } else { // schedule runs for SET | ADD | DELETE // 往相应队列添加依赖 if (key !== void 0) { add(depsMap.get(key)) } // also run for iteration key on ADD | DELETE | Map.SET // 通过不同的TriggerOpTypes将depsMap的数据取出，添加到effects switch (type) { case TriggerOpTypes.ADD: if (!isArray(target)) { add(depsMap.get(ITERATE_KEY)) if (isMap(target)) { add(depsMap.get(MAP_KEY_ITERATE_KEY)) } } else if (isIntegerKey(key)) { // new index added to array -&gt; length changes add(depsMap.get('length')) } break case TriggerOpTypes.DELETE: if (!isArray(target)) { add(depsMap.get(ITERATE_KEY)) if (isMap(target)) { add(depsMap.get(MAP_KEY_ITERATE_KEY)) } } break case TriggerOpTypes.SET: if (isMap(target)) { add(depsMap.get(ITERATE_KEY)) } break } } const run = (effect: ReactiveEffect) =&gt; { if (__DEV__ &amp;&amp; effect.options.onTrigger) { effect.options.onTrigger({ effect, target, key, type, newValue, oldValue, oldTarget }) } if (effect.options.scheduler) { // 如果有调度属性，就通过scheduler处理执行 effect.options.scheduler(effect) } else { effect() } } effects.forEach(run) }","link":"/2021/08/01/%E8%A7%A3%E6%9E%90reactive-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/"}],"tags":[{"name":"H5","slug":"H5","link":"/tags/H5/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"Vite","slug":"Vite","link":"/tags/Vite/"},{"name":"SSR","slug":"SSR","link":"/tags/SSR/"},{"name":"pnpm","slug":"pnpm","link":"/tags/pnpm/"},{"name":"瀑布流","slug":"瀑布流","link":"/tags/%E7%80%91%E5%B8%83%E6%B5%81/"},{"name":"虚拟列表","slug":"虚拟列表","link":"/tags/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/"},{"name":"蓝牙","slug":"蓝牙","link":"/tags/%E8%93%9D%E7%89%99/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"ReactQuery","slug":"ReactQuery","link":"/tags/ReactQuery/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[]}