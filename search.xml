<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>H5跳转微信小程序</title>
    <url>/2021/06/10/H5%E8%B7%B3%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="H5跳转微信小程序"><a href="#H5跳转微信小程序" class="headerlink" title="H5跳转微信小程序"></a>H5跳转微信小程序</h2><blockquote>
<p>H5跳转小程序有两个方法，需要根据浏览器环境判断<br>微信外使用<code>URL Scheme</code>，根据生成的一个link进行location跳转<br>微信内使用<code>wx-open-launch-weapp</code>开放标签进行跳转，实测ios系统微信内也可以使用<code>URL Scheme</code>，根据自己的需求选择</p>
</blockquote>
<h3 id="wx-open-launch-weapp"><a href="#wx-open-launch-weapp" class="headerlink" title="wx-open-launch-weapp"></a><code>wx-open-launch-weapp</code></h3><ul>
<li><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html">官方文档</a></li>
<li>注意事项：微信版本要求为：7.0.12及以上。 系统版本要求为：iOS 10.3及以上、Android 5.0及以上</li>
<li>绑定域名: 登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”  </li>
<li>引入SDK：官网推荐引入方法<code>&lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;</code>;，也可以使用第三方npm包<code>weixin-js-sdk</code>  </li>
<li>校验签名是否正确：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign">微信 JS 接口签名校验工具</a></li>
<li>如果开放标签需要绝对定位，就在外面包裹一个div进行定位，避免直接定位开放标签</li>
<li>调试：好多人在进行调试的时候认为非常麻烦，需要不断切换环境，我推荐一个我的调试方式，在开发过程中，使用SwitchHosts进行IP映射，把本地启动项目的域名映射到公众号平台设置的域名，然后在微信开发工具中调试，就非常轻松了</li>
</ul>
<pre><code class="highlight html">// 普通H5的写法可参考官方文档，以下是我在vue中的写法
<span class="tag">&lt;<span class="name">wx-open-launch-weapp</span></span>
<span class="tag"> <span class="attr">username</span>=<span class="string">&quot;小程序原始id&quot;</span></span>
<span class="tag"> <span class="attr">path</span>=<span class="string">&quot;页面路径及参数&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/wxtag-template&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml">           </span></span>
<span class="language-xml"><span class="language-handlebars">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;wx-btn&quot;</span>&gt;</span>跳转小程序<span class="tag">&lt;/<span class="name">button</span>&gt;</span>   </span></span>
<span class="language-xml"><span class="language-handlebars">  </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
<span class="tag">&lt;/<span class="name">wx-open-launch-weapp</span>&gt;</span>
<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">...</span>
<span class="language-javascript"><span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span>
<span class="language-javascript">  <span class="keyword">const</span> wx = <span class="built_in">require</span>(<span class="string">&#x27;weixin-js-sdk&#x27;</span>)</span>
<span class="language-javascript">  wx.<span class="title function_">config</span>(&#123;</span>
<span class="language-javascript">    <span class="attr">debug</span>: <span class="literal">true</span>, <span class="comment">// 开启调试模式，会在移动端以alert的形式打印返回值</span></span>
<span class="language-javascript">    <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，从服务端获取</span></span>
<span class="language-javascript">    <span class="attr">timestamp</span>: , <span class="comment">// 必填，生成签名的时间戳，从服务端获取</span></span>
<span class="language-javascript">    <span class="attr">nonceStr</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，生成签名的随机串，从服务端获取</span></span>
<span class="language-javascript">    <span class="attr">signature</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">// 必填，签名，从服务端获取</span></span>
<span class="language-javascript">    <span class="attr">jsApiList</span>: [], <span class="comment">// 必填，需要使用的JS接口列表，这个随便填一个就行</span></span>
<span class="language-javascript">    <span class="attr">openTagList</span>: [<span class="string">&#x27;wx-open-launch-weapp&#x27;</span>]</span>
<span class="language-javascript">  &#125;)</span>
<span class="language-javascript">  wx.<span class="title function_">ready</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span>
<span class="language-javascript">  wx.<span class="title function_">error</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span>
<span class="language-javascript">&#125;</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>

<h3 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a><code>URL Scheme</code></h3><ul>
<li>注意事项：安卓不能直接跳转，需要H5中转，否则Android会出现无法访问</li>
<li>写法很简单，只需<code>location.href=&#39;URL Scheme&#39;</code>，在页面初始化时调用或者在按钮点击事件中调用</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>React源码分析之diff核心算法</title>
    <url>/2022/09/04/React%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdiff%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>React的diff算法是在render的beginWork阶段中进行处理</li>
<li><code>beginWork</code>是在向下深度遍历fiber树时会对途径的每个节点进行状态处理和进行diff对比</li>
<li>首先diff的入口是在<code>reconcileChildFibers</code>中，然后会根据type来判断使用哪种diff函数进行处理<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params"></span>
<span class="params">  returnFiber: Fiber,</span>
<span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span>
<span class="params">  newChild: any,</span>
<span class="params">  lanes: Lanes,</span>
<span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;
    <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;
      <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:
        <span class="keyword">return</span> <span class="title function_">placeSingleChild</span>(
          <span class="title function_">reconcileSingleElement</span>(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );··
      <span class="keyword">case</span> <span class="attr">REACT_PORTAL_TYPE</span>:
        <span class="comment">// ...</span>
      <span class="keyword">case</span> <span class="attr">REACT_LAZY_TYPE</span>:
        <span class="comment">//...</span>
    &#125;

    <span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;
      <span class="keyword">return</span> <span class="title function_">reconcileChildrenArray</span>(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    &#125;

    <span class="keyword">if</span> (<span class="title function_">getIteratorFn</span>(newChild)) &#123;
      <span class="comment">//...</span>
    &#125;
  &#125;
  <span class="comment">// ...</span>
&#125;</code></pre></li>
<li>我在本篇会针对两种较常用的diff函数进行分析<ul>
<li><code>reconcileSingleElement</code></li>
<li><code>reconcileChildrenArray</code></li>
</ul>
</li>
</ul>
<h2 id="reconcileSingleElement"><a href="#reconcileSingleElement" class="headerlink" title="reconcileSingleElement"></a>reconcileSingleElement</h2><ul>
<li>reconcileSingleElement是针对新newChild是单节点，而oldChild单节点或者是多节点就无法确定了，所以在此diff算法中就会对旧节点进行遍历，然后删除不匹配的oldFiber<pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">reconcileSingleElement</span>(<span class="params"></span>
<span class="params">  returnFiber: Fiber,</span>
<span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span>
<span class="params">  element: ReactElement</span>
<span class="params">  lanes: Lanes,</span>
<span class="params"></span>): <span class="title class_">Fiber</span> &#123;
  <span class="keyword">const</span> key = element.<span class="property">key</span>;
  <span class="keyword">let</span> child = currentFirstChild;
  <span class="comment">/**</span>
<span class="comment">    * 遍历旧节点，找到与newChild相同key的节点，不匹配的删除</span>
<span class="comment">    * 针对匹配的oldFiber, 用newChild中新节点的props来生成新的fiber节点</span>
<span class="comment">    */</span>
  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;
    <span class="keyword">if</span> (child.<span class="property">key</span> === key) &#123;
      <span class="keyword">const</span> elementType = element.<span class="property">type</span>;
      <span class="comment">/**</span>
<span class="comment">        * 通过useFiber创建一个新的Fiber</span>
<span class="comment">        * 如果element是一个Fragment，则以element.props.children建立Fiber</span>
<span class="comment">        * 将returnFiber赋给新的fiber的return字段，然后返回这个新的fiber</span>
<span class="comment">        */</span>·
      <span class="keyword">if</span> (elementType === <span class="variable constant_">REACT_FRAGMENT_TYPE</span>) &#123;
        <span class="keyword">if</span> (child.<span class="property">tag</span> === <span class="title class_">Fragment</span>) &#123;
          <span class="title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="property">sibling</span>);
          <span class="keyword">const</span> existing = <span class="title function_">useFiber</span>(child, element.<span class="property">props</span>.<span class="property">children</span>);
          existing.<span class="property">return</span> = returnFiber;
          <span class="keyword">if</span> (__DEV__) &#123;
            existing.<span class="property">_debugSource</span> = element.<span class="property">_source</span>;
            existing.<span class="property">_debugOwner</span> = element.<span class="property">_owner</span>;
          &#125;
          <span class="keyword">return</span> existing;
        &#125;
      &#125; <span class="keyword">else</span> &#123;
        <span class="keyword">if</span> (
          child.<span class="property">elementType</span> === elementType ||
          (__DEV__
            ? <span class="title function_">isCompatibleFamilyForHotReloading</span>(child, element)
            : <span class="literal">false</span>) ||
          (<span class="keyword">typeof</span> elementType === <span class="string">&#x27;object&#x27;</span> &amp;&amp;
            elementType !== <span class="literal">null</span> &amp;&amp;
            elementType.<span class="property">$$typeof</span> === <span class="variable constant_">REACT_LAZY_TYPE</span> &amp;&amp;
            <span class="title function_">resolveLazy</span>(elementType) === child.<span class="property">type</span>)
        ) &#123;
          <span class="title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="property">sibling</span>);
          <span class="keyword">const</span> existing = <span class="title function_">useFiber</span>(child, element.<span class="property">props</span>);
          existing.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, child, element);
          existing.<span class="property">return</span> = returnFiber;
          <span class="keyword">if</span> (__DEV__) &#123;
            existing.<span class="property">_debugSource</span> = element.<span class="property">_source</span>;
            existing.<span class="property">_debugOwner</span> = element.<span class="property">_owner</span>;
          &#125;
          <span class="keyword">return</span> existing;
        &#125;
      &#125;
      <span class="comment">// Didn&#x27;t match.</span>
      <span class="title function_">deleteRemainingChildren</span>(returnFiber, child);
      <span class="keyword">break</span>;
    &#125; <span class="keyword">else</span> &#123;
      <span class="comment">// key不相同就删除</span>
      <span class="title function_">deleteChild</span>(returnFiber, child);
    &#125;
    child = child.<span class="property">sibling</span>;
  &#125;

  <span class="comment">// 如果没有命中一个key，则通过createFiberFormElement或CreateFiberFormFragment创建一个新的fiber，然后返回</span>
  <span class="keyword">if</span> (element.<span class="property">type</span> === <span class="variable constant_">REACT_FRAGMENT_TYPE</span>) &#123;
    <span class="keyword">const</span> created = <span class="title function_">createFiberFromFragment</span>(
      element.<span class="property">props</span>.<span class="property">children</span>,
      returnFiber.<span class="property">mode</span>,
      lanes,
      element.<span class="property">key</span>,
    );
    created.<span class="property">return</span> = returnFiber;
    <span class="keyword">return</span> created;
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">const</span> created = <span class="title function_">createFiberFromElement</span>(element, returnFiber.<span class="property">mode</span>, lanes);
    created.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, currentFirstChild, element);
    created.<span class="property">return</span> = returnFiber;
    <span class="keyword">return</span> created;
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="reconcileChildrenArray"><a href="#reconcileChildrenArray" class="headerlink" title="reconcileChildrenArray"></a>reconcileChildrenArray</h2><ul>
<li><p>针对<code>newChild</code>是多节点的情况就需要调用<code>reconcileChildrenArray</code>进行diff操作</p>
</li>
<li><p>多节点会有四种可能性的变化：删除、新增、位移、更新</p>
</li>
<li><p><code>reconcileChildrenArray</code>针对这四种变化，首先会处理的是更新，当出现无法匹配的情况时，就会根据遍历的情况来判断是否处理删除或者新增，然后最后会根据情况处理位移</p>
</li>
<li><p>因为fiber是单向链表，所以<code>reconcileChildrenArray</code>的遍历不是双端遍历</p>
</li>
<li><p>首先第一轮遍历，是处理节点更新</p>
<pre><code class="highlight ts"><span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;
  <span class="comment">// newChildren遍历完了，oldFiber没有遍历完，中断遍历</span>
  <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) &#123;
    nextOldFiber = oldFiber;
    oldFiber = <span class="literal">null</span>;
  &#125; <span class="keyword">else</span> &#123;
    <span class="comment">// 记录oldFiber的下一个节点</span>
    nextOldFiber = oldFiber.<span class="property">sibling</span>;
  &#125;
  <span class="comment">// 更新节点，如果节点没有匹配上，就会返回null</span>
  <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(
    returnFiber,
    oldFiber,
    newChildren[newIdx],
    lanes,
  );
  <span class="comment">// newFiber为null说明节点没有匹配上，中断遍历</span>
  <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;
    <span class="comment">// oldFiber为null说明oldFiber也遍历完了</span>
    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;
      oldFiber = nextOldFiber;
    &#125;
    <span class="keyword">break</span>;
  &#125;

  <span class="comment">/**</span>
<span class="comment">   * shouldTrackSideEffects为true表示是更新过程</span>
<span class="comment">   * mountChildFibers = ChildReconciler(false);</span>
<span class="comment">   * reconcileChildFibers = ChildReconciler(true);</span>
<span class="comment">   * ChildReconciler接收的就是shouldTrackSideEffects</span>
<span class="comment">   */</span>
  <span class="keyword">if</span> (shouldTrackSideEffects) &#123;
    <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;
      <span class="comment">// 新节点没有现有节点，需要删除</span>
      <span class="title function_">deleteChild</span>(returnFiber, oldFiber);
    &#125;
  &#125;
  <span class="comment">// 记录固定节点的位置</span>
  lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);

  <span class="comment">// 将新节点拼接成以sibling为指针的单向链表</span>
  <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;
    resultingFirstChild = newFiber;
  &#125; <span class="keyword">else</span> &#123;
    previousNewFiber.<span class="property">sibling</span> = newFiber;
  &#125;
  previousNewFiber = newFiber;
  oldFiber = nextOldFiber;
&#125;</code></pre>
</li>
<li><p>遍历完匹配的节点后，就判断新节点是否遍历完，如果遍历完，那么剩余的oldFiber都是要删除的</p>
<pre><code class="highlight ts"><span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;
  <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);
  <span class="keyword">if</span> (<span class="title function_">getIsHydrating</span>()) &#123;
    <span class="keyword">const</span> numberOfForks = newIdx;
    <span class="title function_">pushTreeFork</span>(returnFiber, numberOfForks);
  &#125;
  <span class="keyword">return</span> resultingFirstChild;
&#125;</code></pre>
</li>
<li><p>如果新旧点没有遍历完，就判断旧fiber链是否遍历完，如果遍历完那么剩余的新节点全部作为新fiber插入</p>
<pre><code class="highlight ts"><span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;
  <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;
    <span class="comment">// 创建新fiber节点</span>
    <span class="keyword">const</span> newFiber = <span class="title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);
    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;
      <span class="keyword">continue</span>;
    &#125;

    <span class="comment">// 记录固定节点</span>
    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);

    <span class="comment">// 将新fiber拼接成以sibling为指针的单向链表</span>
    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;
      resultingFirstChild = newFiber;
    &#125; <span class="keyword">else</span> &#123;
      previousNewFiber.<span class="property">sibling</span> = newFiber;
    &#125;
    previousNewFiber = newFiber;
  &#125;
  <span class="keyword">if</span> (<span class="title function_">getIsHydrating</span>()) &#123;
    <span class="keyword">const</span> numberOfForks = newIdx;
    <span class="title function_">pushTreeFork</span>(returnFiber, numberOfForks);
  &#125;
  <span class="keyword">return</span> resultingFirstChild;
&#125;</code></pre>
</li>
<li><p>执行到这一步，说明新旧节点都没有遍历完，就说明存在有位移的未知序列</p>
<pre><code class="highlight ts"><span class="comment">// 首先创建一个以oldFiber key为键，值为oldFiber的map</span>
<span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);

<span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;
  <span class="comment">// 然后根据map中的oldFiber创建新fiber</span>
  <span class="keyword">const</span> newFiber = <span class="title function_">updateFromMap</span>(
    existingChildren,
    returnFiber,
    newIdx,
    newChildren[newIdx],
    lanes,
  );
  <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;
    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;
      <span class="keyword">if</span> (newFiber.<span class="property">alternate</span> !== <span class="literal">null</span>) &#123;
        <span class="comment">// 如果newFiber.alternate不为null，说明是根据oldFiber创建的，那么就需要在map中删除oldFiber</span>
        existingChildren.<span class="title function_">delete</span>(
          newFiber.<span class="property">key</span> === <span class="literal">null</span> ? newIdx : newFiber.<span class="property">key</span>,
        );
      &#125;
    &#125;

    <span class="comment">// 根据lastPlacedIndex判断是否移动节点</span>
    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);

    <span class="comment">// 将新fiber拼接成以sibling为指针的单向链表</span>
    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;
      resultingFirstChild = newFiber;
    &#125; <span class="keyword">else</span> &#123;
      previousNewFiber.<span class="property">sibling</span> = newFiber;
    &#125;
    previousNewFiber = newFiber;
  &#125;
&#125;

<span class="keyword">if</span> (shouldTrackSideEffects) &#123;
  <span class="comment">// 删除剩余的oldFiber</span>
  existingChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">deleteChild</span>(returnFiber, child));
&#125;</code></pre></li>
<li><p>移动节点的核心是在<code>placeChild</code>这个函数中，如果当前正在遍历的节点的oldIndex是在<code>lastPlacedIndex</code>的右边，就说明它的位置没变化，因为旧节点中就处于右边，新节点中也处于右边。</p>
<ul>
<li>例如：old：A -&gt; B -&gt; C -&gt; D，new：D -&gt; A -&gt; B -&gt; C</li>
<li>遍历到D时，<code>lastPlacedIndex = D的oldIndex = 3</code></li>
<li>然后遍历到A时，A的<code>oldIndex</code>为0，小于3，说明A在旧序列中肯定不是D的右边，所以A肯定产生了位移<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">placeChild</span>(<span class="params"></span>
<span class="params">  newFiber: Fiber,</span>
<span class="params">  lastPlacedIndex: number,</span>
<span class="params">  newIndex: number,</span>
<span class="params"></span>): number &#123;
  newFiber.<span class="property">index</span> = newIndex;
  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;
    newFiber.<span class="property">flags</span> |= <span class="title class_">Forked</span>;
    <span class="keyword">return</span> lastPlacedIndex;
  &#125;
  <span class="keyword">const</span> current = newFiber.<span class="property">alternate</span>;
  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;
    <span class="keyword">const</span> oldIndex = current.<span class="property">index</span>;
    <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;
      <span class="comment">// 小于lastPlacedIndex 产生了位移</span>
      newFiber.<span class="property">flags</span> |= <span class="title class_">Placement</span> | <span class="title class_">PlacementDEV</span>;
      <span class="keyword">return</span> lastPlacedIndex;
    &#125; <span class="keyword">else</span> &#123;
      <span class="comment">// 没有位移，返回当前的oldIndex</span>
      <span class="keyword">return</span> oldIndex;
    &#125;
  &#125; <span class="keyword">else</span> &#123;
    newFiber.<span class="property">flags</span> |= <span class="title class_">Placement</span> | <span class="title class_">PlacementDEV</span>;
    <span class="keyword">return</span> lastPlacedIndex;
  &#125;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>针对单节点的diff，会遍历oldFiber链，如果有匹配的fiber，就以匹配的生成新fiber，如果没有就新建一个fiber，然后删除不匹配的fiber</li>
<li>针对多节点diff<ul>
<li>首先是从头向尾遍历，针对复用的fiber进行更新，如果无法复用就中断遍历</li>
<li>然后判断新旧节点的遍历情况，来判断是否新增或者删除</li>
<li>如果都没有遍历完，就创建一个map<code>Map&lt;old key, old Fiber&gt;</code>，然后遍历新节点，基于map来创建新fiber，然后根据<code>lastPlacedIndex</code>来判断是否产生了位移，遍历完最后删除剩余的oldFiber</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建详细教程</title>
    <url>/2022/09/06/Hexo%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%93%8D%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><ol>
<li>首先需要以下安装环境，直接在官网下载即可</li>
</ol>
<ul>
<li><a href="https://nodejs.org/en/">Node.js</a></li>
<li><a href="https://git-scm.com/">Git</a></li>
</ul>
<ol start="2">
<li>环境准备好后，安装Hexo <code>npm install -g hexo-cli</code></li>
<li>安装后在指定文件夹创建项目<pre><code class="highlight sh">hexo init &lt;folder&gt;
<span class="built_in">cd</span> &lt;folder&gt;
npm install</code></pre></li>
<li>选择主题</li>
</ol>
<ul>
<li><p>Hexo初始化成功后，然后需要选择一个漂亮的主题，这个推荐直接在官网上找，<a href="https://hexo.io/themes/">主题</a><br><img src="https://img-blog.csdnimg.cn/60988327e65c46ec8becc25b8591c650.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>选中主题后下载到项目themes文件夹</p>
</li>
<li><p>然后修改根目录下的_config.yml文件</p>
</li>
<li><p><code>theme: &#39;主题名,也就是themes文件夹里的名字&#39;</code></p>
</li>
</ul>
<ol start="5">
<li>hexo最常用的有以下几个命令</li>
</ol>
<ul>
<li>启动服务：<code>hexo server</code> 或 <code>hexo s</code></li>
<li>新建文章：<code>hexo new &quot;文章名字&quot;</code></li>
<li>新建静态页面：<code>hexo new page &quot;页面名字&quot;</code></li>
<li>生成public文件夹：<code>hexo generate</code> 或 <code>hexo g</code></li>
<li>清除public文件夹：<code>hexo clean</code></li>
<li>部署：<code>hexo deploy</code> 或 <code>hexo d</code></li>
</ul>
<h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>Github有免费提供搭建静态网站的功能，所以hexo推荐直接放到GitHub Page，按照以下步骤进行部署。  </p>
<ol>
<li>首先新建一个源码repo，建议选择Private，这个用来放hexo项目代码，不对外开放</li>
<li>本地仓库运行以下命令提交代码</li>
</ol>
<ul>
<li><code>git init</code>：git初始化</li>
<li><code>git add .</code>: 将所有代码添加到暂存区</li>
<li><code>git commit -m &quot;first commit&quot;</code>：提交本次commit</li>
<li><code>git remote add origin &#39;远程仓库地址&#39;</code>：添加远程仓库地址</li>
<li><code>git push -u origin main</code>：推送代码</li>
</ul>
<ol start="3">
<li>然后再新建一个仓库，名字为 <code>github名字.github.io</code>，这个仓库用于放部署后的代码</li>
<li>安装Hexo部署插件 <code>npm install hexo-deployer-git</code></li>
<li>修改根目录下的 <code>_config.yml</code><pre><code class="highlight yml"><span class="attr">deploy:</span>
  <span class="attr">type:</span> <span class="string">git</span>
  <span class="attr">repo:</span> <span class="string">部署仓库地址</span>
  <span class="attr">branch:</span> <span class="string">main</span></code></pre></li>
<li>最后执行<code>hexo deploy</code>命令就可以在<code>github名字.github.io</code>看到博客了</li>
</ol>
<h2 id="SSH-github-Actions自动部署"><a href="#SSH-github-Actions自动部署" class="headerlink" title="SSH + github Actions自动部署"></a>SSH + github Actions自动部署</h2><ul>
<li><strong>Github Actions</strong>是github专用的持续集成脚本，用于自动执行工作流程，<strong>SSH</strong>可以通过建立密钥免密登录，这两个结合就能达到自动部署的效果</li>
</ul>
<ol>
<li><p>首先通过ssh-keygen生成密钥，<code>ssh-keygen -t rsa -C &quot;Github 的邮箱地址&quot;</code></p>
</li>
<li><p>然后github配置ssh，配置路径：<code>github -&gt; Settings –&gt; SSH and GPG keys</code><br> <img src="https://img-blog.csdnimg.cn/277cd5e70dad47a5af70a9ce9dc06f5a.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>git仓库添加密钥私有变量，配置路径：<code>repo -&gt; Settings -&gt; Secrets</code>，点击<code>New repository secret</code>，name可以自定义，主要是接下来的deploy.yaml文件需要使用，Secret填写你生成的密钥<br><img src="https://img-blog.csdnimg.cn/10897de98a7f44a2b3171371b71b91ac.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>然后根目录下新建<code>.github/workflows/deploy.yaml</code>，并填写以下内容</p>
<pre><code class="highlight yml"><span class="attr">name:</span> <span class="string">Deploy</span>
<span class="attr">on:</span>
  <span class="attr">push:</span>
    <span class="attr">branches:</span> [<span class="string">你需要自动化部署的分支</span>]
<span class="attr">jobs:</span>
  <span class="attr">build:</span>
    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span>
    <span class="attr">steps:</span>
      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Repository</span> <span class="string">main</span> <span class="string">branch</span>
        <span class="attr">uses:</span> <span class="string">actions/checkout@main</span>
      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span>
        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span>
        <span class="attr">with:</span>
          <span class="attr">node-version:</span> <span class="number">14.</span><span class="string">x</span>
      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span> <span class="string">Dependencies</span>
        <span class="attr">run:</span> <span class="string">|</span>
<span class="string">          npm install hexo-cli -g</span>
<span class="string">          npm install</span>
<span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Deploy</span>
        <span class="attr">env:</span>
          <span class="attr">HEXO_DEPLOY_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.&#x27;你上一步自定义的变量名&#x27;</span> <span class="string">&#125;&#125;</span>
        <span class="attr">run:</span> <span class="string">|</span>
<span class="string">          mkdir -p ~/.ssh/</span>
<span class="string">          echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa </span>
<span class="string">          chmod 600 ~/.ssh/id_rsa</span>
<span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span>
<span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Git</span> <span class="string">Infomation</span>
        <span class="attr">run:</span> <span class="string">|</span>
<span class="string">          git config --global user.name &quot;git名字&quot;</span>
<span class="string">          git config --global user.email &quot;git邮箱&quot;</span>
<span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span>
        <span class="attr">run:</span> <span class="string">|</span>
<span class="string">          hexo clean</span>
<span class="string">          hexo generate </span>
<span class="string">          hexo deploy    </span></code></pre></li>
<li><p>然后把代码push上去的时候，就可以在仓库的<strong>Actions</strong>上看自动工作流程的情况</p>
</li>
</ol>
<h2 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h2><ol>
<li><p>首先在<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google Search Console</a>登录谷歌账号</p>
</li>
<li><p>然后在网址前缀中填写网址，下载验证文件到主题文件夹的source目录<br><img src="https://img-blog.csdnimg.cn/68c9ef2e3f4c42ec8ca29f46f01905d4.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>下载后再重新部署一下，最后点击验证</p>
</li>
</ol>
<h3 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h3><p>站点地图是一种文件，您可以在其中提供与您网站中的网页、视频或其他文件有关的信息，还可以说明这些内容之间的关系。Google 等搜索引擎会读取此文件，以便更高效地抓取您的网站。站点地图会告诉 Google 您认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。</p>
<ol>
<li><p>安装站点地图插件 <code>npm install hexo-generator-sitemap --save</code></p>
</li>
<li><p>在hexo根目录的_config.yml修改以下内容</p>
<pre><code class="highlight yml"><span class="attr">url:</span> <span class="string">博客地址</span>
<span class="attr">sitemap:</span>
 <span class="attr">path:</span> <span class="string">sitemap.xml</span></code></pre></li>
<li><p>然后部署博客，输入<code>博客地址/sitemap.xml</code>能看见以下内容<br><img src="https://img-blog.csdnimg.cn/74745ec1ca3e4d06a06ba512ddb5e3f1.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>最后在<strong>Google Search Console</strong>上的站点地图上点击提交<br><img src="https://img-blog.csdnimg.cn/371a45539f694c08a207367d47d25d88.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<h2 id="Disqus评论"><a href="#Disqus评论" class="headerlink" title="Disqus评论"></a>Disqus评论</h2><p>Hexo可以搭载的评论系统有很多，比如Valine，Waline，Disqus等等，但是按颜值来看还是Disqus</p>
<ol>
<li>首先在<a href="https://disqus.com/">Disqus官网</a>进行注册，然后点击“Get STARTED”，并选择 “I want to install Disqus on my site” 选项</li>
<li>然后在进入表单页按照提示进行填写即可，但是有两个地方需要注意，<code>Website Name</code>这个是你的专属网址的名字，需要记住，还有就是在“Select Plan”记得选“Basic”</li>
<li>最后修改_config.yml中把shortname替换为你在创建时的名字，一般现在的主题都带的有评论模版，如果没有就需要自己添加了，这个不同的主题不太相同，可以看下官方的安装模版进行修改<br><img src="https://img-blog.csdnimg.cn/d1dc79115212411383a8dbd11971aaee.jpeg#pic_center" alt="在这里插入图片描述"></li>
</ol>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3+Vite3 SSR基本搭建</title>
    <url>/2022/08/27/Vue3-Vite3-SSR%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<ul>
<li>首先说明如果是生产使用强烈推荐Nuxt，但是如果想深入服务端渲染的运行原理，可以看本篇，会根据渲染流程搭建一个demo版ssr，源码在最后会贴上</li>
<li>主要技术栈：Vite3 + Vue3 + pinia + VueRouter4 + express</li>
<li>开始搭建之前，先说一下SSR渲染流程</li>
</ul>
<h3 id="SSR渲染流程"><a href="#SSR渲染流程" class="headerlink" title="SSR渲染流程"></a>SSR渲染流程</h3><ul>
<li>首先浏览器向服务器请求，然后服务器根据请求的路由，会匹配相关的路由组件，然后执行组件的自定义服务端生命周期(例：Nuxt的asyncData)或者自定义获取数据的hook，并且把执行后的数据收集起来，统一在window的属性中存储</li>
<li>然后vue的组件会被renderToString渲染成静态HTML字符串，替换掉index.html的提前指定的占位代码。然后index.html改变后的静态字符串发给客户端</li>
<li>客户端拿到后，首先对数据进行初始化，然后进行激活，因为当前html只是静态数据，激活主要做两件事<ul>
<li><ol>
<li>把页面中的DOM元素与虚拟DOM之间建立联系</li>
</ol>
</li>
<li><ol start="2">
<li>为页面中的DOM元素添加事件绑定</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><ul>
<li>首先用vite命令创建项目<code>pnpm create vite vue-ssr --template vue-ts</code><ul>
<li>安装相关依赖：<code>pnpm add express pinia vue-router@4</code></li>
</ul>
</li>
<li>创建三个文件 <code>touch server.js  src/entry-client.ts src/entry-server.js</code><ul>
<li>server.js：服务端启动文件</li>
<li>entry-client.ts：客户端入口，应用挂载元素</li>
<li>entry-server.js：服务端入口，处理服务端逻辑和静态资源</li>
</ul>
</li>
<li>修改<code>package.json</code>运行脚本<pre><code class="highlight js"><span class="string">&quot;scripts&quot;</span>: &#123;
  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;node server&quot;</span>, <span class="comment">// 运行开发环境</span>
&#125;</code></pre></li>
<li>然后需要把应用创建都改为函数的方式进行调用创建，因为在SSR环境下，和纯客户端不一样，服务器只会初始化一次，所以为了防止状态污染，每次请求必须是全新的实例<pre><code class="highlight js"><span class="comment">// src/main.ts</span>
<span class="keyword">import</span> &#123; createSSRApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>
<span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>
<span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>
<span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>

<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> app = <span class="title function_">createSSRApp</span>(<span class="title class_">App</span>)
  <span class="keyword">const</span> router = <span class="title function_">createRouter</span>()
  <span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()
  app.<span class="title function_">use</span>(router)
  app.<span class="title function_">use</span>(pinia)
  <span class="keyword">return</span> &#123; app, router, pinia &#125;
&#125;</code></pre></li>
<li>roter同理<pre><code class="highlight js"><span class="comment">// src/router/index</span>
<span class="keyword">import</span> &#123; createRouter <span class="keyword">as</span> _createRrouter, createMemoryHistory, createWebHistory, <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>

<span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">RouteRecordRaw</span>[] = [
  ...
]

<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRouter</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> <span class="title function_">_createRrouter</span>(&#123;
    <span class="attr">history</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">SSR</span> ? <span class="title function_">createMemoryHistory</span>() : <span class="title function_">createWebHistory</span>(),
    routes,
  &#125;)
&#125;</code></pre></li>
<li>然后修改index.html，增加注释占位和客户端入口文件，在之后的服务端渲染时注入<pre><code class="highlight html"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">head</span>&gt;</span>
    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/vite.svg&quot;</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vite + Vue + TS<span class="tag">&lt;/<span class="name">title</span>&gt;</span>
    <span class="comment">&lt;!-- 静态资源占位 .js .css ... --&gt;</span>
    <span class="comment">&lt;!--preload-links--&gt;</span>
  <span class="tag">&lt;/<span class="name">head</span>&gt;</span>
  <span class="tag">&lt;<span class="name">body</span>&gt;</span>
    <span class="comment">&lt;!-- 应用代码占位 --&gt;</span>
    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="comment">&lt;!--ssr-outlet--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>
    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.ts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
    <span class="comment">&lt;!-- 引用客户端入口文件 --&gt;</span>
    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/entry-client.ts&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span>
<span class="language-xml"><span class="language-handlebars">      // 服务端获取的数据统一挂载到window上</span></span>
<span class="language-xml"><span class="language-handlebars">      window.__INITIAL_STATE__ = &#x27;<span class="comment">&lt;!--pinia-state--&gt;</span>&#x27;</span></span>
<span class="language-xml"><span class="language-handlebars">    </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">body</span>&gt;</span>
<span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre></li>
</ul>
<h3 id="2-服务端启动文件"><a href="#2-服务端启动文件" class="headerlink" title="2. 服务端启动文件"></a>2. 服务端启动文件</h3><ul>
<li>创建项目后，就开始编写服务端启动文件，也就是项目根路径下的server.js文件</li>
<li>这个文件的功能是启动一个node服务，然后根据请求，读取html文件，处理资源后把注释进行替换，最后把html发送给客户端<pre><code class="highlight js"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>
<span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>
<span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>
<span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>

<span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;
<span class="keyword">const</span> __dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>))
<span class="keyword">const</span> <span class="built_in">require</span> = <span class="title function_">createRequire</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);
<span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">p</span>) =&gt; path.<span class="title function_">resolve</span>(__dirname, p);

<span class="keyword">const</span> <span class="title function_">createServer</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;
  <span class="comment">// 创建node服务</span>
  <span class="keyword">const</span> app = <span class="title function_">express</span>()

  <span class="comment">/**</span>
<span class="comment">   * @官方解释</span>
<span class="comment">   * 以中间件模式创建vite应用，这将禁用vite自身的HTML服务逻辑</span>
<span class="comment">   * 并让上级服务器接管</span>
<span class="comment">   */</span>
  <span class="keyword">const</span> vite = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">&#x27;vite&#x27;</span>).<span class="title function_">createServer</span>(&#123;
    <span class="attr">server</span>: &#123;
      <span class="attr">middlewareMode</span>: <span class="literal">true</span>,
    &#125;,
    <span class="attr">appType</span>: <span class="string">&#x27;custom&#x27;</span>
  &#125;);
  app.<span class="title function_">use</span>(vite.<span class="property">middlewares</span>);
  
  app.<span class="title function_">use</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;
    <span class="keyword">const</span> url = req.<span class="property">originalUrl</span>
    <span class="keyword">try</span> &#123;
      <span class="comment">// 读取index.html</span>
      <span class="keyword">let</span> template = fs.<span class="title function_">readFileSync</span>(
        <span class="title function_">resolve</span>(<span class="string">&#x27;index.html&#x27;</span>),
        <span class="string">&#x27;utf-8&#x27;</span>
      )
      <span class="comment">// 应用vite html转换，会注入vite HMR</span>
      template = <span class="keyword">await</span> vite.<span class="title function_">transformIndexHtml</span>(url, template)

      <span class="comment">// 加载服务端入口</span>
      <span class="keyword">const</span> render = (<span class="keyword">await</span> vite.<span class="title function_">ssrLoadModule</span>(<span class="string">&#x27;/src/entry-server.js&#x27;</span>)).<span class="property">render</span>
      <span class="keyword">const</span> [ appHtml, piniaState ] = <span class="keyword">await</span> <span class="title function_">render</span>(url)

      <span class="comment">// 替换处理过后的模版</span>
      <span class="keyword">const</span> html = template
        .<span class="title function_">replace</span>(<span class="string">`&lt;!--ssr-outlet--&gt;`</span>, appHtml)
        .<span class="title function_">replace</span>(<span class="string">`&lt;!--pinia-state--&gt;`</span>, piniaState)
      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">set</span>(&#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;).<span class="title function_">end</span>(html)
    &#125; <span class="keyword">catch</span> (error) &#123;
      vite?.<span class="title function_">ssrFixStacktrace</span>(error)
      <span class="title function_">next</span>(e)
    &#125;
  &#125;)

  <span class="comment">// 监听5100端口</span>
  app.<span class="title function_">listen</span>(<span class="number">5100</span>)
&#125;

<span class="title function_">createServer</span>();</code></pre></li>
</ul>
<h3 id="3-服务端入口文件"><a href="#3-服务端入口文件" class="headerlink" title="3. 服务端入口文件"></a>3. 服务端入口文件</h3><ul>
<li>服务端入口文件主要是调用SSR的renderToString和收集需要发送的资源和数据<pre><code class="highlight js"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&#x27;vue/server-renderer&#x27;</span>
<span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./main&#x27;</span>

<span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">url, manifest</span>) &#123;
  <span class="keyword">const</span> &#123; app, router, pinia &#125; = <span class="title function_">createApp</span>()

  router.<span class="title function_">push</span>(url)
  <span class="keyword">await</span> router.<span class="title function_">isReady</span>()

  <span class="keyword">const</span> ctx = &#123;&#125;
  <span class="keyword">const</span> html = <span class="keyword">await</span> <span class="title function_">renderToString</span>(app, ctx)
  <span class="keyword">return</span> [html, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(pinia.<span class="property">state</span>.<span class="property">value</span>)]
&#125;</code></pre></li>
</ul>
<h3 id="4-客户端入口文件"><a href="#4-客户端入口文件" class="headerlink" title="4. 客户端入口文件"></a>4. 客户端入口文件</h3><ul>
<li>客户端入口文件主要用于挂载节点和初始化数据<pre><code class="highlight js"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./main&#x27;</span>

<span class="keyword">const</span> &#123; app, router, pinia &#125; = <span class="title function_">createApp</span>()

router.<span class="title function_">isReady</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;
  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">__INITIAL_STATE__</span>) &#123;
    pinia.<span class="property">state</span>.<span class="property">value</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">window</span>.<span class="property">__INITIAL_STATE__</span>);
  &#125;

  app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)
&#125;)</code></pre></li>
</ul>
<h3 id="5-组件和页面"><a href="#5-组件和页面" class="headerlink" title="5. 组件和页面"></a>5. 组件和页面</h3><ul>
<li>组件和页面获取数据主要有两种方式，一种是增加一个<code>asyncData</code>选项，然后在enter-server.js的逻辑中增加遍历当前组件的逻辑，统一触发<code>asyncData</code>，但是现在都是用<code>script setup</code>的方式写业务代码，所以有点麻烦，<pre><code class="highlight js">&lt;script&gt;
  <span class="keyword">export</span> defualt &#123;
    <span class="title function_">asyncData</span>(<span class="params"></span>) &#123;
      <span class="comment">// 服务端获取数据逻辑</span>
    &#125;
  &#125;
&lt;/script&gt;

<span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&#x27;ts&#x27;</span>&gt;</span></span>
<span class="language-xml">  ...</span>
<span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></code></pre></li>
<li>另一种就是hook的方式，通过<code>import.meta.env.SSR</code>的方式进行判断</li>
<li>对于数据具体存储方式，大概有三种，一种是存在vuex或者pinia这种全局状态库中，一种是存在context上下文中，还有一种是自定义数据</li>
</ul>
<h3 id="6-生产环境"><a href="#6-生产环境" class="headerlink" title="6. 生产环境"></a>6. 生产环境</h3><h4 id="6-1-pacnakge-json"><a href="#6-1-pacnakge-json" class="headerlink" title="6.1 pacnakge.json"></a>6.1 pacnakge.json</h4><ul>
<li>增加构建脚本<pre><code class="highlight diff">&quot;scripts&quot;: &#123;
  &quot;dev&quot;: &quot;node server&quot;,
<span class="addition">+ &quot;build&quot;: &quot;npm run build:client &amp;&amp; npm run build:server&quot;,</span>
<span class="addition">+  &quot;build:client&quot;: &quot;vite build --ssrManifest --outDir dist/client&quot;,</span>
<span class="addition">+  &quot;build:server&quot;: &quot;vite build --ssr src/entry-server.js --outDir dist/server&quot;,</span>
<span class="addition">+  &quot;serve&quot;: &quot;cross-env NODE_ENV=production node server&quot;</span>
&#125;,</code></pre></li>
</ul>
<h4 id="6-2-服务端运行文件"><a href="#6-2-服务端运行文件" class="headerlink" title="6.2 服务端运行文件"></a>6.2 服务端运行文件</h4><ul>
<li>针对生产环境，需要启动静态资源服务，引用路径需要改为dist目录下</li>
</ul>
<pre><code class="highlight diff">import fs from &#x27;fs&#x27;
import path from &#x27;path&#x27;
import &#123; fileURLToPath &#125; from &#x27;url&#x27;
import express from &#x27;express&#x27;

import &#123; createRequire &#125; from &#x27;module&#x27;;
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const require = createRequire(import.meta.url);
const resolve = (p) =&gt; path.resolve(__dirname, p);

const createServer = async (isProd = process.env.NODE_ENV <span class="comment">=== &#x27;production&#x27;) =&gt; &#123;</span>
  const app = express()

<span class="deletion">-  const vite = await require(&#x27;vite&#x27;).createServer(&#123;</span>
<span class="deletion">-    server: &#123;</span>
<span class="deletion">-      middlewareMode: true,</span>
<span class="deletion">-    &#125;,</span>
<span class="deletion">-    appType: &#x27;custom&#x27;</span>
<span class="deletion">-  &#125;);</span>
<span class="deletion">-  app.use(vite.middlewares);</span>

<span class="addition">+  let vite;</span>
<span class="addition">+  if (isProd) &#123;</span>
<span class="addition">+    app.use(require(&#x27;compression&#x27;)());</span>
<span class="addition">+    app.use(</span>
<span class="addition">+      require(&#x27;serve-static&#x27;)(resolve(&#x27;./dist/client&#x27;), &#123;</span>
<span class="addition">+        index: false</span>
<span class="addition">+      &#125;)</span>
<span class="addition">+    );</span>
<span class="addition">+  &#125; else &#123;</span>
<span class="addition">+    vite = await require(&#x27;vite&#x27;).createServer(&#123;</span>
<span class="addition">+      server: &#123;</span>
<span class="addition">+        middlewareMode: true,</span>
<span class="addition">+      &#125;,</span>
<span class="addition">+      appType: &#x27;custom&#x27;</span>
<span class="addition">+    &#125;);</span>
<span class="addition">+    app.use(vite.middlewares);</span>
<span class="addition">+  &#125;</span>
   // 通过bulid --ssrManifest命令生成的静态资源映射需要在生产环境下引用
<span class="addition">+  const manifest = isProd ? fs.readFileSync(resolve(&#x27;./dist/client/ssr-manifest.json&#x27;), &#x27;utf-8&#x27;) :&#123;&#125;</span>
  
  app.use(&#x27;*&#x27;, async (req, res, next) =&gt; &#123;
    const url = req.originalUrl
    try &#123;
<span class="deletion">-      let template = fs.readFileSync(</span>
<span class="deletion">-        resolve(&#x27;index.html&#x27;),</span>
<span class="deletion">-        &#x27;utf-8&#x27;</span>
<span class="deletion">-      )</span>
<span class="deletion">-      template = await vite.transformIndexHtml(url, template)</span>
<span class="deletion">-      const render = (await vite.ssrLoadModule(&#x27;/src/entry-server.js&#x27;)).render</span>
<span class="deletion">-      const [ appHtml, piniaState ] = await render(url)</span>

<span class="addition">+      let template, render</span>
<span class="addition">+      if (isProd) &#123;</span>
<span class="addition">+        template = fs.readFileSync(resolve(&#x27;./dist/client/index.html&#x27;), &#x27;utf-8&#x27;)</span>
<span class="addition">+        render = (await import(&#x27;./dist/server/entry-server.js&#x27;)).render</span>
<span class="addition">+      &#125; else &#123;</span>
<span class="addition">+        template = fs.readFileSync(</span>
<span class="addition">+          resolve(&#x27;index.html&#x27;),</span>
<span class="addition">+          &#x27;utf-8&#x27;</span>
<span class="addition">+        )</span>
<span class="addition">+        template = await vite.transformIndexHtml(url, template)</span>
<span class="addition">+        render = (await vite.ssrLoadModule(&#x27;/src/entry-server.js&#x27;)).render</span>
<span class="addition">+      &#125;</span>
<span class="addition">+      const [ appHtml, preloadLinks, piniaState ] = await render(url, manifest)</span>
      const html = template
        .replace(`&lt;!--preload-links--&gt;`, preloadLinks)
        .replace(`&lt;!--ssr-outlet--&gt;`, appHtml)
<span class="addition">+        .replace(`&lt;!--pinia-state--&gt;`, piniaState)</span>
      res.status(200).set(&#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;).end(html)
    &#125; catch (error) &#123;
      vite?.ssrFixStacktrace(error)
      next()
    &#125;
  &#125;)

  app.listen(5100)
&#125;

createServer();
</code></pre>

<h4 id="6-3-服务端入口文件"><a href="#6-3-服务端入口文件" class="headerlink" title="6.3 服务端入口文件"></a>6.3 服务端入口文件</h4><ul>
<li>服务端入口文件主要是增加了构建时生成的静态资源映射处理的逻辑<pre><code class="highlight diff">import &#123; basename &#125; from &#x27;path&#x27;
import &#123; renderToString &#125; from &#x27;vue/server-renderer&#x27;
import &#123; createApp &#125; from &#x27;./main&#x27;

export async function render(url, manifest) &#123;
  const &#123; app, router, pinia &#125; = createApp()

  router.push(url)
  await router.isReady()

  const ctx = &#123;&#125;
  const html = await renderToString(app, ctx)
<span class="addition">+  const preloadLinks = renderPreloadLinks(ctx.modules, manifest)</span>
<span class="addition">+  return [html, preloadLinks, JSON.stringify(pinia.state.value)]</span>
&#125;

 function renderPreloadLinks(modules, manifest) &#123;
   let links = &#x27;&#x27;
   const seen = new Set()
   modules.forEach((id) =&gt; &#123;
     const files = manifest[id]
     if (files) &#123;
       files.forEach((file) =&gt; &#123;
         if (!seen.has(file)) &#123;
           seen.add(file)
           const filename = basename(file)
           if (manifest[filename]) &#123;
             for (const depFile of manifest[filename]) &#123;
               links += renderPreloadLink(depFile)
               seen.add(depFile)
             &#125;
           &#125;
           links += renderPreloadLink(file)
         &#125;
       &#125;)
     &#125;
   &#125;)
   return links
 &#125;
 
 function renderPreloadLink(file) &#123;
   if (file.endsWith(&#x27;.js&#x27;)) &#123;
     return `&lt;link rel=&quot;modulepreload&quot; crossorigin href=&quot;$&#123;file&#125;&quot;&gt;`
   &#125; else if (file.endsWith(&#x27;.css&#x27;)) &#123;
     return `&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;file&#125;&quot;&gt;`
   &#125; else if (file.endsWith(&#x27;.woff&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;font&quot; type=&quot;font/woff&quot; crossorigin&gt;`
   &#125; else if (file.endsWith(&#x27;.woff2&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;`
   &#125; else if (file.endsWith(&#x27;.gif&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/gif&quot;&gt;`
   &#125; else if (file.endsWith(&#x27;.jpg&#x27;) || file.endsWith(&#x27;.jpeg&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/jpeg&quot;&gt;`
   &#125; else if (file.endsWith(&#x27;.png&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/png&quot;&gt;`
   &#125; else &#123;
     return &#x27;&#x27;
   &#125;
 &#125;</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><a href="https://github.com/LHRUN/vue-ssr">repo</a></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://vuejs.org/guide/scaling-up/ssr.html">Server-Side Rendering</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vite</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas画板之画笔的多种效果</title>
    <url>/2022/12/17/canvas%E7%94%BB%E6%9D%BF%E4%B9%8B%E7%94%BB%E7%AC%94%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我之前做了一个画板，已经迭代了两个版本，但既然是画板，如果只有一种画笔就显得太单调了，我就搜罗了一下网上的各种方案和自己的一些想法，目前做出了5种样式，包括基础的总共6种，当然有了一些思路后，后续会继续增加。我会在本文详细说明实现思路和具体代码，6种样式包括：</p>
<ol>
<li>基础单色</li>
<li>荧光</li>
<li>多色画笔</li>
<li>喷雾</li>
<li>蜡笔</li>
<li>泡泡</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>预览地址：<a href="https://songlh.top/paint-board/">https://songlh.top/paint-board/</a><br>源码：<a href="https://github.com/LHRUN/paint-board">https://github.com/LHRUN/paint-board</a> 欢迎Star⭐️</p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH59vn.png"></p>
<h2 id="基础单色"><a href="#基础单色" class="headerlink" title="基础单色"></a>基础单色</h2><p>画笔的基础实现，除了点与点之间的连接，还需要注意两点</p>
<ol>
<li>首先是在鼠标移动时计算当前移动的速度，然后根据速度计算线宽，这个是为了实现鼠标移动快，线宽就变窄，移动慢，线宽就恢复正常这个效果</li>
<li>为了避免直线连接点效果不好，我会采用贝塞尔曲线进行连接</li>
</ol>
<p><img src="https://s1.ax1x.com/2022/12/17/zH5YPe.png"></p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 鼠标移动时添加新的坐标</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">position</span></span>
<span class="comment"> */</span>
<span class="title function_">addPosition</span>(<span class="params">position: MousePosition</span>) &#123;
  <span class="variable language_">this</span>.<span class="property">positions</span>.<span class="title function_">push</span>(position)
  <span class="comment">// 处理当前线宽</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;
    <span class="comment">// 计算移动速度</span>
    <span class="keyword">const</span> mouseSpeed = <span class="variable language_">this</span>.<span class="title function_">_computedSpeed</span>(
      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">2</span>],
      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">1</span>]
    )
    <span class="comment">// 计算线宽</span>
    <span class="keyword">const</span> lineWidth = <span class="variable language_">this</span>.<span class="title function_">_computedLineWidth</span>(mouseSpeed)
    <span class="variable language_">this</span>.<span class="property">lineWidths</span>.<span class="title function_">push</span>(lineWidth)
  &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 计算移动速度</span>
<span class="comment"> * <span class="doctag">@param</span> start 起点</span>
<span class="comment"> * <span class="doctag">@param</span> end 终点</span>
<span class="comment"> */</span>
<span class="title function_">_computedSpeed</span>(<span class="params">start: MousePosition, end: MousePosition</span>) &#123;
  <span class="comment">// 获取距离</span>
  <span class="keyword">const</span> moveDistance = <span class="title function_">getDistance</span>(start, end)

  <span class="keyword">const</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()
  <span class="comment">// 获取移动间隔时间   lastMoveTime：最后鼠标移动时间</span>
  <span class="keyword">const</span> moveTime = curTime - <span class="variable language_">this</span>.<span class="property">lastMoveTime</span>
  <span class="comment">// 计算速度</span>
  <span class="keyword">const</span> mouseSpeed = moveDistance / moveTime
  <span class="comment">// 更新最后移动时间</span>
  <span class="variable language_">this</span>.<span class="property">lastMoveTime</span> = curTime
  <span class="keyword">return</span> mouseSpeed
&#125;

<span class="comment">/**</span>
<span class="comment"> * 计算画笔宽度</span>
<span class="comment"> * <span class="doctag">@param</span> speed 鼠标移动速度</span>
<span class="comment"> */</span>
<span class="title function_">_computedLineWidth</span>(<span class="params">speed: number</span>) &#123;
  <span class="keyword">let</span> lineWidth = <span class="number">0</span>
  <span class="keyword">const</span> minWidth = <span class="variable language_">this</span>.<span class="property">minWidth</span>
  <span class="keyword">const</span> maxWidth = <span class="variable language_">this</span>.<span class="property">maxWidth</span>
  <span class="keyword">if</span> (speed &gt;= <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) &#123;
    lineWidth = minWidth
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (speed &lt;= <span class="variable language_">this</span>.<span class="property">minSpeed</span>) &#123;
    lineWidth = maxWidth
  &#125; <span class="keyword">else</span> &#123;
    lineWidth = maxWidth - (speed / <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) * maxWidth
  &#125;

  lineWidth = lineWidth * (<span class="number">1</span> / <span class="number">3</span>) + <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> * (<span class="number">2</span> / <span class="number">3</span>)
  <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> = lineWidth
  <span class="keyword">return</span> lineWidth
&#125;</code></pre>

<p>渲染时就遍历所有坐标</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 自由画笔渲染</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">freeDrawRender</span>(<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeLine</span>
<span class="params"></span>) &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// 现在是只有基础画笔，后续会增加不同的case</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Basic</span>:
      context.<span class="property">strokeStyle</span> = instance.<span class="property">colors</span>[<span class="number">0</span>]
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Basic</span>:
        <span class="title function_">_drawBasic</span>(instance, i, context)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制基础线条</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw 实例</span>
<span class="comment"> * <span class="doctag">@param</span> i 下标</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> cb 一些绘制前的处理，修改一些样式</span>
<span class="comment"> * </span>
<span class="comment"> * 画笔轨迹是借鉴了网上的一些方案，分两种情况</span>
<span class="comment"> * 1. 如果是前两个坐标，就通过lineTo连接即可</span>
<span class="comment"> * 2. 如果是前两个坐标之后的坐标，就采用贝塞尔曲线进行连接，</span>
<span class="comment"> *    比如现在有a, b, c 三个点，到c点时，把ab坐标的中间点作为起点</span>
<span class="comment"> *     bc坐标的中间点作为终点，b点作为控制点进行连接</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">_drawBasic</span>(<span class="params"></span>
<span class="params">  instance: FreeLine,</span>
<span class="params">  i: number,</span>
<span class="params">  context: CanvasRenderingContext2D</span>
<span class="params">  cb?: (</span>
<span class="params">    instance: FreeDraw,</span>
<span class="params">    i: number,</span>
<span class="params">    context: CanvasRenderingContext2D</span>
<span class="params">  ) =&gt; <span class="keyword">void</span></span>
<span class="params"></span>) &#123;
  <span class="keyword">const</span> &#123; positions, lineWidths &#125; = instance
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: centerX, <span class="attr">y</span>: centerY &#125; = positions[i - <span class="number">1</span>]
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: endX, <span class="attr">y</span>: endY &#125; = positions[i]
  context.<span class="title function_">beginPath</span>()
  <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;
    context.<span class="title function_">moveTo</span>(centerX, centerY)
    context.<span class="title function_">lineTo</span>(endX, endY)
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">const</span> &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125; = positions[i - <span class="number">2</span>]
    <span class="keyword">const</span> lastX = (startX + centerX) / <span class="number">2</span>
    <span class="keyword">const</span> lastY = (startY + centerY) / <span class="number">2</span>
    <span class="keyword">const</span> x = (centerX + endX) / <span class="number">2</span>
    <span class="keyword">const</span> y = (centerY + endY) / <span class="number">2</span>
    context.<span class="title function_">moveTo</span>(lastX, lastY)
    context.<span class="title function_">quadraticCurveTo</span>(centerX, centerY, x, y)
  &#125;

  context.<span class="property">lineWidth</span> = lineWidths[i]
  cb?.(instance, i, context)
  context.<span class="title function_">stroke</span>()
&#125;</code></pre>

<h2 id="荧光"><a href="#荧光" class="headerlink" title="荧光"></a>荧光</h2><p>荧光只需在基础样式上增加一个阴影即可</p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH53VK.png"></p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">freeDrawRender</span>(<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeLine</span>
<span class="params"></span>) &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// ...</span>
    <span class="comment">// 荧光 增加阴影效果</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Shadow</span>:
      context.<span class="property">shadowColor</span> = instance.<span class="property">colors</span>[<span class="number">0</span>]
      context.<span class="property">strokeStyle</span> = instance.<span class="property">colors</span>[<span class="number">0</span>]
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="comment">// ...</span>
      <span class="comment">// 荧光</span>
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Shadow</span>:
        <span class="title function_">_drawBasic</span>(instance, i, context, <span class="function">(<span class="params">instance, i, context</span>) =&gt;</span> &#123;
          context.<span class="property">shadowBlur</span> = instance.<span class="property">lineWidths</span>[i]
        &#125;)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;</code></pre>

<h2 id="多色画笔"><a href="#多色画笔" class="headerlink" title="多色画笔"></a>多色画笔</h2><p>多色画笔需要使用<code>context.createPattern</code>，这个api是可以通过canvas创建一个指定的模版，然后可以让这个模版在指定的方向上重复元图像，具体使用可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createPattern">MDN</a></p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH58UO.png"></p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 自由画笔渲染</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw</span>
<span class="comment"> * <span class="doctag">@param</span> material 画笔素材</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">freeDrawRender</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  material: Material</span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// ...</span>
    <span class="comment">// 多色画笔</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">MultiColor</span>:
      context.<span class="property">strokeStyle</span> = <span class="title function_">getMultiColorPattern</span>(instance.<span class="property">colors</span>)
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="comment">// ...</span>
      <span class="comment">// 多色画笔</span>
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">MultiColor</span>:
        <span class="title function_">_drawBasic</span>(instance, i, context)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取多色模版</span>
<span class="comment"> * <span class="doctag">@param</span> colors 多色数组</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">getMultiColorPattern</span> = (<span class="params">colors: string[]</span>) =&gt; &#123;
  <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>)
  <span class="keyword">const</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>) <span class="keyword">as</span> <span class="title class_">CanvasRenderingContext2D</span>
  <span class="keyword">const</span> <span class="variable constant_">COLOR_WIDTH</span> = <span class="number">5</span> <span class="comment">// 每个颜色的宽度</span>

  canvas.<span class="property">width</span> = <span class="variable constant_">COLOR_WIDTH</span> * colors.<span class="property">length</span>
  canvas.<span class="property">height</span> = <span class="number">20</span>
  colors.<span class="title function_">forEach</span>(<span class="function">(<span class="params">color, i</span>) =&gt;</span> &#123;
    context.<span class="property">fillStyle</span> = color
    context.<span class="title function_">fillRect</span>(<span class="variable constant_">COLOR_WIDTH</span> * i, <span class="number">0</span>, <span class="variable constant_">COLOR_WIDTH</span>, <span class="number">20</span>)
  &#125;)
  <span class="keyword">return</span> context.<span class="title function_">createPattern</span>(canvas, <span class="string">&#x27;repeat&#x27;</span>) <span class="keyword">as</span> <span class="title class_">CanvasPattern</span>
&#125;</code></pre>

<h2 id="喷雾"><a href="#喷雾" class="headerlink" title="喷雾"></a>喷雾</h2><p>喷雾是一种类似雪花的效果，在鼠标移动路径上随机绘制，但是最初我在写的时候发现，如果对每个点都进行随机雪花点记录然后缓存下来，内存占用过多，我就尝试了提前生成5套不同的数据，按顺序展示，也能达到随机的效果</p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH5N2d.png"></p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">freeDrawRender</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  material: Material</span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// ...</span>
    <span class="comment">// 喷雾</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Spray</span>:
      context.<span class="property">fillStyle</span> = instance.<span class="property">colors</span>[<span class="number">0</span>]
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="comment">// ...</span>
      <span class="comment">// 喷雾</span>
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Spray</span>:
        <span class="title function_">_drawSpray</span>(instance, i, context)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制喷雾</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw 实例</span>
<span class="comment"> * <span class="doctag">@param</span> i 下标</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">_drawSpray</span> = (<span class="params"></span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  i: number,</span>
<span class="params">  context: CanvasRenderingContext2D</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; x, y &#125; = instance.<span class="property">positions</span>[i]
  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;
    <span class="comment">/**</span>
<span class="comment">     * sprayPoint 是我提前生成的5套随机喷雾数据，按顺序展示</span>
<span class="comment">     * &#123;</span>
<span class="comment">     *    angle 弧度</span>
<span class="comment">     *    radius 半径</span>
<span class="comment">     *    alpha 透明度</span>
<span class="comment">     * &#125;</span>
<span class="comment">     */</span>
    <span class="keyword">const</span> &#123; angle, radius, alpha &#125; = sprayPoint[i % <span class="number">5</span>][j]
    context.<span class="property">globalAlpha</span> = alpha
    <span class="keyword">const</span> distanceX = radius * <span class="title class_">Math</span>.<span class="title function_">cos</span>(angle)
    <span class="keyword">const</span> distanceY = radius * <span class="title class_">Math</span>.<span class="title function_">sin</span>(angle)
    <span class="comment">// 根据宽度限制喷雾宽度，因为喷雾太细了不好看，我就统一放大一倍</span>
    <span class="keyword">if</span> (
      distanceX &lt; instance.<span class="property">lineWidths</span>[i] * <span class="number">2</span> &amp;&amp;
      distanceY &lt; instance.<span class="property">lineWidths</span>[i] * <span class="number">2</span> &amp;&amp;
      distanceX &gt; -instance.<span class="property">lineWidths</span>[i] * <span class="number">2</span> &amp;&amp;
      distanceY &gt; -instance.<span class="property">lineWidths</span>[i] * <span class="number">2</span>
    ) &#123;
      context.<span class="title function_">fillRect</span>(x + distanceX, y + distanceY, <span class="number">2</span>, <span class="number">2</span>)
    &#125;
  &#125;
&#125;</code></pre>

<h2 id="蜡笔"><a href="#蜡笔" class="headerlink" title="蜡笔"></a>蜡笔</h2><p>蜡笔效果也是使用了<code>context.createPattern</code>，首先我是以当前画笔颜色为底色，然后通过在网上找的一张蜡笔材质的透明图覆盖在上面，就可以实现蜡笔的效果</p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH5G5D.png"></p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 自由画笔渲染</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw</span>
<span class="comment"> * <span class="doctag">@param</span> material 画笔素材</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">freeDrawRender</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  material: Material</span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// ...</span>
    <span class="comment">// 蜡笔</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Crayon</span>:
      context.<span class="property">strokeStyle</span> = <span class="title function_">getCrayonPattern</span>(
        instance.<span class="property">colors</span>[<span class="number">0</span>],
        material.<span class="property">crayon</span>
      )
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="comment">// ...</span>
      <span class="comment">// 蜡笔</span>
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Crayon</span>:
        <span class="title function_">_drawBasic</span>(instance, i, context)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取蜡笔模版</span>
<span class="comment"> * <span class="doctag">@param</span> color 蜡笔底色</span>
<span class="comment"> * <span class="doctag">@param</span> crayon 蜡笔素材</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">getCrayonPattern</span> = (<span class="params">color: string, crayon: Material[<span class="string">&#x27;crayon&#x27;</span>]</span>) =&gt; &#123;
  <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>)
  <span class="keyword">const</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>) <span class="keyword">as</span> <span class="title class_">CanvasRenderingContext2D</span>
  canvas.<span class="property">width</span> = <span class="number">100</span>
  canvas.<span class="property">height</span> = <span class="number">100</span>
  context.<span class="property">fillStyle</span> = color
  context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)
  <span class="keyword">if</span> (crayon) &#123;
    context.<span class="title function_">drawImage</span>(crayon, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)
  &#125;
  <span class="keyword">return</span> context.<span class="title function_">createPattern</span>(canvas, <span class="string">&#x27;repeat&#x27;</span>) <span class="keyword">as</span> <span class="title class_">CanvasPattern</span>
&#125;</code></pre>

<h2 id="泡泡"><a href="#泡泡" class="headerlink" title="泡泡"></a>泡泡</h2><ol>
<li>鼠标移动时记录泡泡的半径和透明度</li>
<li>渲染时通过<code>context.arc</code>进行画圆绘制</li>
</ol>
<p><img src="https://s1.ax1x.com/2022/12/17/zH5t8H.png"></p>
<pre><code class="highlight js"><span class="title function_">addPosition</span>(<span class="params">position: MousePosition</span>) &#123;
  <span class="comment">// ...</span>
  <span class="comment">// 记录泡泡半径和透明度</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">style</span> === <span class="title class_">FreeDrawStyle</span>.<span class="property">Bubble</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">bubbles</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">bubbles</span>.<span class="title function_">push</span>(&#123;
      <span class="comment">// getRandomInt 获取范围内随机整数</span>
      <span class="attr">radius</span>: <span class="title function_">getRandomInt</span>(<span class="variable language_">this</span>.<span class="property">minWidth</span> * <span class="number">2</span>, <span class="variable language_">this</span>.<span class="property">maxWidth</span> * <span class="number">2</span>),
      <span class="comment">// 透明度</span>
      <span class="attr">opacity</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>()
    &#125;)
  &#125;
  <span class="comment">// ...</span>
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制泡泡</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw 实例</span>
<span class="comment"> * <span class="doctag">@param</span> i 下标</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">_drawBubble</span> = (<span class="params"></span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  i: number,</span>
<span class="params">  context: CanvasRenderingContext2D</span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">beginPath</span>()
  <span class="keyword">if</span> (instance.<span class="property">bubbles</span>) &#123;
    <span class="keyword">const</span> &#123; x, y &#125; = instance.<span class="property">positions</span>[i]
    context.<span class="property">globalAlpha</span> = instance.<span class="property">bubbles</span>[i].<span class="property">opacity</span>
    context.<span class="title function_">arc</span>(x, y, instance.<span class="property">bubbles</span>[i].<span class="property">radius</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">false</span>)
    context.<span class="title function_">fill</span>()
  &#125;
&#125;</code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果有发现问题或者有好的方案，欢迎讨论👻</p>
<p>画板系列文章：</p>
<ul>
<li><a href="https://songlh.top/2022/09/21/%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%94%BB%E6%9D%BF/">基于canvas实现的多功能画板</a></li>
<li><a href="https://songlh.top/2022/12/05/canvas%E7%94%BB%E6%9D%BF%E4%B9%8B%E7%BB%98%E7%94%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%A1%86%E9%80%89/">canvas画板之绘画元素的框选</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://perfectionkills.com/exploring-canvas-drawing-techniques/">Exploring canvas drawing techniques</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3模版编译原理</title>
    <url>/2022/08/31/Vue3%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="模版编译流程"><a href="#模版编译流程" class="headerlink" title="模版编译流程"></a>模版编译流程</h2><p>Vue3模版编译就是把template字符串编译成渲染函数</p>
<pre><code class="highlight js"><span class="comment">// template</span>
&lt;div&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;LH_R&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&lt;/div&gt;

<span class="comment">// render</span>
<span class="keyword">import</span> &#123; toDisplayString <span class="keyword">as</span> _toDisplayString, createElementVNode <span class="keyword">as</span> _createElementVNode, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>

<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;
  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [
    <span class="title function_">_createElementVNode</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">LH_R</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)
  ]))
&#125;</code></pre>

<p>我会按照编译流程分3步分析</p>
<ol>
<li><strong>parse</strong>：将模版字符串转换成模版AST</li>
<li><strong>transform</strong>：将模版AST转换为用于描述渲染函数的AST</li>
<li><strong>generate</strong>：根据AST生成渲染函数<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">baseCompile</span>(<span class="params"></span>
<span class="params">  template: <span class="built_in">string</span> | RootNode,</span>
<span class="params">  options: CompilerOptions = &#123;&#125;</span>
<span class="params"></span>): <span class="title class_">CodegenResult</span> &#123;
  <span class="comment">// ...</span>
  <span class="keyword">const</span> ast = <span class="title function_">isString</span>(template) ? <span class="title function_">baseParse</span>(template, options) : template

  <span class="keyword">const</span> [nodeTransforms, directiveTransforms] = <span class="title function_">getBaseTransformPreset</span>(
    prefixIdentifiers
  )
  <span class="title function_">transform</span>(
    ast,
    <span class="title function_">extend</span>(&#123;&#125;, options, &#123;
      prefixIdentifiers,
      <span class="attr">nodeTransforms</span>: [
        ...nodeTransforms,
        ...(options.<span class="property">nodeTransforms</span> || []) <span class="comment">// user transforms</span>
      ],
      <span class="attr">directiveTransforms</span>: <span class="title function_">extend</span>(
        &#123;&#125;,
        directiveTransforms,
        options.<span class="property">directiveTransforms</span> || &#123;&#125; <span class="comment">// user transforms</span>
      )
    &#125;)
  )

  <span class="keyword">return</span> <span class="title function_">generate</span>(
    ast,
    <span class="title function_">extend</span>(&#123;&#125;, options, &#123;
      prefixIdentifiers
    &#125;)
  )
&#125;</code></pre></li>
</ol>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><ul>
<li><p>parse对模版字符串进行遍历，然后循环判断开始标签和结束标签把字符串分割成一个个<strong>token</strong>，存在一个token列表，然后扫描token列表并维护一个开始标签栈，每当扫描一个开始标签节点，就将其压入栈顶，栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有Token扫描完成后，即可构建成一颗树形AST</p>
</li>
<li><p>以下是简化版<strong>parseChildren</strong>源码，是parse的主入口</p>
<pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">parseChildren</span>(<span class="params"></span>
<span class="params">  context: ParserContext,</span>
<span class="params">  mode: TextModes,</span>
<span class="params">  ancestors: ElementNode[] <span class="comment">// 节点栈结构，用于维护节点嵌套关系</span></span>
<span class="params"></span>): <span class="title class_">TemplateChildNode</span>[] &#123;
  <span class="comment">// 获取父节点</span>
  <span class="keyword">const</span> parent = <span class="title function_">last</span>(ancestors)
  <span class="keyword">const</span> ns = parent ? parent.<span class="property">ns</span> : <span class="title class_">Namespaces</span>.<span class="property">HTML</span>
  <span class="keyword">const</span> <span class="attr">nodes</span>: <span class="title class_">TemplateChildNode</span>[] = [] <span class="comment">// 存储解析出来的AST子节点</span>

  <span class="comment">// 遇到闭合标签结束解析</span>
  <span class="keyword">while</span> (!<span class="title function_">isEnd</span>(context, mode, ancestors)) &#123;
    <span class="comment">// 切割处理的模版字符串</span>
    <span class="keyword">const</span> s = context.<span class="property">source</span>
    <span class="keyword">let</span> <span class="attr">node</span>: <span class="title class_">TemplateChildNode</span> | <span class="title class_">TemplateChildNode</span>[] | <span class="literal">undefined</span> = <span class="literal">undefined</span>

    <span class="keyword">if</span> (mode === <span class="title class_">TextModes</span>.<span class="property">DATA</span> || mode === <span class="title class_">TextModes</span>.<span class="property">RCDATA</span>) &#123;
      <span class="keyword">if</span> (!context.<span class="property">inVPre</span> &amp;&amp; <span class="title function_">startsWith</span>(s, context.<span class="property">options</span>.<span class="property">delimiters</span>[<span class="number">0</span>])) &#123;
        <span class="comment">// 解析插值表达式&#123;&#123;&#125;&#125;</span>
        node = parseInterpolation(context, mode)
      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode === <span class="title class_">TextModes</span>.<span class="property">DATA</span> &amp;&amp; s[<span class="number">0</span>] === <span class="string">&#x27;&lt;&#x27;</span>) &#123;
        <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;!&#x27;</span>) &#123;
          <span class="comment">// 解析注释节点和文档声明...</span>
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;/&#x27;</span>) &#123;
          <span class="keyword">if</span> (s[<span class="number">2</span>] === <span class="string">&#x27;&gt;&#x27;</span>) &#123;
            <span class="comment">// 针对自闭合标签，前进三个字符</span>
            <span class="title function_">advanceBy</span>(context, <span class="number">3</span>)
            <span class="keyword">continue</span>
          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(s[<span class="number">2</span>])) &#123;
            <span class="comment">// 解析结束标签</span>
            <span class="title function_">parseTag</span>(context, <span class="title class_">TagType</span>.<span class="property">End</span>, parent)
            <span class="keyword">continue</span>
          &#125; <span class="keyword">else</span> &#123;
            <span class="comment">// 如果不符合上述情况，就作为伪注释解析</span>
            node = <span class="title function_">parseBogusComment</span>(context)
          &#125;
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(s[<span class="number">1</span>])) &#123;
          <span class="comment">// 解析html开始标签，获得解析到的AST节点</span>
          node = <span class="title function_">parseElement</span>(context, ancestors)
        &#125;
      &#125;
    &#125;
    <span class="keyword">if</span> (!node) &#123;
      <span class="comment">// 普通文本节点</span>
      node = <span class="title function_">parseText</span>(context, mode)
    &#125;

    <span class="comment">// 如果节点是数组，就遍历添加到nodes中</span>
    <span class="keyword">if</span> (<span class="title function_">isArray</span>(node)) &#123;
      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">length</span>; i++) &#123;
        <span class="title function_">pushNode</span>(nodes, node[i])
      &#125;
    &#125; <span class="keyword">else</span> &#123;
      <span class="title function_">pushNode</span>(nodes, node)
    &#125;
  &#125;
  <span class="keyword">return</span> nodes
&#125;</code></pre>
</li>
<li><p>就拿<code>&lt;div&gt;&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;</code>流程举例</p>
</li>
</ul>
<ol>
<li>div开始标签入栈，context.source &#x3D; <code>&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;</code>，ancestors &#x3D; <code>[div]</code></li>
<li>p开始标签入栈，context.source &#x3D; <code>LH_R&lt;/p&gt;&lt;/div&gt;</code>，ancestors &#x3D; <code>[div, p]</code></li>
<li>解析文本<code>LH_R</code></li>
<li>解析p结束标签，p标签出栈</li>
<li>解析div结束标签，div标签出栈</li>
<li>栈空，模版解析完毕</li>
</ol>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul>
<li>transform采用深度优先的方式对AST进行遍历，在遍历过程中，对节点的操作与转换采用插件化架构，都封装为独立的函数，然后转换函数通过<code>context.nodeTransforms</code>来注册</li>
<li>转换过程是优先转换子节点，因为有的父节点的转换依赖子节点</li>
<li>以下是AST遍历<code>traverseNode</code>核心源码<pre><code class="highlight ts"><span class="comment">/* </span>
<span class="comment">  遍历AST节点树，通过node转换器对当前节点进行node转换</span>
<span class="comment">  子节点全部遍历完成后执行对应指令的onExit回调退出转换</span>
<span class="comment">*/</span>
<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">traverseNode</span>(<span class="params"></span>
<span class="params">  node: RootNode | TemplateChildNode,</span>
<span class="params">  context: TransformContext</span>
<span class="params"></span>) &#123;
  <span class="comment">// 记录当前正在遍历的节点</span>
  context.<span class="property">currentNode</span> = node

  <span class="comment">/* </span>
<span class="comment">    nodeTransforms：transformElement、transformExpression、transformText...</span>
<span class="comment">    transformElement：负责整个节点层面的转换</span>
<span class="comment">    transformExpression：负责节点中表达式的转化</span>
<span class="comment">    transformText：负责节点中文本的转换</span>
<span class="comment">  */</span>
  <span class="keyword">const</span> &#123; nodeTransforms &#125; = context
  <span class="keyword">const</span> exitFns = []
  <span class="comment">// 依次调用转换工具</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodeTransforms.<span class="property">length</span>; i++) &#123;
    <span class="comment">/* </span>
<span class="comment">      转换器只负责生成onExit回调，onExit函数才是执行转换主逻辑的地方，为什么要推到栈中先不执行呢？</span>
<span class="comment">      因为要等到子节点都转换完成挂载gencodeNode后，也就是深度遍历完成后</span>
<span class="comment">      再执行当前节点栈中的onExit，这样保证了子节点的表达式全部生成完毕</span>
<span class="comment">    */</span>
    <span class="keyword">const</span> onExit = nodeTransforms[i](node, context)
    <span class="keyword">if</span> (onExit) &#123;
      <span class="keyword">if</span> (<span class="title function_">isArray</span>(onExit)) &#123;
        <span class="comment">// v-if、v-for为结构化指令，其onExit是数组形式</span>
        exitFns.<span class="title function_">push</span>(...onExit)
      &#125; <span class="keyword">else</span> &#123;
        exitFns.<span class="title function_">push</span>(onExit)
      &#125;
    &#125;
    <span class="keyword">if</span> (!context.<span class="property">currentNode</span>) &#123;
      <span class="comment">// node was removed 节点被移除</span>
      <span class="keyword">return</span>
    &#125; <span class="keyword">else</span> &#123;
      <span class="comment">// node may have been replaced</span>
      <span class="comment">// 因为在转换的过程中节点可能被替换，恢复到之前的节点</span>
      node = context.<span class="property">currentNode</span>
    &#125;
  &#125;

  <span class="keyword">switch</span> (node.<span class="property">type</span>) &#123;
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">COMMENT</span>:
      <span class="keyword">if</span> (!context.<span class="property">ssr</span>) &#123;
        <span class="comment">// inject import for the Comment symbol, which is needed for creating</span>
        <span class="comment">// comment nodes with `createVNode`</span>
        <span class="comment">// 需要导入createComment辅助函数</span>
        context.<span class="title function_">helper</span>(<span class="variable constant_">CREATE_COMMENT</span>)
      &#125;
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">INTERPOLATION</span>:
      <span class="comment">// no need to traverse, but we need to inject toString helper</span>
      <span class="keyword">if</span> (!context.<span class="property">ssr</span>) &#123;
        context.<span class="title function_">helper</span>(<span class="variable constant_">TO_DISPLAY_STRING</span>)
      &#125;
      <span class="keyword">break</span>

    <span class="comment">// for container types, further traverse downwards</span>
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">IF</span>:
      <span class="comment">// 对v-if生成的节点束进行遍历</span>
      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">branches</span>.<span class="property">length</span>; i++) &#123;
        <span class="title function_">traverseNode</span>(node.<span class="property">branches</span>[i], context)
      &#125;
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">IF_BRANCH</span>:
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">FOR</span>:
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">ELEMENT</span>:
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">ROOT</span>:
      <span class="comment">// 遍历子节点</span>
      <span class="title function_">traverseChildren</span>(node, context)
      <span class="keyword">break</span>
  &#125;
  <span class="comment">// 当前节点树遍历完成，依次执行栈中的指令退出回调onExit</span>
  context.<span class="property">currentNode</span> = node
  <span class="keyword">let</span> i = exitFns.<span class="property">length</span>
  <span class="keyword">while</span> (i--) &#123;
    exitFns[i]()
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>generate</code>生成代码大致分为3步</p>
<ol>
<li>创建代码生成上下文，因为该上下文对象是用于维护代码生成过程中程序的运行状态，如：</li>
</ol>
<ul>
<li><code>code</code>：最终生成的渲染函数</li>
<li><code>push</code>：拼接代码</li>
<li><code>indent</code>：代码缩进</li>
<li><code>deindent</code>：减少代码缩进</li>
<li>…</li>
</ul>
<ol start="2">
<li>生成渲染函数的前置预设部分<ul>
<li>module模式下：<code>genModulePreamble()</code></li>
<li>function模式下：<code>genFunctionPreamble</code></li>
<li>还有一些函数名，参数，作用域…</li>
</ul>
</li>
<li>生成渲染函数<ul>
<li>通过调用<code>genNode</code>，然后在<code>genNode</code>内部通过switch语句来匹配不同类型的节点，并调用对应的生成器函数</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000023594560">Vue3 模板编译原理</a></li>
<li>《Vue.js设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>pnpm的node_modules结构设计</title>
    <url>/2022/08/24/pnpm%E7%9A%84node-modules%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="pnpm的node-modules结构设计"><a href="#pnpm的node-modules结构设计" class="headerlink" title="pnpm的node_modules结构设计"></a>pnpm的node_modules结构设计</h2><p>分析pnpm之前，先说一下npm现在的一些问题</p>
<h3 id="npm的问题"><a href="#npm的问题" class="headerlink" title="npm的问题"></a>npm的问题</h3><ul>
<li><p>平时我们使用<code>npm install</code>命令后，node_modules就会呈现以下类似内容<br><img src="https://img-blog.csdnimg.cn/7396b28d86f84a21b15b4ef6026ddd45.png#pic_center" alt="npm_node_modules"></p>
</li>
<li><p>之所以出现这种扁平的结构，最初时初衷是好的，为了更好的利用资源，把每个依赖全部放到顶层，这样就不会造成每个依赖嵌套过深，导致很多重复依赖文件</p>
</li>
<li><p>但是随着这种文件结构逐步使用后，就会暴露出来两个问题</p>
<ul>
<li><strong>幽灵依赖</strong></li>
<li><strong>版本冲突</strong></li>
</ul>
</li>
<li><p>幽灵依赖就是你在引用npm包时，你会发现一些没有在<code>package.json</code>中出现的包也能引用，这个就是幽灵依赖，这是因为你在install下载npm包时，npm包也有它的依赖会下载，但是下载的依赖也会存在node_modules同一层级下，这样就会导致可以直接引用</p>
</li>
<li><p>版本冲突是因为不同的依赖可能依赖的包版本也不同，但是node_modules的同一层级只能存在一个包的一个版本号，如果有不同的版本号就只能存在依赖包的node_modules中，这样就会导致出现重复资源</p>
<pre><code class="highlight js">├── package-A @<span class="number">1.0</span>
|── package-B @<span class="number">1.0</span>
├── package-C @<span class="number">1.0</span>
│   └── package-A @<span class="number">2.0</span>
│   └── package-B @<span class="number">2.0</span>
├── package-D @<span class="number">1.0</span>
│   └── package-A @<span class="number">2.0</span>
│   └── package-B @<span class="number">2.0</span></code></pre></li>
</ul>
<h3 id="pnpm的出现"><a href="#pnpm的出现" class="headerlink" title="pnpm的出现"></a>pnpm的出现</h3><ul>
<li><p>在所有前端苦npm久已时，pnpm出现了，并且在pnpm官网的简介上就简单说明了它的构造：<code>store + link</code><br><img src="https://img-blog.csdnimg.cn/20ef6cd68a0440c9841ea1450297c17a.jpeg#pic_center" alt="pnpm_node_modules"></p>
<ul>
<li>store就是依赖的实际存储位置，Mac&#x2F;linux在<code>&#123;home dir&#125;&gt;/.pnpm-store/v3</code>，windows在<code>当前盘/.pnpm-store/v3</code>。这样就会有个好处，你在多个项目使用的是同一个依赖时，就不用重复下载，这样就极大的减少存储空间</li>
<li>link是指符号链接(<code>SymbolicLink</code>)和硬链接(<code>HardLink</code>)<ul>
<li>SymbolicLink是一种特殊的文件，包含一条以绝对路径或者相对路径的形式指向其他文件或者目录的引用，它的存在不依赖于目标文件，如果目标文件被删除或者移动，指向目标文件的符号链接依然存在，但是它们会指向一个不复存在的文件</li>
<li>相比于SymbolicLink，HardLink不是引用文件，而是引用<strong>inode</strong>，inode是文件系统的一种数据结构，用于描述文件系统对象。所以你即使更改目标文件的内容或位置，HardLink仍然指向目标文件，因为inode指向该文件</li>
</ul>
</li>
</ul>
</li>
<li><p>然后拿react举例，当<code>pnpm add react</code>后，在node_modules终端输入<code>tree -a -L 3</code>会得到以下node_modules结构</p>
<pre><code class="highlight js">.
├── .<span class="property">modules</span>.<span class="property">yaml</span>
├── .<span class="property">pnpm</span>
│   ├── js-tokens@<span class="number">4.0</span><span class="number">.0</span>
│   │   └── node_modules
│   ├── lock.<span class="property">yaml</span>
│   ├── loose-envify@<span class="number">1.4</span><span class="number">.0</span>
│   │   └── node_modules
│   ├── node_modules
│   │   ├── .<span class="property">bin</span>
│   │   ├── js-tokens -&gt; ../js-tokens@<span class="number">4.0</span><span class="number">.0</span>/node_modules/js-tokens
│   │   └── loose-envify -&gt; ../loose-envify@<span class="number">1.4</span><span class="number">.0</span>/node_modules/loose-envify
│   └── react@<span class="number">18.2</span><span class="number">.0</span>
│       └── node_modules
└── react -&gt; .<span class="property">pnpm</span>/react@<span class="number">18.2</span><span class="number">.0</span>/node_modules/react</code></pre></li>
<li><p>node_modules下除了.pnpm外只有一个react，这个react只是一个SymbolicLink，当node.js解析时，会找到react的真实位置<code>node_modules/.pnpm/react@18.2.0/node_modules/react</code></p>
</li>
<li><p>.pnpm就是将所有依赖放在同一层文件夹中，每个包都可以通过<code>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</code>这种路径找到，然后通过<code>hand link</code>的方式在store中引用依赖文件</p>
</li>
<li><p>通过这种文件结构，pnpm就解决了npm的两个问题，首先node_modules下不会有你未在package.json中声明的依赖，这样就不会有幽灵依赖的问题。然后.pnpm下会有name+version的方式链接到store中，这样就不会出现因为版本冲突造成资源重复的问题</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.pnpm.cn/blog/2020/05/27/flat-node-modules-is-not-the-only-way">Flat node_modules is not the only way</a></li>
<li><a href="https://www.pnpm.cn/symlinked-node-modules-structure">Symlinked node_modules structure</a></li>
<li><a href="https://juejin.cn/post/7043998041786810398">One For All：基于pnpm + lerna + typescript的最佳项目实践 - 理论篇</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas画板之绘画元素的框选</title>
    <url>/2022/12/05/canvas%E7%94%BB%E6%9D%BF%E4%B9%8B%E7%BB%98%E7%94%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%A1%86%E9%80%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我大概在两个月之前做了一个基于canvas的画板，<a href="https://songlh.top/2022/09/21/%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%94%BB%E6%9D%BF/">基于canvas实现的多功能画板</a>，然后最近不是太忙，就利用下班的时间又迭代了一个版本，增加了以下内容</p>
<ol>
<li>在选择模式下可以点击元素进行框选，并按住手柄进行缩放或者移动，点击Backspace键可以删除选择元素</li>
<li>双击画板输入文字绘制在指定位置</li>
</ol>
<p>本篇我就详细介绍下框选元素的实现思路和具体代码，效果如下</p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>预览地址：<a href="https://songlh.top/paint-board/">https://songlh.top/paint-board/</a><br>repo：<a href="https://github.com/LHRUN/paint-board">https://github.com/LHRUN/paint-board</a> 欢迎Star⭐️ </p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bd83319aae4af5aeaad2e83a73580c~tplv-k3u1fbpfcp-watermark.image"></p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li>首先需要框选的元素必须在初始化时和更新时记录矩形属性，比如宽高、矩形坐标，这是实现框选的基础</li>
<li>鼠标在移动时需要根据当前坐标判断悬浮在哪个元素上方，这样才能在点击时进行处理，并且鼠标移动时需要有光标的改变</li>
<li>在有框选元素的情况下，渲染时在最后根据框选元素的矩形属性渲染框选效果</li>
<li>在有框选元素的情况下，拖拽时根据拖拽的位置来判断是移动还是改变大小</li>
<li>元素改变大小有两种情况，保持比例(文字)的缩放和不保持比例(画笔)的缩放</li>
</ol>
<h2 id="记录矩形属性"><a href="#记录矩形属性" class="headerlink" title="记录矩形属性"></a>记录矩形属性</h2><p>因为画笔随着绘画一直在增加新的坐标点，所以我在矩形属性外另记录了最小和最大的xy坐标用于计算宽高</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 根据新坐标点，更新矩形属性</span>
<span class="comment"> * <span class="doctag">@param</span> instance 画笔元素</span>
<span class="comment"> * <span class="doctag">@param</span> position 坐标点</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">updateRect</span> = (<span class="params">instance: FreeDraw, position: MousePosition</span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; x, y &#125; = position
  <span class="keyword">let</span> &#123; minX, maxX, minY, maxY &#125; = instance.<span class="property">rect</span>
  <span class="keyword">if</span> (x &lt; minX) &#123;
    minX = x
  &#125;
  <span class="keyword">if</span> (x &gt; maxX) &#123;
    maxX = x
  &#125;
  <span class="keyword">if</span> (y &lt; minY) &#123;
    minY = y
  &#125;
  <span class="keyword">if</span> (y &gt; maxY) &#123;
    maxY = y
  &#125;
  <span class="keyword">const</span> rect = &#123;
    minX,
    maxX,
    minY,
    maxY,
    <span class="attr">x</span>: minX,
    <span class="attr">y</span>: minY,
    <span class="attr">width</span>: maxX - minX,
    <span class="attr">height</span>: maxY - minY
  &#125;
  instance.<span class="property">rect</span> = rect
  <span class="keyword">return</span> rect
&#125;</code></pre>

<h2 id="计算鼠标移动坐标"><a href="#计算鼠标移动坐标" class="headerlink" title="计算鼠标移动坐标"></a>计算鼠标移动坐标</h2><ul>
<li>随着鼠标移动，我们需要改变光标让使用者感知到已经移动到元素上方，所以就需要计算鼠标坐标是否已经和绘画路径临近到一定距离</li>
<li>绘画路径是由一个个的坐标点组成，我们可以把每个坐标点和上一个坐标点连成一个线段，然后在满足以下任何一种情况就可以认为是悬浮在元素上方了<ul>
<li>鼠标坐标距离线段起点小于10像素</li>
<li>鼠标坐标距离线段终点小于10像素</li>
<li>鼠标坐标距离线段小于10像素并且x和y坐标在线段的两端点范围内</li>
<li><img src="https://s1.ax1x.com/2022/12/05/zy7D6s.png"><pre><code class="highlight js"><span class="comment">// 遍历画笔元素所有坐标点</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; positions.<span class="property">length</span>; i++) &#123;
  <span class="comment">// 距离起点距离</span>
  <span class="keyword">const</span> startDistance = <span class="title function_">getDistance</span>(movePos, positions[i - <span class="number">1</span>])
  <span class="comment">// 距离终点距离</span>
  <span class="keyword">const</span> endDistance = <span class="title function_">getDistance</span>(movePos, positions[i])
  <span class="comment">// 距离线段距离</span>
  <span class="keyword">const</span> lineDistance = <span class="title function_">getPositionToLineDistance</span>(
    movePos,
    positions[i - <span class="number">1</span>],
    positions[i]
  )
  <span class="keyword">const</span> rangeX =
    <span class="title class_">Math</span>.<span class="title function_">max</span>(positions[i - <span class="number">1</span>].<span class="property">x</span>, positions[i].<span class="property">x</span>) &gt;= movePos.<span class="property">x</span> &amp;&amp;
    movePos.<span class="property">x</span> &gt;= <span class="title class_">Math</span>.<span class="title function_">min</span>(positions[i - <span class="number">1</span>].<span class="property">x</span>, positions[i].<span class="property">x</span>)
  <span class="keyword">const</span> rangeY =
    <span class="title class_">Math</span>.<span class="title function_">max</span>(positions[i - <span class="number">1</span>].<span class="property">y</span>, positions[i].<span class="property">y</span>) &gt;= movePos.<span class="property">y</span> &amp;&amp;
    movePos.<span class="property">y</span> &gt;= <span class="title class_">Math</span>.<span class="title function_">min</span>(positions[i - <span class="number">1</span>].<span class="property">y</span>, positions[i].<span class="property">y</span>)

  <span class="comment">// 满足三种情况其中一种就可以记录下画笔元素</span>
  <span class="keyword">if</span> (
    startDistance &lt; <span class="number">10</span> ||
    endDistance &lt; <span class="number">10</span> ||
    (lineDistance &lt; <span class="number">10</span> &amp;&amp; rangeX &amp;&amp; rangeY)
  ) &#123;
    <span class="variable language_">this</span>.<span class="property">mouseHoverElementIndex</span> = eleIndex
  &#125;
&#125;
<span class="comment">// ...</span>

<span class="comment">/**</span>
<span class="comment"> * 计算两点之间的距离</span>
<span class="comment"> * <span class="doctag">@param</span> start 起点</span>
<span class="comment"> * <span class="doctag">@param</span> end 终点</span>
<span class="comment"> * <span class="doctag">@returns</span> 距离</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getDistance</span> = (<span class="params">start: MousePosition, end: MousePosition</span>) =&gt; &#123;
  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(start.<span class="property">x</span> - end.<span class="property">x</span>, <span class="number">2</span>) + <span class="title class_">Math</span>.<span class="title function_">pow</span>(start.<span class="property">y</span> - end.<span class="property">y</span>, <span class="number">2</span>))
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取鼠标坐标距离线段距离</span>
<span class="comment"> * <span class="doctag">@param</span> pos 鼠标坐标</span>
<span class="comment"> * <span class="doctag">@param</span> startPos 线段起点</span>
<span class="comment"> * <span class="doctag">@param</span> endPos 线段终点</span>
<span class="comment"> * <span class="doctag">@returns</span> 距离</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPositionToLineDistance</span> = (<span class="params"></span>
<span class="params">  pos: MousePosition,</span>
<span class="params">  startPos: MousePosition,</span>
<span class="params">  endPos: MousePosition</span>
<span class="params"></span>) =&gt; &#123;
  <span class="comment">/**</span>
<span class="comment">   * 1. 计算三点之间的直线距离</span>
<span class="comment">   * 2. 计算三角形半周长</span>
<span class="comment">   * 3. 通过海伦公式求面积</span>
<span class="comment">   * 4. 根据面积公式求三角形的高</span>
<span class="comment">   */</span>
  <span class="keyword">const</span> A = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title function_">getDistance</span>(pos, startPos))
  <span class="keyword">const</span> B = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title function_">getDistance</span>(pos, endPos))
  <span class="keyword">const</span> C = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title function_">getDistance</span>(startPos, endPos))

  <span class="keyword">const</span> P = (A + B + C) / <span class="number">2</span>
  <span class="keyword">const</span> area = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(P * (P - A) * (P - B) * (P - C)))
  <span class="keyword">const</span> distance = (<span class="number">2</span> * area) / C
  <span class="keyword">return</span> distance
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h2 id="点击渲染框选效果"><a href="#点击渲染框选效果" class="headerlink" title="点击渲染框选效果"></a>点击渲染框选效果</h2><ul>
<li>点击时如果在之前hover时满足三种情况已经记录下来了，就继续记录为框选元素</li>
<li>然后在画板渲染时，就按照框选元素的矩形属性渲染框选效果<pre><code class="highlight js"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">select</span>.<span class="property">selectElementIndex</span> !== -<span class="number">1</span>) &#123;
  <span class="comment">// 获取选择元素的矩形属性，绘制框选效果</span>
  <span class="keyword">const</span> rect = <span class="variable language_">this</span>.<span class="property">select</span>.<span class="title function_">getCurSelectElement</span>().<span class="property">rect</span>
  <span class="title function_">drawResizeRect</span>(<span class="variable language_">this</span>.<span class="property">context</span>, rect)
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制拖拽矩形</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">drawResizeRect</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  rect: ElementRect</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; x, y, width, height &#125; = rect
  context.<span class="title function_">save</span>()
  context.<span class="property">strokeStyle</span> = <span class="string">&#x27;#65CC8A&#x27;</span>
  context.<span class="title function_">setLineDash</span>([<span class="number">5</span>])
  context.<span class="property">lineWidth</span> = <span class="number">2</span>
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="comment">// 绘制虚线框</span>
  <span class="title function_">drawRect</span>(context, x, y, width, height)

  <span class="comment">// 绘制四角手柄</span>
  context.<span class="property">fillStyle</span> = <span class="string">&#x27;#65CC8A&#x27;</span>
  <span class="title function_">drawRect</span>(context, x - <span class="number">10</span>, y - <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">true</span>)
  <span class="title function_">drawRect</span>(context, x + width, y - <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">true</span>)
  <span class="title function_">drawRect</span>(context, x - <span class="number">10</span>, y + height, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">true</span>)
  <span class="title function_">drawRect</span>(context, x + width, y + height, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">true</span>)
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制矩形</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">drawRect</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  x: number,</span>
<span class="params">  y: number,</span>
<span class="params">  width: number,</span>
<span class="params">  height: number,</span>
<span class="params">  fill = <span class="literal">false</span> <span class="comment">// 是否填充</span></span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">beginPath</span>()
  context.<span class="title function_">rect</span>(x, y, width, height)
  <span class="keyword">if</span> (fill) &#123;
    context.<span class="title function_">fill</span>()
  &#125; <span class="keyword">else</span> &#123;
    context.<span class="title function_">stroke</span>()
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="拖拽元素"><a href="#拖拽元素" class="headerlink" title="拖拽元素"></a>拖拽元素</h2><p>拖拽元素比较简单，就是计算鼠标移动的距离，然后遍历坐标点加上距离即可</p>
<pre><code class="highlight js"><span class="comment">// startMousePos就是上一个移动的坐标</span>
<span class="keyword">const</span> disntanceX = x - <span class="variable language_">this</span>.<span class="property">startMousePos</span>.<span class="property">x</span>
<span class="keyword">const</span> disntanceY = y - <span class="variable language_">this</span>.<span class="property">startMousePos</span>.<span class="property">y</span>

<span class="comment">/**</span>
<span class="comment"> * 更新位置</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">distanceX</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">distanceY</span></span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">moveFreeDraw</span> = (<span class="params"></span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  distanceX: number,</span>
<span class="params">  distanceY: number</span>
<span class="params"></span>) =&gt; &#123;
  <span class="title function_">initRect</span>(instance)
  instance.<span class="property">positions</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">position</span>) =&gt;</span> &#123;
    position.<span class="property">x</span> += distanceX
    position.<span class="property">y</span> += distanceY
    <span class="title function_">updateRect</span>(instance, position)
  &#125;)
&#125;</code></pre>

<h2 id="画笔缩放-不保持比例"><a href="#画笔缩放-不保持比例" class="headerlink" title="画笔缩放(不保持比例)"></a>画笔缩放(不保持比例)</h2><ul>
<li>画笔缩放我先以右下角手柄拖拽为例分析</li>
<li>首先画笔的缩放比例是分为水平缩放比例和垂直缩放比例<ul>
<li>水平缩放比例 &#x3D; (旧矩形的宽 + 鼠标水平移动的距离) &#x2F; 旧矩形的宽</li>
<li>垂直缩放比例 &#x3D; (旧矩形的高 + 鼠标垂直移动的距离) &#x2F; 旧矩形的高</li>
</ul>
</li>
<li>然后遍历画笔的所有坐标点进行缩放，这时会出现一个偏移的缩放效果，如下图<ul>
<li><img src="https://s1.ax1x.com/2022/12/05/zy7600.png"></li>
</ul>
</li>
<li>这时就需要计算当前拖拽手柄对角顶点移动的距离是多少，然后减去这个距离就得到了正确的缩放效果了<ul>
<li><img src="https://s1.ax1x.com/2022/12/05/zy72kT.png"></li>
</ul>
</li>
<li>当然四个角的拖拽计算是不一致的，但是思路一致<pre><code class="highlight js"><span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">resizeType</span>) &#123;
  <span class="comment">// disntanceX 鼠标水平移动距离</span>
  <span class="comment">// disntanceY 鼠标垂直移动距离</span>
  <span class="comment">// 右下角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>:
    <span class="title function_">resizeFreeDraw</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">FreeDraw</span>,
      (rect.<span class="property">width</span> + disntanceX) / rect.<span class="property">width</span>,
      (rect.<span class="property">height</span> + disntanceY) / rect.<span class="property">height</span>,
      rect,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 左下角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>:
    <span class="title function_">resizeFreeDraw</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">FreeDraw</span>,
      (rect.<span class="property">width</span> - disntanceX) / rect.<span class="property">width</span>,
      (rect.<span class="property">height</span> + disntanceY) / rect.<span class="property">height</span>,
      rect,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 左上角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>:
    <span class="title function_">resizeFreeDraw</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">FreeDraw</span>,
      (rect.<span class="property">width</span> - disntanceX) / rect.<span class="property">width</span>,
      (rect.<span class="property">height</span> - disntanceY) / rect.<span class="property">height</span>,
      rect,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 右上角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>:
    <span class="title function_">resizeFreeDraw</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">FreeDraw</span>,
      (rect.<span class="property">width</span> + disntanceX) / rect.<span class="property">width</span>,
      (rect.<span class="property">height</span> - disntanceY) / rect.<span class="property">height</span>,
      rect,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>
    )
    <span class="keyword">break</span>
  <span class="attr">default</span>:
    <span class="keyword">break</span>
&#125;

<span class="comment">/**</span>
<span class="comment"> * 缩放绘画</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">instance</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">scaleX</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">scaleY</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">rect</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">resizeType</span></span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">resizeFreeDraw</span> = (<span class="params"></span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  scaleX: number,</span>
<span class="params">  scaleY: number,</span>
<span class="params">  rect: FreeDrawRect,</span>
<span class="params">  resizeType: string</span>
<span class="params"></span>) =&gt; &#123;
  <span class="comment">// 初始化矩形</span>
  <span class="title function_">initRect</span>(instance)
  <span class="comment">// 遍历所有坐标进行缩放</span>
  instance.<span class="property">positions</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">position</span>) =&gt;</span> &#123;
    position.<span class="property">x</span> = position.<span class="property">x</span> * scaleX
    position.<span class="property">y</span> = position.<span class="property">y</span> * scaleY
    <span class="title function_">updateRect</span>(instance, position)
  &#125;)
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: newX, <span class="attr">y</span>: newY, <span class="attr">width</span>: newWidth, <span class="attr">height</span>: newHeight &#125; = instance.<span class="property">rect</span>
  <span class="keyword">let</span> offsetX = <span class="number">0</span>
  <span class="keyword">let</span> offsetY = <span class="number">0</span>
  <span class="comment">// 计算偏移距离，这个是要根据当前缩放手柄的对角顶点进行计算，所以要分为4种情况</span>
  <span class="keyword">switch</span> (resizeType) &#123;
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>:
      offsetX = newX - rect.<span class="property">x</span>
      offsetY = newY - rect.<span class="property">y</span>
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>:
      offsetX = newX + newWidth - (rect.<span class="property">x</span> + rect.<span class="property">width</span>)
      offsetY = newY - rect.<span class="property">y</span>
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>:
      offsetX = newX + newWidth - (rect.<span class="property">x</span> + rect.<span class="property">width</span>)
      offsetY = newY + newHeight - (rect.<span class="property">y</span> + rect.<span class="property">height</span>)
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>:
      offsetX = newX - rect.<span class="property">x</span>
      offsetY = newY + newHeight - (rect.<span class="property">y</span> + rect.<span class="property">height</span>)
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;
  <span class="title function_">initRect</span>(instance)
  <span class="comment">// 减去偏移距离</span>
  instance.<span class="property">positions</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">position</span>) =&gt;</span> &#123;
    position.<span class="property">x</span> = position.<span class="property">x</span> - offsetX
    position.<span class="property">y</span> = position.<span class="property">y</span> - offsetY
    <span class="title function_">updateRect</span>(instance, position)
  &#125;)
&#125;</code></pre></li>
</ul>
<h2 id="文字缩放-保持比例"><a href="#文字缩放-保持比例" class="headerlink" title="文字缩放(保持比例)"></a>文字缩放(保持比例)</h2><ul>
<li>文字缩放需要一直保持着宽高比，通过计算出新旧矩形的宽高比<ul>
<li>当新的宽高比小于旧的宽高比时，宽度不变，计算 高度 &#x3D; 宽度 &#x2F; 旧的宽高比</li>
<li>但新的宽高比大于旧的宽高比时，高度不变，计算 宽度 &#x3D; 高度 * 旧的宽高比<pre><code class="highlight js"><span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">resizeType</span>) &#123;
  <span class="comment">// ...</span>
  <span class="comment">// 右下角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>:
    <span class="title function_">resizeTextElement</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">TextElement</span>,
      resizeElement.<span class="property">rect</span>.<span class="property">width</span> + disntanceX,
      resizeElement.<span class="property">rect</span>.<span class="property">height</span> + disntanceY,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 左下角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>:
    <span class="title function_">resizeTextElement</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">TextElement</span>,
      resizeElement.<span class="property">rect</span>.<span class="property">width</span> - disntanceX,
      resizeElement.<span class="property">rect</span>.<span class="property">height</span> + disntanceY,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 左上角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>:
    <span class="title function_">resizeTextElement</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">TextElement</span>,
      resizeElement.<span class="property">rect</span>.<span class="property">width</span> - disntanceX,
      resizeElement.<span class="property">rect</span>.<span class="property">height</span> - disntanceY,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 右上角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>:
    <span class="title function_">resizeTextElement</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">TextElement</span>,
      resizeElement.<span class="property">rect</span>.<span class="property">width</span> + disntanceX,
      resizeElement.<span class="property">rect</span>.<span class="property">height</span> - disntanceY,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>
    )
    <span class="keyword">break</span>
  <span class="attr">default</span>:
    <span class="keyword">break</span>
&#125;

<span class="comment">/**</span>
<span class="comment"> * 修改文本元素大小</span>
<span class="comment"> * <span class="doctag">@param</span> ele 文本元素</span>
<span class="comment"> * <span class="doctag">@param</span> width 改变后的宽度</span>
<span class="comment"> * <span class="doctag">@param</span> height 改变后的高度</span>
<span class="comment"> * <span class="doctag">@param</span> resizeType 拖拽类型</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">resizeTextElement</span> = (<span class="params"></span>
<span class="params">  ele: TextElement,</span>
<span class="params">  width: number,</span>
<span class="params">  height: number,</span>
<span class="params">  resizeType: string</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> oldRatio = ele.<span class="property">rect</span>.<span class="property">width</span> / ele.<span class="property">rect</span>.<span class="property">height</span>
  <span class="keyword">const</span> newRatio = width / height
  <span class="comment">// 按照之前的说明，修改宽高比不一致的情况</span>
  <span class="keyword">if</span> (newRatio &lt; oldRatio) &#123;
    height = width / oldRatio
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newRatio &gt; oldRatio) &#123;
    width = oldRatio * height
  &#125;

  <span class="comment">/**</span>
<span class="comment">   * 因为这个缩放是按照左上角缩放的</span>
<span class="comment">   * 所以为了达到当前拖拽手柄不移动，就需要进行偏移操作</span>
<span class="comment">   */</span>
  <span class="keyword">switch</span> (resizeType) &#123;
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>:
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>:
      ele.<span class="property">rect</span>.<span class="property">x</span> -= width - ele.<span class="property">rect</span>.<span class="property">width</span>
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>:
      ele.<span class="property">rect</span>.<span class="property">x</span> -= width - ele.<span class="property">rect</span>.<span class="property">width</span>
      ele.<span class="property">rect</span>.<span class="property">y</span> -= height - ele.<span class="property">rect</span>.<span class="property">height</span>
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>:
      ele.<span class="property">rect</span>.<span class="property">y</span> -= height - ele.<span class="property">rect</span>.<span class="property">height</span>
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;
  ele.<span class="property">rect</span>.<span class="property">height</span> = height
  ele.<span class="property">rect</span>.<span class="property">width</span> = width
  <span class="comment">// 字体大小按照高度修改</span>
  ele.<span class="property">fontSize</span> = ele.<span class="property">rect</span>.<span class="property">height</span>
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果有发现问题或者有好的方案，欢迎讨论👻</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】How peers are resolved</title>
    <url>/2023/05/05/%E3%80%90%E7%BF%BB%E3%80%91How%20peers%20are%20resolved/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://pnpm.io/how-peers-are-resolved">How peers are resolved</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>pnpm最大的一个特点是，在一个项目中，一个特定版本的package总是有一组依赖关系。不过，这个规则有一个例外–有peer dependencies的packages</p>
<p>在dependency graph中，peer dependencies是从更高级别的依赖中解析的，因为它们与它们的父依赖项共享相同的版本。这意味着如果<a href="mailto:&#102;&#x6f;&#x6f;&#64;&#49;&#x2e;&#x30;&#46;&#48;">&#102;&#x6f;&#x6f;&#64;&#49;&#x2e;&#x30;&#46;&#48;</a>有两个peer依赖项(bar@^1 和 baz@^1)，那么在同一个项目中它可能会有多个不同的依赖项集合</p>
<pre><code class="highlight text">- foo-parent-1
  - bar@1.0.0
  - baz@1.0.0
  - foo@1.0.0
- foo-parent-2
  - bar@1.0.0
  - baz@1.1.0
  - foo@1.0.0</code></pre>

<p>在上面这个例子中，<a href="mailto:&#102;&#x6f;&#111;&#x40;&#x31;&#46;&#48;&#x2e;&#x30;">&#102;&#x6f;&#111;&#x40;&#x31;&#46;&#48;&#x2e;&#x30;</a>是在foo-parent-1和foo-parent-2安装的。这两个packages中都有bar和baz，但是他们依赖不同版本的baz。因此，<a href="mailto:&#x66;&#111;&#x6f;&#x40;&#x31;&#46;&#48;&#x2e;&#x30;">&#x66;&#111;&#x6f;&#x40;&#x31;&#46;&#48;&#x2e;&#x30;</a>有两个不同的依赖集：一个是<a href="mailto:&#x62;&#x61;&#122;&#64;&#x31;&#46;&#x30;&#x2e;&#48;">&#x62;&#x61;&#122;&#64;&#x31;&#46;&#x30;&#x2e;&#48;</a>，另一个是<a href="mailto:&#x62;&#x61;&#x7a;&#x40;&#49;&#46;&#x31;&#46;&#48;">&#x62;&#x61;&#x7a;&#x40;&#49;&#46;&#x31;&#46;&#48;</a>。为了支持这些用例，pnpm必须hand link <a href="mailto:&#102;&#x6f;&#111;&#x40;&#49;&#x2e;&#x30;&#46;&#48;">&#102;&#x6f;&#111;&#x40;&#49;&#x2e;&#x30;&#46;&#48;</a>，次数和不同的依赖集一样多。</p>
<p>通常，如果一个package没有peer依赖项，它会与其依赖项的symlinks一起hard linked到node_modules文件夹中，就像：</p>
<pre><code class="highlight text">node_modules
└── .pnpm
    ├── foo@1.0.0
    │   └── node_modules
    │       ├── foo
    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux
    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh
    ├── qux@1.0.0
    ├── plugh@1.0.0</code></pre>

<p>然后，如果foo有peer dependencies，它可能有多组依赖关系，所以我们为不同的peer dependencies 创建不同的集合：</p>
<pre><code class="highlight text">node_modules
└── .pnpm
    ├── foo@1.0.0_bar@1.0.0+baz@1.0.0
    │   └── node_modules
    │       ├── foo
    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar
    │       ├── baz   -&gt; ../../baz@1.0.0/node_modules/baz
    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux
    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh
    ├── foo@1.0.0_bar@1.0.0+baz@1.1.0
    │   └── node_modules
    │       ├── foo
    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar
    │       ├── baz   -&gt; ../../baz@1.1.0/node_modules/baz
    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux
    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh
    ├── bar@1.0.0
    ├── baz@1.0.0
    ├── baz@1.1.0
    ├── qux@1.0.0
    ├── plugh@1.0.0</code></pre>

<p>我们要么创建symlinks到<code>foo@1.0.0_bar@1.0.0+baz@1.0.0</code>中的foo，要么创建symlinks到<code>foo@1.0.0_bar@1.0.0+baz@1.1.0</code>中的foo。因此，Node.js模块解析可以找到正确的peers依赖项。</p>
<p>如果一个package没有peer依赖项，但是有依赖于已在图中解析的同级依赖项的依赖项，那么这个transitive package可以以不同的依赖项集出现在项目中。例如，存在一个版本为<code>a@1.0.0</code>的包，它只有一个依赖项<code>b@1.0.0</code>。<code>b@1.0.0</code>有一个同级依赖项<code>c@^1</code>。<code>a@1.0.0</code>永远不会解析<code>b@1.0.0</code>的同级依赖项，所以它也会依赖于<code>b@1.0.0</code>的同级依赖项。</p>
<p>下面是这个结构在<code>node_modules</code>中的样子，在这个例子中，<a href="mailto:&#x61;&#64;&#49;&#46;&#x30;&#x2e;&#x30;">&#x61;&#64;&#49;&#46;&#x30;&#x2e;&#x30;</a>需要在项目的<code>node_modules</code>中出现两次，一次和<code>c@1.0.0</code>，另一次和<code>c@1.1.0</code>解决。</p>
<pre><code class="highlight text">node_modules
└── .pnpm
    ├── a@1.0.0_c@1.0.0
    │   └── node_modules
    │       ├── a
    │       └── b -&gt; ../../b@1.0.0_c@1.0.0/node_modules/b
    ├── a@1.0.0_c@1.1.0
    │   └── node_modules
    │       ├── a
    │       └── b -&gt; ../../b@1.0.0_c@1.1.0/node_modules/b
    ├── b@1.0.0_c@1.0.0
    │   └── node_modules
    │       ├── b
    │       └── c -&gt; ../../c@1.0.0/node_modules/c
    ├── b@1.0.0_c@1.1.0
    │   └── node_modules
    │       ├── b
    │       └── c -&gt; ../../c@1.1.0/node_modules/c
    ├── c@1.0.0
    ├── c@1.1.0</code></pre>
]]></content>
      <tags>
        <tag>pnpm</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Flat node_modules is not the only way</title>
    <url>/2023/05/01/%E3%80%90%E7%BF%BB%E3%80%91Flat%20node_modules%20is%20not%20the%20only%20way/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way">Flat node_modules is not the only way</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>pnpm的新用户经常问我关于pnpm创建后的<code>node_module</code>结构为什么这么奇怪。为什么不是扁平化的？所有的次级依赖在哪里？</p>
<blockquote>
<p>我假设阅读这篇文章的读者都已经熟悉了npm和yarn创建后的扁平化<code>node_modules</code>，如果你不明白npm在v3中开始使用扁平化<code>node_modules</code>，你可以在<a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">Why should we use pnpm?</a>中找到一些历史说明</p>
</blockquote>
<p>那么为什么pnpm的<code>node_modules</code>不寻常呢？我们来创建两个目录，一个运行<code>npm add express</code>，另一个运行<code>pnpm add express</code>，下面是你在第一个目录的<code>node_modules</code>中得到的顶部内容结构</p>
<pre><code class="highlight text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express</code></pre>

<p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">这里</a>看到整个目录。</p>
<p>然后这是你在pnpm创建的<code>node_modules</code>中得到的目录：</p>
<pre><code class="highlight text">.pnpm
.modules.yaml
express</code></pre>

<p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">这里</a>查看.</p>
<p>那么，所有的依赖项都在哪里呢，在<code>node_modules</code>中只有一个叫做<code>.pnpm</code>的文件夹和一个叫做<code>express</code>的<code>symlink</code>。好吧，因为我们只安装了<code>express</code>，所以这是你的应用可以访问的唯一<code>package</code></p>
<blockquote>
<p>在<a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">此</a>阅读更多关于pnpm的严格性为什么是一件好事情</p>
</blockquote>
<p>让我们看看<code>express</code>的内部：</p>
<pre><code class="highlight text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
  .modules.yaml</code></pre>

<p>express没有node_modules？express的所有依赖项在哪里?</p>
<p>诀窍在于，<code>express</code>只是一个<code>symlink</code>，但<code>Node.js</code>解析依赖关系时，它会使用<code>express</code>的真实位置，所以依赖不会保留在符号连接上，但是你可能会问，<code>express</code>的真实位置在哪?</p>
<p>这里：<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules&#x2F;.pnpm&#x2F;express@4.17.1/node_modules&#x2F;express</a>.</p>
<p>现在我们知道了<code>.pnpm</code>文件夹的用途。<code>.pnpm</code>在一个扁平的文件夹结构中存储所有的<code>packages</code>，所以每个<code>package</code>都可以在这个模式命名的文件夹中找到</p>
<pre><code class="highlight text">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</code></pre>

<p>我们称它为虚拟存储目录</p>
<p>这种扁平结构避免了<code>npm v2</code>创建的嵌套<code>node_modules</code>造成的长路径问题，但是又与<code>npm v3,4,5,6</code>和<code>yarn v1</code>的扁平化结构不同，保持了<code>packages</code>的隔离</p>
<p>现在我们来研究一下express的真实位置：</p>
<pre><code class="highlight text">▾ express
  ▸ lib
    History.md
    index.js
    LICENSE
    package.json
    Readme.md</code></pre>

<p>这是错误的吗？它仍然缺少<code>node_modules</code>！<code>pnpm</code>的<code>node_modules</code>结构的第二个诀窍是，<code>packages</code>的依赖关系在同一级的目录上，而<code>package</code>依赖的真正位置在这个目录上。所以<code>express</code>的依赖不在<code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code>，而是在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm&#x2F;express@4.17.1/node_modules&#x2F;</a></p>
<pre><code class="highlight text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md</code></pre>

<p><code>express</code>的所有依赖都是指向<code>node_modules/.pnpm</code>内目录的symlinks。<code>express</code>的依赖放在上一级，可以避免循环symlinks</p>
<p>所以你可以看到，尽管pnpm的<code>node_modules</code>结构从开始时看起来不寻常：</p>
<ol>
<li>完全兼容Node.js</li>
<li>packages和相关依赖被很好的组合在一起</li>
</ol>
<p>对于同样依赖关系的packages来说结构要复杂一些，但是想法是一样的：使用symlinks创建一个有扁平目录结构的嵌套</p>
]]></content>
      <tags>
        <tag>pnpm</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Mastering TypeScript: A Guide to Choosing Between ‘type’ and ‘interface’</title>
    <url>/2023/05/24/%E3%80%90%E7%BF%BB%E3%80%91Mastering-TypeScript-A-Guide-to-Choosing-Between-%E2%80%98type%E2%80%99-and-%E2%80%98interface%E2%80%99/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://levelup.gitconnected.com/mastering-typescript-a-guide-to-choosing-between-type-and-interface-c31d3527693b">Mastering TypeScript: A Guide to Choosing Between ‘type’ and ‘interface’</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>TypeScript现在已经成为捕捉错误和提高代码稳定性的可靠工具。然而，在使用TypeScript时，我经常想知道type和interface之间的区别，以及如何使用它们</p>
<p>在这篇博客中，我想分享我所知道的的关于type和interface之间的区别，以及何时使用它们，我会提供明确的例子和解释，帮助你更好地理解如何在TypeScript项目中使用这两个强大的工具。</p>
<p>在本篇文章结束时，你将对type和interface之间的区别有更好的理解，以及知道如何在TypeScript代码中更有效地使用它们。我希望这篇文章对希望提高TypeScript技能和希望编写更多可靠代码的web开发者有所帮助。</p>
<h3 id="Type-vs-Interface"><a href="#Type-vs-Interface" class="headerlink" title="Type vs Interface"></a>Type vs Interface</h3><p>在TypeScript中，type和interface都可以用来定义对象类型，但他们在语法和功能上有一些区别，首先interface是一个用来定义对象类型关键字，其语法是：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">IUser</span> &#123;
  <span class="attr">name</span>: <span class="built_in">string</span>;
  <span class="attr">age</span>: <span class="built_in">number</span>;
  ...
&#125;</code></pre>

<p>另一方面，type也是一个定义对象类型的关键字，其语法是：</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;
  <span class="attr">name</span>: <span class="built_in">string</span>;
  <span class="attr">age</span>: <span class="built_in">number</span>;
  ...
&#125;;</code></pre>

<p>语法差异不大，但在功能上还有其他差异。</p>
<p>interface可以扩展并创建继承父interface属性的新类型：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">IUser</span> &#123;
  <span class="attr">name</span>: <span class="built_in">string</span>;
&#125;

<span class="keyword">interface</span> <span class="title class_">IMember</span> <span class="keyword">extends</span> <span class="title class_">IUser</span> &#123;
  <span class="attr">department</span>: <span class="built_in">string</span>;
&#125;</code></pre>

<p>这允许你定义一套多个类型共享的基础属性，然后根据需要为更多的特定类型进行扩展。这可以帮助你避免代码重复，使你的代码更具有模块化和组织。</p>
<p>而type不能以同样的方式被扩展，但它可以用来定义联合、交叉和其他复杂类型：</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">Union</span> = <span class="title class_">Type1</span> | <span class="title class_">Type2</span>;

<span class="keyword">type</span> <span class="title class_">Intersection</span> = <span class="title class_">Type1</span> &amp; <span class="title class_">Type2</span>;</code></pre>

<p>这些type允许你定义类型更复杂的关系，并且可以帮助你更准确地建立数据模型。</p>
<h3 id="Example-—-Building-a-Messaging-App"><a href="#Example-—-Building-a-Messaging-App" class="headerlink" title="Example — Building a Messaging App"></a>Example — Building a Messaging App</h3><p>假如你正在构建一个消息app，你想为一条信息定义一个类型，它可以包含文本或图像，你可以使用一个联合类型来定义：</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">Message</span> = &#123;
  <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span> | <span class="string">&#x27;image&#x27;</span>;
  <span class="attr">content</span>: <span class="built_in">string</span> | <span class="title class_">File</span>;
&#125;</code></pre>

<p>在这个例子中，我们使用type来定义一个联合类型，它只能是两个字符串值中的一个：”text”或者”image”，我们还使用联合类型来定义content属性，他可以是一个字符串(text messages)或者是一个File对象(image messages)。</p>
<p>现在，假如你想在你的app中为一组拥有不同角色的用户定义一个类型，比如管理员、版主和普通用户。你可以使用一个交叉类型来定义：</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;
  <span class="attr">id</span>: <span class="built_in">number</span>;
  <span class="attr">name</span>: <span class="built_in">string</span>;
&#125;

<span class="keyword">type</span> <span class="title class_">Admin</span> = <span class="title class_">User</span> &amp; &#123;
  <span class="attr">role</span>: <span class="string">&#x27;admin&#x27;</span>;
  <span class="attr">permissions</span>: <span class="built_in">string</span>[];
&#125;

<span class="keyword">type</span> <span class="title class_">Moderator</span> = <span class="title class_">User</span> &amp; &#123;
  <span class="attr">role</span>: <span class="string">&#x27;moderator&#x27;</span>;
  <span class="attr">canDelete</span>: <span class="built_in">boolean</span>;
&#125;

<span class="keyword">type</span> <span class="title class_">RegularUser</span> = <span class="title class_">User</span> &amp; &#123;
  <span class="attr">role</span>: <span class="string">&#x27;user&#x27;</span>;
  <span class="attr">isPremium</span>: <span class="built_in">boolean</span>;
&#125;</code></pre>

<p>在这个例子中，我们定义了一个有两个属性的用户类型：id和name。然后我们定义了另外三个类型(Admin、Moderator和RegularUser)，它们使用一个交叉类型(&amp;)来扩展User类型。这些类型中每一个都有一个不同的role属性和针对其角色的额外属性。</p>
<p>使用联合类型和交叉类型可以帮助你在TypeScript代码中定义更复杂的类型，并使其更容易对现实世界的数据进行建模。</p>
<h3 id="Declaration-Merging"><a href="#Declaration-Merging" class="headerlink" title="Declaration Merging"></a>Declaration Merging</h3><p>interface还支持声明合并，它允许你定义多个同名的interface，并将它们的属性合并到一个interface中：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">MyObject</span> &#123;
  <span class="attr">property1</span>: <span class="title class_">Type1</span>;
&#125;

<span class="keyword">interface</span> <span class="title class_">MyObject</span> &#123;
  <span class="attr">property2</span>: <span class="title class_">Type2</span>;
&#125;

<span class="keyword">const</span> <span class="attr">myObject</span>: <span class="title class_">MyObject</span> = &#123;
  <span class="attr">property1</span>: <span class="string">&#x27;value1&#x27;</span>,
  <span class="attr">property2</span>: <span class="string">&#x27;value2&#x27;</span>
&#125;;</code></pre>

<p>当你与第三方库或系统一起工作时，这很有用，它们分别定义了它们的interface，然后在需要时把它们合并成一个interface。</p>
<h3 id="Example-—-Unleashing-the-Power-of-Declaration-Merging"><a href="#Example-—-Unleashing-the-Power-of-Declaration-Merging" class="headerlink" title="Example — Unleashing the Power of Declaration Merging"></a>Example — Unleashing the Power of Declaration Merging</h3><p>假如你正在构建一个需要用户登录的app，你想为认证API返回的用户对象定义一个interface。你可以像这样定义这个interface：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;
  <span class="attr">username</span>: <span class="built_in">string</span>;
  <span class="attr">email</span>: <span class="built_in">string</span>;
&#125;</code></pre>

<p>后来，你发现认证API也会为每个用户返回一个userId属性，但你不想修改原来的User interface。相反，你可以定义一个同名的新interface，它将自动将属性与原来的User interface合并：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;
  <span class="attr">userId</span>: <span class="built_in">number</span>;
&#125;

<span class="comment">// Now the User interface has three properties: username, email, and userId</span>
<span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123;
  <span class="attr">username</span>: <span class="string">&#x27;john.doe&#x27;</span>,
  <span class="attr">email</span>: <span class="string">&#x27;john.doe@example.com&#x27;</span>,
  <span class="attr">userId</span>: <span class="number">123</span>
&#125;;</code></pre>

<p>在这个例子中，我们定义了User interface， 有两个属性：username和email，然后，我们定义了一个新的User interface，并带有userId属性。当我们使用User interface来定义我们的用户对象时，两个接口的属性会被合并在一起，创建一个具有三个属性的对象：username，email和userId。</p>
<p>声明合并是interface一个很有用的功能，它允许你在不修改原有定义的情况下扩展现有interface。</p>
<h3 id="Let’s-talk-about-the-Open-x2F-Closed-Principle"><a href="#Let’s-talk-about-the-Open-x2F-Closed-Principle" class="headerlink" title="Let’s talk about the Open&#x2F;Closed Principle"></a>Let’s talk about the Open&#x2F;Closed Principle</h3><p>开闭原则(OCP)，是面向对象编程设计SOLID原则之一。它就像软件开发的圣杯。每个人都在谈论它，但是你们真的了解它吗？还只是假装了解？</p>
<p>我希望你记住：SOLID是一个缩写，代表了Robert C.Martin（也被称为Bob叔叔）提出的面向对象编程设计的五个原则。这些原则使软件开发具有可伸缩、可维护、可扩展</p>
<p>之前的例子很好的说明了开闭原则，因为它展示了如何在不修改原有interface的情况下扩展它。通过定义一个带有userId属性的新interface，而不是修改原来的User interface，在保持原来的接口不被修改的同时还能扩展其功能。这种方式随着时间的推移，使你的代码更容易维护和扩展，而不会引入意想不到的问题和破坏式变化。</p>
<p>但是等等，还有更多！如果你使用TypeScript或其他具有声明合并功能的语言，你可以只用两个属性来定义user interface，然后用userId属性定义一个新的user interface，但你用User interface定义用户对象时，两个接口的属性会神奇地合并在一起，创建一个有三个属性的对象。这就像魔术一样，只不过没有兔子，更多的是TypeScript。</p>
<p>但是实际中，谁有时间去研究OCP这些废话？有时你只是需要完成一些功能，而修改现有代码是最快的办法。谁会关心OCP呢？它只是软件开发者喜欢抛出的一个花哨的原则，让自己听起来很聪明。</p>
<p>所以，如果你必须做的话，就去违反OCP吧。只要确保你有一个很好的理由这样做。如果有人问起，就告诉他们你是在遵循KCP(保持满足原则)。这是一个我们都支持的原则。</p>
<h3 id="React-Component-Props"><a href="#React-Component-Props" class="headerlink" title="React Component Props"></a>React Component Props</h3><p>所以你是想用type还是interface来定义React component props？让我告诉你，你来对地方了，我的意思是，当你可以将时间花在探讨TypeScript语法的细微差别时，谁还需要生活呢？你就像现代的苏格拉底，提着重要的问题，比如“我应该是用type还是interface？”而我们这些凡人则忙着在Tinder上左滑右滑。所以，请系好安全带，我的朋友，因为我们即将深入探索React Components 类型定义的精彩世界</p>
<p>在React组件上使用type还是interface来定义props在很大程度上是一个个人偏好的问题，因为这两个选项提供了相似的功能。然而，在选择它们的时候，有一些区别需要考虑。</p>
<p>首先interface是React组件中定义props的一种常用方式。因为interface允许你扩展和重用来定义props对象。例如，你可以创建一个基本props interface，然后在每个单独的组件中扩展它</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;
  className?: <span class="built_in">string</span>;
  onClick?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;
&#125;

<span class="keyword">interface</span> <span class="title class_">ButtonProps</span> <span class="keyword">extends</span> <span class="title class_">Props</span> &#123;
  <span class="keyword">type</span>?: <span class="string">&#x27;button&#x27;</span> | <span class="string">&#x27;submit&#x27;</span> | <span class="string">&#x27;reset&#x27;</span>;
&#125;

<span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params">&#123; className, onClick, <span class="keyword">type</span> &#125;: ButtonProps</span>) &#123;
  <span class="comment">// render button with props</span>
&#125;</code></pre>

<p>在这个例子中，我们定义了一个包含className和onClick属性的interface。然后我们扩展这个interface，创建了一个ButtonProps interface，增加了一个可选的type prop。然后用这个interface来定义Button组件的props。</p>
<p>另一方面，当你需要定义更复杂的类型时，比如联合或者交叉类型时，type就很有用。比如，你可以使用type来定义一个size options，代表一个组件的不同size选项。</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">Size</span> = <span class="string">&#x27;small&#x27;</span> | <span class="string">&#x27;medium&#x27;</span> | <span class="string">&#x27;large&#x27;</span>;

<span class="keyword">interface</span> <span class="title class_">Props</span> &#123;
  <span class="attr">size</span>: <span class="title class_">Size</span>;
&#125;

<span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">&#123; size &#125;: Props</span>) &#123;
  <span class="comment">// render component with props</span>
&#125;</code></pre>

<p>在这个例子中，我们使用type定义了一个size类型，代表组件的不同尺寸。然后，我们用props interface来定义size prop，要求是必须的并且是尺寸类型中的一个。</p>
<p>通常，使用interface是定义简单props的好选择，可以扩展或重复使用，而使用type是定义复杂类型的好选择。</p>
<p>总之，type和interface都可以用来React组件中定义props，但它们在功能上有一些区别。interface可以扩展或重复使用，而type对于定义更复杂的类型很有用。最终，在type和interface之间选择是一个个人偏好和你项目具体需求的问题。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>一般来说，interface经常被用来定义对象的结构，并作为其他系统或库的interface。另一方面，type经常用来定义更复杂的类型，如联合、交叉或映射类型，或者定义不能用interface表达的类型，如函数类型或条件类型。</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】On Styling Web Components</title>
    <url>/2023/06/17/%E3%80%90%E7%BF%BB%E3%80%91On%20Styling%20Web%20Components/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://blog.webf.zone/on-styling-web-components-b74b8c70c492">On Styling Web Components</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>以正确的方式进行 — 使用CSSOM</p>
<p><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*nrlNnE1jCyNVqNQllN1Qzw.png"></p>
<p>更好的封装性可能是你开始使用Web Components的主要原因。特别是，ShadowDOM是实现真正封装性的机制。多年来，Web社区发明了一些方案来修复和改善CSS和JS的全局特性，这些解决方案虽起作用了但并不完美。直到有了Shadow DOM，我们才真正实现了CSS的完美作用域。</p>
<p>在这篇文章中，我们会探索如何将样式应用到Web Components上，并尝试找到最合适的方法。此外，我们还将尝试将我们的解决方案和当前的构建工具相结合。</p>
<h2 id="The-naive-way-—-Plain-lt-style-gt-tag"><a href="#The-naive-way-—-Plain-lt-style-gt-tag" class="headerlink" title="The naive way — Plain &lt;style&gt; tag"></a>The naive way — Plain <code>&lt;style&gt;</code> tag</h2><p>在使用Shadow DOM时，为了使 style sheet 发挥作用，目前是要在每个shadow root中使用<code>&lt;style&gt;</code> 元素，在大多数文章中，都会很表面的说出这个方案</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">FancyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;

  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">super</span>();

    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);

    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">      &lt;!-- Styles are scoped --&gt;</span>
<span class="string">      &lt;style&gt;</span>
<span class="string">        p &#123; color: red; &#125;</span>
<span class="string">      &lt;/style&gt;</span>
<span class="string">      &lt;div&gt;</span>
<span class="string">        &lt;p&gt;Hello World&lt;/p&gt;</span>
<span class="string">      &lt;/div&gt;</span>
<span class="string">    `</span>;
  &#125;
&#125;

customElements.<span class="title function_">define</span>(<span class="string">&#x27;fancy-comp&#x27;</span>, <span class="title class_">FacyComponent</span>);</code></pre>

<p>这个解决办法简单直接，然而有一个问题：</p>
<blockquote>
<p>对于页面中添加的每个组件实例，浏览器都会解析它的样式表规则。</p>
</blockquote>
<p>这对性能会产生很大的影响，比如时间增加和内存增加。时间会增加是因为浏览器需要解析更多的原始字符串，内存成本增加是因为每个组件都会存储样式规则。浏览器没有办法知道同一个组件的两个实例是否共享相同的样式。</p>
<blockquote>
<p>原作者更新：Eric Bidelman在评论中指出，性能方面不一定会影响。浏览器可能在内部进行优化，这样它就不会在每次创建实例时解析样式标签。事实上，Blink（Chrome、Opera等）引擎已经对此进行了优化</p>
</blockquote>
<h2 id="Can-we-do-something-better"><a href="#Can-we-do-something-better" class="headerlink" title="Can we do something better?"></a>Can we do something better?</h2><p>其实，我们可以通过创建一个样式节点，然后在组件的每个实例中进行深度克隆，来防止样式规则的重新解析：</p>
<pre><code class="highlight js"><span class="comment">// Create style node outside of WebComponent</span>
<span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);

style.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">  p &#123; color: blue; &#125;</span>
<span class="string">`</span>;

<span class="keyword">class</span> <span class="title class_">FancyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;

  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">super</span>();

    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);

    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">      &lt;div&gt;</span>
<span class="string">        &lt;p&gt;Hello World&lt;/p&gt;</span>
<span class="string">      &lt;/div&gt;</span>
<span class="string">    `</span>;

    <span class="comment">// Let us try to optimize</span>
    <span class="comment">// Deep cloning of style node</span>
    <span class="keyword">const</span> clonedStyle = style.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);

    shadowRoot.<span class="title function_">appendChild</span>(clonedStyle);
  &#125;
&#125;</code></pre>

<p>不过，这种方法虽然很容易，但是仍然有问题。</p>
<ul>
<li>首先，它不能真正的帮助我们在组件实例间共享样式。新的样式节点仍然会创建</li>
<li>其次这个方法与 <strong>lit-html</strong> 和 <strong>hyperHTML</strong> 等声明式解决方案一起使用有点尴尬。</li>
</ul>
<h2 id="Enter-the-Constructible-Stylesheets"><a href="#Enter-the-Constructible-Stylesheets" class="headerlink" title="Enter the Constructible Stylesheets"></a>Enter the Constructible Stylesheets</h2><p>顾名思义，可构建的样式表允许在使用Shadow DOM时创建和共享样式。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5R11T84I-Fd0JBzOur2AQ.png"></p>
<pre><code class="highlight js"><span class="keyword">const</span> sheet = <span class="keyword">new</span> <span class="title class_">CSSStyleSheet</span>();

<span class="comment">// Replace all styles synchronously for this style sheet</span>
sheet.<span class="title function_">replaceSync</span>(<span class="string">&#x27;p &#123; color: green; &#125;&#x27;</span>);

<span class="keyword">class</span> <span class="title class_">FancyComponent1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;

  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">super</span>();

    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);

    <span class="comment">// Attaching the style sheet to the Shadow DOM of this component</span>
    shadowRoot.<span class="property">adoptedStyleSheets</span> = [sheet];

    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">      &lt;div&gt;</span>
<span class="string">        &lt;p&gt;Hello World&lt;/p&gt;</span>
<span class="string">      &lt;/div&gt;</span>
<span class="string">    `</span>;

  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">FancyComponent2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;

  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">super</span>();

    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);

    <span class="comment">// Same style sheet can also be used by another web component</span>
    shadowRoot.<span class="property">adoptedStyleSheets</span> = [sheet];

    <span class="comment">// You can even manipulate the style sheet with plain JS manipulations</span>
    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> shadowRoot.<span class="property">adoptedStyleSheets</span> = [], <span class="number">2000</span>);

    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">      &lt;div&gt;</span>
<span class="string">        &lt;p&gt;Hello World&lt;/p&gt;</span>
<span class="string">      &lt;/div&gt;</span>
<span class="string">    `</span>;

  &#125;
&#125;</code></pre>

<p>除了解决重复拷贝的问题，它还有一些特点：</p>
<ul>
<li>首先样式不仅仅被同一组件的实例共享，也会被多个不同组件所共享</li>
<li>它还支持处理异步样式。例如，在你的CSS代码中使用 <code>url</code> 和 <code>@import</code></li>
<li>最后，<code>adoptedStyleSheets</code> 是一个数组。这意味着你可以在我们以前不可能做到的方式来组成可复用的样式表。首先你可以把你的CSS规则分成小块，然后只应用需要的那部分。甚至你可以做下面这样的事情：</li>
</ul>
<pre><code class="highlight js">shadowRoot.<span class="property">adoptedStyleSheets</span> = [sheet];
<span class="comment">// Remove stylesheets after two seconds</span>
<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> shadowRoot.<span class="property">adoptedStyleSheets</span> = [], <span class="number">2000</span>);</code></pre>

<h2 id="Using-with-Webpack-and-SCSS"><a href="#Using-with-Webpack-and-SCSS" class="headerlink" title="Using with Webpack and SCSS"></a>Using with Webpack and SCSS</h2><p>SCSS作为一个CSS预处理器，Webpack作为一个模块打包和构建工具，都是非常常见的配置。其中<br> <code>CSSStyleSheet.replace()</code> 和 <code>CSSStyleSheet.replaceSync()</code> 预期接收一个原始字符串形式的CSS规则。我们可以使用一个简单的loader chain，包括sass-loader和raw-loader，如下：</p>
<pre><code class="highlight js"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;

  <span class="attr">entry</span>: &#123; <span class="comment">/* config */</span> &#125;,

  <span class="attr">output</span>: &#123; <span class="comment">/* config */</span> &#125;,

  <span class="attr">module</span>: &#123;
    <span class="attr">rules</span>: [
      <span class="comment">// Regular css files</span>
      &#123;
        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,
        <span class="attr">loader</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]
      &#125;,

      <span class="comment">// Transforming SCSS file into CSS string</span>
      &#123;
        <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,
        <span class="attr">use</span>: [
          <span class="string">&#x27;raw-loader&#x27;</span>,
          &#123;
            <span class="attr">loader</span>: <span class="string">&#x27;sass-loader&#x27;</span>,
            <span class="attr">options</span>: &#123;
              <span class="attr">includePaths</span>: [path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;node_modules&#x27;</span>)]
            &#125;
          &#125;
        ]
      &#125;,
    ]
  &#125;,
  <span class="attr">plugins</span>: [],
&#125;;</code></pre>

<p>在你的代码中可以导入SCSS文件：</p>
<pre><code class="highlight js"><span class="comment">// Read SCSS file as a raw CSS text</span>
<span class="keyword">import</span> styleText <span class="keyword">from</span> <span class="string">&#x27;./my-component.scss&#x27;</span>;

<span class="keyword">const</span> sheet = <span class="keyword">new</span> <span class="title class_">CSSStyleSheet</span>();
sheet.<span class="title function_">replaceSync</span>(styleText);</code></pre>

<p>在Rollup.js中也可以进行类似的设置。此外，来自Polymer团队的新库<strong>LitElement</strong>已经在使用这种方法，并具有回退机制</p>
<p>*注意：目前可构建的样式表是在Chromium系列的浏览器中实现。然而，通过合理的渐进式增强，为不支持的浏览器提供支持应该是容易的。</p>
<h2 id="Under-the-hood-—-CSSOM"><a href="#Under-the-hood-—-CSSOM" class="headerlink" title="Under the hood — CSSOM"></a>Under the hood — CSSOM</h2><p>*如果你对其中细节不感兴趣，可以跳过这一节。</p>
<p>如果HTML被转化为DOM，那么CSS则被转化为CSSOM。这些都是独立的数据结构。最终的渲染树是由这两个数据结构构建的。作为一个前端开发者，理解CSSOM的机制其实并不重要，因此它是一个不太知名的概念。</p>
<p>粗略地说，一个<code>&lt;link type=&#39;text/css&#39; href=&#39;&#39;/&gt;</code>标签对应一个CSS样式表。它在CSSOM中由CSSStyleSheet接口表示。一个CSSStyleSheet由多个规则组成。每个规则由CSSRule接口表示。</p>
<p>要访问document上的CSSStyleSheet对象，你可以使用 <code>document.styleSheets</code> 属性。实际上，如果你想创建一个CSSStyleSheet对象，你必须创建一个样式标签，然后将其添加到document中并使用sheet属性：</p>
<pre><code class="highlight js"><span class="keyword">const</span> styleNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);
<span class="comment">// It is important to add style node to the document</span>
<span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(styleNode);
<span class="keyword">const</span> sheet = styleNode.<span class="property">sheet</span>;</code></pre>

<p>然后，可构建的样式表启用了两个API — <code>CSSStyleSheet()</code>构造函数和<code>document.adoptedStyleSheets</code>。</p>
<blockquote>
<p>有了可构造的样式表，你可以使用CSSStyleSheet()构造函数来创建样式表</p>
</blockquote>
<p>在Shadow Roots和Documents上 <code>adoptedStyleSheets</code> 是可用的。它允许我们将一个CSSStyleSheet定义的样式应用到一个给定的DOM子树上。另需要注意，adoptedStyleSheets是一个不可变的数组，因此 <code>push</code> 或 <code>splice</code> 会不起作用。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*xQyzox2_i0wMUZh6wJm_DA.png"></p>
<p>就CSSRule而言，有许多CSSRule type都扩展了CSSRule interface。以下是MDN提供的一个所有规则的列表：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSRule">CSSRule MDN</a></li>
</ul>
<p>CSS Object MOdel是很庞大的，而且一直都在不停的发展，你可以在下面找到详细的信息：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSS Object Model (CSSOM)</a></li>
</ul>
<p>另外，不要忘记新的 CSS Typed Object Model正在积极开发中，它肯定会对如何用JS编写CSS产生影响，你可以在下面的文章中找到更多关于它的内容：</p>
<ul>
<li><a href="https://developer.chrome.com/blog/cssom/">Working with the new CSS Typed Object Model</a></li>
</ul>
<h2 id="Side-notes"><a href="#Side-notes" class="headerlink" title="Side notes"></a>Side notes</h2><p>不管你是在Shadow DOM中如何处理style，你都应该牢记以下几项：</p>
<ul>
<li>您可以通过使用<code>@import</code>语句来在 Shadow DOM 中使用外部样式</li>
<li>插槽可以通过全局CSS或容器组件的样式表进行设置</li>
<li>CSS自定义属性可以跨越Shadow DOM边界使用和修改</li>
</ul>
<p>因此，这些自定义属性是从外部处理 ShadowDOM 样式的首选</p>
<ul>
<li>除了自定义属性外，还可以使用新的CSS选择器，如 <code>:host</code>、<code>:part</code>、<code>:theme</code>，进一步提供来自外部的样式定制</li>
<li>在很大程度上，使用Shadow DOM进行样式封装是替代CSS-in-JS方法的很好选择</li>
<li>虚拟组件(没有元素的组件，如Vue的<code>&lt;router-view /&gt;</code>或React的<code>&lt;Route /&gt;</code>)是不可能使用Web Components</li>
<li>Web Components非常适合替代子组件，如输入框、面板、卡片、选择器等</li>
</ul>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>Web Component</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】SOLID Principles in JavaScript</title>
    <url>/2023/06/02/%E3%80%90%E7%BF%BB%E3%80%91SOLID-Principles-in-JavaScript/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://medium.com/@akashjha9041/solid-principles-in-javascript-ab69197e4cf7">SOLID Principles in JavaScript</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>SOLID原则是由Robert C. Martin提出的一套软件设计原则。这些原则指导开发人员构建出健壮的、可维护的应用程序，同时将维护的成本降到最低。在这篇文章中，我们将讨论如何在JavaScript中使用这些原则，并会展示一些代码示例</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*b8uhCfoR8YgDFc58"></p>
<p>SOLID原则是由Robert C. Martin. “Bob叔叔” 提出的一套软件设计原则。这些原则指导开发人员构建出健壮的、可维护的应用程序，同时将维护的成本降到最低。</p>
<p>尽管SOLID原则经常被用于面向对象的编程，但我们可以将其用于其他语言，比如JavaScript。在这篇文章中，我们将讨论如何在JavaScript中使用这些原则，并会展示一些代码示例</p>
<h2 id="What-are-the-SOLID-principles"><a href="#What-are-the-SOLID-principles" class="headerlink" title="What are the SOLID principles?"></a>What are the SOLID principles?</h2><ul>
<li>Single responsibility principle（单一职责原则）</li>
<li>Open-closed principle（开闭原则）</li>
<li>Liskov substitution principle（里式替换原则）</li>
<li>Interface segregation principle（接口分离原则）</li>
<li>Dependency inversion principle（依赖倒置原则）</li>
</ul>
<h2 id="Single-responsibility-principle"><a href="#Single-responsibility-principle" class="headerlink" title="Single responsibility principle"></a>Single responsibility principle</h2><p>一个class，一个module或者一个function应该只负责一个角色。所以它应该只有一个改变原因。</p>
<p>单一职责原则是SOLID最简单的原则之一。然而，开发者经常误解它。认为一个模块应该只做一件事。</p>
<p>让我们用一个简单的例子来理解这个原则。下面的JavaScript代码片段有一个名为 ManageEmployee 的 class 和几个管理雇员的 function</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">ManageEmployee</span> &#123;

  <span class="title function_">constructor</span>(<span class="params">private http: HttpClient</span>)
  <span class="variable constant_">SERVER_URL</span> = <span class="string">&#x27;http://localhost:5000/employee&#x27;</span>;

  getEmployee (empId)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
  &#125;

  updateEmployee (employee)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">put</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;employee.id&#125;</span>`</span>,employee);
  &#125;

  deleteEmployee (empId)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
  &#125;

  calculateEmployeeSalary (empId, workingHours)&#123;
    <span class="keyword">var</span> employee = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
    <span class="keyword">return</span> employee.<span class="property">rate</span> * workingHours;
  &#125;

&#125;</code></pre>

<p>前面的代码看上去完全没有问题，并且很多开发者都会按照相同的方法来做并不会有任何问题。然而，由于它是对两个角色负责，这样他就有违单一职责原则。<code>getEmployee()</code>、<code>updateEmployee()</code>和<code>deleteEmployee()</code>函数直接与 HR 管理有关，而<code>calculateEmployeeSalary()</code>则与财务管理有关。</p>
<p>将来，如果你需要为HR或财务更新一个功能时，你就必须改变 <code>ManageEmployee class</code> 来影响两个角色，因此， <code>ManageEmployee class</code> 违反了单一职责原则。你需要把HR和财务有关的功能分开，使代码符合单一职责原则。下面的代码示例证明了这一点。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">ManageEmployee</span> &#123;

  <span class="title function_">constructor</span>(<span class="params">private http: HttpClient</span>)
  <span class="variable constant_">SERVER_URL</span> = <span class="string">&#x27;http://localhost:5000/employee&#x27;</span>;

  getEmployee (empId)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
  &#125;

  updateEmployee (employee)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">put</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;employee.id&#125;</span>`</span>,employee);
  &#125;

  deleteEmployee (empId)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
  &#125;

&#125;

<span class="keyword">class</span> <span class="title class_">ManageSalaries</span> &#123;

  <span class="title function_">constructor</span>(<span class="params">private http: HttpClient</span>)
  <span class="variable constant_">SERVER_URL</span> = <span class="string">&#x27;http://localhost:5000/employee&#x27;</span>;

  calculateEmployeeSalary (empId, workingHours)&#123;
    <span class="keyword">var</span> employee = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
    <span class="keyword">return</span> employee.<span class="property">rate</span> * workingHours;
  &#125;

&#125;</code></pre>

<h2 id="Open-closed-principle"><a href="#Open-closed-principle" class="headerlink" title="Open-closed principle"></a>Open-closed principle</h2><p>Functions, modules, 和 classes 应该是可扩展的，但不是可修改的。</p>
<p>这是实现大型应用时需要遵循的一个重要原则。根据这一原则，我们应该能够很容易地为应用添加新的功能，但同时我们不应该对现有的代码引入破坏式修改。</p>
<p>举个例子，假设我们实现一个 <code>calculateSalaries()</code> 的函数，该函数使用一个带有工作角色和时薪的数组来计算工资。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">ManageSalaries</span> &#123;
  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">this</span>.<span class="property">salaryRates</span> = [
      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">role</span>: <span class="string">&#x27;developer&#x27;</span>, <span class="attr">rate</span>: <span class="number">100</span> &#125;,
      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">role</span>: <span class="string">&#x27;architect&#x27;</span>, <span class="attr">rate</span>: <span class="number">200</span> &#125;,
      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">role</span>: <span class="string">&#x27;manager&#x27;</span>, <span class="attr">rate</span>: <span class="number">300</span> &#125;,
    ];
  &#125;

  <span class="title function_">calculateSalaries</span>(<span class="params">empId, hoursWorked</span>) &#123;
    <span class="keyword">let</span> salaryObject = <span class="variable language_">this</span>.<span class="property">salaryRates</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> o.<span class="property">id</span> === empId);
    <span class="keyword">return</span> hoursWorked * salaryObject.<span class="property">rate</span>;
  &#125;
&#125;

<span class="keyword">const</span> mgtSalary = <span class="keyword">new</span> <span class="title class_">ManageSalaries</span>();
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Salary : &quot;</span>, mgtSalary.<span class="title function_">calculateSalaries</span>(<span class="number">1</span>, <span class="number">100</span>));</code></pre>

<p>直接修改 salaryRates 数组会违反开闭原则。例如，你需要为一个新角色进行工资计算。在这种情况下，你需要创建一个单独的方法，将工资添加到 salaryRates 数组中，而不是对原代码进行修改。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">ManageSalaries</span> &#123;
  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">this</span>.<span class="property">salaryRates</span> = [
      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">role</span>: <span class="string">&#x27;developer&#x27;</span>, <span class="attr">rate</span>: <span class="number">100</span> &#125;,
      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">role</span>: <span class="string">&#x27;architect&#x27;</span>, <span class="attr">rate</span>: <span class="number">200</span> &#125;,
      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">role</span>: <span class="string">&#x27;manager&#x27;</span>, <span class="attr">rate</span>: <span class="number">300</span> &#125;,
    ];
  &#125;

  <span class="title function_">calculateSalaries</span>(<span class="params">empId, hoursWorked</span>) &#123;
    <span class="keyword">let</span> salaryObject = <span class="variable language_">this</span>.<span class="property">salaryRates</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> o.<span class="property">id</span> === empId);
    <span class="keyword">return</span> hoursWorked * salaryObject.<span class="property">rate</span>;
  &#125;

  <span class="title function_">addSalaryRate</span>(<span class="params">id, role, rate</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">salaryRates</span>.<span class="title function_">push</span>(&#123; <span class="attr">id</span>: id, <span class="attr">role</span>: role, <span class="attr">rate</span>: rate &#125;);
  &#125;
&#125;

<span class="keyword">const</span> mgtSalary = <span class="keyword">new</span> <span class="title class_">ManageSalaries</span>();
mgtSalary.<span class="title function_">addSalaryRate</span>(<span class="number">4</span>, <span class="string">&#x27;developer&#x27;</span>, <span class="number">250</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Salary : &#x27;</span>, mgtSalary.<span class="title function_">calculateSalaries</span>(<span class="number">4</span>, <span class="number">100</span>));</code></pre>

<h2 id="Liskov-substitution-principle"><a href="#Liskov-substitution-principle" class="headerlink" title="Liskov substitution principle"></a>Liskov substitution principle</h2><p>假设P(y)是类型A的对象y的一个可证明属性，那么对于类型B的对象x，其中B是A的子类型，P(x)应该为真</p>
<p>你能在网上找到关于里式替换原则的不同定义，但它们都有相同的含义。简单的说，里式替换原则指出，如果父类的子类在应用中产生意外行为，我们就不应该用子类替换父类。</p>
<p>例如，有一个名为 Animal 的类，它包括一个名为 <code>eat()</code> 的函数。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;
  <span class="title function_">eat</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Animal Eats&quot;</span>)
  &#125;
&#125;</code></pre>

<p>现在，我将把 Animal 类扩展成一个名为Bird的新类，其函数名为 <code>fly()</code> 。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;
  <span class="title function_">fly</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Bird Flies&quot;</span>)
  &#125;
&#125;

<span class="keyword">var</span> parrot = <span class="keyword">new</span> <span class="title class_">Bird</span>();
parrot.<span class="title function_">eat</span>();
parrot.<span class="title function_">fly</span>();</code></pre>

<p>在之前的例子中，我根据 Bird 类创建了一个名为 parrot 的对象，并同时拥有 eat 和 fly 方法。由于鹦鹉能够完成这两个动作，因此将 Animal 类扩展到 Bird 类并不违反里式替换原则</p>
<p>现在我们进一步扩展 Bird ，创建了一个名为 Ostrich 的新类</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Bird</span>&#123;
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Ostriches Do Not Fly&quot;</span>)
&#125;

<span class="keyword">var</span> ostrich = <span class="keyword">new</span> <span class="title class_">Ostrich</span>();
ostrich.<span class="title function_">eat</span>();
ostrich.<span class="title function_">fly</span>();</code></pre>

<p>这个对 Bird 类的扩展就违反了里式替换原则，因为鸵鸟不会飞行，这可能会在应用中引发意外行为。解决这个情况的最佳方法是从 Animal 类扩展 Ostrich 类。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;

  <span class="title function_">walk</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Ostrich Walks&quot;</span>)
  &#125;

&#125;</code></pre>

<h2 id="Interface-segregation-principle"><a href="#Interface-segregation-principle" class="headerlink" title="Interface segregation principle"></a>Interface segregation principle</h2><p>客户端不应该添加他们永远不会使用的依赖接口。</p>
<p>这个原则和接口有关，主要是将大接口分为小接口。举个例子，假如你要去驾校学习如何驾驶汽车，他们给你一大套关于驾驶汽车、卡车、火车的说明。由于你只需要学习驾驶汽车，你不需要其他的信息。驾校就应该把说明分开，只给你专门针对汽车的说明。</p>
<p>由于 JavaScript 不支持 interface ，所以在基于 JavaScript 的应用中很难采用这一原则。然而，我们可以使用 JavaScript 组合来实现这一点。组合允许开发人员在不继承整个类的情况下添加功能。假设有一个名为 DrivingTest 的类，然后有两个名为 startCarTest 和 startTruckTest 的函数。然后我们有 CarDrivingTest 和 TruckDrivingTest 扩展 DrivingTest 类，然后我们必须强制这两个类实现 startCarTest 和 startTruckTest s函数。</p>
<pre><code class="highlight js"><span class="title class_">Class</span> <span class="title class_">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">userType</span> = userType;
  &#125;

  <span class="title function_">startCarTest</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(“<span class="title class_">This</span> is <span class="keyword">for</span> <span class="title class_">Car</span> <span class="title class_">Drivers</span>”’);
  &#125;

  <span class="title function_">startTruckTest</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(“<span class="title class_">This</span> is <span class="keyword">for</span> <span class="title class_">Truck</span> <span class="title class_">Drivers</span>”);
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">CarDrivingTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">super</span>(userType);
  &#125;

  <span class="title function_">startCarTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> “<span class="title class_">Car</span> <span class="title class_">Test</span> <span class="title class_">Started</span>”;
  &#125;

  <span class="title function_">startTruckTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> <span class="literal">null</span>;
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">TruckDrivingTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">super</span>(userType);
  &#125;

  <span class="title function_">startCarTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> <span class="literal">null</span>;
  &#125;

  <span class="title function_">startTruckTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> “<span class="title class_">Truck</span> <span class="title class_">Test</span> <span class="title class_">Started</span>”;
  &#125;
&#125;

<span class="keyword">const</span> carTest = <span class="keyword">new</span> <span class="title class_">CarDrivingTest</span>(carDriver );
<span class="variable language_">console</span>.<span class="title function_">log</span>(carTest.<span class="title function_">startCarTest</span>());
<span class="variable language_">console</span>.<span class="title function_">log</span>(carTest.<span class="title function_">startTruckTest</span>());

<span class="keyword">const</span> truckTest = <span class="keyword">new</span> <span class="title class_">TruckDrivingTest</span>( ruckdriver );
<span class="variable language_">console</span>.<span class="title function_">log</span>(truckTest.<span class="title function_">startCarTest</span>());
<span class="variable language_">console</span>.<span class="title function_">log</span>(truckTest.<span class="title function_">startTruckTest</span>());</code></pre>

<p>然而，这种实现方法违反了接口分离原则，因为我们强迫那两个扩展类实现这两种功能。我们可以通过组合来为所需的类添加功能来解决这个问题，如下面的例子中所示。</p>
<pre><code class="highlight js"><span class="title class_">Class</span> <span class="title class_">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">userType</span> = userType;
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">CarDrivingTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">super</span>(userType);
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">TruckDrivingTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">super</span>(userType);
  &#125;
&#125;

<span class="keyword">const</span> carUserTests = &#123;
  <span class="title function_">startCarTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> ‘<span class="title class_">Car</span> <span class="title class_">Test</span> <span class="title class_">Started</span>’;
  &#125;,
&#125;;

<span class="keyword">const</span> truckUserTests = &#123;
  <span class="title function_">startTruckTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> ‘<span class="title class_">Truck</span> <span class="title class_">Test</span> <span class="title class_">Started</span>’;
  &#125;,
&#125;;

<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">CarDrivingTest</span>.<span class="property"><span class="keyword">prototype</span></span>, carUserTests);
<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">TruckDrivingTest</span>.<span class="property"><span class="keyword">prototype</span></span>, truckUserTests);

<span class="keyword">const</span> carTest = <span class="keyword">new</span> <span class="title class_">CarDrivingTest</span>(carDriver );
<span class="variable language_">console</span>.<span class="title function_">log</span>(carTest.<span class="title function_">startCarTest</span>());
<span class="variable language_">console</span>.<span class="title function_">log</span>(carTest.<span class="title function_">startTruckTest</span>()); <span class="comment">// Will throw an exception</span>

<span class="keyword">const</span> truckTest = <span class="keyword">new</span> <span class="title class_">TruckDrivingTest</span>( ruckdriver );
<span class="variable language_">console</span>.<span class="title function_">log</span>(truckTest.<span class="title function_">startTruckTest</span>());
<span class="variable language_">console</span>.<span class="title function_">log</span>(truckTest.<span class="title function_">startCarTest</span>()); <span class="comment">// Will throw an exception</span></code></pre>

<p>现在， <code>carTest.startTruckTest()</code> 将抛出一个异常，因为 <code>startTruckTest()</code> 函数没有分配给 CarDrivingTest 类。</p>
<h2 id="Dependency-inversion-principle"><a href="#Dependency-inversion-principle" class="headerlink" title="Dependency inversion principle"></a>Dependency inversion principle</h2><p>高层模块应该使用抽象化。并且，他们不应该依赖于低层模块。</p>
<p>依赖倒置是关于解耦代码的。遵循这个原则将使你能够灵活地在最高级别上扩展和改变你的应用而不出现任何问题。</p>
<p>关于JavaScript，我们不需要考虑抽象的问题，因为JavaScript是一种动态语言。然而，我们需要确保高层模块不依赖于低层模块。</p>
<p>我们来用一个简单的例子来解释依赖倒置是如何工作的。假设你在你的应用中需要使用 Yahoo 的 email API ，现在你需要把它改为 Gmail 的 API 。如果你像下面的例子一样实现了没有依赖倒置的控制器，你需要对每个控制器都进行修改。这是因为多个控制器使用了 Yahoo API ，你需要找到每个实例并更新它。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">EmailController</span> &#123; 
  <span class="title function_">sendEmail</span>(<span class="params">emailDetails</span>) &#123; 
    <span class="comment">// Need to change this line in every controller that uses YahooAPI.const response = YahooAPI.sendEmail(emailDetails); </span>
    <span class="keyword">if</span> (response.<span class="property">status</span> == <span class="number">200</span>) &#123; 
       <span class="keyword">return</span> <span class="literal">true</span>;
    &#125; <span class="keyword">else</span> &#123;
       <span class="keyword">return</span> <span class="literal">false</span>;
    &#125;
  &#125;
&#125;</code></pre>

<p>依赖倒置原则可以帮助开发者避免这种高昂的错误，在这个原则下，将 email API 处理部分转移到一个单独的控制器。然后你只需要在 email API 发生改变时改变该控制器即可。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">EmailController</span> &#123; 
  <span class="title function_">sendEmail</span>(<span class="params">emailDetails</span>) &#123; 
    <span class="keyword">const</span> response = <span class="title class_">EmailApiController</span>.<span class="title function_">sendEmail</span>(emailDetails);   
    <span class="keyword">if</span> (response.<span class="property">status</span> == <span class="number">200</span>) &#123; 
       <span class="keyword">return</span> <span class="literal">true</span>;
    &#125; <span class="keyword">else</span> &#123;
       <span class="keyword">return</span> <span class="literal">false</span>;
    &#125;
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">EmailApiController</span> &#123;
  <span class="title function_">sendEmail</span>(<span class="params">emailDetails</span>) &#123;
    <span class="comment">// Only need to change this controller. return YahooAPI.sendEmail(emailDetails);</span>
  &#125;
&#125;</code></pre>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在这篇文章中，我们讨论了在软件设计中SOLID原则的重要性，以及我们如何在JavaScript应用中采用这些概念。作为开发人员，理解并在我们的应用中使用这些核心概念是很重要的。有时，在处理一些小的应用时，这些原则的好处可能并不明显，但一旦你开始在一个大规模的项目上工作时，你一定会知道它们的不同。</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Stop using &amp;&amp; in React Conditional Rendering</title>
    <url>/2023/05/20/%E3%80%90%E7%BF%BB%E3%80%91Stop-using-in-React-Conditional-Rendering/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://www.crocoder.dev/blog/react-conditional-rendering/">Stop using &amp;&amp; in React Conditional Rendering</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>条件渲染是React中的一项技术，它允许你根据某些条件来展示或隐藏用户界面的一部分。这意味着你可以根据你应用程序在任何时间发生的情况来显示不同的内容和组件</p>
<p>比如，你正在构建一个网站，用户可以登录并查看他们的个人资料信息。当用户没有登录时，你可能想展示一个登录表单。但当用户登录后，你可能想展示他们的资料信息。</p>
<p>让我们看看React中条件渲染的一个例子。</p>
<h3 id="The-CrocDemo-component"><a href="#The-CrocDemo-component" class="headerlink" title="The CrocDemo component"></a>The CrocDemo component</h3><pre><code class="highlight js"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;

<span class="keyword">const</span> <span class="title class_">CrocDemo</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;
  <span class="keyword">const</span> crocodiles = [<span class="string">&#x27;Lyle&#x27;</span>, <span class="string">&#x27;Snappy&#x27;</span>, <span class="string">&#x27;Mr. Vile&#x27;</span>];

  <span class="keyword">const</span> dodos = [];

  <span class="keyword">return</span> (
    <span class="language-xml"><span class="tag">&lt;&gt;</span></span>
<span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;crocodiles.length &amp;&amp; `crocodiles: $&#123;crocodiles.map(() =&gt; &#x27;🐊&#x27;).join(&#x27; &#x27;)&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;dodos.length &amp;&amp; `dodos: $&#123;dodos.map(() =&gt; &#x27;🦤&#x27;).join(&#x27; &#x27;)&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span>
<span class="language-xml">    <span class="tag">&lt;/&gt;</span></span>
  );
&#125;;</code></pre>

<p>这段代码定义了一个名为<code>CrocDemo</code>的React组件</p>
<p>在这个组件中，定义了两个数组：<code>crocodiles</code>和<code>dodos</code>。crocodiles数组包含三条鳄鱼的名字。而dodos数组是空的。这是当然的，因为渡渡鸟已经灭绝了</p>
<p>然后该组件返回了一些JSX代码，包括两个div元素，第一个div元素显示鳄鱼的名字，第二个div元素显示渡渡鸟的名字。</p>
<p>这段代码中有意思的一部分是如何展示这些名字。div元素使用一种叫做条件渲染的技术来决定是否显示名字。</p>
<p>第一个div元素检查crocodies数组的长度是否大于0。如果是，这个div元素就会显示crocodiles文本，然后是一系列的鳄鱼表情。这些表情是用map函数创建，它根据原数组中的鳄鱼数量生成一个新的表情数组，然后用join函数将这些表情连接成一个字符串，显示在div元素内。</p>
<p>第二个div元素按照相同的模式，当它检查dodos数组的长度是否大于0。由于dodos数组是空的，所以这个div元素不会显示任何东西。</p>
<p>所以，最终的结果是，如果鳄鱼数组中有任何鳄鱼，CrocDemo组件就会显示鳄鱼的名字(表情符号)，而对dodos数组则不显示。</p>
<p>至少没有展示关于dodos数组的内容。</p>
<pre><code class="highlight text">crocodiles: 🐊 🐊 🐊
0</code></pre>

<p>嗯… 看起来是有一个随机的0，我们期望的是什么都不展示，这是为什么呢？</p>
<p>让我们试着用具有不同<code>false value</code>的<code>&amp;&amp;</code>运算符来了解发生了什么</p>
<pre><code class="highlight js"><span class="comment">/* This won&#x27;t render anything ✅ */</span>
&lt;&gt;&#123;<span class="literal">false</span> &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&lt;/&gt;

<span class="comment">/* This will render 0 😡 */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;0 &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;&quot;&quot;  &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;null &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;undefined &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This will render NaN 😡 */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;NaN &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span></code></pre>

<p>在JavaScript中，<code>&amp;&amp;</code>运算符会检查左右操作对象是否都是true，如果左边的操作对象是false，那么右边的操作对象就不会被检查，并且<code>&amp;&amp;</code>运算符会返回左边的操作对象</p>
<p>在表达式<code>&#123;0 &amp;&amp; &lt;div&gt;👋&lt;/div&gt;&#125;</code>中，左边的操作对象是0，这在javascript中是一个<code>false value</code>，因为左边的操作对象是false，所以右边的操作对象不会被检查。并且返回左边的操作对象，也就是0</p>
<p>当React试图渲染该组件时，它将0解释为一个字符串，并将其渲染到页面上。😡😡😡</p>
<p>NaN的情况是一样的。</p>
<pre><code class="highlight js"><span class="comment">/* This will render NaN 😡 */</span>
&lt;&gt;&#123;<span class="title class_">NaN</span> &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&lt;/&gt;</code></pre>

<p>那么，我们怎么解决这个问题呢？</p>
<h3 id="Use-the-ternary-operator"><a href="#Use-the-ternary-operator" class="headerlink" title="Use the ternary operator"></a>Use the ternary operator</h3><p>有几种方法可以解决这个问题。第一个(也是最好的)方法是使用三元运算符。三元运算符是一个条件运算符，它检查一个条件是否为true。如果条件为true，它返回第一个操作对象，如果条件为false，这返回第二个操作对象。</p>
<pre><code class="highlight js"><span class="comment">/* This won&#x27;t render anything ✅ */</span>
&lt;&gt;&#123;<span class="number">0</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>&#125;&lt;/&gt;

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;NaN ? <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span> : null&#125;<span class="tag">&lt;/&gt;</span></span></code></pre>

<h3 id="Convert-falsy-values-to-Boolean"><a href="#Convert-falsy-values-to-Boolean" class="headerlink" title="Convert falsy values to Boolean"></a>Convert falsy values to Boolean</h3><p>另外，我们可以把所有的false转为boolean，或者使用<code>!!</code>运算符，<code>!!</code>运算符是将一个值转为布尔值的，它本质上是将一个true value或者false value转换为true或false的一个速记方法。</p>
<pre><code class="highlight js"><span class="comment">/* This won&#x27;t render anything ✅ */</span>
&lt;&gt;&#123;<span class="title class_">Boolean</span>(<span class="number">0</span>) &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&lt;/&gt;

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;Boolean(NaN) &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;!!0 &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;!!NaN &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span></code></pre>

<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>条件渲染是React中的一项技术，它允许你根据某些条件来展示或者隐藏用户界面的某些部分。当你想根据应用程序中发生的事情来显示不同的内容或组件时，这很有用。</p>
<p>然而，在使用<code>&amp;&amp;</code>运算符时，有一个问题，如0和NaN这样的false value，会意外地导致意外的渲染。</p>
<p>为了解决这个问题，我们可以使用三元运算符或将false value转换为boolean。这些技术将有助于确保你的React组件完全呈现出你所期望的效果。</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】“return null” vs “return false” in React</title>
    <url>/2023/05/13/%E3%80%90%E7%BF%BB%E3%80%91%E2%80%9Creturn-null%E2%80%9D-vs-%E2%80%9Creturn-false%E2%80%9D-in-React/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://caglayanyanikoglu.medium.com/return-null-vs-return-false-in-react-826d8abcc429">“return null” vs “return false” in React</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>大家好，在本周的#SundayTechMusings，我将尝试解释在React中”return null”和”return false”之间的区别。</p>
<p>这实际上与性能有关，在写之前，你可以看看我的文章<a href="https://tech.jotform.com/react-performance-improvements-356f81b1904f">Performance Optimization Techniques</a></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*yaIvvEwXKIvFQ_8g"></p>
<p>我知道很多人认为”return null”和”return false”是一样的，实际上是非常相似的，但是也有一些区别，这和React的工作方式有关。</p>
<p>在使用React开发时，通常会使用条件渲染根据不同的条件显示不同的组件。在一些条件下，你可能想明确指出一个组件不应该渲染任何东西。这就是null和false的来历，虽然这两个值都会阻止一个组件的渲染，但是它们之间有着重要的区别。</p>
<h3 id="Returning-null"><a href="#Returning-null" class="headerlink" title="Returning null"></a>Returning null</h3><p>当一个组件返回null，它会告诉React不要在DOM中为该组件渲染任何东西。当你想要根据某种状态有条件地渲染一个组件时，但不希望在不符合该状态时显示任何东西时，返回null就很有用，比如说：</p>
<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">Greeting</span> = (<span class="params">props</span>) =&gt; &#123;
  <span class="keyword">if</span> (!props.<span class="property">name</span>) &#123;
    <span class="keyword">return</span> <span class="literal">null</span>;
  &#125;

  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;
&#125;;</code></pre>

<p>在上面的例子中，如果没有提供 <code>name</code> prop，组件会返回null，这样就不会渲染<code>&lt;h1&gt;</code>元素。如果提供了 <code>name</code> prop，该组件就会渲染带有实际内容的<code>&lt;h1&gt;</code>元素，这实际上是每个人的经典做法。</p>
<h3 id="Returning-false"><a href="#Returning-false" class="headerlink" title="Returning false"></a>Returning false</h3><p>当一个组件返回false时，它告诉会React不要再DOM中为该组件渲染任何东西，就像null一样。然而，有一个重要的区别：返回false也会阻止该组件在未来的更新。这是因为React将false解释为“卸载”组件的信号，这意味着从DOM中完全删除它。</p>
<p>下面是一个返回false的组件的例子：</p>
<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">props</span>) =&gt; &#123;
  <span class="keyword">if</span> (!props.<span class="property">onClick</span>) &#123;
    <span class="keyword">return</span> <span class="literal">false</span>;
  &#125;

  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;
&#125;;</code></pre>

<p>在这个例子中，如果没有提供 <code>onClick</code> prop，组件就会返回false，从而阻止 <code>&lt;button&gt;</code>元素渲染。如果提供了 <code>onClick</code> prop，组件会用指定的点击处理来渲染 <code>&lt;button&gt;</code> 元素</p>
<p>值得注意的是，返回false可能会有意想不到的后果，比如在应该更新的时候阻止组件的更新。出于这个原因，当你想在不影响未来更新的情况下阻止渲染，使用null通常更安全</p>
<p>从一个组件的渲染方法中返回false，只有在该组件没有任何副作用时才有用，比如更新状态或者触发API请求。如果一个组件有副作用并返回false时，这些副作用仍然会发生，可能会导致意外的行为。</p>
<p><a href="https://github.com/facebook/react/blob/main/packages/react/src/ReactElementValidator.js#L347-L385">react&#x2F;ReactElementValidator.js at main</a></p>
<p>如果你在React库中检查上面这段代码时，你会看到一个”null”检查，为了更好的理解React的工作，你可以看看这段代码。</p>
<h3 id="To-sum-up"><a href="#To-sum-up" class="headerlink" title="To sum up"></a>To sum up</h3><p>总而言之，返回null和返回false都会阻止一个组件在DOM中渲染任何东西，但它们之间有重要的区别。null是一个简单的方法来有条件的渲染一个组件，并且不影响未来的更新，而false则是向React发出卸载组件的信号，并可能导致意想不到的后果。为你特定的用例选择正确的选项是很重要的</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>前端的Docker学习记录</title>
    <url>/2022/10/30/%E5%89%8D%E7%AB%AF%E7%9A%84Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><ul>
<li>Docker 是一个应用<strong>打包</strong>、<strong>分发</strong>、<strong>部署</strong>的工具，可以使应用部署更加轻量，可移植，可扩展，可以理解为一个轻量的虚拟机<ul>
<li>打包：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</li>
<li>分发：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装</li>
<li>部署：拿着“安装包”就可以一个命令运行起来应用，自动模拟出一模一样的运行环境，不管是在Windows&#x2F;Mac&#x2F;Linux</li>
</ul>
</li>
<li>docker架构图<br><img src="https://s1.ax1x.com/2022/10/30/xI2lGR.png"></li>
</ul>
<ul>
<li><strong>docker client</strong>: 即docker命令行工具</li>
<li><strong>docker host</strong>: 宿主机，docker daemon的运行环境服务器</li>
<li><strong>docker daemon</strong>: docker的守护进程，docker client通过命令行与docker daemon交互</li>
<li><strong>image</strong>: 镜像，可以理解为安装包，可以方便的进行传播和安装</li>
<li><strong>container</strong>: 容器，镜像的运行实例，每个软件运行环境都是独立的，隔离的</li>
<li><strong>registry</strong>: 镜像仓库，可以从镜像仓库拉取和推送镜像</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>docker底层使用了一些linux内核的特性，<code>namespace</code>，<code>cgroups</code>，<code>unionFS</code></p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><ul>
<li>namespace，也叫命名空间，名称空间，它表示一个标识符的可见范围。一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它不会与任何已有的标识符发生冲突，因为已有的定义都处于其他命名空间中</li>
<li>docker使用linux namespace构建隔离的环境，它由以下namespace组成<ul>
<li>pid：隔离进程</li>
<li>net：隔离网络</li>
<li>ipc：隔离IPC</li>
<li>mnt：隔离文件系统挂载</li>
<li>uts：隔离hostname</li>
<li>user：隔离uid&#x2F;gid</li>
</ul>
</li>
</ul>
<h3 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h3><ul>
<li>cgroups，是控制组群(control groups)的简写，是用来限制、控制与分离一个进程组的资源(如CPU、内存、磁盘输入输出等)</li>
<li>cgroups功能：<ul>
<li>资源限制：设置内存限制，包括虚拟内存</li>
<li>优先级：一些资源可以得到大量的CPU或磁盘IO吞吐量</li>
<li>结算：用来度量系统实际用了多少资源</li>
<li>控制：冻结组或检查点和重启动</li>
</ul>
</li>
</ul>
<h3 id="unionFS"><a href="#unionFS" class="headerlink" title="unionFS"></a>unionFS</h3><ul>
<li>unionFS(Union file systems)是一种分层、轻量级并且高性能的文件性能，支持对文件系统的修改作为一次提交来一层层的叠加。docker的镜像与容器就是分层存储，可用的存储引擎呦aufs，overlay等</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul>
<li>镜像是一份用来创造容器的配置文件，而容器可以视作最小型的一个操作系统</li>
<li>docker的镜像和容器都使用了unionFS做分层存储，镜像作为只读层是共享的，而容器在镜像之上附加了一层可写层，最大程度地减少了空间的浪费</li>
<li>镜像的相关命令<ul>
<li>镜像拉取：<code>docker pull node:alpine</code></li>
<li>查看镜像信息：<code>docker inspect node:alpine</code></li>
<li>列出所有镜像：<code>docker images</code></li>
<li>镜像打包：<code>docker build -t docker-app:v1.0.0</code><ul>
<li><code>-t</code>：设置镜像名字和版本号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul>
<li>Dockerfile是docker构建镜像的配置文件，比如一个简单的Dockerfile如下<pre><code class="highlight dockerfile"><span class="keyword">FROM</span> node:<span class="number">16</span>
<span class="keyword">MAINTAINER</span> songlh

<span class="keyword">ADD</span><span class="language-bash"> . /app</span>
<span class="keyword">WORKDIR</span><span class="language-bash"> /app</span>

<span class="keyword">RUN</span><span class="language-bash"> npm install pnpm -g</span>
<span class="keyword">RUN</span><span class="language-bash"> pnpm install</span>

<span class="keyword">CMD</span><span class="language-bash"> pnpm run dev</span></code></pre></li>
<li>常用指令</li>
<li><code>FROM</code>：表示基于一个已有的基础镜像，<code>FROM &lt;image&gt; [AS &lt;name&gt;]</code></li>
<li><code>MAINTAINER</code>：声明dockerfile镜像构建的作者</li>
<li><code>ADD</code>：表示把宿主机的文件或目录加入到镜像的文件系统，<code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>RUN</code>: 在镜像中执行命令，由于ufs的文件系统，它会在当前镜像的顶层新增一层，<code>RUN &lt;command&gt;</code></li>
<li><code>CMD</code>: 指定容器如何启动，一个Dockerfile中只允许有一个CMD</li>
<li><code>WORKDIR</code>：设置工作目录</li>
<li><code>ENV</code>：设置环境变量</li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul>
<li><code>docker run</code>：创建容器<ul>
<li><code>docker run -p 8080:8080 --name docker-hello docker-app:v1.0.0</code>表示基于docker-app镜像的v1.0.0版本创建一个容器并在本地的8080端口运行，容器名字叫<code>docker-hellp</code></li>
<li><code>-p host-port:container-port</code>：宿主机与容器端口映射，方便容器对外提供服务</li>
<li><code>--name</code>：为容器指定名称</li>
<li><code>-d</code>：后台运行</li>
<li><code>--rm</code>：当停止容器时自动清除容器</li>
</ul>
</li>
<li><code>docker stop</code>：停止容器</li>
<li><code>docker rm</code>：删除容器</li>
<li><code>docker exec -it container-name</code>：进入容器环境</li>
<li><code>docker ps</code>：列出所有容器</li>
<li><code>docker port</code>：查看容器端口映射</li>
<li><code>docker stats</code>：查看容器资源占用</li>
</ul>
<h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><ul>
<li>按照目前已有知识，如果改了项目代码不会立刻生效，需要重新build和run，很麻烦，而且容器产生的数据，如果容器删除了就会没有，目录挂载就是为了解决这些问题</li>
<li>目前的挂载方式<ul>
<li><code>bind mount</code>：直接把宿主机目录映射到容器内，适合挂载代码目录和配置文件，可挂载到多个容器上</li>
<li><code>volume</code>：由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux文件系统，适合存储数据库数据。可挂载到多个容器上</li>
<li><code>tmpfs mount</code>：适合存储临时文件，存储在宿主机内存中。不可多容器共享</li>
<li><img src="https://s1.ax1x.com/2022/10/30/xI2Qi9.png"></li>
</ul>
</li>
</ul>
<h3 id="bind-mount"><a href="#bind-mount" class="headerlink" title="bind mount"></a>bind mount</h3><ul>
<li><code>bind mount</code>是通过<code>-v</code>参数来绑定宿主机目录，比如将外部的html文档挂载到Nginx容器的根目录下<ul>
<li><code>docker run -v ~/html:/usr/share/nginx/html -p 81:80 -d --name nginx_bind nginx:latest</code></li>
</ul>
</li>
<li>这种方式的缺点就是被挂载的宿主机目录(或文件)不受保护，任何容器都可以随意修改</li>
</ul>
<h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><ul>
<li>volume也是一个文件，但是这个文件是在docker的管控范围内，docker可以通过挂载的设定来控制容器对volume的读写权限</li>
<li>通过<code>docker volume create volume-name</code>创建一个Volume，实际上是在docker的<code>/var/lib/docker/volumes/</code>文件夹内创建一个相同名字的文件夹来保存数据</li>
<li>比如设置一个只能读取volume<ul>
<li><code>docker run --mount type=volume,source=nginx-volume,destination=/usr/share/nginx/html,readonly -p 82:80 -d --name nginx_volume nginx:latest</code></li>
</ul>
</li>
</ul>
<h3 id="tmpfs-mount"><a href="#tmpfs-mount" class="headerlink" title="tmpfs mount"></a>tmpfs mount</h3><ul>
<li>tmpfs挂载是临时的，仅保留在主机内存中。当容器停止时，tmpfs挂载被移除，写入的文件不会被持久化</li>
<li><code>docker run --mount type=tmpfs,destination=/usr/share/nginx/html -p 83:80 -d --name nginx-tempfs nginx:latest</code></li>
<li>tmpfs因为不是持久化，一般不使用</li>
</ul>
<h2 id="容器通信"><a href="#容器通信" class="headerlink" title="容器通信"></a>容器通信</h2><ul>
<li>容器间的通信根据媒介可以分为：volume共享通信、网络通信</li>
<li>根据通信范围可以分为：同主机通信、跨主机通信</li>
</ul>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul>
<li>Docker的网络通信模型分为以下几种，在安装Docker以后，会默认创建三种网络，可以通过<code>docker network ls</code>查看<ul>
<li><strong>bridge</strong>：为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code>虚拟网桥，默认为该模式</li>
<li><strong>host</strong>：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</li>
<li><strong>none</strong>：容器有独立的<code>network namespace</code>，但并没有对其进行任何网络设置，如分配<code>veth pair</code>和网桥连接，IP等</li>
<li><strong>overlay</strong>：可以连接多个docker守护进程或者满足集群服务之间的通信，适用于不同宿主机上的docker容器之间的通信</li>
<li><strong>macvlan</strong>: 可以为docker容器分配MAC地址，使其像真实的物理及一样运行</li>
</ul>
</li>
<li>Docker内置的<code>bridge network</code>，也就是docker0接口所属的network，所有未指定network的容器，默认连接到此network中，其网段未<code>172.17.0.1/16</code>，所以两个未进行任何连接操作的容器是可以通过IP地址互相通信的，因为他们同在一个network下，但通信只能通过IP地址进行，不可以通过容器名通信<ul>
<li><img src="https://s1.ax1x.com/2022/10/30/xI21R1.png"></li>
</ul>
</li>
<li>创建自定义网络：<code>docker network create custom_network</code></li>
<li>查看网络模式：<code>docker network ls</code></li>
<li>通过自定义网络创建容器：<code>docker run -di --name docker-app --net custom_network docker-app:v1.0.0</code></li>
<li>查看容器的网络信息：<code>docker inspect 容器名称|ID</code>，然后在<code>NetworkSettings</code>节点中可以看到</li>
<li>为容器连接新的网络：<code>docker network connect 网络名称 容器名称</code></li>
<li>断开网络：<code>docker network disconnect 网络名称 容器名称</code></li>
</ul>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><ul>
<li>docker-compose是用于定义和运行多容器Docker应用程序的工具。通过compose，您可以使用YML文件来配置应用程序需要的所有服务，然后使用一个命令就可以从YML文件配置中创建并启动所有服务</li>
<li>使用分三步<ul>
<li><ol>
<li>使用Dockerfile定义应用程序的环境</li>
</ol>
</li>
<li><ol start="2">
<li>使用docker-compose.yml定义构成应用程序的服务，这样它们可以在隔离环境中一起运行</li>
</ol>
</li>
<li><ol start="3">
<li>最后，执行docker-compose up命令启动并运行整个应用程序</li>
</ol>
</li>
</ul>
</li>
<li>比如运行一个web项目和redis，可以编写一个如下的<code>docker-compose.yml</code>文件<pre><code class="highlight yml"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span>

<span class="attr">services:</span>
  <span class="attr">app:</span>
    <span class="attr">build:</span> <span class="string">./</span>
    <span class="attr">ports:</span>
      <span class="bullet">-</span> <span class="number">80</span><span class="string">:8080</span>
    <span class="attr">volumes:</span>
      <span class="bullet">-</span> <span class="string">./:/app</span>
  <span class="attr">redis:</span>
    <span class="attr">image:</span> <span class="string">redis:5.0.13</span>
    <span class="attr">volumes:</span>
      <span class="bullet">-</span> <span class="string">redis:/data</span>
<span class="attr">volumes:</span>
  <span class="attr">redis:</span></code></pre></li>
<li>version：指定本yml依从的compose哪个版本指定的</li>
<li>build: 指定构建镜像上下文路径</li>
<li>image：指定启动容器的镜像</li>
<li>volumes：卷挂载路径设置，如果跨多个服务并重用挂载卷，可以在volumes关键字中命名挂载卷</li>
<li>ports：暴露端口信息</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/Mr_YanMingXin/article/details/123016807">浅谈Docker底层原理</a></li>
<li><a href="https://docker.easydoc.net/">Docker快速入门</a></li>
<li><a href="https://q.shanyue.tech/deploy/docker.html#%E6%9C%AF%E8%AF%AD">Docker使用指南</a></li>
<li><a href="https://juejin.cn/post/6993979788020940830">Docker与数据：三种挂载方式</a></li>
<li><a href="https://www.cnblogs.com/mrhelloworld/p/docker11.html">Docker 网络模式详解及容器间网络通信</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Why Japanese Websites Look So Different</title>
    <url>/2023/06/10/%E3%80%90%E7%BF%BB%E3%80%91Why-Japanese-Websites-Look-So-Different/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://medium.com/@mirijam.missbichler/why-japanese-websites-look-so-different-2c7273e8be1e">Why Japanese Websites Look So Different</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>多年以来，我多次接触过日本网站，无论是研究签证、计划旅行，还是简单的在网上购物。我花了很长时间才习惯下面这样的文字布局，使用大量鲜艳的颜色和十多种不同的字体</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfpAOTRBmUP6k80b2GNGlg.png"></p>
<p>对于习惯使用西方网站的人，有许多网站设计的简约且易于浏览，但是为什么这种更加复杂的风格在日本却很流行。</p>
<p>澄清一下，这些不是过去的网站，是现在正在维护的网站，比如下面这个网站最后一次更新是在2023年。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52jHrlyvsqRw2l7hwfMS5A.png"></p>
<p>我们可以从几个不同角度来分析这种设计：</p>
<ul>
<li>字体和网站开发的限制</li>
<li>技术发展停滞</li>
<li>机构缺乏数字素养</li>
<li>文化的影响</li>
</ul>
<p>就像大多数话题一样，可能没有一个正确的答案。这种网站设计是各种因素长期互相作用的结果</p>
<h2 id="Fonts-amp-Front-End-Website-Development-Constraints"><a href="#Fonts-amp-Front-End-Website-Development-Constraints" class="headerlink" title="Fonts &amp; Front-End Website Development Constraints"></a>Fonts &amp; Front-End Website Development Constraints</h2><p>为罗马语言创建新的字体是一个很好的挑战，每个人只要对字体设计有基本的了解，并且用适当的程序和一些时间就可以承受，但是为日语创建字体是一个很难的事情</p>
<p>首先如果从头创建一个英语字体，你会看到大约230个字形，一个字形是一个字母的单独展示(A a a 算3个字形)，如果你想覆盖所有基于拉丁字母的语言，就需要840个字形。但是对于日语，由于三种不同的书写系统和无数的汉字，你就会看到7000 - 16000个字形甚至更多。因此，创建一个新的日语字体需要一个有组织的团队花费比拉丁语字体相当多的时间才可能</p>
<p>毫不奇怪，对于中文和(汉字)韩文字体来说，类似的工作量也是必然的，这导致这些语言通常被所谓的CJK字体所覆盖</p>
<p>随着越来越少的设计师接受这一特殊挑战，在建立一个网站时可供选择的字体也就越来越少。再加上缺乏大写字体和日文字体，需要引入较大体积的库，会导致加载时间过长，最终你就需要使用不同的方法，来创建视觉层次。</p>
<p>我们可以拿美国和日本的星巴克主页为例：</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfaaGd_Bl2fTN9uqAT-bKA.png"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-TiKrBADjkMrnHjBAQ4bQ.png"></p>
<p>就这样，我们可以解释为什么对于许多日本网站倾向于用文字密集的图像来表示内容类别。有时候你甚至可以看到每个瓷砖都使用自己特定的字体，特别是限时优惠时。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Imrz53GsvI3Jmibv4Lltxw.png"></p>
<h2 id="Technological-Development-x2F-Stagnation-amp-Institutional-Digital-Literacy"><a href="#Technological-Development-x2F-Stagnation-amp-Institutional-Digital-Literacy" class="headerlink" title="Technological Development&#x2F;Stagnation &amp; Institutional Digital Literacy"></a>Technological Development&#x2F;Stagnation &amp; Institutional Digital Literacy</h2><p>虽然关于 “失去的十年” 和日本技术进步的关系有无数的讨论，但我最喜欢这个总结：</p>
<blockquote>
<p>Japan, living in the year 2000 since 1985. (<a href="https://www.reddit.com/r/japan/comments/10herkr/comment/j59m31c/?context=3">thanks Reddit</a>)</p>
</blockquote>
<p>如果你对日本感兴趣，你可能会熟悉先进技术和过时技术的这种对比，这种对比在许多地方都存在。作为世界机器人领域的领先者之一，将一座<a href="https://www.unicorn-gundam-statue.jp/en/">真人大小的高达雕像</a>放在御台场人工岛上的国家，却仍然依赖软驱和传真机，并在2022年时面对<a href="https://www.bloomberg.com/news/articles/2022-06-15/end-of-internet-explorer-era-spells-trouble-for-japan-businesses?leadSource=uverify%20wall#xj4y7vzkg">windows ie关闭</a>陷入恐慌</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDYVc3z22_A-ELz8Q1KHIw.png"></p>
<p>在德国，前总理安格拉-默克尔在2013年称互联网为 “未知领域”（德文原话：”Das Internet ist für uns alle Neuland”）后，被全国取笑。然而，这一情况被前网络安全部长樱田义孝在2018年超越。据报道，他声称从未使用过计算机，并且当在议会被问及USB驱动器的概念时，他“困惑不解”(<a href="https://www.theguardian.com/world/2018/nov/15/japan-cyber-security-ministernever-used-computer-yoshitaka-sakurada">来源</a>)。</p>
<p>对于那些没有机会看到幕后的人来说，这样的状况可能听起来很奇怪。因为日本在技术素养方面，一直严重滞后。因此，推断这些问题对日本网站设计发展也起到了一点阻碍的作用。而且，日本的网站设计也面临着这种困境。只需在谷歌或Pinterest上搜索日本海报设计，就能见证一种截然不同且现代化的平面设计水平。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4nu6H_pheQBXEiAIZz6jA.png"></p>
<h2 id="Cultural-Influence"><a href="#Cultural-Influence" class="headerlink" title="Cultural Influence"></a>Cultural Influence</h2><p>在分析任何类型的设计选择时，文化习俗、倾向、偏见和偏好都不应被低估。然而，“这是文化”的观点存在过于简化主题的风险，并可能被用作为各种差异辩护的借口。而要摆脱个人的观点偏见是困难的，甚至不可能完全做到。</p>
<p>所以，从我们的角度来看，很容易看待这个网站…</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Tgk9_5Ci-B4DoITuGqQTw.png"></p>
<p>…感觉难以接受，并且认为它的设计很糟糕，然后宣布结束。因为谁会使用这个混乱无序的网站呢？</p>
<p>正是因为这种无知，这些有趣的见解就被忽视了。现在，我不能确切的告诉你日本文化如何影响了这种设计。然而，我很幸运地能够从与日本本土人的对话中获得启示，也有在日本工作和生活的经验可以借鉴。</p>
<p>我曾经参与过一次与这个分析相关但与网站无关的对话，是关于YouTube的缩略图，因为这同样让人难以接受</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lwaEIIIUc5peoMMo6fM_Q.png"></p>
<p>对于一个习惯了许多西方频道使用的极简和光滑设计的人来说，以一个标题，反复出现的调色板和有限的字体为特色，上面的缩略图让人难以接受，我曾问一个日本人为什么许多非常受欢迎的频道的缩略图都是这样设计的，然而，他非常惊讶这种视为混乱的想法。他认为日本人的视频看起来更有吸引力，提供了一些能让人抓住的信息，让人们更容易决定视频是否有趣。我给他看英文视频缩略图做对比时，他认为非常模糊且无聊。</p>
<p>而正是这种寻求信息的态度，可能是我们的观念出现如此大分歧的根本原因。在日本，规避风险、反复检查和对做决定时的犹豫不决的程度明显高于西方国家。这与更多的集体主义社会心态密切相关，比如，将一份文件发送给商业伙伴之前，进行双重（或三重）检查可能会花费更多时间，但却大大降低错误溜走的风险，从而防止相关人员丢脸。</p>
<p>回到网站设计，这个文化角度更能助于解释为什么网上购物、新闻和政府网站从外部来看往往是”最糟糕的犯罪者”。毕竟，在这些情况下，大量的细节直接对应着好的的购买决策、高效地保持最新信息或确保你拥有某个流程的所有必要信息。</p>
<p>有趣的是，关于美国人和中国&#x2F;日本人对信息的感知方式，有着大量研究。一些研究的结果似乎表明，日本人对信息的感知更加全面，而美国人则倾向于选择一个焦点来引导他们的注意力(<a href="https://www.wired.com/2008/03/japanese-more-s/">来源</a>)。这就给我们提供了一个解释，为什么西方人即使在日语水平很高的情况下也很难使用这类网站</p>
<p>最后，需要指出，网站不是单独存在的。从杂志到地铁里的广告等各种媒体也尽可能在小的空间里塞进尽可能多的信息，人们可能只是习惯了这种无处不在的展示导致没有人想要质疑它。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6KRgu_BarZlRVPehgytsA.png"></p>
<p>长话短说，这既不是为了找到标题的绝对答案，也不是为了加强日本人独特性的概念。相反，特别是看到一些专注于将某种解释视为“真正答案”的讨论后，我想要说明科技、历史和文化影响的范围导致最终形成的这种差异。</p>
<h2 id="Sources-amp-further-reading"><a href="#Sources-amp-further-reading" class="headerlink" title="Sources &amp; further reading"></a>Sources &amp; further reading</h2><h3 id="Fonts-amp-Typography"><a href="#Fonts-amp-Typography" class="headerlink" title="Fonts &amp; Typography"></a>Fonts &amp; Typography</h3><p>Interview with Font Designer Akira Kobayashi: <a href="https://www.smashingmagazine.com/2015/04/interview-with-akira-kobayashi/">https://www.smashingmagazine.com/2015/04/interview-with-akira-kobayashi/</a></p>
<p>A detailed breakdown of the creation process behind a Chinese font: <a href="https://qz.com/522079/the-long-incredibly-tortuous-and-fascinating-process-of-creating-a-chinese-font">https://qz.com/522079/the-long-incredibly-tortuous-and-fascinating-process-of-creating-a-chinese-font</a></p>
<p>An example of a Japanese font including glyph count from Adobe Fonts: <a href="https://fonts.adobe.com/fonts/source-han-sans-japanese#fonts-section">https://fonts.adobe.com/fonts/source-han-sans-japanese#fonts-section</a></p>
<p>CJK Fonts: <a href="https://en.wikipedia.org/wiki/List_of_CJK_fonts">https://en.wikipedia.org/wiki/List_of_CJK_fonts</a></p>
<h3 id="Japan-amp-Technology"><a href="#Japan-amp-Technology" class="headerlink" title="Japan &amp; Technology"></a>Japan &amp; Technology</h3><p>An article on Japan’s fading hi-tech image and where it came from: <a href="https://thenextweb.com/news/japan-loves-fax-machine-techno-orientalism">https://thenextweb.com/news/japan-loves-fax-machine-techno-orientalism</a></p>
<p>Bloomberg on the effects of the Internet Explorer shutdown in Japan: <a href="https://www.bloomberg.com/news/articles/2022-06-15/end-of-internet-explorer-era-spells-trouble-for-japan-businesses#xj4y7vzkg?leadSource=uverify%20wall">https://www.bloomberg.com/news/articles/2022-06-15/end-of-internet-explorer-era-spells-trouble-for-japan-businesses#xj4y7vzkg?leadSource=uverify%20wall</a></p>
<p>The Guardian on the 2018 statement made by Japan’s former Cybersecurity Minister: <a href="https://www.theguardian.com/world/2018/nov/15/japan-cyber-security-ministernever-used-computer-yoshitaka-sakurada">https://www.theguardian.com/world/2018/nov/15/japan-cyber-security-ministernever-used-computer-yoshitaka-sakurada</a></p>
<p>Reading up on the Lost Decades: <a href="https://en.wikipedia.org/wiki/Lost_Decades">https://en.wikipedia.org/wiki/Lost_Decades</a></p>
<h3 id="Cultural-Influences"><a href="#Cultural-Influences" class="headerlink" title="Cultural Influences"></a>Cultural Influences</h3><p>Wired on several studies about perception differences: <a href="https://www.wired.com/2008/03/japanese-more-s/">https://www.wired.com/2008/03/japanese-more-s/</a></p>
<p>A study on the same topic: <a href="https://www.researchgate.net/publication/11645680_Attending_holistically_vs_analytically_Comparing_the_context_sensitivity_of_Japanese_and_Americans_Journal_of_Personality_and_Social_Psychology_81_922-934">https://www.researchgate.net/publication/11645680_Attending_holistically_vs_analytically_Comparing_the_context_sensitivity_of_Japanese_and_Americans_Journal_of_Personality_and_Social_Psychology_81_922-934</a></p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>Web Design</tag>
      </tags>
  </entry>
  <entry>
    <title>基于canvas实现的多功能画板</title>
    <url>/2022/09/21/%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%94%BB%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近空闲时间比较多，就想做点小工具玩玩，方案选了好几个，最终决定做一个基于canvas的画板，目前已经完成了第一版，有以下主要功能</p>
<ol>
<li>画笔（动态宽度设置，颜色设置）</li>
<li>橡皮擦</li>
<li>撤回，反撤回，清除画板，保存</li>
<li>画板拖拽</li>
<li>多图层</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>目前实现效果如下<br><img src="https://img-blog.csdnimg.cn/img_convert/6ee0b9163552f4c61abfde6af199b3ed.png"><br>预览地址：<a href="https://lhrun.github.io/paint-board/">https://lhrun.github.io/paint-board/</a><br>repo：<a href="https://github.com/LHRUN/paint-board">https://github.com/LHRUN/paint-board</a></p>
<h2 id="画板设计"><a href="#画板设计" class="headerlink" title="画板设计"></a>画板设计</h2><ol>
<li>首先是建立一个canvas画板类，所有canvas上的操作和数据全都在此处理，例如初始化，渲染，拖拽画板等等<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;
  <span class="attr">canvas</span>: <span class="title class_">HTMLCanvasElement</span>
  <span class="attr">context</span>: <span class="title class_">CanvasRenderingContext2D</span>
  ...
  <span class="title function_">constructor</span>(<span class="params">canvas: HTMLCanvasElement</span>) &#123;&#125;
  <span class="comment">// 初始化canvas</span>
  <span class="title function_">initCanvas</span>(<span class="params"></span>) &#123;&#125;
  <span class="comment">// 渲染</span>
  <span class="title function_">render</span>(<span class="params"></span>) &#123;&#125;
  <span class="comment">// 拖拽</span>
  <span class="title function_">drag</span>(<span class="params"></span>) &#123;&#125;
  ...
&#125;</code></pre></li>
<li>然后基于canvas类，根据当前的操作，建立对应的canvas元素，比如画笔，橡皮擦，基本类型如下<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">CanvasElement</span> &#123;
  <span class="attr">type</span>: string <span class="comment">// 元素类型</span>
  <span class="attr">layer</span>: number <span class="comment">// 图层</span>
  <span class="comment">// ...</span>
  <span class="title function_">constructor</span>(<span class="params">type: string, layer: number</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">type</span> = type
    <span class="variable language_">this</span>.<span class="property">layer</span> = layer
    <span class="comment">// ...</span>
  &#125;
  <span class="comment">// ...</span>
&#125;</code></pre></li>
<li>最后根据渲染逻辑，还会封装一些通用的逻辑来改变canvas上最终的展示，比如撤回，反撤回，图层操作等等</li>
</ol>
<h2 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h2><ul>
<li>实现画笔效果首先要在鼠标按下时建立一个画笔元素，然后在构造函数中接受基础宽度，颜色，初始化鼠标移动记录和线宽记录，然后在鼠标移动时记录鼠标移动的坐标</li>
<li>为了体现鼠标移动快，线宽就变窄，移动慢，线宽就恢复正常这个效果，我会计算当前移动的速度，然后根据速度计算线宽<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">FreeLine</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CanvasElement</span> &#123;
  ...
  <span class="title function_">constructor</span>(<span class="params">color: string, width: number, layer: number</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">positions</span> = [] <span class="comment">// 鼠标移动位置记录</span>
    <span class="variable language_">this</span>.<span class="property">lineWidths</span> = [<span class="number">0</span>] <span class="comment">// 线宽记录</span>
    <span class="variable language_">this</span>.<span class="property">color</span> = color <span class="comment">// 当前绘线颜色</span>
    <span class="variable language_">this</span>.<span class="property">maxWidth</span> = width <span class="comment">// 最大线宽</span>
    <span class="variable language_">this</span>.<span class="property">minWidth</span> = width / <span class="number">2</span> <span class="comment">// 最小线宽</span>
    <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> = width <span class="comment">// 最后绘线宽度</span>
  &#125;
&#125;</code></pre></li>
<li>记录鼠标位置和当前线宽<pre><code class="highlight js">interface <span class="title class_">MousePosition</span> &#123;
  <span class="attr">x</span>: number
  <span class="attr">y</span>: number
&#125;

<span class="title function_">addPosition</span>(<span class="params">position: MousePosition</span>) &#123;
  <span class="variable language_">this</span>.<span class="property">positions</span>.<span class="title function_">push</span>(position)
  <span class="comment">// 处理当前线宽</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;
    <span class="keyword">const</span> mouseSpeed = <span class="variable language_">this</span>.<span class="title function_">_computedSpeed</span>(
      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">2</span>],
      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">1</span>]
    )
    <span class="keyword">const</span> lineWidth = <span class="variable language_">this</span>.<span class="title function_">_computedLineWidth</span>(mouseSpeed)
    <span class="variable language_">this</span>.<span class="property">lineWidths</span>.<span class="title function_">push</span>(lineWidth)
  &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 计算移动速度</span>
<span class="comment"> * <span class="doctag">@param</span> start 起点</span>
<span class="comment"> * <span class="doctag">@param</span> end 终点</span>
<span class="comment"> */</span>
<span class="title function_">_computedSpeed</span>(<span class="params">start: MousePosition, end: MousePosition</span>) &#123;
  <span class="comment">// 获取距离</span>
  <span class="keyword">const</span> moveDistance = <span class="title function_">getDistance</span>(start, end)

  <span class="keyword">const</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()
  <span class="comment">// 获取移动间隔时间   lastMoveTime：最后鼠标移动时间</span>
  <span class="keyword">const</span> moveTime = curTime - <span class="variable language_">this</span>.<span class="property">lastMoveTime</span>
  <span class="comment">// 计算速度</span>
  <span class="keyword">const</span> mouseSpeed = moveDistance / moveTime
  <span class="comment">// 更新最后移动时间</span>
  <span class="variable language_">this</span>.<span class="property">lastMoveTime</span> = curTime
  <span class="keyword">return</span> mouseSpeed
&#125;

<span class="comment">/**</span>
<span class="comment"> * 计算画笔宽度</span>
<span class="comment"> * <span class="doctag">@param</span> speed 鼠标移动速度</span>
<span class="comment"> */</span>
<span class="title function_">_computedLineWidth</span>(<span class="params">speed: number</span>) &#123;
  <span class="keyword">let</span> lineWidth = <span class="number">0</span>
  <span class="keyword">const</span> minWidth = <span class="variable language_">this</span>.<span class="property">minWidth</span>
  <span class="keyword">const</span> maxWidth = <span class="variable language_">this</span>.<span class="property">maxWidth</span>
  <span class="keyword">if</span> (speed &gt;= <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) &#123;
    lineWidth = minWidth
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (speed &lt;= <span class="variable language_">this</span>.<span class="property">minSpeed</span>) &#123;
    lineWidth = maxWidth
  &#125; <span class="keyword">else</span> &#123;
    lineWidth = maxWidth - (speed / <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) * maxWidth
  &#125;

  lineWidth = lineWidth * (<span class="number">1</span> / <span class="number">3</span>) + <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> * (<span class="number">2</span> / <span class="number">3</span>)
  <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> = lineWidth
  <span class="keyword">return</span> lineWidth
&#125;</code></pre></li>
<li>保存坐标后，渲染就是遍历所有坐标<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">freeLineRender</span>(<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeLine</span>
<span class="params"></span>) &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">strokeStyle</span> = instance.<span class="property">color</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="title function_">_drawLine</span>(instance, i, context)
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 画笔轨迹是借鉴了网上的一些方案，分两种情况</span>
<span class="comment"> * 1. 如果是前两个坐标，就通过lineTo连接即可</span>
<span class="comment"> * 2. 如果是前两个坐标之后的坐标，就采用贝塞尔曲线进行连接，</span>
<span class="comment"> *    比如现在有a, b, c 三个点，到c点时，把ab坐标的中间点作为起点</span>
<span class="comment"> *     bc坐标的中间点作为终点，b点作为控制点进行连接</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">_drawLine</span>(<span class="params"></span>
<span class="params">  instance: FreeLine,</span>
<span class="params">  i: number,</span>
<span class="params">  context: CanvasRenderingContext2D</span>
<span class="params"></span>) &#123;
  <span class="keyword">const</span> &#123; positions, lineWidths &#125; = instance
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: centerX, <span class="attr">y</span>: centerY &#125; = positions[i - <span class="number">1</span>]
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: endX, <span class="attr">y</span>: endY &#125; = positions[i]
  context.<span class="title function_">beginPath</span>()
  <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;
    context.<span class="title function_">moveTo</span>(centerX, centerY)
    context.<span class="title function_">lineTo</span>(endX, endY)
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">const</span> &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125; = positions[i - <span class="number">2</span>]
    <span class="keyword">const</span> lastX = (startX + centerX) / <span class="number">2</span>
    <span class="keyword">const</span> lastY = (startY + centerY) / <span class="number">2</span>
    <span class="keyword">const</span> x = (centerX + endX) / <span class="number">2</span>
    <span class="keyword">const</span> y = (centerY + endY) / <span class="number">2</span>
    context.<span class="title function_">moveTo</span>(lastX, lastY)
    context.<span class="title function_">quadraticCurveTo</span>(centerX, centerY, x, y)
  &#125;

  context.<span class="property">lineWidth</span> = lineWidths[i]
  context.<span class="title function_">stroke</span>()
&#125;</code></pre></li>
</ul>
<h2 id="橡皮擦"><a href="#橡皮擦" class="headerlink" title="橡皮擦"></a>橡皮擦</h2><ul>
<li>橡皮擦是一个线状擦除，我采用的方案是通过计算每个点的圆弧轨迹和两个点之间的矩形区域，然后通过clip剪切后清除<br><img src="https://img-blog.csdnimg.cn/img_convert/8ae8229d79cd8b69d175d5fbb68e3c43.png"><pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 橡皮擦渲染</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> cleanCanvas 清除画板</span>
<span class="comment"> * <span class="doctag">@param</span> instance CleanLine</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">cleanLineRender</span>(<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  cleanCanvas: () =&gt; <span class="keyword">void</span>,</span>
<span class="params">  instance: CleanLine</span>
<span class="params"></span>) &#123;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;
    <span class="title function_">_cleanLine</span>(
      instance.<span class="property">positions</span>[i],
      instance.<span class="property">positions</span>[i + <span class="number">1</span>],
      context,
      cleanCanvas,
      instance.<span class="property">cleanWidth</span>
    )
  &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 线状清除</span>
<span class="comment"> * <span class="doctag">@param</span> start 起点</span>
<span class="comment"> * <span class="doctag">@param</span> end 终点</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> cleanCanvas 清除画板</span>
<span class="comment"> * <span class="doctag">@param</span> cleanWidth 清楚宽度</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">_cleanLine</span>(<span class="params"></span>
<span class="params">  start: MousePosition,</span>
<span class="params">  end: MousePosition,</span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  cleanCanvas: () =&gt; <span class="keyword">void</span>,</span>
<span class="params">  cleanWidth: number</span>
<span class="params"></span>)&#123;
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: x1, <span class="attr">y</span>: y1 &#125; = start
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: x2, <span class="attr">y</span>: y2 &#125; = end

  <span class="comment">// 获取鼠标起点和终点之间的矩形区域端点</span>
  <span class="keyword">const</span> asin = cleanWidth * <span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="title class_">Math</span>.<span class="title function_">atan</span>((y2 - y1) / (x2 - x1)))
  <span class="keyword">const</span> acos = cleanWidth * <span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="title class_">Math</span>.<span class="title function_">atan</span>((y2 - y1) / (x2 - x1)))
  <span class="keyword">const</span> x3 = x1 + asin
  <span class="keyword">const</span> y3 = y1 - acos
  <span class="keyword">const</span> x4 = x1 - asin
  <span class="keyword">const</span> y4 = y1 + acos
  <span class="keyword">const</span> x5 = x2 + asin
  <span class="keyword">const</span> y5 = y2 - acos
  <span class="keyword">const</span> x6 = x2 - asin
  <span class="keyword">const</span> y6 = y2 + acos

  <span class="comment">// 清除末端圆弧</span>
  context.<span class="title function_">save</span>()
  context.<span class="title function_">beginPath</span>()
  context.<span class="title function_">arc</span>(x2, y2, cleanWidth, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>)
  context.<span class="title function_">clip</span>()
  <span class="title function_">cleanCanvas</span>()
  context.<span class="title function_">restore</span>()

  <span class="comment">// 清除矩形区域</span>
  context.<span class="title function_">save</span>()
  context.<span class="title function_">beginPath</span>()
  context.<span class="title function_">moveTo</span>(x3, y3)
  context.<span class="title function_">lineTo</span>(x5, y5)
  context.<span class="title function_">lineTo</span>(x6, y6)
  context.<span class="title function_">lineTo</span>(x4, y4)
  context.<span class="title function_">closePath</span>()
  context.<span class="title function_">clip</span>()
  <span class="title function_">cleanCanvas</span>()
  context.<span class="title function_">restore</span>()
&#125;</code></pre></li>
</ul>
<h2 id="撤回、反撤回"><a href="#撤回、反撤回" class="headerlink" title="撤回、反撤回"></a>撤回、反撤回</h2><ul>
<li>实现撤回，反撤回就要把canvas上的每个元素的渲染数据进行存储，通过改变控制变量，限制渲染元素的遍历，这样就可以达到撤回的效果</li>
<li>首先画板初始化时建立一个history类，然后建立缓存和step数据，撤回和反撤回时，只需要修改step即可<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">History</span>&lt;T&gt; &#123;
  <span class="attr">cacheQueue</span>: T[]
  <span class="attr">step</span>: number
  <span class="title function_">constructor</span>(<span class="params">cacheQueue: T[]</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">cacheQueue</span> = cacheQueue
    <span class="variable language_">this</span>.<span class="property">step</span> = cacheQueue.<span class="property">length</span> - <span class="number">1</span>
  &#125;
  <span class="comment">// 添加数据</span>
  <span class="title function_">add</span>(<span class="params">data: T</span>) &#123;
    <span class="comment">// 如果在回退时添加数据就删除暂存数据</span>
    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> !== <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;
      <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> = <span class="variable language_">this</span>.<span class="property">step</span> + <span class="number">1</span>
    &#125;
    <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="title function_">push</span>(data)
    <span class="variable language_">this</span>.<span class="property">step</span> = <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span>
  &#125;

  <span class="comment">// 遍历cacheQueue</span>
  <span class="title function_">each</span>(<span class="params">cb?: (ele: T, i: number) =&gt; <span class="keyword">void</span></span>) &#123;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="variable language_">this</span>.<span class="property">step</span>; i++) &#123;
      cb?.(<span class="variable language_">this</span>.<span class="property">cacheQueue</span>[i], i)
    &#125;
  &#125;

  <span class="comment">// 后退</span>
  <span class="title function_">undo</span>(<span class="params"></span>) &#123;
    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> &gt;= <span class="number">0</span>) &#123;
      <span class="variable language_">this</span>.<span class="property">step</span>--
      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheQueue</span>[<span class="variable language_">this</span>.<span class="property">step</span>]
    &#125;
  &#125;

  <span class="comment">// 前进</span>
  <span class="title function_">redo</span>(<span class="params"></span>) &#123;
    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> &lt; <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;
      <span class="variable language_">this</span>.<span class="property">step</span>++
      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheQueue</span>[<span class="variable language_">this</span>.<span class="property">step</span>]
    &#125;
  &#125;
&#125;</code></pre></li>
<li>针对画板，通过监听鼠标按下操作，在history中添加一个元素，然后对渲染函数的遍历限制到step就达到了撤回的效果<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;
  ...
  <span class="comment">/**</span>
<span class="comment">   * 记录当前元素，并加入history</span>
<span class="comment">   */</span>
  <span class="title function_">recordCurrent</span>(<span class="params">type: string</span>) &#123;
    <span class="keyword">let</span> <span class="attr">ele</span>: <span class="variable constant_">ELEMENT_INSTANCE</span> | <span class="literal">null</span> = <span class="literal">null</span>
    <span class="keyword">switch</span> (type) &#123;
      <span class="keyword">case</span> <span class="variable constant_">CANVAS_ELE_TYPE</span>.<span class="property">FREE_LINE</span>:
        ele = <span class="keyword">new</span> <span class="title class_">FreeLine</span>(
          <span class="variable language_">this</span>.<span class="property">currentLineColor</span>,
          <span class="variable language_">this</span>.<span class="property">currentLineWidth</span>,
          <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">current</span>
        )
        <span class="keyword">break</span>
      <span class="keyword">case</span> <span class="variable constant_">CANVAS_ELE_TYPE</span>.<span class="property">CLEAN_LINE</span>:
        ele = <span class="keyword">new</span> <span class="title class_">CleanLine</span>(<span class="variable language_">this</span>.<span class="property">cleanWidth</span>, <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">current</span>)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
    <span class="keyword">if</span> (ele) &#123;
      <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">add</span>(ele)
      <span class="variable language_">this</span>.<span class="property">currentEle</span> = ele
    &#125;
  &#125;

  <span class="comment">/**</span>
<span class="comment">   * 遍历history渲染数据</span>
<span class="comment">   */</span>
  <span class="title function_">render</span>(<span class="params"></span>) &#123;
    <span class="comment">// 清除画布</span>
    <span class="variable language_">this</span>.<span class="title function_">cleanCanvas</span>()
    <span class="comment">// 遍历history</span>
    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">each</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;
      <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">save</span>()
      <span class="comment">// render....</span>
      <span class="variable language_">this</span>.<span class="property">context</span>,<span class="title function_">resore</span>()
    &#125;)
    <span class="comment">// 缓存数据</span>
    <span class="variable language_">this</span>.<span class="title function_">cache</span>()
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="拖拽画布"><a href="#拖拽画布" class="headerlink" title="拖拽画布"></a>拖拽画布</h2><ul>
<li>拖拽画布的实现是通过计算鼠标移动距离，根据距离改变画布的原点位置，达到拖拽的效果</li>
</ul>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">position: MousePosition</span>) &#123;
  <span class="keyword">const</span> mousePosition = &#123;
    <span class="attr">x</span>: position.<span class="property">x</span> - <span class="variable language_">this</span>.<span class="property">canvasRect</span>.<span class="property">left</span>,
    <span class="attr">y</span>: position.<span class="property">y</span> - <span class="variable language_">this</span>.<span class="property">canvasRect</span>.<span class="property">top</span>
  &#125;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">x</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">y</span>) &#123;
    <span class="keyword">const</span> translteX = mousePosition.<span class="property">x</span> - <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">x</span>
    <span class="keyword">const</span> translteY = mousePosition.<span class="property">y</span> - <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">y</span>
    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">translate</span>(translteX, translteY)
    <span class="variable language_">this</span>.<span class="property">originTranslate</span> = &#123;
      <span class="attr">x</span>: translteX + <span class="variable language_">this</span>.<span class="property">originTranslate</span>.<span class="property">x</span>,
      <span class="attr">y</span>: translteY + <span class="variable language_">this</span>.<span class="property">originTranslate</span>.<span class="property">y</span>
    &#125;
    <span class="variable language_">this</span>.<span class="title function_">render</span>()
  &#125;
  <span class="variable language_">this</span>.<span class="property">originPosition</span> = mousePosition
&#125;</code></pre>

<h2 id="多图层"><a href="#多图层" class="headerlink" title="多图层"></a>多图层</h2><p>实现多图层需要对以下几个地方进行处理</p>
<ol>
<li>画板初始化时建立图层类，所有的图层数据和图层逻辑全在此处</li>
<li>然后对canvas上的元素加layer属性，用于判断归属于哪个图层</li>
<li>画板的渲染函数改为按照图层顺序进行渲染</li>
<li>拖拽或者隐藏图层都需要重新渲染，删除图层把对应的缓存图层元素进行删除</li>
</ol>
<pre><code class="highlight js">interface <span class="title class_">ILayer</span> &#123;
  <span class="attr">id</span>: number <span class="comment">// 图层id</span>
  <span class="attr">title</span>: string <span class="comment">// 图层名称</span>
  <span class="attr">show</span>: boolean <span class="comment">// 图层展示状态</span>
&#125;

<span class="comment">/**</span>
<span class="comment"> * 图层</span>
<span class="comment"> */</span>
<span class="keyword">class</span> <span class="title class_">Layer</span> &#123;
  <span class="attr">stack</span>: <span class="title class_">ILayer</span>[] <span class="comment">// 图层数据</span>
  <span class="attr">current</span>: number <span class="comment">// 当前图层</span>
  <span class="attr">render</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span> <span class="comment">// 画板渲染事件</span>

  <span class="title function_">constructor</span>(<span class="params">render: () =&gt; <span class="keyword">void</span>, initData?: Layer</span>) &#123;
    <span class="keyword">const</span> &#123;
      stack = [
        &#123;
          <span class="attr">id</span>: <span class="number">1</span>,
          <span class="attr">title</span>: <span class="string">&#x27;item1&#x27;</span>,
          <span class="attr">show</span>: <span class="literal">true</span>
        &#125;
      ],
      id = <span class="number">1</span>,
      current = <span class="number">1</span>
    &#125; = initData || &#123;&#125;
    <span class="variable language_">this</span>.<span class="property">stack</span> = stack
    <span class="variable language_">this</span>.<span class="property">id</span> = id
    <span class="variable language_">this</span>.<span class="property">current</span> = current
    <span class="variable language_">this</span>.<span class="property">render</span> = render
  &#125;
  ...
&#125;

<span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;
  <span class="comment">// 通过图层进行排序</span>
   <span class="title function_">sortOnLayer</span>(<span class="params"></span>) &#123;
     <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;
       <span class="keyword">return</span> (
         <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> id === b?.<span class="property">layer</span>) -
         <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> id === a?.<span class="property">layer</span>)
       )
     &#125;)
   &#125;

   <span class="comment">// 渲染函数只渲染图层展示状态的元素</span>
   <span class="title function_">render</span>(<span class="params"></span>) &#123;
     <span class="keyword">const</span> showLayerIds = <span class="keyword">new</span> <span class="title class_">Set</span>(
       <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="property">reduce</span>&lt;number[]&gt;(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;
         <span class="keyword">return</span> cur.<span class="property">show</span> ? [...acc, cur.<span class="property">id</span>] : acc
       &#125;, [])
     )
     <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">each</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;
       <span class="keyword">if</span> (ele?.<span class="property">layer</span> &amp;&amp; showLayerIds.<span class="title function_">has</span>(ele.<span class="property">layer</span>)) &#123;
         ...
       &#125;
     &#125; 
   &#125;
&#125;</code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>我本篇主要是分享一些主要逻辑，还有一些兼容问题和一些UI交互就不叙述了</li>
<li>这个画板写下来大概用了一个星期，有好多功能还没写上，如果过段时间有空的话就继续写下去，并进一步优化，现在还是有点优化问题没有写好，比如画笔宽度显示的还是有点问题，原点位置和一些初始化设计的不太好，不过写完这个画板还是挺有成就感的</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/axes/p/3850309.html">HTML5 实现橡皮擦的擦除效果</a></li>
<li><a href="https://juejin.cn/post/7091276963146530847">我做了一个在线白板！</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>基于markdown-it打造的markdown编辑器</title>
    <url>/2022/10/12/%E5%9F%BA%E4%BA%8Emarkdown-it%E6%89%93%E9%80%A0%E7%9A%84markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>markdown-it是一个用来解析markdown的库，它可以将markdown编译为html，然后解析时markdown-it会根据规则生成tokens，如果需要自定义，就通过rules函数对token进行处理<br>我现在基于markdown-it已完成第一版编辑器，现有以下功能：</p>
<ol>
<li>快捷编辑按钮</li>
<li>代码块主题切换</li>
<li>同步滚动</li>
<li>目录列表生成</li>
<li>内容状态缓存</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>目前实现效果如下<br><img src="https://s1.ax1x.com/2022/10/12/xaMejs.jpg"></p>
<p>预览地址：<a href="https://lhrun.github.io/md-editor/">https://lhrun.github.io/md-editor/</a><br>repo：<a href="https://github.com/LHRUN/md-editor">https://github.com/LHRUN/md-editor</a> 欢迎star⭐️</p>
<h2 id="编辑器设计"><a href="#编辑器设计" class="headerlink" title="编辑器设计"></a>编辑器设计</h2><ol>
<li>页面布局分四部分，顶部是快捷工具栏，然后主体内容分三部分，编辑区域(textarea)、html展示区域、目录列表(可展示隐藏)，因为我是用react开发的，所以html字符串我是通过<a href="https://zh-hans.reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml">dangerouslySetInnerHTML</a>设置</li>
<li>markdown-it初始化<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">MD</span> = <span class="keyword">new</span> <span class="title class_">MarkdownIt</span>(&#123;
  <span class="attr">html</span>: <span class="literal">true</span>, <span class="comment">// 在源码中启用HTML标签</span>
  <span class="attr">linkify</span>: <span class="literal">true</span>, <span class="comment">// 将类似URL的文本自动转换为链接</span>
  <span class="attr">breaks</span>: <span class="literal">true</span>, <span class="comment">// 转换段落里的 &#x27;\n&#x27; 到 &lt;br&gt;</span>
  <span class="attr">highlight</span>: <span class="keyword">function</span> (<span class="params">str, lang</span>) &#123;
    <span class="keyword">return</span> <span class="title function_">highlightFormatCode</span>(str, lang)
  &#125;
&#125;)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItSub</span>)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItSup</span>)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItMark</span>)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItDeflist</span>)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItTaskLists</span>)
  .<span class="title function_">use</span>(markdownItAbbr)
  .<span class="title function_">use</span>(markdownItFootnote)
  <span class="comment">// 其余的markdownIt插件...</span>

<span class="keyword">const</span> highlightFormatCode = (<span class="attr">str</span>: string, <span class="attr">lang</span>: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;
  <span class="keyword">if</span> (lang &amp;&amp; hljs.<span class="title function_">getLanguage</span>(lang)) &#123;
    <span class="keyword">try</span> &#123;
      <span class="keyword">return</span> <span class="title function_">codeBlockStyle</span>(hljs.<span class="title function_">highlight</span>(lang, str, <span class="literal">true</span>).<span class="property">value</span>)
    &#125; <span class="keyword">catch</span> (e) &#123;
      <span class="variable language_">console</span>.<span class="title function_">error</span>(e)
    &#125;
  &#125;

  <span class="keyword">return</span> <span class="title function_">codeBlockStyle</span>(<span class="variable constant_">MD</span>.<span class="property">utils</span>.escapeHtml(str))
&#125;

<span class="keyword">const</span> codeBlockStyle = (<span class="attr">val</span>: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;
  <span class="keyword">return</span> <span class="string">`&lt;pre class=&quot;hljs&quot; style=&quot;padding: 10px;border-radius: 10px;&quot;&gt;&lt;code&gt;<span class="subst">$&#123;val&#125;</span>&lt;/code&gt;&lt;/pre&gt;`</span>
&#125;</code></pre></li>
</ol>
<h2 id="快捷编辑按钮"><a href="#快捷编辑按钮" class="headerlink" title="快捷编辑按钮"></a>快捷编辑按钮</h2><p>快捷便捷按钮主要是通过判断textarea的光标位置，然后通过光标位置改变编辑器文本内容，比如添加图片</p>
<pre><code class="highlight js"><span class="comment">// 获取光标位置</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getCursorPosition</span> = (<span class="params">editor: HTMLTextAreaElement</span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; selectionStart, selectionEnd &#125; = editor
  <span class="keyword">return</span> [selectionStart, selectionEnd]
&#125;

<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addImage</span> = (<span class="params"></span>
<span class="params">  editor: HTMLTextAreaElement,</span>
<span class="params">  source: string,</span>
<span class="params">  setSource: (v: string) =&gt; <span class="keyword">void</span></span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> [start, end] = <span class="title function_">getCursorPosition</span>(editor)
  <span class="keyword">let</span> val = source
  <span class="keyword">if</span> (start === end) &#123;
    val = <span class="string">`<span class="subst">$&#123;source.slice(<span class="number">0</span>, start)&#125;</span>\n![图片描述](url)\n<span class="subst">$&#123;source.slice(end)&#125;</span>`</span>
  &#125; <span class="keyword">else</span> &#123;
    val = <span class="string">`<span class="subst">$&#123;source.slice(<span class="number">0</span>, start)&#125;</span>\n![<span class="subst">$&#123;source.slice(</span></span>
<span class="subst"><span class="string">      start,</span></span>
<span class="subst"><span class="string">      end</span></span>
<span class="subst"><span class="string">    )&#125;</span>](url)\n<span class="subst">$&#123;source.slice(end)&#125;</span>`</span>
  &#125;
  <span class="title function_">setSource</span>(val)
&#125;</code></pre>

<h2 id="代码块主题切换"><a href="#代码块主题切换" class="headerlink" title="代码块主题切换"></a>代码块主题切换</h2><ul>
<li>代码块高亮我是采用了<strong>highlight.js</strong>，因为这个库提供了很多主题样式，所以主题切换，我只需要改变css link即可<pre><code class="highlight js"><span class="comment">// codeTheme就是已选的主题名字</span>
<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;
  <span class="keyword">if</span> (codeTheme) &#123;
    <span class="title function_">switchLink</span>(
      <span class="string">&#x27;code-style&#x27;</span>,
      <span class="string">`https://cdn.bootcdn.net/ajax/libs/highlight.js/11.6.0/styles/<span class="subst">$&#123;codeTheme&#125;</span>.min.css`</span>
    )
  &#125;
&#125;, [codeTheme])

<span class="comment">/**</span>
<span class="comment"> * 切换html css link</span>
<span class="comment"> * <span class="doctag">@param</span> key link key 指定唯一标识，用于切换link</span>
<span class="comment"> * <span class="doctag">@param</span> href link href</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">switchLink</span> = (<span class="params">key: string, href: string</span>) =&gt; &#123;
  <span class="keyword">const</span> head = <span class="variable language_">document</span>.<span class="property">head</span>
  <span class="keyword">const</span> oldLink = head.<span class="title function_">getElementsByClassName</span>(key)
  <span class="keyword">if</span> (oldLink.<span class="property">length</span>) head.<span class="title function_">removeChild</span>(oldLink[<span class="number">0</span>])

  <span class="keyword">const</span> newLink = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>)
  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>)
  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>)
  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, key)
  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, href)
  newLink.<span class="property">onerror</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;
    <span class="variable language_">console</span>.<span class="title function_">error</span>(e)
    message.<span class="title function_">error</span>(<span class="string">&#x27;获取css link失败&#x27;</span>)
  &#125;
  head.<span class="title function_">appendChild</span>(newLink)
&#125;</code></pre></li>
</ul>
<h2 id="同步滚动"><a href="#同步滚动" class="headerlink" title="同步滚动"></a>同步滚动</h2><p>同步滚动是我认为最难搞的一个功能，因为我不想仅仅通过百分比来计算滚动距离，因为这样的话如果编辑区域添加了一堆图片，预览就会有非常大的高度差。我在网上找了许多方案，最后发现markdown-it的官方实现是我能找到并能实现的最佳方案，大致实现思路是如下</p>
<ol>
<li><p>首先在编译时对标题元素和段落元素添加行号</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 注入行号</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="attr">injectLineNumbers</span>: <span class="title class_">Renderer</span>.<span class="property">RenderRule</span> = <span class="function">(<span class="params"></span></span>
<span class="params"><span class="function">  tokens,</span></span>
<span class="params"><span class="function">  idx,</span></span>
<span class="params"><span class="function">  options,</span></span>
<span class="params"><span class="function">  _env,</span></span>
<span class="params"><span class="function">  slf</span></span>
<span class="params"><span class="function"></span>) =&gt;</span> &#123;
  <span class="keyword">let</span> line
  <span class="keyword">if</span> (tokens[idx].<span class="property">map</span> &amp;&amp; tokens[idx].<span class="property">level</span> === <span class="number">0</span>) &#123;
    line = (tokens[idx].<span class="property">map</span> <span class="keyword">as</span> [number, number])[<span class="number">0</span>]
    tokens[idx].<span class="title function_">attrJoin</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;line&#x27;</span>)
    tokens[idx].<span class="title function_">attrSet</span>(<span class="string">&#x27;data-line&#x27;</span>, <span class="title class_">String</span>(line))
  &#125;
  <span class="keyword">return</span> slf.<span class="title function_">renderToken</span>(tokens, idx, options)
&#125;

<span class="variable constant_">MD</span>.<span class="property">renderer</span>.<span class="property">rules</span>.<span class="property">heading_open</span> = <span class="variable constant_">MD</span>.<span class="property">renderer</span>.<span class="property">rules</span>.<span class="property">paragraph_open</span> = injectLineNumbers</code></pre>
</li>
<li><p>滚动前计算出当前编辑区域每行对应的预览偏移距离，有标记行号的元素直接计算offset，未标记行号的元素就等比计算</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 获取编辑区域每行对应的预览偏移距离</span>
<span class="comment"> * <span class="doctag">@param</span> editor 编辑元素</span>
<span class="comment"> * <span class="doctag">@param</span> review 预览元素</span>
<span class="comment"> * <span class="doctag">@returns</span> number[]</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">buildScrollMap</span> = (<span class="params"></span>
<span class="params">  editor: HTMLTextAreaElement,</span>
<span class="params">  review: HTMLDivElement</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> <span class="attr">lineHeightMap</span>: number[] = []
  <span class="keyword">let</span> linesCount = <span class="number">0</span> <span class="comment">// 编辑区总行数</span>

  <span class="comment">/**</span>
<span class="comment">   * 临时创建元素获取每次换行之间的总行数</span>
<span class="comment">   */</span>
  <span class="keyword">const</span> sourceLine = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)
  sourceLine.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>
  sourceLine.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span>
  sourceLine.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;auto&#x27;</span>
  sourceLine.<span class="property">style</span>.<span class="property">width</span> = <span class="string">`<span class="subst">$&#123;editor.clientWidth&#125;</span>px`</span>
  sourceLine.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;15px&#x27;</span>
  sourceLine.<span class="property">style</span>.<span class="property">lineHeight</span> = <span class="string">`<span class="subst">$&#123;LINE_HEIGHT&#125;</span>px`</span>
  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(sourceLine)
  <span class="keyword">let</span> acc = <span class="number">0</span>
  editor.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">str</span>) =&gt;</span> &#123;
    lineHeightMap.<span class="title function_">push</span>(acc)
    <span class="keyword">if</span> (str.<span class="property">length</span> === <span class="number">0</span>) &#123;
      acc++
      <span class="keyword">return</span>
    &#125;
    sourceLine.<span class="property">textContent</span> = str
    <span class="keyword">const</span> h = sourceLine.<span class="property">offsetHeight</span>
    acc += <span class="title class_">Math</span>.<span class="title function_">round</span>(h / <span class="variable constant_">LINE_HEIGHT</span>)
  &#125;)
  sourceLine.<span class="title function_">remove</span>()
  lineHeightMap.<span class="title function_">push</span>(acc)
  linesCount = acc

  <span class="comment">// 最终输出的偏移map</span>
  <span class="keyword">const</span> <span class="attr">_scrollMap</span>: number[] = <span class="keyword">new</span> <span class="title class_">Array</span>(linesCount).<span class="title function_">fill</span>(-<span class="number">1</span>)

  <span class="comment">/**</span>
<span class="comment">   * 获取标记行号的offset距离</span>
<span class="comment">   */</span>
  <span class="keyword">const</span> nonEmptyList = []
  nonEmptyList.<span class="title function_">push</span>(<span class="number">0</span>)
  _scrollMap[<span class="number">0</span>] = <span class="number">0</span>
  <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.line&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;
    <span class="keyword">let</span> <span class="attr">t</span>: string | number = el.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-line&#x27;</span>) <span class="keyword">as</span> string
    <span class="keyword">if</span> (t === <span class="string">&#x27;&#x27;</span>) &#123;
      <span class="keyword">return</span>
    &#125;
    t = lineHeightMap[<span class="title class_">Number</span>(t)]
    <span class="keyword">if</span> (t !== <span class="number">0</span>) &#123;
      nonEmptyList.<span class="title function_">push</span>(t)
    &#125;
    _scrollMap[t] = <span class="title class_">Math</span>.<span class="title function_">round</span>((el <span class="keyword">as</span> <span class="title class_">HTMLElement</span>).<span class="property">offsetTop</span> - review.<span class="property">offsetTop</span>)
  &#125;)

  nonEmptyList.<span class="title function_">push</span>(linesCount)
  _scrollMap[linesCount] = review.<span class="property">scrollHeight</span>

  <span class="comment">/**</span>
<span class="comment">   * 未标记行号的元素等比计算</span>
<span class="comment">   */</span>
  <span class="keyword">let</span> pos = <span class="number">0</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; linesCount; i++) &#123;
    <span class="keyword">if</span> (_scrollMap[i] !== -<span class="number">1</span>) &#123;
      pos++
      <span class="keyword">continue</span>
    &#125;
    <span class="keyword">const</span> a = nonEmptyList[pos]
    <span class="keyword">const</span> b = nonEmptyList[pos + <span class="number">1</span>]
    _scrollMap[i] = <span class="title class_">Math</span>.<span class="title function_">round</span>(
      (_scrollMap[b] * (i - a) + _scrollMap[a] * (b - i)) / (b - a)
    )
  &#125;

  <span class="keyword">return</span> _scrollMap
&#125;</code></pre>
</li>
<li><p>编辑区域滚动根据具体行获取需滚动高度</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">editorScroll</span> = (<span class="params"></span>
<span class="params">  editor: HTMLTextAreaElement,</span>
<span class="params">  preview: HTMLDivElement</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">if</span> (!scrollMap) &#123;
    scrollMap = <span class="title function_">buildScrollMap</span>(editor, preview)
  &#125;

  <span class="keyword">const</span> lineNo = <span class="title class_">Math</span>.<span class="title function_">floor</span>(editor.<span class="property">scrollTop</span> / <span class="variable constant_">LINE_HEIGHT</span>)
  <span class="keyword">const</span> posTo = scrollMap[lineNo]
  preview.<span class="title function_">scrollTo</span>(&#123; <span class="attr">top</span>: posTo &#125;)
&#125;</code></pre></li>
<li><p>预览区域滚动根据当前的滚动高度查对应编辑区域的行，然后根据计算滚动高度</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">previewScroll</span> = (<span class="params"></span>
<span class="params">  editor: HTMLTextAreaElement,</span>
<span class="params">  preview: HTMLDivElement</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">if</span> (!scrollMap) &#123;
    scrollMap = <span class="title function_">buildScrollMap</span>(editor, preview)
  &#125;

  <span class="keyword">const</span> lines = <span class="title class_">Object</span>.<span class="title function_">keys</span>(scrollMap)
  <span class="keyword">if</span> (lines.<span class="property">length</span> &lt; <span class="number">1</span>) &#123;
    <span class="keyword">return</span>
  &#125;
  <span class="keyword">let</span> line = lines[<span class="number">0</span>]
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; lines.<span class="property">length</span>; i++) &#123;
    <span class="keyword">if</span> (scrollMap[<span class="title class_">Number</span>(lines[i])] &lt; preview.<span class="property">scrollTop</span>) &#123;
      line = lines[i]
      <span class="keyword">continue</span>
    &#125;
    <span class="keyword">break</span>
  &#125;
  editor.<span class="title function_">scrollTo</span>(&#123; <span class="attr">top</span>: <span class="variable constant_">LINE_HEIGHT</span> * <span class="title class_">Number</span>(line) &#125;)
&#125;</code></pre></li>
</ol>
<h3 id="同步滚动注意点"><a href="#同步滚动注意点" class="headerlink" title="同步滚动注意点"></a>同步滚动注意点</h3><ol>
<li>在改变编辑内容和窗口大小时需清空计算结果，因为这两个一改变，每行的偏移距离就会发生变化，在滚动时需要重新计算</li>
<li>同步滚动时会有一个无限触发的问题，因为编辑区域滚动，会触发预览区域的<code>scrollTo()</code>，然后预览区域的滚动监听方法就会被触发，然后这样就会无限触发下去，所以需要一个变量记住当前的手动滚动的区域，进行限制</li>
</ol>
<h2 id="目录列表生成"><a href="#目录列表生成" class="headerlink" title="目录列表生成"></a>目录列表生成</h2><p>目录列表通过rules的<code>heading_open</code>方法，获取当前标题的token，然后通过token得出标题的具体内容进行拼接，最后根据level计算字体大小</p>
<ul>
<li>获取标题内容<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">getTitle</span> = (<span class="params">tokens: Token[], idx: number</span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; children &#125; = tokens[idx + <span class="number">1</span>]
  <span class="keyword">const</span> &#123; markup &#125; = tokens[idx]
  <span class="keyword">const</span> val = children?.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;acc&#125;</span><span class="subst">$&#123;cur.content&#125;</span>`</span>, <span class="string">&#x27;&#x27;</span>) || <span class="string">&#x27;&#x27;</span>
  toc.<span class="title function_">push</span>(&#123;
    val,
    <span class="attr">level</span>: markup.<span class="property">length</span>
  &#125;)
&#125;</code></pre></li>
<li>html展示<pre><code class="highlight js">&#123;showToc &amp;&amp; (
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.toc&#125;</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.tocTitle&#125;</span>&gt;</span>目录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span>
<span class="language-xml">      &#123;tocList.map((&#123; val, level &#125;, index) =&gt; &#123;</span>
<span class="language-xml">        const fontSize = ((7 - level) / 10) * 40</span>
<span class="language-xml"></span>
<span class="language-xml">        return (</span>
<span class="language-xml">          <span class="tag">&lt;<span class="name">div</span></span></span>
<span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span>
<span class="tag"><span class="language-xml">              <span class="attr">marginLeft:</span> `$&#123;<span class="attr">level</span> * <span class="attr">10</span>&#125;<span class="attr">px</span>`,</span></span>
<span class="tag"><span class="language-xml">              <span class="attr">fontSize:</span> `$&#123;<span class="attr">fontSize</span> &gt;</span> 12 ? fontSize : 12&#125;px`</span>
<span class="language-xml">            &#125;&#125;</span>
<span class="language-xml">            key=&#123;index&#125;</span>
<span class="language-xml">          &gt;</span>
<span class="language-xml">            &#123;val&#125;</span>
<span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml">        )</span>
<span class="language-xml">      &#125;)&#125;</span>
<span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
)&#125;</code></pre></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能完成的有点粗糙，以后有时间继续完善细节，有问题欢迎讨论👻</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/m0_67393295/article/details/123220722">手把手带你10分钟手撸一个简易的Markdown编辑器</a></li>
<li><a href="https://github.com/markdown-it/markdown-it/blob/master/support/demo_template/index.js">markdown-it.github.io</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>markdown-it</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序前端登录模块设计</title>
    <url>/2022/09/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信小程序登录基本上是每个小程序都必备的功能，但是随着业务的逐渐复杂，需要考虑的情况会越来越多，所以登录功能的健壮和高效是值得重点关注的，我会按照以往经验实现一个较优雅的登录方案</p>
<h2 id="基本登录流程"><a href="#基本登录流程" class="headerlink" title="基本登录流程"></a>基本登录流程</h2><ol>
<li>获取微信登录凭证，通过<code>wx.login</code>获取，这个api会返回一个带有时效性的code</li>
<li>发送code给服务端，这一步就是通过你和后端定义的接口发送</li>
<li>服务端根据前端发送的code获取用户身份信息，当然这一步就不是前端的逻辑了</li>
<li>服务端处理完后，会把用户信息和sessinId发送给前端，然后前端把需要的信息进行存储，接下来的请求就可以带着sessinId来表示身份</li>
<li>下面是微信官方的流程图<br><img src="https://img-blog.csdnimg.cn/3b0b114c140247ebbc666b027dfbda66.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h2 id="逻辑封装"><a href="#逻辑封装" class="headerlink" title="逻辑封装"></a>逻辑封装</h2><p>针对以上登录流程，我会封装以下几个方法供业务层调用</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>getLoginCode</code></td>
<td>获取微信登录凭证</td>
</tr>
<tr>
<td><code>staticLogin</code></td>
<td>静默登录</td>
</tr>
<tr>
<td><code>singleLogin</code></td>
<td>登录请求封装</td>
</tr>
<tr>
<td><code>checkLogin</code></td>
<td>判断是否登录</td>
</tr>
<tr>
<td><code>getPhoneNum</code></td>
<td>获取微信授权手机号</td>
</tr>
</tbody></table>
<ul>
<li><p>我习惯在promise请求中使用await-to方法，这是一个针对异步比较优雅的方案</p>
<ul>
<li><a href="https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/">How to write async await without try-catch blocks in Javascript</a></li>
</ul>
</li>
<li><p>getLoginCode，一个简单的promise封装获取code</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getLoginCode</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;
      wx.<span class="title function_">login</span>(&#123;
        success (res) &#123;
          <span class="keyword">if</span> (res.<span class="property">code</span>) &#123;
            <span class="title function_">resolve</span>(res.<span class="property">code</span>)
          &#125; <span class="keyword">else</span> &#123;
            <span class="title function_">reject</span>(res)
          &#125;
        &#125;,
        <span class="title function_">fail</span>(<span class="params">err</span>) &#123;
          <span class="title function_">reject</span>(err)
        &#125;
      &#125;)
  &#125;)
&#125;</code></pre>
</li>
<li><p>静默登录封装，获取用户信息，并进行存储</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">staticLogin</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;
  <span class="comment">// 如果已经登录，直接返回登录信息</span>
  <span class="keyword">if</span> (<span class="title function_">checkLogin</span>()) &#123;
    <span class="keyword">return</span> <span class="title function_">getLoginInfo</span>()
  &#125;
  <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">singleLogin</span>());
  <span class="keyword">if</span> (loginErr) &#123;
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(loginErr);
  &#125;
  <span class="comment">// 存储用户信息，这个就根据自己的情况了，我这随便定个方法</span>
  <span class="title function_">setLoginInfo</span>(&#123;
    ...loginRes,
  &#125;)
  <span class="keyword">return</span> loginRes;
&#125;</code></pre>
</li>
<li><p>登录请求封装，这里我是用单例模式并返回了一个promise，这样做是为了，你多次调用singleLogin时，比如快速切换页面，快速点击多个需登录区域，在数据没有返回的时候，都会等待，而不是触发多次请求</p>
<pre><code class="highlight js"><span class="keyword">let</span> loginInstance = <span class="literal">null</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">singleLogin</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">if</span> (loginInstance) &#123;
    <span class="keyword">return</span> loginInstance
  &#125;
  <span class="comment">// loginReq：封装请求，包括请求后端和getLoginCode</span>
  loginInstance = <span class="title function_">loginReq</span>()
  loginInstance.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;
    loginInstance = <span class="literal">null</span>;
    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);
  &#125;)
  <span class="keyword">return</span> loginInstance
&#125;</code></pre>
</li>
<li><p>checkLogin，检查是否登录，这个就看你存储在那个地方了，视情况而定</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">checkLogin</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">return</span> <span class="title class_">Boolean</span>(loginInfo?.<span class="property">sid</span>)
&#125;</code></pre>
</li>
<li><p>getPhoneNum</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPhoneNum</span> = <span class="keyword">async</span> (<span class="params">iv, encryptedData</span>) =&gt; &#123;
  <span class="keyword">const</span> [codeErr, codeRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">getLoginCode</span>())
  <span class="keyword">if</span> (codeErr) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(codeErr);
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(codeErr);
  &#125;
  <span class="comment">// decrypt：请求后端</span>
  <span class="keyword">const</span> [phoneErr, phoneRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">decrypt</span>(&#123;
    iv,
    encryptedData,
    <span class="attr">code</span>: codeRes.<span class="property">code</span>
  &#125;))
  <span class="keyword">if</span> (phoneErr) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(phoneErr);
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(phoneErr);
  &#125;
  <span class="keyword">const</span> phoneNumber = phoneRes.<span class="property">result</span>.<span class="property">phoneNumber</span>
  <span class="title function_">setLoginInfo</span>(&#123;
    phoneNumber,
  &#125;)
  <span class="keyword">return</span> phoneNumber
&#125;</code></pre></li>
</ul>
<h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p>业务层我会在以下几个地方调用</p>
<ol>
<li><p>请求前根据options判断是否需登录，并进行处理</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">REQUEST</span> = <span class="keyword">async</span> (<span class="params">requestObj</span>) =&gt; &#123;
  <span class="comment">// isLogin 当前接口请求是否需要登录</span>
  <span class="keyword">if</span> (requestObj.<span class="property">isLogin</span> &amp;&amp; !<span class="title function_">checkLogin</span>()) &#123;
    <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">staticLogin</span>());
    <span class="keyword">if</span> (loginErr) &#123;
      <span class="title class_">Toast</span>(<span class="string">&#x27;登录失败&#x27;</span>)
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(loginErr);
    &#125;
  &#125;
  ...
&#125;</code></pre>
</li>
<li><p>登录按钮，这个主要用于登录失败兜底的情况，让用户主动点击，用于登录弹窗等组件，只需调用<code>staticLogin</code>即可</p>
</li>
<li><p>获取用户授权手机号按钮</p>
<pre><code class="highlight js"><span class="comment">// index.html</span>
<span class="comment">// 用户主动触发进行授权手机号</span>
&lt;button open-type=<span class="string">&quot;getPhoneNumber&quot;</span> bindgetphonenumber=<span class="string">&quot;bindPhoneNumber&quot;</span>&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span>
&lt;/button&gt;

<span class="comment">// index.js</span>
<span class="keyword">async</span> <span class="title function_">bindPhoneNumber</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> iv = e.<span class="property">detail</span>.<span class="property">iv</span>;
  <span class="keyword">const</span> encryptedData = e.<span class="property">detail</span>.<span class="property">encryptedData</span>;
  <span class="keyword">const</span> [phoneErr, phoneRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">getPhoneNum</span>(iv, encryptedData));
  <span class="keyword">if</span> (phoneErr) &#123;
    <span class="title class_">Toast</span>(<span class="string">&#x27;获取手机号失败&#x27;</span>);
    <span class="keyword">return</span>;
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;getPhoneNumber&#x27;</span>, phoneRes);
&#125;</code></pre>
</li>
<li><p>页面组件，在小程序中一般都有一个页面组件，用于封装一些页面必需的功能，比如loading，导航栏，无效页面等等，登录也是必需的，所以我把登录逻辑封装到页面组件上，如果成功会通过triggerEvent触发给页面，如果失败就弹出登录弹窗，当然这种处理不太细，根据业务的不同改变相关的逻辑<br><img src="https://img-blog.csdnimg.cn/f6cd710acc4d45a1a7d88042623ad4bc.png#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<pre><code class="highlight js"><span class="comment">// index.html</span>
&lt;view&gt;
  ...
  &lt;login-modal show=&#123;loginShow&#125; &#123;...props&#125; /&gt;
&lt;/view&gt;

<span class="comment">// index.js</span>
<span class="keyword">async</span> <span class="title function_">created</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">staticLogin</span>());
  <span class="keyword">if</span> (loginErr) &#123;
    <span class="title class_">Toast</span>(<span class="string">&#x27;登录失败&#x27;</span>);
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">loginShow</span>: <span class="literal">true</span>,
    &#125;);
    <span class="keyword">return</span>;
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;login&#x27;</span>, loginRes);
&#125;</code></pre>
<ol start="5">
<li>还有一些不是太通用的业务组件就不叙述了…</li>
</ol>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序单指拖拽和双指缩放旋转</title>
    <url>/2021/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%95%E6%8C%87%E6%8B%96%E6%8B%BD%E5%92%8C%E5%8F%8C%E6%8C%87%E7%BC%A9%E6%94%BE%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小程序单指拖拽和双指操作是一个比较常用的功能，效果如下图<br><img src="https://img-blog.csdnimg.cn/babbbc7162d241e9b0fb01e0b18531eb.gif#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>实现这三个功能，主要用三个触摸事件<code>touchstart</code>、<code>touchmove</code>、<code>touchend</code><pre><code class="highlight html"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;height: 100vh; width: 100vw&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">image</span></span>
<span class="tag">    <span class="attr">src</span>=<span class="string">&quot;...&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;translateX&#125;&#125;px, &#123;&#123;translateY&#125;&#125;px) scale(&#123;&#123;scale&#125;&#125;) rotate(&#123;&#123;rotate&#125;&#125;deg);&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchstart</span>=<span class="string">&quot;touchStart&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span>
<span class="tag">  /&gt;</span>
<span class="tag">&lt;/<span class="name">view</span>&gt;</span></code></pre></li>
<li>用了以下变量<pre><code class="highlight ts"><span class="title class_">Page</span>(&#123;
  <span class="attr">data</span>: &#123;
    <span class="attr">translateX</span>: <span class="number">0</span>, <span class="comment">// 位移x坐标 单位px</span>
    <span class="attr">translateY</span>: <span class="number">0</span>, <span class="comment">// 位移y坐标 单位px</span>
    <span class="attr">distance</span>: <span class="number">0</span>, <span class="comment">// 双指接触点距离</span>
    <span class="attr">scale</span>: <span class="number">1</span>, <span class="comment">// 缩放倍数</span>
    <span class="attr">rotate</span>: <span class="number">0</span>, <span class="comment">// 旋转角度</span>
    <span class="attr">oldRotate</span>: <span class="number">0</span>, <span class="comment">// 上一次旋转停止后的角度</span>
    <span class="attr">startMove</span>: &#123; <span class="comment">// 起始位移距离</span>
      <span class="attr">x</span>: <span class="number">0</span>,
      <span class="attr">y</span>: <span class="number">0</span>,
    &#125;,
    <span class="attr">startTouches</span>: [] <span class="comment">// 起始点touch数组</span>
  &#125;,
&#125;)</code></pre></li>
</ul>
<h2 id="单指拖拽"><a href="#单指拖拽" class="headerlink" title="单指拖拽"></a>单指拖拽</h2><ul>
<li>实现单指拖拽比较简单，只需要记录移动的点坐标，然后减去起始点坐标，就可以求出相对页面的移动距离</li>
<li><code>touchstart</code><pre><code class="highlight ts"><span class="title function_">touchStart</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> touches = e.<span class="property">touches</span>
  <span class="keyword">const</span> &#123; translateX, translateY &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = touches[<span class="number">0</span>]
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">startMove</span> = &#123;
    <span class="attr">x</span>: pageX - translateX,
    <span class="attr">y</span>: pageY - translateY
  &#125;
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">startTouches</span> = touches
&#125;,</code></pre></li>
<li><code>touchmove</code><pre><code class="highlight ts"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> touches = e.<span class="property">touches</span>
  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; startMove &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,
    <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span>
  &#125;)
&#125;</code></pre></li>
</ul>
<h2 id="双指缩放"><a href="#双指缩放" class="headerlink" title="双指缩放"></a>双指缩放</h2><ul>
<li>双指缩放的原理是根据两点坐标求出距离(勾股定理)，然后在用移动坐标的距离比就可以求出缩放倍数</li>
<li><code>touchmove</code><pre><code class="highlight js"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> touches = e.<span class="property">touches</span>
  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; startMove, scale, <span class="attr">distance</span>: oldDistance, startTouches &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">if</span> (touches.<span class="property">length</span> === <span class="number">2</span> &amp;&amp; startTouches.<span class="property">length</span> === <span class="number">2</span>) &#123;
    <span class="comment">// 双指缩放</span>
    <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: twoPageX, <span class="attr">pageY</span>: twoPageY &#125; = touches[<span class="number">1</span>]
    <span class="comment">// 求出当前双指距离</span>
    <span class="keyword">const</span> distance = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((twoPageX - onePageX) ** <span class="number">2</span> + (twoPageY - onePageY) ** <span class="number">2</span>)
    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">distance</span> = distance
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">scale</span>: scale * (distance / (oldDistance || distance))
    &#125;)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startTouches.<span class="property">length</span> !== <span class="number">2</span>) &#123;
    <span class="comment">// 单指拖拽</span>
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,
      <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span>
    &#125;)
  &#125;
&#125;</code></pre></li>
<li><code>startTouches.length !== 2</code>这个判断的原因是防止图片跳动，因为如果你两个手指触摸，然后离开一个手指，我是禁止拖拽的，只有双指都离开后再次触摸才能单指拖拽</li>
</ul>
<h2 id="双指旋转"><a href="#双指旋转" class="headerlink" title="双指旋转"></a>双指旋转</h2><ul>
<li>双指旋转的原理是根据三角函数求出起始点的角度，然后再求出移动坐标的角度，相减然后加上上一次旋转的角度就等于你当前所需的选择角度</li>
<li><code>touchmove</code></li>
</ul>
<pre><code class="highlight ts"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> touches = e.<span class="property">touches</span>
  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; startMove, scale, <span class="attr">distance</span>: oldDistance, startTouches, oldRotate &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">if</span> (touches.<span class="property">length</span> === <span class="number">2</span> &amp;&amp; startTouches.<span class="property">length</span> === <span class="number">2</span>) &#123;
    <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: twoPageX, <span class="attr">pageY</span>: twoPageY &#125; = touches[<span class="number">1</span>]
    <span class="keyword">const</span> distance = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((twoPageX - onePageX) ** <span class="number">2</span> + (twoPageY - onePageY) ** <span class="number">2</span>)
+   <span class="keyword">let</span> rotate = <span class="variable language_">this</span>.<span class="title function_">getAngle</span>(touches[<span class="number">0</span>], touches[<span class="number">1</span>]) - <span class="variable language_">this</span>.<span class="title function_">getAngle</span>(startTouches[<span class="number">0</span>], startTouches[<span class="number">1</span>]) + oldRotate
  <span class="comment">// 如果大于360度，就减去360</span>
+   rotate = rotate &gt; <span class="number">360</span> ? rotate - <span class="number">360</span> : rotate
    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">distance</span> = distance
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">scale</span>: scale * (distance / (oldDistance || distance)),
+     rotate
    &#125;)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startTouches.<span class="property">length</span> !== <span class="number">2</span>) &#123;
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,
      <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span>
    &#125;)
  &#125;
&#125;,</code></pre>
<ul>
<li><code>getAngle</code><pre><code class="highlight ts"><span class="title function_">getAngle</span>(<span class="params">p1, p2</span>) &#123;
  <span class="keyword">const</span> x = p1.<span class="property">pageX</span> - p2.<span class="property">pageX</span>
  <span class="keyword">const</span> y = p1.<span class="property">pageY</span>- p2.<span class="property">pageY</span>
  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">atan2</span>(y, x) * <span class="number">180</span> / <span class="title class_">Math</span>.<span class="property">PI</span>
&#125;</code></pre></li>
<li><code>touchend</code><pre><code class="highlight ts"><span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;
  <span class="comment">// 保存当前旋转角度</span>
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">oldRotate</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">rotate</span>
&#125;,</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/0nS1tImU7Rs5</code></li>
<li>H5原理一致，只需改一下语法即可</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序图片上传&amp;九宫格拖拽组件</title>
    <url>/2021/09/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="微信小程序图片上传-amp-九宫格拖拽组件"><a href="#微信小程序图片上传-amp-九宫格拖拽组件" class="headerlink" title="微信小程序图片上传&amp;九宫格拖拽组件"></a>微信小程序图片上传&amp;九宫格拖拽组件</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>图片上传加九宫格拖拽是一个比较常用的组件，常用于发帖或者评论等内容上传模块，我这篇九宫格拖拽的思路是借鉴了<a href="https://www.cnblogs.com/haha1212/p/11562944.html"><strong>一款优雅的小程序拖拽排序组件实现</strong></a>这篇文章</p>
</li>
<li><p>实现效果如下图<br><img src="https://img-blog.csdnimg.cn/cc8c84d6bc3049349e94b95f540916c7.gif" alt="请添加图片描述"></p>
</li>
<li><p>实现原理：新增图片时，为每一个图片增加一个key属性，和tranX、tranY属性，用于transform位移，然后这个九宫格的拖拽新增删除都是以key为标记来修改tranX和tranY，从而达到拖拽效果</p>
</li>
<li><p>使用了以下变量</p>
<pre><code class="highlight js"><span class="attr">data</span>: &#123;
  <span class="attr">ITEM_SIZE</span>: <span class="number">100</span>, <span class="comment">// 图片大小 单位px</span>
  <span class="attr">dragImgList</span>: [], <span class="comment">// 图片列表 &#123; src: string, key: number, tranX: number, tranY: number &#125;[]</span>
  <span class="attr">containerRes</span>: &#123;&#125;, <span class="comment">// 拖拽容器属性</span>
  <span class="attr">currentKey</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的key</span>
  <span class="attr">currentIndex</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的index</span>
  <span class="attr">tranX</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的x距离</span>
  <span class="attr">tranY</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的y距离</span>
  <span class="attr">uploadPosition</span>: &#123; <span class="comment">// upload上传图标位移距离</span>
    <span class="attr">tranX</span>: <span class="number">0</span>,
    <span class="attr">tranY</span>: <span class="number">0</span>,
  &#125;
&#125;,</code></pre></li>
</ul>
<h3 id="WXML-amp-WXSS"><a href="#WXML-amp-WXSS" class="headerlink" title="WXML &amp; WXSS"></a>WXML &amp; WXSS</h3><pre><code class="highlight html"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-container&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">view</span></span>
<span class="tag">    <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;dragImgList&#125;&#125;&quot;</span> </span>
<span class="tag">    <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;index === currentIndex ? tranX : item.tranX&#125;&#125;px, &#123;&#123;index === currentIndex ? tranY : item.tranY&#125;&#125;px); z-index: &#123;&#123;index === currentIndex ? 10 : 1&#125;&#125;;&quot;</span></span>
<span class="tag">    <span class="attr">class</span>=<span class="string">&quot;darg-item item-transition&quot;</span></span>
<span class="tag">    <span class="attr">mark:index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">catch:longpress</span>=<span class="string">&quot;longPress&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span>
<span class="tag">  &gt;</span>
    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;darg-item-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.src&#125;&#125;&quot;</span>/&gt;</span>
    <span class="tag">&lt;<span class="name">text</span> <span class="attr">catch:tap</span>=<span class="string">&quot;deleteImg&quot;</span> <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete&quot;</span>&gt;</span>×<span class="tag">&lt;/<span class="name">text</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
  <span class="tag">&lt;<span class="name">view</span></span>
<span class="tag">    <span class="attr">bindtap</span>=<span class="string">&quot;uploadImage&quot;</span></span>
<span class="tag">    <span class="attr">class</span>=<span class="string">&quot;darg-item drag-item-upload&quot;</span></span>
<span class="tag">    <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123;dragImgList.length &gt;= 9&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;uploadPosition.tranX&#125;&#125;px, &#123;&#123;uploadPosition.tranY&#125;&#125;px);&quot;</span></span>
<span class="tag">  &gt;</span>+<span class="tag">&lt;/<span class="name">view</span>&gt;</span>
<span class="tag">&lt;/<span class="name">view</span>&gt;</span></code></pre>
<pre><code class="highlight css"><span class="selector-class">.drag-container</span>&#123;
  <span class="attribute">position</span>: relative;
  <span class="attribute">width</span>: <span class="number">300px</span>;
  <span class="attribute">height</span>: <span class="number">300px</span>;
&#125;
<span class="selector-class">.item-transition</span> &#123;
  <span class="attribute">transition</span>: transform <span class="number">0.1s</span>
&#125;
<span class="selector-class">.darg-item</span>&#123;
  <span class="attribute">position</span>: absolute;
  <span class="attribute">top</span>: <span class="number">0</span>;
  <span class="attribute">left</span>: <span class="number">0</span>;
  <span class="attribute">width</span>: <span class="number">100px</span>;
  <span class="attribute">height</span>: <span class="number">100px</span>;
&#125;
<span class="selector-class">.darg-item-img</span>&#123;
  <span class="attribute">width</span>: <span class="number">100%</span>;
  <span class="attribute">height</span>: <span class="number">100%</span>;
&#125;
<span class="selector-class">.drag-item-delete</span>&#123;
  <span class="attribute">position</span>: absolute;
  <span class="attribute">top</span>: <span class="number">0</span>;
  <span class="attribute">right</span>: <span class="number">0</span>;
  <span class="attribute">width</span>: <span class="number">58</span>rpx;
  <span class="attribute">height</span>: <span class="number">33</span>rpx;
  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.7</span>);
  <span class="attribute">font-size</span>: <span class="number">47</span>rpx;
  <span class="attribute">line-height</span>: <span class="number">25</span>rpx;
  <span class="attribute">text-align</span>: center;
  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">64</span>rpx;
  <span class="attribute">color</span>: <span class="number">#fff</span>;
&#125;
<span class="selector-class">.drag-item-upload</span>&#123;
  <span class="attribute">background-color</span>: burlywood;
  <span class="attribute">font-size</span>: <span class="number">200</span>rpx;
  <span class="attribute">text-align</span>: center;
  <span class="attribute">color</span>: white;
  <span class="attribute">line-height</span>: <span class="number">200</span>rpx;
&#125;</code></pre>

<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><ul>
<li>图片上传很简单，就是初始化上传的图片，然后拼接图片列表，最后修改上传图标位置即可<pre><code class="highlight js"><span class="title function_">uploadImage</span>(<span class="params"></span>) &#123;
  <span class="keyword">let</span> &#123; dragImgList, <span class="variable constant_">ITEM_SIZE</span> &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  wx.<span class="title function_">chooseImage</span>(&#123;
    <span class="attr">count</span>: <span class="number">9</span> - dragImgList.<span class="property">length</span>,
    <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;
      <span class="keyword">const</span> imgList = res.<span class="property">tempFilePaths</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (&#123;
        <span class="attr">tranX</span>: <span class="variable constant_">ITEM_SIZE</span> * ((dragImgList.<span class="property">length</span> + index) % <span class="number">3</span>),
        <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>((dragImgList.<span class="property">length</span> + index) / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>,
        <span class="attr">src</span>: item,
        <span class="attr">key</span>: dragImgList.<span class="property">length</span> + index
      &#125;))
      dragImgList = dragImgList.<span class="title function_">concat</span>(imgList)
      <span class="comment">// 修改上传图标位置</span>
      <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(dragImgList.<span class="property">length</span>)
      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
        dragImgList,
      &#125;)
    &#125;
  &#125;)
&#125;,</code></pre>
<pre><code class="highlight js"><span class="title function_">setUploaPosition</span>(<span class="params">listLength</span>) &#123;
  <span class="keyword">const</span> <span class="variable constant_">ITEM_SIZE</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">ITEM_SIZE</span>
  <span class="keyword">const</span> uploadPosition = &#123;
    <span class="attr">tranX</span>: listLength % <span class="number">3</span> * <span class="variable constant_">ITEM_SIZE</span>,
    <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(listLength / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>,
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    uploadPosition,
  &#125;)
&#125;,</code></pre></li>
</ul>
<h3 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h3><ul>
<li>首先从图片列表中删除所需图片，然后修改列表，把大于所选图片key的key全部减一，最后修改剩余图片位置和上传图标位置<pre><code class="highlight js"><span class="title function_">deleteImg</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> key = e.<span class="property">mark</span>.<span class="property">key</span>
  <span class="comment">// 删除图片</span>
  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> !== key)
  <span class="comment">// 修改key值</span>
  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> &gt; key &amp;&amp; item.<span class="property">key</span>--)
  <span class="comment">// 修改剩余图片位置</span>
  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(list)
  <span class="comment">// 修改上传图标位置</span>
  <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(list.<span class="property">length</span>)
&#125;</code></pre>
<pre><code class="highlight js"><span class="title function_">getListPosition</span>(<span class="params">list</span>) &#123;
  <span class="keyword">const</span> <span class="variable constant_">ITEM_SIZE</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">ITEM_SIZE</span>
  <span class="keyword">const</span> dragImgList = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    item.<span class="property">tranX</span> = <span class="variable constant_">ITEM_SIZE</span> * (item.<span class="property">key</span> % <span class="number">3</span>);
    item.<span class="property">tranY</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(item.<span class="property">key</span> / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>;
    <span class="keyword">return</span> item
  &#125;)
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    dragImgList,
  &#125;)

  <span class="comment">// 向页面传递最新图片列表</span>
  <span class="keyword">const</span> urlList = [...dragImgList].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">key</span> - b.<span class="property">key</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">src</span>)
  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;updateImage&#x27;</span>, &#123;
    <span class="attr">list</span>: urlList
  &#125;)
&#125;,</code></pre></li>
</ul>
<h3 id="九宫格拖拽"><a href="#九宫格拖拽" class="headerlink" title="九宫格拖拽"></a>九宫格拖拽</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>初始化只需获取容器的位置信息即可，因为拖拽组件不一定是在页面的左上角，所以需要知道容器的位置信息<pre><code class="highlight js"><span class="attr">lifetimes</span>: &#123;
  <span class="title function_">ready</span>(<span class="params"></span>) &#123;
    <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>()
      .<span class="title function_">select</span>(<span class="string">&quot;.drag-container&quot;</span>)
      .<span class="title function_">boundingClientRect</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;
        <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span> = res
      &#125;).<span class="title function_">exec</span>();
  &#125;
&#125;,</code></pre></li>
</ul>
<h4 id="longPress"><a href="#longPress" class="headerlink" title="longPress"></a>longPress</h4><ul>
<li>这里采用longPress，而不是touchStart的原因，一是为了优化体验，二是touchStart与删除按钮冲突<pre><code class="highlight js"><span class="title function_">longPress</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> index = e.<span class="property">mark</span>.<span class="property">index</span>
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; top, left &#125; = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span>
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">currentIndex</span>: index,
    <span class="attr">tranX</span>: pageX - <span class="number">50</span> - left,
    <span class="attr">tranY</span>: pageY - <span class="number">50</span> - top
  &#125;)
&#125;,</code></pre></li>
</ul>
<h4 id="touchMove"><a href="#touchMove" class="headerlink" title="touchMove"></a>touchMove</h4><ul>
<li>touchMove首先计算出位移距离，然后根据位移距离求出停放位置的key，如果不一样就修改位置<pre><code class="highlight js"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="comment">// 如果currentIndex &lt; 0，说明并没有触发longPress</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentIndex</span> &lt; <span class="number">0</span>) <span class="keyword">return</span>
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; top, left &#125; = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span>
  <span class="keyword">const</span> tranX = pageX - <span class="number">50</span> - left
  <span class="keyword">const</span> tranY = pageY - <span class="number">50</span> - top
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    tranX,
    tranY
  &#125;)
  <span class="comment">// 对比当前移动的key和停放位置的key，如果不一样就修改位置</span>
  <span class="keyword">const</span> currentKey = e.<span class="property">mark</span>.<span class="property">key</span>
  <span class="keyword">const</span> moveKey = <span class="variable language_">this</span>.<span class="title function_">getMoveKey</span>(tranX, tranY)
  <span class="keyword">if</span> (currentKey === moveKey || <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> === currentKey) <span class="keyword">return</span>
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = currentKey
  <span class="variable language_">this</span>.<span class="title function_">insert</span>(currentKey, moveKey)
&#125;,</code></pre>
<pre><code class="highlight js"><span class="title function_">getMoveKey</span>(<span class="params">tranX, tranY</span>) &#123;
  <span class="keyword">const</span> &#123; <span class="attr">dragImgList</span>: list, <span class="variable constant_">ITEM_SIZE</span> &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">const</span> <span class="title function_">_getPositionNumber</span> = (<span class="params">position</span>) =&gt; &#123;
    <span class="keyword">const</span> positionNumber = <span class="title class_">Math</span>.<span class="title function_">round</span>(position/ <span class="variable constant_">ITEM_SIZE</span>)
    <span class="keyword">return</span> positionNumber &gt; <span class="number">2</span> ? <span class="number">2</span> : positionNumber &lt; <span class="number">0</span> ? <span class="number">0</span> : positionNumber
  &#125;
  <span class="keyword">const</span> endKey = <span class="number">3</span> * <span class="title function_">_getPositionNumber</span>(tranY) + <span class="title function_">_getPositionNumber</span>(tranX)
  <span class="keyword">return</span> endKey &gt;= list.<span class="property">length</span> ? list.<span class="property">length</span> - <span class="number">1</span> : endKey
&#125;,</code></pre>
<pre><code class="highlight js"><span class="title function_">insert</span>(<span class="params">origin, end</span>) &#123;
  <span class="keyword">const</span> dragImgList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>
  dragImgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (origin &lt; end) &#123;
      <span class="comment">// 如果起始key小于结束key，就把区间内的key全部减一</span>
      <span class="keyword">if</span> (item.<span class="property">key</span> &gt; origin &amp;&amp; item.<span class="property">key</span> &lt;= end) item.<span class="property">key</span>--
      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === origin) item.<span class="property">key</span> = end
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (origin &gt; end) &#123;
      <span class="comment">// 如果起始key大于结束key，就把区间内的key全部加一</span>
      <span class="keyword">if</span> (item.<span class="property">key</span> &gt;= end &amp;&amp; item.<span class="property">key</span> &lt; origin) item.<span class="property">key</span>++
      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === origin) item.<span class="property">key</span> = end
    &#125;
  &#125;)
  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(dragImgList)
&#125;,</code></pre></li>
</ul>
<h4 id="touchEnd"><a href="#touchEnd" class="headerlink" title="touchEnd"></a>touchEnd</h4><ul>
<li>touchEnd用于重置数据<pre><code class="highlight js"><span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">tranX</span>: <span class="number">0</span>,
    <span class="attr">tranY</span>: <span class="number">0</span>,
    <span class="attr">currentIndex</span>: -<span class="number">1</span>,
  &#125;)
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = -<span class="number">1</span>
&#125;,</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/2rFIJamX7xty</code></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序图片拖拽排序组件</title>
    <url>/2022/09/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>图片拖拽排序是一个比较常用的组件，常用于发帖或者评论等内容上传模块，我借鉴了<a href="https://www.cnblogs.com/haha1212/p/11562944.html">《一款优雅的小程序拖拽排序组件实现》</a>这篇文章的拖拽思路，并封装成<a href="https://github.com/LHRUN/wx-drag-img">wx-drag-img</a>发布到npm</li>
<li>实现原理：每个图片初始化我都会封装成一个拖拽的数据结构，然后触发touch事件时，通过改变图片的key来计算transform位置，从而达到拖拽效果</li>
<li>功能包括图片上传拖拽删除，源码和npm地址我会贴在结尾，如果感觉好的话，欢迎star</li>
<li>我会在下面逐步分析这个组件的实现思路</li>
<li>使用了以下变量<pre><code class="highlight ts"><span class="comment">// 拖拽数据结构</span>
<span class="keyword">interface</span> <span class="title class_">IDragImg</span> &#123;
  <span class="attr">src</span>: <span class="built_in">string</span>; <span class="comment">// 图片路径</span>
  <span class="attr">key</span>: <span class="built_in">number</span>; <span class="comment">// </span>
  <span class="attr">id</span>: <span class="built_in">number</span>; <span class="comment">// for循环遍历使用, 不会改变, 创建时自增id</span>
  <span class="attr">tranX</span>: <span class="built_in">number</span>; <span class="comment">// x轴位移距离</span>
  <span class="attr">tranY</span>: <span class="built_in">number</span>; <span class="comment">// y轴位移距离</span>
&#125;

<span class="comment">// props</span>
&#123;
  previewSize <span class="comment">// 图片大小</span>
  defaultImgList <span class="comment">// 初始化图片数组</span>
  maxCount <span class="comment">// 图片上传数量限制</span>
  columns <span class="comment">// 列数</span>
  gap <span class="comment">// 图片间隔</span>
  deleteStyle <span class="comment">// 删除样式</span>
&#125;

<span class="attr">data</span>: &#123;
  <span class="attr">dragImgList</span>: <span class="title class_">IDragImg</span>[],
  <span class="attr">containerRes</span>: &#123;
    <span class="attr">top</span>: <span class="number">0</span>, <span class="comment">// 容器距离页面顶部距离 px</span>
    <span class="attr">left</span>: <span class="number">0</span>, <span class="comment">// 容器距离页面左边距离 px</span>
    <span class="attr">width</span>: <span class="number">0</span>, <span class="comment">// 容器宽度 px</span>
    <span class="attr">height</span>: <span class="number">0</span>, <span class="comment">// 容器高度 px</span>
  &#125;, <span class="comment">// 拖拽容器属性</span>
  <span class="attr">currentKey</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的key</span>
  <span class="attr">currentIndex</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的index</span>
  <span class="attr">tranX</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的x距离</span>
  <span class="attr">tranY</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的y距离</span>
  <span class="attr">uploadPosition</span>: &#123; <span class="comment">// upload上传图标位移距离</span>
    <span class="attr">tranX</span>: <span class="number">0</span>,
    <span class="attr">tranY</span>: <span class="number">0</span>,
  &#125;
&#125;,</code></pre></li>
</ul>
<h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><pre><code class="highlight html"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;width: &#123;&#123;containerRes.width&#125;&#125;px; height: &#123;&#123;containerRes.height&#125;&#125;px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-container&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">view</span></span>
<span class="tag">    <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;dragImgList&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;index === currentIndex ? tranX : item.tranX&#125;&#125;px, &#123;&#123;index === currentIndex ? tranY : item.tranY&#125;&#125;px); z-index: &#123;&#123;index === currentIndex ? 10 : 1&#125;&#125;; width: &#123;&#123;previewSize&#125;&#125;px; height: &#123;&#123;previewSize&#125;&#125;px;&quot;</span></span>
<span class="tag">    <span class="attr">class</span>=<span class="string">&quot;drag-item drag-item-transition&quot;</span></span>
<span class="tag">    <span class="attr">mark:index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">catch:longpress</span>=<span class="string">&quot;longPress&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span>
<span class="tag">  &gt;</span>
    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.src&#125;&#125;&quot;</span>/&gt;</span>
    <span class="comment">&lt;!-- 删除图标 --&gt;</span>
    <span class="tag">&lt;<span class="name">view</span> <span class="attr">catch:tap</span>=<span class="string">&quot;deleteImg&quot;</span> <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete&quot;</span>&gt;</span>
      <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete_default&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&#123;&#123;deleteStyle&#125;&#125;&quot;</span>&gt;</span>x<span class="tag">&lt;/<span class="name">view</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">view</span>&gt;</span>

  <span class="comment">&lt;!-- 上传图片 --&gt;</span>
  <span class="tag">&lt;<span class="name">view</span></span>
<span class="tag">    <span class="attr">bindtap</span>=<span class="string">&quot;uploadImage&quot;</span></span>
<span class="tag">    <span class="attr">class</span>=<span class="string">&quot;drag-item drag-upload&quot;</span></span>
<span class="tag">    <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123;dragImgList.length &gt;= maxCount&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;uploadPosition.tranX&#125;&#125;px, &#123;&#123;uploadPosition.tranY&#125;&#125;px); width: &#123;&#123;previewSize&#125;&#125;px; height: &#123;&#123;previewSize&#125;&#125;px;&quot;</span></span>
<span class="tag">  &gt;</span>
    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-upload_solt&quot;</span>&gt;</span>
      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-upload_default&quot;</span>&gt;</span>
      <span class="tag">&lt;<span class="name">text</span>&gt;</span>+<span class="tag">&lt;/<span class="name">text</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
<span class="tag">&lt;/<span class="name">view</span>&gt;</span></code></pre>

<h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><ul>
<li>图片上传很简单，就是初始化上传的图片，然后拼接到现有图片，最后修改上传图标位置即可</li>
<li>点击上传区域回调函数<code>uploadImage</code><pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 上传图片</span>
<span class="comment"> */</span>
<span class="keyword">async</span> <span class="title function_">uploadImage</span>(<span class="params"></span>) &#123;
  <span class="keyword">let</span> &#123; dragImgList, maxCount &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">try</span> &#123;
    <span class="keyword">const</span> res = <span class="keyword">await</span> wx.<span class="title function_">chooseMedia</span>(&#123;
      <span class="attr">count</span>: maxCount - dragImgList.<span class="property">length</span>,
      <span class="attr">mediaType</span>: [<span class="string">&#x27;image&#x27;</span>],
    &#125;);
    <span class="comment">// 获取上传图片数据后需要初始化图片拽结构</span>
    <span class="keyword">const</span> imgList = <span class="variable language_">this</span>.<span class="title function_">getDragImgList</span>(res?.<span class="property">tempFiles</span>?.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; tempFilePath &#125;</span>) =&gt;</span> tempFilePath) || [], <span class="literal">false</span>);
    dragImgList = dragImgList.<span class="title function_">concat</span>(imgList);
    <span class="comment">// 修改上传区域位置</span>
    <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(dragImgList.<span class="property">length</span>);
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      dragImgList,
    &#125;);
    <span class="variable language_">this</span>.<span class="title function_">updateEvent</span>(dragImgList);
  &#125; <span class="keyword">catch</span> (error) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);
  &#125;
&#125;,</code></pre></li>
<li>上传后需要初始化拖拽的数据结构<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 根据图片列表生成拖拽列表数据结构</span>
<span class="comment"> * <span class="doctag">@param</span> list 图片src列表</span>
<span class="comment"> * <span class="doctag">@param</span> init 是否是初始化</span>
<span class="comment"> */</span>
 <span class="title function_">getDragImgList</span>(<span class="params">list, init = <span class="literal">true</span></span>) &#123;
  <span class="keyword">let</span> &#123; dragImgList, previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">return</span> list.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;
    <span class="keyword">const</span> i = (init ? <span class="number">0</span> : dragImgList.<span class="property">length</span>) + index;
    <span class="keyword">return</span> &#123;
      <span class="attr">tranX</span>: (previewSize + gap) * (i % columns),
      <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(i / columns) * (previewSize + gap),
      <span class="attr">src</span>: item,
      <span class="attr">id</span>: i,
      <span class="attr">key</span>: i,
    &#125;;
  &#125;);
&#125;,</code></pre></li>
<li>修改上传区域位置<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 修改上传区域位置</span>
<span class="comment"> * <span class="doctag">@param</span> listLength 数组长度</span>
<span class="comment"> */</span>
<span class="title function_">setUploaPosition</span>(<span class="params">listLength</span>) &#123;
  <span class="keyword">const</span> &#123; previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> uploadPosition = &#123;
    <span class="attr">tranX</span>: listLength % columns * (previewSize + gap),
    <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(listLength / columns) * (previewSize + gap),
  &#125;;
  <span class="keyword">const</span> &#123; width, height &#125; = <span class="variable language_">this</span>.<span class="title function_">getContainerRect</span>(listLength);
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    uploadPosition,
    [<span class="string">&#x27;containerRes.width&#x27;</span>]: width,
    [<span class="string">&#x27;containerRes.height&#x27;</span>]: height,
  &#125;);
&#125;,</code></pre></li>
<li>图片数量改变后就要重新获取容器宽高了<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 改变图片数量后获取容器宽高</span>
<span class="comment"> * <span class="doctag">@parma</span> listLength 数组长度</span>
<span class="comment"> */</span>
<span class="title function_">getContainerRect</span>(<span class="params">listLength</span>) &#123;
  <span class="keyword">const</span> &#123; columns, previewSize, maxCount, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> number = listLength === maxCount ? listLength : listLength + <span class="number">1</span>;
  <span class="keyword">const</span> row = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(number / columns)
  <span class="keyword">return</span> &#123;
    <span class="attr">width</span>: columns * previewSize + (columns - <span class="number">1</span>) * gap,
    <span class="attr">height</span>: row * previewSize + gap * (row - <span class="number">1</span>),
  &#125;;
&#125;,</code></pre></li>
<li>updateEvent<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * updateEvent</span>
<span class="comment"> * <span class="doctag">@describe</span> 上传删除拖拽后触发事件把列表数据发给页面</span>
<span class="comment"> */</span>
<span class="title function_">updateEvent</span>(<span class="params">dragImgList</span>) &#123;
  <span class="keyword">const</span> list = [...dragImgList].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">key</span> - b.<span class="property">key</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">src</span>);
    <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;updateImageList&#x27;</span>, &#123;
      list,
  &#125;);
&#125;,</code></pre></li>
</ul>
<h3 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h3><ul>
<li>首先从图片列表中删除所需图片，然后修改列表，把大于所选图片key的key全部减一，最后计算剩余图片位置和上传图标位置<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 删除图片</span>
<span class="comment"> */</span>
<span class="title function_">deleteImg</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> key = e.<span class="property">mark</span>.<span class="property">key</span>;
  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> !== key);
  <span class="comment">// 大于删除图片key的key全部减1</span>
  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    item.<span class="property">key</span> &gt; key &amp;&amp; item.<span class="property">key</span>--;
  &#125;);
  <span class="comment">// 获取</span>
  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(list);
  <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(list.<span class="property">length</span>);
&#125;,</code></pre>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 计算数组的位移位置</span>
<span class="comment"> * <span class="doctag">@param</span> list 拖拽图片数组</span>
<span class="comment"> */</span>
<span class="title function_">getListPosition</span>(<span class="params">list</span>) &#123;
  <span class="keyword">const</span> &#123; previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> dragImgList = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    item.<span class="property">tranX</span> = (previewSize + gap) * (item.<span class="property">key</span> % columns);
    item.<span class="property">tranY</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(item.<span class="property">key</span> / columns) * (previewSize + gap);
    <span class="keyword">return</span> item;
  &#125;)
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    dragImgList,
  &#125;);
  <span class="variable language_">this</span>.<span class="title function_">updateEvent</span>(dragImgList);
&#125;,</code></pre></li>
</ul>
<h2 id="图片拖拽"><a href="#图片拖拽" class="headerlink" title="图片拖拽"></a>图片拖拽</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化只需获取容器的位置信息即可，因为拖拽组件不一定是在页面的左上角，所以需要知道容器的位置信息<pre><code class="highlight js"><span class="attr">lifetimes</span>: &#123;
  <span class="title function_">ready</span>(<span class="params"></span>) &#123;
    <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>()
      .<span class="title function_">select</span>(<span class="string">&quot;.drag-container&quot;</span>)
      .<span class="title function_">boundingClientRect</span>(<span class="function">(<span class="params">&#123; top, left &#125;</span>) =&gt;</span> &#123;
        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
          [<span class="string">&#x27;containerRes.top&#x27;</span>]: top,
          [<span class="string">&#x27;containerRes.left&#x27;</span>]: left,
        &#125;);
      &#125;).<span class="title function_">exec</span>();
  &#125;
&#125;,</code></pre></li>
</ul>
<h3 id="longPress"><a href="#longPress" class="headerlink" title="longPress"></a>longPress</h3><ul>
<li>这里采用longPress，而不是touchStart的原因，一是为了优化体验，二是touchStart与删除按钮冲突<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 长按图片</span>
<span class="comment"> */</span>
<span class="title function_">longPress</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> index = e.<span class="property">mark</span>.<span class="property">index</span>;
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>];
  <span class="keyword">const</span> &#123; previewSize, <span class="attr">containerRes</span>: &#123; top, left &#125; &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">currentIndex</span>: index,
    <span class="attr">tranX</span>: pageX - previewSize / <span class="number">2</span> - left,
    <span class="attr">tranY</span>: pageY - previewSize / <span class="number">2</span> - top,
  &#125;);
&#125;,</code></pre></li>
</ul>
<h3 id="touchMove"><a href="#touchMove" class="headerlink" title="touchMove"></a>touchMove</h3><ul>
<li>touchMove首先计算出位移距离，然后根据位移距离求出停放位置的key，如果不一样就修改位置</li>
<li>touchMove<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * touchMove</span>
<span class="comment"> */</span>
<span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="comment">// 如果currentIndex &lt; 0，说明并没有触发longPress</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentIndex</span> &lt; <span class="number">0</span>) &#123;
    <span class="keyword">return</span>;
  &#125;
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>];
  <span class="keyword">const</span> &#123; previewSize, <span class="attr">containerRes</span>: &#123; top, left &#125; &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> tranX = pageX - previewSize / <span class="number">2</span> - left;
  <span class="keyword">const</span> tranY = pageY - previewSize / <span class="number">2</span> - top;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    tranX,
    tranY
  &#125;);
  <span class="comment">// 对比当前移动的key和停放位置的key，如果不一样就修改位置</span>
  <span class="keyword">const</span> currentKey = e.<span class="property">mark</span>.<span class="property">key</span>;
  <span class="keyword">const</span> moveKey = <span class="variable language_">this</span>.<span class="title function_">getMoveKey</span>(tranX, tranY);

  <span class="comment">// 当移动的key和正在停放位置的key相等，就无须处理</span>
  <span class="keyword">if</span> (currentKey === moveKey || <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> === currentKey) &#123;
    <span class="keyword">return</span>;
  &#125;
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = currentKey;
  <span class="variable language_">this</span>.<span class="title function_">replace</span>(currentKey, moveKey);
&#125;,</code></pre></li>
<li>getMoveKey<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 计算移动中的key</span>
<span class="comment"> * <span class="doctag">@param</span> tranX 正在拖拽图片的tranX</span>
<span class="comment"> * <span class="doctag">@param</span> tranY 正在拖拽图片的tranY</span>
<span class="comment"> */</span>
<span class="title function_">getMoveKey</span>(<span class="params">tranX, tranY</span>) &#123;
  <span class="keyword">const</span> &#123; <span class="attr">dragImgList</span>: list, previewSize, columns &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> <span class="title function_">_getPositionNumber</span> = (<span class="params">drag, limit</span>) =&gt; &#123;
    <span class="keyword">const</span> positionNumber = <span class="title class_">Math</span>.<span class="title function_">round</span>(drag / previewSize);
    <span class="keyword">return</span> positionNumber &gt;= limit ? limit - <span class="number">1</span> : positionNumber &lt; <span class="number">0</span> ? <span class="number">0</span> : positionNumber;
  &#125;
  <span class="keyword">const</span> endKey = columns * <span class="title function_">_getPositionNumber</span>(tranY, <span class="title class_">Math</span>.<span class="title function_">ceil</span>(list.<span class="property">length</span> / columns)) + <span class="title function_">_getPositionNumber</span>(tranX, columns);
  <span class="keyword">return</span> endKey &gt;= list.<span class="property">length</span> ? list.<span class="property">length</span> - <span class="number">1</span> : endKey;
&#125;,</code></pre></li>
<li>replace<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 生成拖拽后的新数组</span>
<span class="comment"> * <span class="doctag">@param</span> start 拖拽起始的key</span>
<span class="comment"> * <span class="doctag">@param</span> end 拖拽结束的key</span>
<span class="comment"> */</span>
<span class="title function_">replace</span>(<span class="params">start, end</span>) &#123;
  <span class="keyword">const</span> dragImgList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>;
  dragImgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (start &lt; end) &#123;
      <span class="keyword">if</span> (item.<span class="property">key</span> &gt; start &amp;&amp; item.<span class="property">key</span> &lt;= end) item.<span class="property">key</span>--;
      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === start) item.<span class="property">key</span> = end;
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; end) &#123;
      <span class="keyword">if</span> (item.<span class="property">key</span> &gt;= end &amp;&amp; item.<span class="property">key</span> &lt; start) item.<span class="property">key</span>++;
      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === start) item.<span class="property">key</span> = end;
    &#125;
  &#125;);
  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(dragImgList);
&#125;,</code></pre></li>
</ul>
<h3 id="touchEnd"><a href="#touchEnd" class="headerlink" title="touchEnd"></a>touchEnd</h3><ul>
<li>touchEnd用于重置数据<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * touchEnd</span>
<span class="comment"> */</span>
<span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">tranX</span>: <span class="number">0</span>,
    <span class="attr">tranY</span>: <span class="number">0</span>,
    <span class="attr">currentIndex</span>: -<span class="number">1</span>,
  &#125;);
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = -<span class="number">1</span>;
&#125;,</code></pre></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><a href="https://github.com/LHRUN/wx-drag-img">repo</a></li>
<li><a href="https://www.npmjs.com/package/wx-drag-img">npm</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/haha1212/p/11562944.html">一款优雅的小程序拖拽排序组件实现</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序瀑布流和虚拟列表</title>
    <url>/2022/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%80%91%E5%B8%83%E6%B5%81%E5%92%8C%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="微信小程序瀑布流和虚拟列表"><a href="#微信小程序瀑布流和虚拟列表" class="headerlink" title="微信小程序瀑布流和虚拟列表"></a>微信小程序瀑布流和虚拟列表</h2><p>首先声明虽然本篇是写的微信小程序的案例，但是也可用于H5，思路是想通的，只是有些api的差异，最后会贴代码片段<br><img src="https://img-blog.csdnimg.cn/40f9275783f14ed4a2a020ec733b3043.gif#pic_center" alt="example"></p>
<h3 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h3><ul>
<li>一般在做长列表优化时，特别是面试时，虚拟列表就是个高频词。这个名词听起来很高级，其实原理很简单</li>
<li>虚拟列表就是将需要渲染的数组数据改造成二维数组，然后通过监听DOM在合适的地方切换为占位元素，达到长列表无限滚动时减少DOM的优化</li>
<li>JS <pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 处理占位元素，就是在获取新的数据后</span>
<span class="comment"> * 通过SelectQuery获取当前数据的实际高度，然后把这个高度设置到占位元素上</span>
<span class="comment"> */</span>
<span class="title function_">getCurrentItemHeight</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> query = <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>();
  <span class="keyword">const</span> &#123; virtualId &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  query.<span class="title function_">select</span>(<span class="string">`#<span class="subst">$&#123;virtualId&#125;</span>`</span>).<span class="title function_">boundingClientRect</span>()
  query.<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">height</span>: res[<span class="number">0</span>].<span class="property">height</span>
    &#125;, <span class="variable language_">this</span>.<span class="title function_">observePage</span>())
  &#125;)
&#125;

<span class="comment">/**</span>
<span class="comment"> * 监听元素与页面的相交</span>
<span class="comment"> * 可以选择指定元素为参照区域，也可以选择页面为参照元素，只是API不同</span>
<span class="comment"> * <span class="doctag">@doc</span> https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html</span>
<span class="comment"> */</span>
<span class="title function_">observePage</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> &#123; virtualId, observeDistance, wrapId &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">let</span> <span class="title class_">IntersectionObserver</span> = wx.<span class="title function_">createIntersectionObserver</span>(<span class="variable language_">this</span>);
  (wrapId ? <span class="title class_">IntersectionObserver</span>.<span class="title function_">relativeTo</span>(<span class="string">`#<span class="subst">$&#123;wrapId&#125;</span>`</span>) : <span class="title class_">IntersectionObserver</span>.<span class="title function_">relativeToViewport</span>(&#123; <span class="attr">top</span>: observeDistance, <span class="attr">bottom</span>: observeDistance &#125;))
  .<span class="title function_">observe</span>(<span class="string">`#<span class="subst">$&#123;virtualId&#125;</span>`</span>, <span class="function">(<span class="params">&#123; intersectionRatio &#125;</span>) =&gt;</span> &#123;
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">isShow</span>: intersectionRatio &gt; <span class="number">0</span>,
    &#125;)
  &#125;)
&#125;</code></pre></li>
<li>html<pre><code class="highlight js">&lt;view id=<span class="string">&quot;&#123;&#123;virtualId&#125;&#125;&quot;</span>&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;isShow&#125;&#125;&quot;</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span>
<span class="language-xml">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span>
  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span> <span class="attr">style</span>=<span class="string">&quot;height: &#123;&#123; height &#125;&#125;px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span>
&lt;/view&gt;</code></pre></li>
</ul>
<h3 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h3><ul>
<li>瀑布流，又称瀑布流式布局。视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部</li>
<li>瀑布流有多种写法，有通过纯CSS完成的，也有借助JS完成的，方法很多，但是我为了接下来能与虚拟列表相结合，就采用JS的写法，就是通过列数把每一列分为一个单独的子元素，然后会记录每一列的高度，通过判断哪一列高度最小，然后将数据push到高度最小的那一列<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 获取列表数据</span>
<span class="comment"> * <span class="doctag">@describe</span> 瀑布流处理，哪列高度小，就往哪列push新数据</span>
<span class="comment"> */</span>
<span class="title function_">getList</span>(<span class="params"></span>) &#123;
  <span class="keyword">let</span> &#123; <span class="attr">listQuery</span>: &#123; pageIndex, pageSize &#125;, columns, columnsHeight &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pageSize; i++) &#123;
    <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)
    <span class="keyword">const</span> item = height &lt; <span class="number">50</span> ? height + <span class="number">50</span> : height
    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">computePosition</span>(columnsHeight)
    columns[position].<span class="title function_">push</span>(item)
    columnsHeight += item
  &#125;
  <span class="comment">// 在html中双重遍历columns，然后通过flex：1均匀分布</span>
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    columns,
  &#125;)
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">columnsHeight</span> = columnsHeight
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取高度最小列下标</span>
<span class="comment"> */</span>
<span class="title function_">computePosition</span>(<span class="params">heights</span>) &#123;
  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...heights);
  <span class="keyword">return</span> heights.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item === min)
&#125;</code></pre></li>
</ul>
<h3 id="瀑布流结合虚拟列表"><a href="#瀑布流结合虚拟列表" class="headerlink" title="瀑布流结合虚拟列表"></a>瀑布流结合虚拟列表</h3><ul>
<li>让瀑布流有虚拟滚动的能力，思路很简单，就是计算每列的偏移量，因为瀑布流被我们分成了二维数组，所以每块子元素之间就会因为列高度的不一致产生空白区域，所以需要计算这个空白区域的大小，然后通过<code>margin-top</code>移动列元素达到视觉上的瀑布流衔接效果<br><img src="https://img-blog.csdnimg.cn/070e8c72d982470ca8808ad8121e6110.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<pre><code class="highlight js"><span class="title function_">getList</span>(<span class="params"></span>) &#123;
  <span class="keyword">let</span> &#123; <span class="attr">listQuery</span>: &#123; pageIndex &#125;, column, columnsHeights &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> columns = [];
  <span class="comment">// 上一组的高度数据，用于计算偏移值</span>
  <span class="keyword">const</span> lastHeights = [...columnsHeights];
  <span class="comment">// 获取数据</span>
  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="title function_">getListData</span>();
  <span class="comment">// 初始化当前屏数据</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; column; i++ ) &#123;
    columns.<span class="title function_">push</span>([]);
  &#125;
  <span class="comment">// 遍历新数据，分配至各列</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i++) &#123;
    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">computePosition</span>(columnsHeights);
    columns[position].<span class="title function_">push</span>(list[i]);
    columnsHeights[position] += <span class="title class_">Number</span>(list[i].<span class="property">height</span>);
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    [<span class="string">`listData[<span class="subst">$&#123;pageIndex&#125;</span>]`</span>]: &#123;
      columns,
      <span class="attr">columnOffset</span>: <span class="variable language_">this</span>.<span class="title function_">computeOffset</span>(lastHeights),
    &#125;
  &#125;);
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">listQuery</span>.<span class="property">pageIndex</span> = pageIndex + <span class="number">1</span>;
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">columnsHeights</span> = columnsHeights;
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 获取列表数据</span>
<span class="comment"> */</span>
<span class="title function_">getListData</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> result = []
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">listQuery</span>.<span class="property">pageSize</span>; i++) &#123;
    <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">300</span>);
    <span class="keyword">const</span> item = &#123;
      <span class="attr">height</span>: height &lt; <span class="number">150</span> ? height + <span class="number">150</span> : height,
      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="title function_">randomRgbColor</span>(),
    &#125;;
    result.<span class="title function_">push</span>(item);
  &#125;
  <span class="keyword">return</span> result;
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 随机生成RGB颜色</span>
<span class="comment"> */</span>
<span class="title function_">randomRgbColor</span>(<span class="params"></span>) &#123;
  <span class="keyword">var</span> r = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内r值</span>
  <span class="keyword">var</span> g = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内g值</span>
  <span class="keyword">var</span> b = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内b值</span>
  <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>)`</span>; <span class="comment">//返回rgb(r,g,b)格式颜色</span>
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 获取最小高度列下标</span>
<span class="comment"> */</span>
<span class="title function_">computePosition</span>(<span class="params">heights</span>) &#123;
  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...heights);
  <span class="keyword">return</span> heights.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item === min);
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 计算偏移量</span>
<span class="comment"> */</span>
<span class="title function_">computeOffset</span>(<span class="params">heights</span>) &#123;
  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...heights);
  <span class="keyword">return</span> heights.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> max - item);
&#125;,

<span class="title function_">onScrollLower</span>(<span class="params"></span>) &#123;
  <span class="variable language_">this</span>.<span class="title function_">getList</span>();
&#125;</code></pre>
<ul>
<li>WXML<pre><code class="highlight js">&lt;view&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">class</span>=<span class="string">&quot;virtualScrollView&quot;</span> <span class="attr">eventhandle</span> <span class="attr">scroll-y</span> <span class="attr">bindscrolltolower</span>=<span class="string">&quot;onScrollLower&quot;</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; listData &#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;screenIndex&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;screenIndex&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;screenItem&quot;</span>&gt;</span></span>
<span class="language-xml">      <span class="tag">&lt;<span class="name">VirtualItem</span> <span class="attr">virtualId</span>=<span class="string">&quot;virtual_&#123;&#123;pageIndex&#125;&#125;&quot;</span>&gt;</span></span>
<span class="language-xml">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;fall&quot;</span>&gt;</span></span>
<span class="language-xml">          <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; screenItem.columns &#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;columnIndex&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;columnIndex&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;column&quot;</span> &gt;</span></span>
<span class="language-xml">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: -&#123;&#123;screenItem.columnOffset[columnIndex]&#125;&#125;px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fallCol&quot;</span>&gt;</span></span>
<span class="language-xml">              <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;column&#125;&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: &#123;&#123; item.height &#125;&#125;px; background-color: &#123;&#123; item.color &#125;&#125;;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span>
<span class="language-xml">                screen: &#123;&#123; screenIndex &#125;&#125;, column: &#123;&#123; columnIndex &#125;&#125;</span>
<span class="language-xml">              <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span>
<span class="language-xml">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span>
<span class="language-xml">          <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span>
<span class="language-xml">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span>
<span class="language-xml">      <span class="tag">&lt;/<span class="name">VirtualItem</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span>
<span class="language-xml">  <span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span>
&lt;/view&gt;</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段：<a href="https://developers.weixin.qq.com/s/5P3DpGmI7PBc">https://developers.weixin.qq.com/s/5P3DpGmI7PBc</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>瀑布流</tag>
        <tag>虚拟列表</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序蓝牙控制开门</title>
    <url>/2020/01/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%93%9D%E7%89%99%E6%8E%A7%E5%88%B6%E5%BC%80%E9%97%A8/</url>
    <content><![CDATA[<h2 id="小程序低功耗蓝牙控制开门"><a href="#小程序低功耗蓝牙控制开门" class="headerlink" title="小程序低功耗蓝牙控制开门"></a>小程序低功耗蓝牙控制开门</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><blockquote>
<ol>
<li>初始化蓝牙模块<code>openBluetoothAdapter</code></li>
<li>获取本机蓝牙适配器状态<code>getBluetoothAdapterState</code></li>
<li>搜索外围蓝牙设备<code>startBluetoothDevicesDiscovery</code></li>
<li>监听寻找到新设备<code>onBluetoothDeviceFound</code></li>
<li>连接蓝牙<code>createBLEConnection</code></li>
<li>获取蓝牙设备的服务<code>getBLEDeviceServices</code></li>
<li>获取服务中的特征值<code>getBLEDeviceCharacteristics</code></li>
<li>启用特征值变化时的notify功能<code>notifyBLECharacteristicValueChange</code></li>
<li>向蓝牙设备写入数据<code>writeBLECharacteristicValue</code></li>
<li>关闭蓝牙模块<code>closeBluetoothAdapter</code></li>
</ol>
</blockquote>
<h3 id="1-初始化蓝牙模块"><a href="#1-初始化蓝牙模块" class="headerlink" title="1. 初始化蓝牙模块"></a>1. 初始化蓝牙模块</h3><ul>
<li>初始化蓝牙模块使用的是：<code>wx.openBluetoothAdapter</code>，初始化之前对蓝牙功能做一个判断，看手机微信版本是否支持此功能</li>
<li>初始化之前需要关闭蓝牙模块：<code>wx.closeBluetoothAdapter</code>，否则容易搜索失败<pre><code class="highlight js"><span class="keyword">var</span> _this = <span class="variable language_">this</span>
<span class="keyword">if</span> (!wx.<span class="property">openBluetoothAdapter</span>) &#123;
  wx.<span class="title function_">showModal</span>(&#123;
    <span class="attr">title</span>: <span class="string">&#x27;提示&#x27;</span>,
    <span class="attr">showCancel</span>: <span class="literal">false</span>,
    <span class="attr">content</span>: <span class="string">&#x27;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试&#x27;</span>,
  &#125;)
&#125; <span class="keyword">else</span> &#123;
  wx.<span class="title function_">closeBluetoothAdapter</span>(&#123;
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      wx.<span class="title function_">openBluetoothAdapter</span>(&#123; <span class="comment">// 初始化蓝牙模块</span>
        <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始化蓝牙成功&#x27;</span>)
          _this.<span class="title function_">getBluetoothAdapterState</span>()
        &#125;,
        <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
          <span class="variable language_">console</span>.<span class="title function_">log</span>(err)
        &#125;
      &#125;)
    &#125;,
  &#125;)
&#125;</code></pre></li>
</ul>
<h3 id="2-获取本机蓝牙适配器状态"><a href="#2-获取本机蓝牙适配器状态" class="headerlink" title="2. 获取本机蓝牙适配器状态"></a>2. 获取本机蓝牙适配器状态</h3><ul>
<li>获取本机蓝牙适配器状态使用的是<code>wx.getBluetoothAdapterState</code>，调用成功后，会返回两个参数<ul>
<li><code>discovering</code>判断是否正在搜索设备</li>
<li><code>available</code>判断蓝牙适配器是否可用<pre><code class="highlight js"><span class="attr">getBluetoothAdapterState</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">getBluetoothAdapterState</span>(&#123;
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      <span class="keyword">if</span> (res.<span class="property">available</span> == <span class="literal">false</span>) &#123;
        wx.<span class="title function_">showToast</span>(&#123;
          <span class="attr">title</span>: <span class="string">&#x27;设备无法开启蓝牙连接&#x27;</span>,
          <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span>,
          <span class="attr">duration</span>: <span class="number">2000</span>
        &#125;)
        wx.<span class="title function_">closeBluetoothAdapter</span>()
      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">discovering</span> == <span class="literal">false</span>) &#123;
        _this.<span class="title function_">startBluetoothDevicesDiscovery</span>() <span class="comment">// 开启搜索外围设备</span>
      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">available</span>)&#123;
        _this.<span class="title function_">startBluetoothDevicesDiscovery</span>() <span class="comment">// 蓝牙适配器正常，去执行搜索外围设备</span>
      &#125;
    &#125;
  &#125;)
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h3 id="3-搜索外围蓝牙设备"><a href="#3-搜索外围蓝牙设备" class="headerlink" title="3. 搜索外围蓝牙设备"></a>3. 搜索外围蓝牙设备</h3><ul>
<li>搜索外围蓝牙设备使用的是<code>wx.startBluetoothDevicesDiscovery</code>，连接设备后一定要使用<code>wx.stopBluetoothDevicesDiscovery</code>停止搜索<pre><code class="highlight js"><span class="attr">startBluetoothDevicesDiscovery</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;
    <span class="keyword">var</span> _this = <span class="variable language_">this</span>
    wx.<span class="title function_">startBluetoothDevicesDiscovery</span>(&#123;
      <span class="attr">allowDuplicatesKey</span>: <span class="literal">false</span>,
      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
        <span class="keyword">if</span>(!res.<span class="property">isDiscovering</span>)&#123; <span class="comment">// 是否在搜索设备</span>
          _this.<span class="title function_">getBluetoothAdapterState</span>()
        &#125;<span class="keyword">else</span>&#123;
          _this.<span class="title function_">onBluetoothDeviceFound</span>() <span class="comment">// 搜索成功后，执行监听设备的api</span>
        &#125;
      &#125;,
      <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;蓝牙搜寻失败&quot;</span>)
        wx.<span class="title function_">stopBluetoothDevicesDiscovery</span>() <span class="comment">// 没有搜索到设备</span>
        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
      &#125;
    &#125;)
&#125;</code></pre></li>
</ul>
<h3 id="4-监听寻找到新设备"><a href="#4-监听寻找到新设备" class="headerlink" title="4. 监听寻找到新设备"></a>4. 监听寻找到新设备</h3><ul>
<li>监听寻找到新设备使用的是<code>wx.onBluetoothDeviceFound</code>，每搜到一个新设备就会触发一次，然后返回一个搜索到的设备列表，包含了设备名称和mac地址，一般都是使用设备名称和mac地址来匹配设备的<ul>
<li>安卓和IOS返回的deviceId不一样，安卓返回的是mac地址，IOS返回的是UUID，如果想通过mac地址来匹配设备，可以让mac地址存储在<code>advertisData</code>数据段中，然后解析这个数据段得到mac地址</li>
<li>我使用的是通过设备名称来进行匹配<pre><code class="highlight js"><span class="attr">onBluetoothDeviceFound</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">onBluetoothDeviceFound</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;
    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">devices</span>.<span class="property">length</span>; i++)&#123;
      <span class="keyword">if</span>(res.<span class="property">devices</span>[i].<span class="property">name</span> == <span class="string">&quot;设备名称&quot;</span> || res.<span class="property">devices</span>[i].<span class="property">localName</span> == <span class="string">&quot;设备名称&quot;</span>)&#123;
        _this.<span class="title function_">setData</span>(&#123;
          <span class="attr">deviceId</span>: res.<span class="property">devices</span>[i].<span class="property">deviceId</span> <span class="comment">// 把匹配设备的deviceId存到data中</span>
        &#125;)
        wx.<span class="title function_">stopBluetoothDevicesDiscovery</span>() <span class="comment">// 匹配到设备后关闭搜索</span>
        _this.<span class="title function_">createBLEConnection</span>() <span class="comment">// 连接蓝牙</span>
      &#125;
    &#125;
  &#125;)
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h3 id="5-连接蓝牙"><a href="#5-连接蓝牙" class="headerlink" title="5. 连接蓝牙"></a>5. 连接蓝牙</h3><ul>
<li>连接蓝牙使用的是<code>wx.createBLEConnection</code>，连接蓝牙是通过<code>deviceId</code>连接，<code>deviceId</code>是通过<code>wx.onBluetoothDeviceFound</code>获取的</li>
<li>连接蓝牙容易失败，所以可以定一个变量<code>count</code>用来计算连接的次数，如果超出特定的次数就判断为连接失败，关闭蓝牙模块<pre><code class="highlight js"><span class="attr">createBLEConnection</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 连接低功耗蓝牙</span>
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">createBLEConnection</span>(&#123;
    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      _this.<span class="title function_">getBLEDeviceServices</span>()
    &#125;,
    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接失败&quot;</span>)
      <span class="keyword">if</span>( count &lt; <span class="number">6</span> )&#123;
        count++
        _this.<span class="title function_">createBLEConnection</span>()
      &#125;<span class="keyword">else</span>&#123;
        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 连接失败关闭蓝牙模块</span>
      &#125;
    &#125;
  &#125;)
&#125;</code></pre></li>
</ul>
<h3 id="6-获取蓝牙设备的服务"><a href="#6-获取蓝牙设备的服务" class="headerlink" title="6. 获取蓝牙设备的服务"></a>6. 获取蓝牙设备的服务</h3><ul>
<li>获取蓝牙设备的服务列表使用的是<code>wx.getBLEDeviceServices</code><pre><code class="highlight js"><span class="attr">getBLEDeviceServices</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">getBLEDeviceServices</span>(&#123;
    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">services</span>.<span class="property">length</span>; i++)&#123;
        <span class="comment">// 如果提前得知可以直接判断，如果不知道可以用蓝牙工具看一下服务所需的功能</span>
        <span class="keyword">if</span>(res.<span class="property">services</span>[i].<span class="property">uuid</span> == _this.<span class="property">data</span>.<span class="property">service</span>)&#123;
          _this.<span class="title function_">setData</span>(&#123;
            <span class="attr">serviceId</span>: res.<span class="property">services</span>[i].<span class="property">uuid</span>
          &#125;)
          _this.<span class="title function_">getBLEDeviceCharacteristics</span>()
        &#125;   
      &#125;
    &#125;,
    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取服务失败&quot;</span>)
      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
    &#125;
  &#125;)
&#125;,</code></pre></li>
</ul>
<h3 id="7-获取服务中的特征值"><a href="#7-获取服务中的特征值" class="headerlink" title="7. 获取服务中的特征值"></a>7. 获取服务中的特征值</h3><ul>
<li>获取服务中的特征值使用的是<code>wx.getBLEDeviceCharacteristics</code><pre><code class="highlight js"><span class="attr">getBLEDeviceCharacteristics</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 获取服务中的特征值</span>
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">getBLEDeviceCharacteristics</span>(&#123;
    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
    <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">characteristics</span>.<span class="property">length</span>; i++)&#123;
        <span class="keyword">let</span> model = res.<span class="property">characteristics</span>[i]
        <span class="keyword">if</span> ((model.<span class="property">properties</span>.<span class="property">notify</span> || model.<span class="property">properties</span>.<span class="property">indicate</span>) &amp;&amp; (model.<span class="property">properties</span>.<span class="property">read</span> &amp;&amp; model.<span class="property">properties</span>.<span class="property">write</span>))&#123;
          _this.<span class="title function_">setData</span>(&#123;
            <span class="attr">characteristicId</span>: model.<span class="property">uuid</span>
          &#125;)
          _this.<span class="title function_">notifyBLECharacteristicValueChange</span>()
        &#125;
      &#125;
    &#125;,
    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取服务中的特征值失败&quot;</span>)
      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
    &#125;
  &#125;)
&#125;,</code></pre></li>
</ul>
<h3 id="8-启用特征值变化时的notify功能"><a href="#8-启用特征值变化时的notify功能" class="headerlink" title="8. 启用特征值变化时的notify功能"></a>8. 启用特征值变化时的notify功能</h3><ul>
<li>启用特征值变化时的notify功能使用的是<code>wx.notifyBLECharacteristicValueChange</code><pre><code class="highlight js"><span class="attr">notifyBLECharacteristicValueChange</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 启用蓝牙特征值变化时的notify功能</span>
    <span class="keyword">var</span> _this = <span class="variable language_">this</span>
    wx.<span class="title function_">notifyBLECharacteristicValueChange</span>(&#123;
      <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
      <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,
      <span class="attr">characteristicId</span>: _thisa.<span class="property">characteristicId</span>,
      <span class="attr">state</span>: <span class="literal">true</span>,
      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
        wx.<span class="title function_">onBLECharacteristicValueChange</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;
            <span class="variable language_">console</span>.<span class="title function_">log</span>(如果要打印需要从arraybuffer格式转为字符串或<span class="number">16</span>进制)
        &#125;)
        _this.<span class="title function_">writeBLECharacteristicValue</span>() <span class="comment">// 向蓝牙设备写入数据</span>
      &#125;,
      <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;启用BLE蓝牙特征值变化时的notify功能错误&quot;</span>)
        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
      &#125;
    &#125;)</code></pre></li>
</ul>
<h3 id="9-向蓝牙设备写入数据"><a href="#9-向蓝牙设备写入数据" class="headerlink" title="9. 向蓝牙设备写入数据"></a>9. 向蓝牙设备写入数据</h3><ul>
<li>向蓝牙设备写入数据<code>wx.writeBLECharacteristicValue</code>，这时候就是输入提前设定好的指令<pre><code class="highlight js"><span class="attr">writeBLECharacteristicValue</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 向蓝牙设备写入数据</span>
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">writeBLECharacteristicValue</span>(&#123;
    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
    <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,
    <span class="attr">characteristicId</span>: _this.<span class="property">data</span>.<span class="property">characteristicId</span>,
    <span class="attr">value</span>: buffer, <span class="comment">// 这个输入的指令，需要转换成ArrayBuffer</span>
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功&quot;</span>)
      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
    &#125;,
    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;输入指令失败&quot;</span>)
      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
    &#125;
  &#125;)
&#125;</code></pre></li>
</ul>
<h3 id="转换格式"><a href="#转换格式" class="headerlink" title="转换格式"></a>转换格式</h3><ul>
<li><p>字符串转为arraybuffer</p>
<pre><code class="highlight js"><span class="attr">string2buffer</span>: <span class="keyword">function</span> (<span class="params">str</span>) &#123;
    <span class="comment">// 首先将字符串转为16进制</span>
    <span class="keyword">let</span> val = <span class="string">&quot;&quot;</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;
      <span class="keyword">if</span> (val === <span class="string">&#x27;&#x27;</span>) &#123;
        val = str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">16</span>)
      &#125; <span class="keyword">else</span> &#123;
        val += <span class="string">&#x27;,&#x27;</span> + str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">16</span>)
      &#125;
    &#125;
    <span class="comment">// 将16进制转化为ArrayBuffer</span>
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(val.<span class="title function_">match</span>(<span class="regexp">/[\da-f]&#123;2&#125;/gi</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">h</span>) &#123;
      <span class="keyword">return</span> <span class="built_in">parseInt</span>(h, <span class="number">16</span>)
    &#125;)).<span class="property">buffer</span>
&#125;</code></pre>
</li>
<li><p>arraybuffer转为字符串</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">ab2str</span>(<span class="params">u,f</span>) &#123;
   <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Blob</span>([u]);
   <span class="keyword">var</span> r = <span class="keyword">new</span> <span class="title class_">FileReader</span>();
    r.<span class="title function_">readAsText</span>(b, <span class="string">&#x27;utf-8&#x27;</span>);
    r.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;<span class="keyword">if</span>(f)f.<span class="title function_">call</span>(<span class="literal">null</span>,r.<span class="property">result</span>)&#125;
&#125;</code></pre></li>
</ul>
<h3 id="蓝牙遇见的坑"><a href="#蓝牙遇见的坑" class="headerlink" title="蓝牙遇见的坑"></a>蓝牙遇见的坑</h3><ul>
<li>1.苹果手机有时候输入指令会显示发送成功，但是设备并没有反应<ul>
<li><pre><code>解决方法：把需要输入的指令改成每10毫秒输入一个字节
</code></pre>
</li>
<li>如果改成每10毫秒输入一个字节，安卓手机就会频繁出现10008错误</li>
<li>针对这个问题我用了一个不太好的方法，我判断了一下手机的类型，如果是ios的就分10毫秒输入，如果是安卓的就一次性输入</li>
</ul>
</li>
<li>2.在调用<code>wx.onBluetoothDeviceFound</code>这个api时ios会监听两次，然后就会导致最后设备会有两次指令输入<ul>
<li>解决方法：我在搜索蓝牙设备之前做了一个定时器，然后用<code>getBluetoothDevices</code>来查看所有已搜索到的蓝牙，在这个里面做判断来连接蓝牙设备</li>
</ul>
</li>
<li>我上面的步骤没有把这些坑的解决步骤加上，如果碰见此类问题，可以自己在合适的位置修改一下</li>
</ul>
<h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>我自己做了一个小程序的蓝牙调试器，下面是小程序码，欢迎大家体验<br><img src="https://img-blog.csdnimg.cn/20200123154720532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>解析Vue3patch核心算法patchKeyedChildren</title>
    <url>/2022/08/25/%E8%A7%A3%E6%9E%90Vue3patch%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95patchKeyedChildren/</url>
    <content><![CDATA[<h3 id="解析Vue3patch核心算法patchKeyedChildren"><a href="#解析Vue3patch核心算法patchKeyedChildren" class="headerlink" title="解析Vue3patch核心算法patchKeyedChildren"></a>解析Vue3patch核心算法patchKeyedChildren</h3><ul>
<li>locate：<code>runtime-core &gt; renderer &gt; baseCreateRenderer &gt; patchKeyedChildren</code></li>
<li>patchKeyedChildren是patch算法中较为复杂的一段，更是vue技术栈面试的高频点，最初我是在vue3.0 beta版本时大概看过源码，后来在《vue设计与分析》中看了霍春阳大佬的解析，本篇就简要分析一下做个记录</li>
<li>首先patchKeyedChildren是在子列表对比并且有key的情况会进入，并且逻辑大致分为5步，这个看源码官方注释就可以看出</li>
</ul>
<h4 id="第一步，从前向后遍历"><a href="#第一步，从前向后遍历" class="headerlink" title="第一步，从前向后遍历"></a>第一步，从前向后遍历</h4><p>这一步是从节点组头部向尾部遍历，如果遍历过程中遇到相似节点，就进行patch对比，否则就退出遍历，并记录当前遍历的最新下标</p>
<pre><code class="highlight js"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
  <span class="keyword">const</span> n1 = c1[i]
  <span class="keyword">const</span> n2 = (c2[i] = optimized
    ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)
    : <span class="title function_">normalizeVNode</span>(c2[i]))
  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;
    <span class="title function_">patch</span>(
      n1,
      n2,
      container,
      <span class="literal">null</span>,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">break</span>
  &#125;
  i++
&#125;</code></pre>

<h4 id="第二步，从后向前遍历"><a href="#第二步，从后向前遍历" class="headerlink" title="第二步，从后向前遍历"></a>第二步，从后向前遍历</h4><p>从后向前遍历，如果遇到第一步记录的下标就停止，然后遍历过程中，如果遇到相似节点也是直接进行patch对比，如果不相同就是直接退出遍历，并且记录旧节点组和新节点组的尾指针</p>
<pre><code class="highlight js"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
  <span class="keyword">const</span> n1 = c1[e1]
  <span class="keyword">const</span> n2 = (c2[e2] = optimized
    ? <span class="title function_">cloneIfMounted</span>(c2[e2] <span class="keyword">as</span> <span class="title class_">VNode</span>)
    : <span class="title function_">normalizeVNode</span>(c2[e2]))
  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;
    <span class="title function_">patch</span>(
      n1,
      n2,
      container,
      <span class="literal">null</span>,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">break</span>
  &#125;
  e1--
  e2--
&#125;</code></pre>

<h4 id="第三步，检查旧节点组"><a href="#第三步，检查旧节点组" class="headerlink" title="第三步，检查旧节点组"></a>第三步，检查旧节点组</h4><p>这一步就是检查旧节点组在上两步的遍历后是否遍历完，如果遍历完，那么新节点组没有遍历完的就都是新的dom，可以全部当作新增节点进行挂载处理</p>
<pre><code class="highlight js"><span class="keyword">if</span> (i &gt; e1) &#123;
  <span class="keyword">if</span> (i &lt;= e2) &#123;
    <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>
    <span class="keyword">const</span> anchor = nextPos &lt; l2 ? (c2[nextPos] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor
    <span class="keyword">while</span> (i &lt;= e2) &#123;
      <span class="comment">// patch第一个参数为null，就是代表没有旧节点，直接将新节点插入</span>
      <span class="title function_">patch</span>(
        <span class="literal">null</span>,
        (c2[i] = optimized
          ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)
          : <span class="title function_">normalizeVNode</span>(c2[i])),
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      )
      i++
    &#125;
  &#125;
&#125;</code></pre>

<h4 id="第四步，检查新节点组"><a href="#第四步，检查新节点组" class="headerlink" title="第四步，检查新节点组"></a>第四步，检查新节点组</h4><p>如果上一步检查旧节点未遍历完，那么就检查新节点组是否遍历完，如果遍历完，那么旧的节点组剩余的节点说明都是要卸载的，因为都不需要了</p>
<pre><code class="highlight js"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;
  <span class="comment">// 旧子节点未被遍历完</span>
  <span class="keyword">while</span> (i &lt;= e1) &#123;
    <span class="title function_">unmount</span>(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>)
    i++
  &#125;
&#125;</code></pre>

<h4 id="第五步，未知序列"><a href="#第五步，未知序列" class="headerlink" title="第五步，未知序列"></a>第五步，未知序列</h4><ul>
<li>如果新旧节点组都未遍历完，说明存在未知序列，可能存在位移等情况，就需要进一步处理</li>
<li>首先创建一个数组，用于记录新旧节点的对应关系<pre><code class="highlight js"><span class="comment">// toBePatched是新序列的节点数量 e2 - s2 + 1</span>
<span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched)
<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span></code></pre></li>
<li>然后会遍历旧节点组，这里会用两个变量记录<ul>
<li><code>let moved = false</code>：位移标识，用于判断是否需要位移</li>
<li><code>let patched = 0</code>：记录已执行patch的新节点数量，用于处理如果在更新时更新过的数量大于需要更新的节点数量，就卸载对应旧节点<pre><code class="highlight js"><span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;
  <span class="keyword">const</span> prevChild = c1[i]
  <span class="comment">// 如果已更新数量大于新节点数量，就卸载节点</span>
  <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;
    <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)
    <span class="keyword">continue</span>
  &#125;
  <span class="keyword">let</span> newIndex <span class="comment">//新旧节点key相同的新节点index</span>
  <span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;
    newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;
      <span class="keyword">if</span> (
        newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp;
        <span class="title function_">isSameVNodeType</span>(prevChild, c2[j] <span class="keyword">as</span> <span class="title class_">VNode</span>)
      ) &#123;
        newIndex = j
        <span class="keyword">break</span>
      &#125;
    &#125;
  &#125;
  <span class="comment">// 如果newIndex为空，则说明未找到与旧节点对应的新节点，直接卸载</span>
  <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;
    <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)
  &#125; <span class="keyword">else</span> &#123;
    <span class="comment">// 更新新旧节点关系表</span>
    newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>
    <span class="comment">/**</span>
<span class="comment">     * 这里的maxNexIndexSoFar是记录每次patch最大index</span>
<span class="comment">     * 也是用于判断是否产生了位移，因为如果新节点index比最大index小，就说明发生了位移</span>
<span class="comment">     * 例如：</span>
<span class="comment">     *  (a b) c</span>
<span class="comment">     *  (a c  b)</span>
<span class="comment">     * 在新旧序列对比b，c时，由于c最新的newIndex已经小于b对应的newIndex，因此会记录需要位移</span>
<span class="comment">     */</span>
    <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;
      maxNewIndexSoFar = newIndex
    &#125; <span class="keyword">else</span> &#123;
      moved = <span class="literal">true</span>
    &#125;
    <span class="title function_">patch</span>(
      prevChild,
      c2[newIndex] <span class="keyword">as</span> <span class="title class_">VNode</span>,
      container,
      <span class="literal">null</span>,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
    patched++
  &#125;
&#125;</code></pre></li>
</ul>
</li>
<li>遍历完旧序列后，就需要确定如何位移</li>
<li>首先是根据新旧节点关系表生成最长递增子序列(这个算法就不陈述了，较复杂，可以看<a href="https://juejin.cn/post/6952674285311754276#comment">精读《DOM diff 最长上升子序列》</a>)，然后倒序遍历新子节点<pre><code class="highlight js"><span class="comment">// 最长递增子序列</span>
<span class="keyword">const</span> increasingNewIndexSequence = moved
  ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap)
  : <span class="variable constant_">EMPTY_ARR</span>
j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span>
<span class="comment">// 从新序列尾部向前遍历，目的是为了使用上一个遍历的节点做锚点</span>
<span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;
  <span class="keyword">const</span> nextIndex = s2 + i
  <span class="keyword">const</span> nextChild = c2[nextIndex] <span class="keyword">as</span> <span class="title class_">VNode</span>
  <span class="comment">// 如果是序列的最后一个节点，anchor就是父节点对应的anchor，否则就是上一个子节点</span>
  <span class="keyword">const</span> anchor =
    nextIndex + <span class="number">1</span> &lt; l2 ? (c2[nextIndex + <span class="number">1</span>] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor
  <span class="comment">// 如果newIndexToOldIndexMap[i]还是0，那么说明新节点没有对应的旧节点，说明是新节点，直接挂载</span>
  <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;
    <span class="title function_">patch</span>(
      <span class="literal">null</span>,
      nextChild,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;
    <span class="comment">// 然后在moved为true的情况下，如果最长子序列为空或者最长子序列和当前访问的新节点index不同，说明就需要进行位移</span>
    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;
      <span class="title function_">move</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>)
    &#125; <span class="keyword">else</span> &#123;
      j--
    &#125;
  &#125;
&#125;</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>解析nextTick---vue3任务调度</title>
    <url>/2021/07/17/%E8%A7%A3%E6%9E%90nextTick-vue3%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><ul>
<li>定义：将回调推迟到下一个 DOM 更新周期之后执行，在更改了一些数据以等待 DOM 更新后立即使用它</li>
<li>在实际中使用这个方法一般是用于组件更新，你需要获取更新后的数据，所以使用nextTick等待DOM更新<pre><code class="highlight js"><span class="keyword">import</span> &#123; createApp, nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>
<span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;
    <span class="title function_">setup</span>(<span class="params"></span>) &#123;
      <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello!&#x27;</span>)
      <span class="keyword">const</span> <span class="title function_">changeMessage</span> = <span class="keyword">async</span> newMessage =&gt; &#123;
        message.<span class="property">value</span> = newMessage
        <span class="comment">// 这里的value是旧值</span>
        <span class="keyword">await</span> <span class="title function_">nextTick</span>()
        <span class="comment">// nextTick后获取的就是DOM更新后的value</span>
        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Now DOM is updated&#x27;</span>)
      &#125;
    &#125;
&#125;)</code></pre></li>
<li>这个api使用时相当简单，而且相当容易理解，但是为了知其意，还是要翻一下源码了解它的执行机制<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params"></span>
<span class="params">  <span class="variable language_">this</span>: ComponentPublicInstance | <span class="built_in">void</span>,</span>
<span class="params">  fn?: () =&gt; <span class="built_in">void</span></span>
<span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;
  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise
  <span class="keyword">return</span> fn ? p.<span class="title function_">then</span>(<span class="variable language_">this</span> ? fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>) : fn) : p
&#125;</code></pre></li>
<li>上面是vue源码中nextTick的实现，为了搞清楚实现逻辑，就必须搞懂<code>currentFlushPromise</code>这个变量的含义，所以要从任务的调度机制开始分析</li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>首先这个调度机制的功能在<code>runtime-core</code>的<code>scheduler</code>文件</p>
<ul>
<li><p>API</p>
<pre><code class="highlight ts"><span class="comment">// 这个文件会抛出以下几个API函数</span>
<span class="title function_">nextTick</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 将函数在任务队列清空后执行</span>
<span class="title function_">queueJob</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加任务并开始执行任务队列</span>
<span class="title function_">invalidateJob</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 删除任务</span>
<span class="title function_">queuePreFlushCb</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加前置回调函数并开始执行任务队列</span>
<span class="title function_">queuePostFlushCb</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加后置回调函数并开始执行任务队列</span>
<span class="title function_">flushPreFlushCbs</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 执行前置回调函数</span>
<span class="title function_">flushPostFlushCbs</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 执行后置回调函数</span></code></pre></li>
<li><p>我们首先要知道几个关键变量</p>
<pre><code class="highlight ts"><span class="keyword">let</span> isFlushing = <span class="literal">false</span> <span class="comment">// 是否正在清空任务队列</span>
<span class="keyword">let</span> isFlushPending = <span class="literal">false</span> <span class="comment">// 清队任务已创建，等待清空状态</span>
<span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">SchedulerJob</span>[] = [] <span class="comment">// 任务队列</span>
<span class="keyword">let</span> flushIndex = <span class="number">0</span> <span class="comment">// 当前正在执行的任务在任务队列中的索引</span></code></pre></li>
<li><p>然后我们从<code>queueJob</code>这个函数开始</p>
<pre><code class="highlight ts"><span class="comment">/* </span>
<span class="comment">  这个函数主要是将一个任务进行入队操作</span>
<span class="comment">  然后在满足条件的情况下启动queueFlush</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueJob</span>(<span class="params">job: SchedulerJob</span>) &#123;
    <span class="comment">/**</span>
<span class="comment">     * 任务可入队逻辑</span>
<span class="comment">     * 1. 任务队列为空</span>
<span class="comment">     * 2. 待入队任务不能存在于任务队列中(按情况分析)</span>
<span class="comment">     */</span>
    <span class="keyword">if</span> (
      (!queue.<span class="property">length</span> ||
        !queue.<span class="title function_">includes</span>(
          job,
          <span class="comment">/* </span>
<span class="comment">            在正在清空队列且当前待入队任务是可以递归时，</span>
<span class="comment">            说明当前任务一定和当前正在执行任务是同一任务，所以+1，</span>
<span class="comment">            就是为了保证待入队任务和正在执行任务相同，但不能和后面待执行任务相同</span>
<span class="comment">           */</span>
          isFlushing &amp;&amp; job.<span class="property">allowRecurse</span> ? flushIndex + <span class="number">1</span> : flushIndex
        )) &amp;&amp;
      job !== currentPreFlushParentJob
    ) &#123;
      <span class="comment">// 二分查找任务在队列中的位置</span>
      <span class="keyword">const</span> pos = <span class="title function_">findInsertionIndex</span>(job)
      <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;
        queue.<span class="title function_">splice</span>(pos, <span class="number">0</span>, job)
      &#125; <span class="keyword">else</span> &#123;
        queue.<span class="title function_">push</span>(job)
      &#125;
      <span class="title function_">queueFlush</span>()
    &#125;
&#125;</code></pre>
</li>
<li><p><code>queueFlush</code></p>
<pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;
    <span class="comment">/**</span>
<span class="comment">      清队任务创建后禁止再次创建更多的清队任务</span>
<span class="comment">      因为在入队操作完成后，flushJobs会在一次递归中将任务队列全部清空，所以只需要一次清队任务即可</span>
<span class="comment">     */</span>
    <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;
      isFlushPending = <span class="literal">true</span>
      <span class="comment">/* </span>
<span class="comment">        清队任务创建成功，并记录下当前清队任务，这个标记可以用于nextTick创建自定义函数，</span>
<span class="comment">        说明nextTick的执行时机是在清队任务后的，其实从这个地方就可以理解nextTick的执行原理了</span>
<span class="comment">      */</span>
      currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)
    &#125;
&#125;</code></pre>
</li>
<li><p><code>flushJobs</code></p>
<pre><code class="highlight ts"><span class="comment">// 清空任务队列</span>
<span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params">seen?: CountMap</span>) &#123;
    isFlushPending = <span class="literal">false</span> <span class="comment">// 关闭清队任务等待状态</span>
    isFlushing = <span class="literal">true</span> <span class="comment">// 开启正在清空队列状态</span>
    <span class="keyword">if</span> (__DEV__) &#123;
      seen = seen || <span class="keyword">new</span> <span class="title class_">Map</span>()
    &#125;

    <span class="comment">// 清空前置回调任务队列</span>
    <span class="title function_">flushPreFlushCbs</span>(seen)

    <span class="comment">/* </span>
<span class="comment">      任务队列中的任务根据ID进行排序的原因</span>
<span class="comment">        1. 因为组件更新是从父组件到子组件的，而任务更新是在数据源更新时触发的，所以为了更新任务的顺序就需要进行排序</span>
<span class="comment">        2. 如果在父组件更新期间已经卸载了组件，那么子组件的更新任务就可以跳过</span>
<span class="comment">    */</span>
    queue.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">getId</span>(a) - <span class="title function_">getId</span>(b))

    <span class="keyword">try</span> &#123;
      <span class="comment">// 遍历任务队列</span>
      <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.<span class="property">length</span>; flushIndex++) &#123;
        <span class="keyword">const</span> job = queue[flushIndex]
        <span class="keyword">if</span> (job &amp;&amp; job.<span class="property">active</span> !== <span class="literal">false</span>) &#123;
          <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="title function_">checkRecursiveUpdates</span>(seen!, job)) &#123;
            <span class="keyword">continue</span>
          &#125;
          <span class="comment">// 执行当前任务</span>
          <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="title class_">ErrorCodes</span>.<span class="property">SCHEDULER</span>)
        &#125;
      &#125;
    &#125; <span class="keyword">finally</span> &#123;
      <span class="comment">// 重置当前任务索引</span>
      flushIndex = <span class="number">0</span>
      <span class="comment">// 清空任务队列</span>
      queue.<span class="property">length</span> = <span class="number">0</span>

      <span class="comment">// 执行后置回调任务队列</span>
      <span class="title function_">flushPostFlushCbs</span>(seen)
        <span class="comment">// 重置清队任务的状态</span>
      isFlushing = <span class="literal">false</span>
      currentFlushPromise = <span class="literal">null</span>
      <span class="comment">/* </span>
<span class="comment">        因为清队任务执行期间也会有任务入队，所以为了清队执行完成</span>
<span class="comment">        就需要判断各任务队列的长度，然后递归执行</span>
<span class="comment">      */</span>
      <span class="keyword">if</span> (
        queue.<span class="property">length</span> ||
        pendingPreFlushCbs.<span class="property">length</span> ||
        pendingPostFlushCbs.<span class="property">length</span>
      ) &#123;
        <span class="title function_">flushJobs</span>(seen)
      &#125;
    &#125;
&#125;</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>nextTick的执行时机是在任务队列(前置、主任务、后置)清除后的，<code>currentFlushPromise</code>是清队任务的promise标记</li>
<li>任务队列执行顺序：执行前置回调任务队列 -&gt; 执行主任务队列 -&gt; 执行后置回调任务队列</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>解决react状态管理---React Query</title>
    <url>/2021/06/12/%E8%A7%A3%E5%86%B3react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-ReactQuery/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210612171112847.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="React Query"></p>
<h3 id="什么是React-Query"><a href="#什么是React-Query" class="headerlink" title="什么是React Query"></a>什么是React Query</h3><ul>
<li><code>react-query</code>是一个适用于react hooks的请求库，它可以为任何类型的异步数据提供React状态管理功能，使React中的获取、缓存、同步和更新服务器数据变得轻而易举</li>
<li><code>react-query</code>与一些传统的状态管理库如redux,mobx不同，它是负责管理服务器与客户端之间的状态，一些用户交互的中间状态，如loading状态，错误信息等都是通过hooks直接返回</li>
<li><a href="https://react-query-v2.tanstack.com/">React Query官网</a></li>
</ul>
<h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><ol>
<li><code>yarn add react-query</code> or <code>npm i react-query</code>安装react-query</li>
<li>使用<code>QueryClientProvider</code>组件连接并提供一个<code>QueryClient</code>到你的应用程序<pre><code class="highlight js"><span class="keyword">import</span> &#123; <span class="title class_">QueryClient</span>, <span class="title class_">QueryClientProvider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query&#x27;</span>

&lt;<span class="title class_">QueryClientProvider</span> client=&#123;<span class="keyword">new</span> <span class="title class_">QueryClient</span>()&#125;&gt;
  &#123; ... &#125;
&lt;/<span class="title class_">QueryClientProvider</span>&gt;</code></pre></li>
</ol>
<h4 id="Devtools"><a href="#Devtools" class="headerlink" title="Devtools"></a>Devtools</h4><ul>
<li><code>yarn add react-query-devtools</code> or <code>npm i --save react-query-devtools</code>安装Devtools</li>
<li><code>react-query-devtools</code>是与<code>react-query</code>相匹配的开发工具</li>
<li>可在开发中实时查看缓存，手动获取和删除查询等等<pre><code class="highlight js"><span class="keyword">import</span> &#123; <span class="title class_">ReactQueryDevtools</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query-devtools&#x27;</span>

<span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">return</span> (
    <span class="language-xml"><span class="tag">&lt;&gt;</span>    </span>
<span class="language-xml">      &#123; ... &#125;</span>
<span class="language-xml">      <span class="tag">&lt;<span class="name">ReactQueryDevtools</span> <span class="attr">initialIsOpen</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;/&gt;</span></span>
  );
&#125;;</code></pre></li>
</ul>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><ul>
<li>react-query最常用的两个hook，查询(<code>useQuery</code>)、增删改(<code>useMutation</code>)</li>
</ul>
<h4 id="useQuery"><a href="#useQuery" class="headerlink" title="useQuery"></a>useQuery</h4><ul>
<li><code>useQuery</code>：在<code>React Query</code>中，查询是对某些异步数据源的声明性依赖。查询可以与任何基于Promise的方法(GET)一起使用，从服务器获取数据<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">useTodos</span> = (<span class="params">param</span>) =&gt; &#123;
  <span class="keyword">const</span> request = <span class="title function_">useHttp</span>()

  <span class="comment">/**</span>
<span class="comment">   * 第一个参数是QueryKey，是查询的关键，是一个独一无二的key，并在之后的增删改中需要，</span>
<span class="comment">   *   如果需要动态的QueryKey，可以使用数组的方式，如[&#x27;todos&#x27;, params]</span>
<span class="comment">   * 第二个参数是用于获取数据的异步函数</span>
<span class="comment">   * useQuery的响应返回就是获取到的数据和一些中间状态，如isLoading，error，isIdle...</span>
<span class="comment">   */</span>
  <span class="keyword">return</span> <span class="title function_">useQuery</span>(<span class="string">&#x27;todos&#x27;</span>, <span class="function">() =&gt;</span>
    <span class="title function_">request</span>(<span class="string">&#x27;todos&#x27;</span>, &#123; <span class="attr">data</span>: param &#125;)
  )
&#125;

<span class="comment">// 在UI组件调用</span>
<span class="keyword">const</span> &#123; isLoading, error, <span class="attr">data</span>: todos &#125; = <span class="title function_">useTodos</span>()</code></pre></li>
</ul>
<h4 id="useMutation"><a href="#useMutation" class="headerlink" title="useMutation"></a>useMutation</h4><ul>
<li><code>useMutation</code>：常用于创建&#x2F;更新&#x2F;删除数据或执行服务器副作用<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">useAddTodo</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> request = <span class="title function_">useHttp</span>()

  <span class="comment">/**</span>
<span class="comment">   * 第一个参数是执行操作的异步函数，在返回的mutate中触发</span>
<span class="comment">   * 第二个参数是执行成功或者失败的一些配置函数，可用于一些处理缓存的操作，例如乐观更新</span>
<span class="comment">   */</span>
  <span class="keyword">return</span> <span class="title function_">useMutation</span>(
    <span class="function">(<span class="params">data</span>) =&gt;</span>
      <span class="title function_">request</span>(<span class="string">`todos`</span>, &#123;
        data,
        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,
      &#125;),
    &#123;
      <span class="title function_">onSuccess</span>(<span class="params"></span>)&#123;&#125;
      <span class="title function_">onError</span>(<span class="params"></span>)&#123;&#125;
      <span class="title function_">onSettled</span>(<span class="params"></span>)&#123;&#125;
      ...
    &#125;
  )
&#125;

<span class="comment">// 操作组件调用</span>
<span class="keyword">const</span> <span class="title function_">TodosAddBtn</span> = (<span class="params"></span>) =&gt; &#123;
  ...
  <span class="keyword">const</span> &#123; mutateAsync, isLoading, error &#125; = <span class="title function_">useAddTodo</span>()
  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> mutateAsync(todoData)&#125;&gt;add<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>
&#125;</code></pre></li>
</ul>
<h5 id="例：用第二个参数配置乐观更新"><a href="#例：用第二个参数配置乐观更新" class="headerlink" title="例：用第二个参数配置乐观更新"></a>例：用第二个参数配置乐观更新</h5><ul>
<li>乐观更新就是在一些请求或者数据处理没有结束的时候，提前给用户显示理想的结果，如果失败就回滚更新<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">useAddConfig</span> = (<span class="params">queryKey</span>) =&gt; &#123;
  <span class="comment">// 获取当前QueryClient的实例</span>
  <span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>()
  
  <span class="keyword">return</span> &#123;
    <span class="comment">// 当mutate被调用时触发</span>
    <span class="keyword">async</span> <span class="title function_">onMutate</span>(<span class="params">target</span>) &#123;
      <span class="comment">// 获取当前数据快照，用于错误时回滚更新</span>
      <span class="keyword">const</span> previousItems = queryClient.<span class="title function_">getQueryData</span>(queryKey)
      <span class="comment">// 乐观更新为新值</span>
      queryClient.<span class="title function_">setQueryData</span>(queryKey, <span class="function">(<span class="params">old</span>) =&gt;</span> &#123;
        <span class="keyword">return</span> <span class="function">(<span class="params">target, old</span>) =&gt;</span> (old ? [...old, target] : [])
      &#125;)

      <span class="comment">// 这个返回值会作为最后一个参数传递给onError和onSettled</span>
      <span class="keyword">return</span> &#123; previousItems &#125;
    &#125;,
    <span class="comment">// 成功回调 清除缓存</span>
    <span class="attr">onSuccess</span>: <span class="function">() =&gt;</span> queryClient.<span class="title function_">invalidateQueries</span>(queryKey),
    <span class="comment">// 失败回调</span>
    <span class="title function_">onError</span>(<span class="params">error, newItem, context</span>) &#123;
      <span class="comment">// 当前queryKey的数据回滚</span>
      queryClient.<span class="title function_">setQueryData</span>(
        queryKey,
        context.<span class="property">previousItems</span>
      )
    &#125;,
    <span class="comment">// 无论错误或者成功都会触发，此例子没有使用</span>
    <span class="title function_">onSettled</span>(<span class="params"></span>) &#123;&#125;
  &#125;
&#125;</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>本地&#x2F;客户端中间状态<ul>
<li>redux与react-query都可，没有较大的优缺点</li>
</ul>
</li>
<li>服务端中间状态<ul>
<li>推荐react-query，将服务器状态从全局状态中解放出来，用更少的代码实现复杂的需求，让你的状态管理更优雅</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>ReactQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3响应式分析</title>
    <url>/2021/08/01/%E8%A7%A3%E6%9E%90reactive-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="vue3响应式分析"><a href="#vue3响应式分析" class="headerlink" title="vue3响应式分析"></a>vue3响应式分析</h2><ol>
<li>首先对vue3响应式分析之前，需要对前置知识<code>Proxy</code>和<code>Reflect</code>有所了解，，关于这两个知识我推荐看阮一峰老师的<a href="https://es6.ruanyifeng.com/#README">ES6入门教程</a></li>
<li>vue3的响应式我是以reactive为入口进行梳理，流程如下图<br><img src="https://img-blog.csdnimg.cn/83a41b1d8a3044d6b8135850ea972ed1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>源码位置：<code>reactivity/src/...</code>，分四部分解析</li>
</ol>
<ul>
<li>reactive文件：目标对象转化为proxy实例</li>
<li>baseHandler文件：基本类型处理器</li>
<li>collectionHandlers文件：Map、Set处理器</li>
<li>effect文件：收集触发依赖</li>
</ul>
<ol start="4">
<li>如果不想看源码解析，可以直接看总结🐶</li>
</ol>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul>
<li><code>reactive</code>：将一个JS对象转为具有响应式的proxy实例<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;
    <span class="comment">// 如果是只读数据，就直接返回</span>
    <span class="keyword">if</span> (target &amp;&amp; (target <span class="keyword">as</span> <span class="title class_">Target</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>]) &#123;
      <span class="keyword">return</span> target
    &#125;
    <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(
      target,
      <span class="literal">false</span>,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    )
&#125;</code></pre></li>
<li><code>createReactiveObject</code><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span>
<span class="params">    target: Target, <span class="comment">// 源对象</span></span>
<span class="params">    isReadonly: <span class="built_in">boolean</span>, <span class="comment">// 是否只读</span></span>
<span class="params">    baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;, <span class="comment">// 基本类型的handlers</span></span>
<span class="params">    collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;, <span class="comment">// 主要针对(set、map、weakSet、weakMap)的handlers</span></span>
<span class="params">    proxyMap: <span class="built_in">WeakMap</span>&lt;Target, <span class="built_in">any</span>&gt;</span>
<span class="params"></span>) &#123;
  <span class="comment">// 如果不是一个对象，直接返回，并且在开发环境发出警告</span>
    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;
      <span class="keyword">if</span> (__DEV__) &#123;
        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)
      &#125;
      <span class="keyword">return</span> target
    &#125;
    <span class="comment">// 如果已经是响应式，直接返回</span>
    <span class="keyword">if</span> (
      target[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>] &amp;&amp;
      !(isReadonly &amp;&amp; target[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])
    ) &#123;
      <span class="keyword">return</span> target
    &#125;

    <span class="comment">// 如果目标对象已经存在代理，直接返回</span>
    <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)
    <span class="keyword">if</span> (existingProxy) &#123;
      <span class="keyword">return</span> existingProxy
    &#125;

    <span class="comment">// 如果类型值不是Object、Array、Map、Set、WeakMap、WeakSet的，直接返回</span>
    <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target)
    <span class="keyword">if</span> (targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;
      <span class="keyword">return</span> target
    &#125;

    <span class="comment">// 根据不同的类型值赋予不同的handlers，就是我之前图上画的分开处理</span>
    <span class="comment">/* </span>
<span class="comment">      把set、Map这种数据与基础数据分开处理，是因为Map、Set中存储的数据必须通过this进行访问</span>
<span class="comment">      但是被proxy劫持后，this就变成了proxy，</span>
<span class="comment">      所以需要特殊处理，把劫持方法进行重写</span>
<span class="comment">     */</span>
    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(
      target,
      targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers
    )
    proxyMap.<span class="title function_">set</span>(target, proxy)
    <span class="keyword">return</span> proxy
  &#125;</code></pre></li>
</ul>
<h3 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h3><p><code>baseHandler</code>主要分析reactive的处理器对象<code>mutableHandlers</code></p>
<pre><code class="highlight ts"><span class="comment">// 对get set delete has onwKeys做了拦截处理</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;
  get,
  set,
  deleteProperty,
  has,
  ownKeys
&#125;</code></pre>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;
  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | <span class="built_in">symbol</span>, receiver: <span class="built_in">object</span></span>) &#123;
    <span class="comment">// 访问标志位时的逻辑处理</span>
    <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;
      <span class="keyword">return</span> !isReadonly
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;
      <span class="keyword">return</span> isReadonly
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (
      key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span> &amp;&amp;
      receiver ===
        (isReadonly
          ? shallow
            ? shallowReadonlyMap
            : readonlyMap
          : shallow
            ? shallowReactiveMap
            : reactiveMap
        ).<span class="title function_">get</span>(target)
    ) &#123;
      <span class="keyword">return</span> target
    &#125;

    <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target)

    <span class="comment">// 如果target是数组并且key属于一些数组的原始方法，即触发拦截</span>
    <span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;
      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)
    &#125;

    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)

    <span class="comment">// 如果key是symbol的内置方法，或者是原型对象，直接返回</span>
    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;
      <span class="keyword">return</span> res
    &#125;

    <span class="comment">// 只读对象不收集依赖，因为不会触发依赖更新</span>
    <span class="keyword">if</span> (!isReadonly) &#123;
      <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)
    &#125;

    <span class="comment">// 浅层响应立即返回，不递归转化</span>
    <span class="keyword">if</span> (shallow) &#123;
      <span class="keyword">return</span> res
    &#125;

    <span class="comment">// 如果是ref对象(数组除外)，返回真正的值，</span>
    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;
      <span class="keyword">const</span> shouldUnwrap = !targetIsArray || !<span class="title function_">isIntegerKey</span>(key)
      <span class="keyword">return</span> shouldUnwrap ? res.<span class="property">value</span> : res
    &#125;

    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;
      <span class="comment">// 由于proxy只能代理一层，所以target[key]的值如果是对象，就继续对其进行代理</span>
      <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)
    &#125;
    <span class="keyword">return</span> res
  &#125;
&#125;</code></pre>
<p>数组方法拦截: 对数组的两种原生方法进行了拦截</p>
<ul>
<li>遍历查找的方法：includes、indexOf、lastIndexOf</li>
<li>改变数组长度的方法：push、pop、shift、unshift、splice<pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">createArrayInstrumentations</span>(<span class="params"></span>) &#123;
    <span class="keyword">const</span> <span class="attr">instrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;&#125;
    ;([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;
      <span class="keyword">const</span> method = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[key] <span class="keyword">as</span> <span class="built_in">any</span>
      instrumentations[key] = <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;
        <span class="comment">// 这一步是为了取原始实例，因为当前的this是receiver</span>
        <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)
        <span class="comment">// 搜集依赖</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;
          <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>)
        &#125;
        <span class="comment">// 触发方法，如果没有找到对应的值，就取原始值再遍历</span>
        <span class="keyword">const</span> res = method.<span class="title function_">apply</span>(arr, args)
        <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;
          <span class="keyword">return</span> method.<span class="title function_">apply</span>(arr, args.<span class="title function_">map</span>(toRaw))
        &#125; <span class="keyword">else</span> &#123;
          <span class="keyword">return</span> res
        &#125;
      &#125;
    &#125;)
    <span class="comment">/* </span>
<span class="comment">      因为改变数组长度的方法，执行期间会触发length的get和set</span>
<span class="comment">      就回导致无限循环track和trigger</span>
<span class="comment">      所以就用pauseTracking()禁用依赖收集，触发方法后，</span>
<span class="comment">      再用resetTracking()恢复track</span>
<span class="comment">     */</span>
    ;([<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;
      <span class="keyword">const</span> method = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[key] <span class="keyword">as</span> <span class="built_in">any</span>
      instrumentations[key] = <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;
        <span class="title function_">pauseTracking</span>()
        <span class="keyword">const</span> res = method.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)
        <span class="title function_">resetTracking</span>()
        <span class="keyword">return</span> res
      &#125;
    &#125;)
    <span class="keyword">return</span> instrumentations
&#125;</code></pre></li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;
  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span>
<span class="params">    target: <span class="built_in">object</span>,</span>
<span class="params">    key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span>
<span class="params">    value: <span class="built_in">unknown</span>,</span>
<span class="params">    receiver: <span class="built_in">object</span></span>
<span class="params">  </span>): <span class="built_in">boolean</span> &#123;
    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key]
    <span class="keyword">if</span> (!shallow) &#123;
      value = <span class="title function_">toRaw</span>(value)
      oldValue = <span class="title function_">toRaw</span>(oldValue)
      <span class="comment">// 如果原来的值是ref，但新的值不是，则将新的值赋给oldValue.value</span>
      <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;
        oldValue.<span class="property">value</span> = value
        <span class="keyword">return</span> <span class="literal">true</span>
      &#125;
    &#125; <span class="keyword">else</span> &#123;
      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span>
    &#125;

    <span class="keyword">const</span> hadKey =
      <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key)
        ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span>
        : <span class="title function_">hasOwn</span>(target, key)
    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)
    
    <span class="comment">// 判断receiver是当前对象的proxy实例，防止原型链上的proxy触发更新</span>
    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;
      <span class="comment">// 判断新增属性还是修改属性</span>
      <span class="keyword">if</span> (!hadKey) &#123;
        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)
      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;
        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)
      &#125;
    &#125;
    <span class="keyword">return</span> result
  &#125;
&#125;</code></pre>
<h4 id="deleteProperty、has…"><a href="#deleteProperty、has…" class="headerlink" title="deleteProperty、has…"></a>deleteProperty、has…</h4><ul>
<li>deleteProperty、has、ownKeys的源码就不贴了，都是判断key的属性，然后选择触发或者收集依赖</li>
</ul>
<h3 id="collectionHandlers"><a href="#collectionHandlers" class="headerlink" title="collectionHandlers"></a>collectionHandlers</h3><ul>
<li>collection主要分析reactive的重写方法对象mutableInstrumentations<pre><code class="highlight ts"><span class="comment">// 主要对以下原生api进行了改写</span>
<span class="keyword">const</span> <span class="attr">mutableInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;
    <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;
      <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key)
    &#125;,
    <span class="keyword">get</span> <span class="title function_">size</span>() &#123;
      <span class="keyword">return</span> <span class="title function_">size</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span>) <span class="keyword">as</span> <span class="title class_">IterableCollections</span>)
    &#125;,
    has,
    add,
    set,
    <span class="attr">delete</span>: deleteEntry,
    clear,
    <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">false</span>, <span class="literal">false</span>)
&#125;</code></pre></li>
</ul>
<h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>
<span class="params">    target: MapTypes,</span>
<span class="params">    key: <span class="built_in">unknown</span>,</span>
<span class="params">    isReadonly = <span class="literal">false</span>,</span>
<span class="params">    isShallow = <span class="literal">false</span></span>
<span class="params"></span>) &#123;
    <span class="comment">// 获取原始值重新赋值给target</span>
    target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]

    <span class="comment">// 对target源对象和key进一步获取原始值</span>
    <span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target)
    <span class="keyword">const</span> rawKey = <span class="title function_">toRaw</span>(key)

    <span class="comment">// 当前key和原始key均进行依赖收集(track)</span>
    <span class="keyword">if</span> (key !== rawKey) &#123;
      !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)
    &#125;
    !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, rawKey)
    <span class="keyword">const</span> &#123; has &#125; = <span class="title function_">getProto</span>(rawTarget)

    <span class="comment">// 获取对应的转换函数</span>
    <span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive
    <span class="comment">/* </span>
<span class="comment">      如果源对象有key对应的属性，就通过原生get方法取到值，</span>
<span class="comment">      并对该值进行响应式转换，返回转换后的响应式对象，</span>
<span class="comment">      如果没有，就去key原始值中去查找</span>
<span class="comment">    */</span>
    <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, key)) &#123;
      <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(key))
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, rawKey)) &#123;
      <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(rawKey))
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target !== rawTarget) &#123;
      target.<span class="title function_">get</span>(key)
    &#125;
&#125;</code></pre>

<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><pre><code class="highlight ts"><span class="comment">// 对size属性做get拦截</span>
<span class="keyword">function</span> <span class="title function_">size</span>(<span class="params">target: IterableCollections, isReadonly = <span class="literal">false</span></span>) &#123;
  target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]
  <span class="comment">// 获取size和获取数组的length类似，都用专门的key做依赖收集</span>
  !isReadonly &amp;&amp; <span class="title function_">track</span>(<span class="title function_">toRaw</span>(target), <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="variable constant_">ITERATE_KEY</span>)
  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, <span class="string">&#x27;size&#x27;</span>, target)
&#125;</code></pre>

<h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span>, value: <span class="built_in">unknown</span></span>) &#123;
  <span class="comment">// 获取value和this上下文的原始值</span>
  value = <span class="title function_">toRaw</span>(value)
  <span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)
  <span class="keyword">const</span> &#123; has, get &#125; = <span class="title function_">getProto</span>(target)

  <span class="comment">/* </span>
<span class="comment">    判断源对象是否已经存在对应的key</span>
<span class="comment">    1. 首先查找源对象是否已有key对应的属性</span>
<span class="comment">    2. 如果没有，再查找key对应的原始值在源对象的属性是否存在</span>
<span class="comment">  */</span>
  <span class="keyword">let</span> hadKey = has.<span class="title function_">call</span>(target, key)
  <span class="keyword">if</span> (!hadKey) &#123;
    key = <span class="title function_">toRaw</span>(key)
    hadKey = has.<span class="title function_">call</span>(target, key)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;
    <span class="title function_">checkIdentityKeys</span>(target, has, key)
  &#125;

  <span class="keyword">const</span> oldValue = get.<span class="title function_">call</span>(target, key)
  target.<span class="title function_">set</span>(key, value)

  <span class="comment">// 触发依赖，新增属性和修改属性分开进行trigger</span>
  <span class="keyword">if</span> (!hadKey) &#123;
    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;
    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)
  &#125;
  <span class="keyword">return</span> <span class="variable language_">this</span>
&#125;</code></pre>
<h4 id="has、clear…"><a href="#has、clear…" class="headerlink" title="has、clear…"></a>has、clear…</h4><ul>
<li>其余重写方法我就不上代码了，不同点是单个属性触发单个的依赖，如果是遍历所有属性的方法就触发所有依赖</li>
</ul>
<h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><ul>
<li>effect文件作为响应式的核心，主要负责收集依赖，触发依赖</li>
</ul>
<h4 id="effect-1"><a href="#effect-1" class="headerlink" title="effect"></a>effect</h4><ul>
<li>effect函数主要是生成收集依赖所需的依赖函数<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">function</span> effect&lt;T = <span class="built_in">any</span>&gt;(
    <span class="attr">fn</span>: <span class="function">() =&gt;</span> T,
    <span class="attr">options</span>: <span class="title class_">ReactiveEffectOptions</span> = <span class="variable constant_">EMPTY_OBJ</span>
): <span class="title class_">ReactiveEffect</span>&lt;T&gt; &#123;
    <span class="comment">// 如果已经是effect函数，取得原来的fn</span>
    <span class="keyword">if</span> (<span class="title function_">isEffect</span>(fn)) &#123;
      fn = fn.<span class="property">raw</span>
    &#125;
    <span class="keyword">const</span> effect = <span class="title function_">createReactiveEffect</span>(fn, options)

    <span class="comment">// 如果lazy为false，立即执行一次</span>
    <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;
      <span class="title function_">effect</span>()
    &#125;
    <span class="keyword">return</span> effect
&#125;</code></pre></li>
<li><code>createReactiveEffect</code>：生成effect对象<pre><code class="highlight ts"><span class="keyword">function</span> createReactiveEffect&lt;T = <span class="built_in">any</span>&gt;(
    <span class="attr">fn</span>: <span class="function">() =&gt;</span> T,
    <span class="attr">options</span>: <span class="title class_">ReactiveEffectOptions</span>
): <span class="title class_">ReactiveEffect</span>&lt;T&gt; &#123;
    <span class="keyword">const</span> effect = <span class="keyword">function</span> <span class="title function_">reactiveEffect</span>(<span class="params"></span>): <span class="built_in">unknown</span> &#123;
      <span class="comment">// 没有激活，已经调用stop函数停止监听</span>
      <span class="keyword">if</span> (!effect.<span class="property">active</span>) &#123;
        <span class="keyword">return</span> <span class="title function_">fn</span>()
      &#125;
      <span class="comment">/**</span>
<span class="comment">       * effectStack是一个全局的effect栈结构</span>
<span class="comment">       * 设计为栈结构是因为如果effect是嵌套时，为了防止内层副作用函数覆盖外层副作用函数，在收集时只收集栈顶的，这样就不会收集到错误的副作用函数</span>
<span class="comment">       */</span>
      <span class="keyword">if</span> (!effectStack.<span class="title function_">includes</span>(effect)) &#123;
        <span class="comment">/**</span>
<span class="comment">         * 为了保证当前effect的dep是最新，因为在一些判断处理中，可能会导致一些无效的副作用函数</span>
<span class="comment">         * 所以为了取消这些不必要的更新，就要清除effect依赖</span>
<span class="comment">         */</span>
        <span class="title function_">cleanup</span>(effect)
        <span class="keyword">try</span> &#123;
          <span class="title function_">enableTracking</span>() <span class="comment">// 重新收集依赖</span>
          effectStack.<span class="title function_">push</span>(effect)
          activeEffect = effect
          <span class="keyword">return</span> <span class="title function_">fn</span>()
        &#125; <span class="keyword">finally</span> &#123;
          <span class="comment">/* </span>
<span class="comment">            track将依赖函数activeEffect添加到对应的dep中，</span>
<span class="comment">            然后将activeEffect重置为上一个effect的值</span>
<span class="comment">          */</span>
          effectStack.<span class="title function_">pop</span>()
          <span class="title function_">resetTracking</span>()
          activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]
        &#125;
      &#125;
    &#125; <span class="keyword">as</span> <span class="title class_">ReactiveEffect</span>
    effect.<span class="property">id</span> = uid++ <span class="comment">// 自增ID</span>
    effect.<span class="property">allowRecurse</span> = !!options.<span class="property">allowRecurse</span> <span class="comment">// 递归状态</span>
    effect.<span class="property">_isEffect</span> = <span class="literal">true</span> <span class="comment">// 用于标识方法是不是effect</span>
    effect.<span class="property">active</span> = <span class="literal">true</span> <span class="comment">// 用于判断当前effect是否激活，有一个stop()来将它设为false</span>
    effect.<span class="property">raw</span> = fn <span class="comment">// effect的执行函数</span>
    effect.<span class="property">deps</span> = [] <span class="comment">// 用于收集依赖</span>
    effect.<span class="property">options</span> = options <span class="comment">// 创建effect传入的options</span>
    <span class="keyword">return</span> effect
&#125;</code></pre></li>
<li>activeEffect就是标记track所需的依赖函数</li>
</ul>
<h4 id="track"><a href="#track" class="headerlink" title="track"></a>track</h4><ul>
<li>track就是baseHandler和collectionHandlers文件中频繁使用的收集依赖函数</li>
<li>首先需要看一个关键变量targetMap<pre><code class="highlight ts"><span class="comment">// targetMap是依赖管理中心，收集依赖和触发依赖都依托于这个Map数据</span>
<span class="comment">// 下面是targetMap的定义(target -&gt; key -&gt; dep)</span>
<span class="comment">// target: 监听的对象源</span>
<span class="comment">// key: 监听的键值</span>
<span class="comment">// dep：依赖函数</span>
<span class="keyword">type</span> <span class="title class_">Dep</span> = <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;
<span class="keyword">type</span> <span class="title class_">KeyToDepMap</span> = <span class="title class_">Map</span>&lt;<span class="built_in">any</span>, <span class="title class_">Dep</span>&gt;
<span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">any</span>, <span class="title class_">KeyToDepMap</span>&gt;()
<span class="comment">// 格式大致为</span>
targetMap = &#123;
  <span class="attr">target</span>: &#123;
    <span class="attr">key1</span>: &#123; fn1, fn2 &#125;
    <span class="attr">key2</span>: &#123; fn1, fn2 &#125;
  &#125;
&#125;</code></pre>
<pre><code class="highlight ts"><span class="comment">/**</span>
<span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">target</span>&#125; 目标对象</span>
<span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">type</span>&#125; 收集类型</span>
<span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">key</span>&#125; 需要收集依赖的key</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: <span class="built_in">unknown</span></span>) &#123;
    <span class="comment">// activeEffect为空，就表示当前没有依赖，就没必要做依赖收集了</span>
    <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;
      <span class="keyword">return</span>
    &#125;
    <span class="comment">// 获取当前依赖数据</span>
    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)

    <span class="keyword">if</span> (!depsMap) &#123;
      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))
    &#125;

    <span class="comment">// 如果当前数据中没有所属的依赖key，就重新设置一个</span>
    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)
    <span class="keyword">if</span> (!dep) &#123;
      depsMap.<span class="title function_">set</span>(key, (dep = <span class="keyword">new</span> <span class="title class_">Set</span>()))
    &#125;
    <span class="comment">// 添加依赖函数</span>
    <span class="keyword">if</span> (!dep.<span class="title function_">has</span>(activeEffect)) &#123;
      dep.<span class="title function_">add</span>(activeEffect)
      activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(dep)
      <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.<span class="property">options</span>.<span class="property">onTrack</span>) &#123;
        activeEffect.<span class="property">options</span>.<span class="title function_">onTrack</span>(&#123;
          <span class="attr">effect</span>: activeEffect,
          target,
          <span class="keyword">type</span>,
          key
        &#125;)
      &#125;
    &#125;
&#125;</code></pre></li>
</ul>
<h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><pre><code class="highlight ts"><span class="comment">// 触发依赖</span>
<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>
<span class="params">  target: <span class="built_in">object</span>,</span>
<span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span>
<span class="params">  key?: <span class="built_in">unknown</span>,</span>
<span class="params">  newValue?: <span class="built_in">unknown</span>,</span>
<span class="params">  oldValue?: <span class="built_in">unknown</span>,</span>
<span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;<span class="built_in">unknown</span>, <span class="built_in">unknown</span>&gt; | <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span>
<span class="params"></span>) &#123;
  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)
  <span class="comment">// 如果没有收集过依赖，直接返回</span>
  <span class="keyword">if</span> (!depsMap) &#123;
    <span class="keyword">return</span>
  &#125;

  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;()
  <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">effectsToAdd: <span class="built_in">Set</span>&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt; &#123;
    <span class="keyword">if</span> (effectsToAdd) &#123;
      effectsToAdd.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;
        <span class="comment">// 避免循环触发依赖 类似`effect(() =&gt; obj.foo++)`</span>
        <span class="keyword">if</span> (effect !== activeEffect || effect.<span class="property">allowRecurse</span>) &#123;
          effects.<span class="title function_">add</span>(effect)
        &#125;
      &#125;)
    &#125;
  &#125;

  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>) &#123;
    <span class="comment">// 在清空前，将对应的依赖全部添加到局部Set</span>
    depsMap.<span class="title function_">forEach</span>(add)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; <span class="title function_">isArray</span>(target)) &#123;
    <span class="comment">// 当数组的length属性变化时触发</span>
    depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;
      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;
        <span class="title function_">add</span>(dep)
      &#125;
    &#125;)
  &#125; <span class="keyword">else</span> &#123;
    <span class="comment">// schedule runs for SET | ADD | DELETE</span>
    <span class="comment">// 往相应队列添加依赖</span>
    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;
      <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(key))
    &#125;

    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span>
    <span class="comment">// 通过不同的TriggerOpTypes将depsMap的数据取出，添加到effects</span>
    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;
      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>:
        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;
          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))
          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;
            <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>))
          &#125;
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isIntegerKey</span>(key)) &#123;
          <span class="comment">// new index added to array -&gt; length changes</span>
          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="string">&#x27;length&#x27;</span>))
        &#125;
        <span class="keyword">break</span>
      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>:
        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;
          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))
          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;
            <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>))
          &#125;
        &#125;
        <span class="keyword">break</span>
      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>:
        <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;
          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))
        &#125;
        <span class="keyword">break</span>
    &#125;
  &#125;

  <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect: ReactiveEffect</span>) =&gt; &#123;
    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.<span class="property">options</span>.<span class="property">onTrigger</span>) &#123;
      effect.<span class="property">options</span>.<span class="title function_">onTrigger</span>(&#123;
        effect,
        target,
        key,
        <span class="keyword">type</span>,
        newValue,
        oldValue,
        oldTarget
      &#125;)
    &#125;
    <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;
      <span class="comment">// 如果有调度属性，就通过scheduler处理执行</span>
      effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect)
    &#125; <span class="keyword">else</span> &#123;
      <span class="title function_">effect</span>()
    &#125;
  &#125;

  effects.<span class="title function_">forEach</span>(run)
&#125;</code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>vue3响应式是通过数据劫持和发布订阅的模式进行处理，首先vue3中的数据是通过<code>proxy</code>做了一层代理，然后处理<code>proxy</code>的<code>handler</code>，基本类型的<code>handler</code>是通过<code>baseHandlers</code>，特殊类型(map，set)的<code>handler</code>是通过<code>collectHandlers</code>。</li>
<li><code>handler</code>中获取属性的操作通过<code>track</code>进行依赖收集，修改属性的操作通过<code>trigger</code>进行依赖触发，依赖的收集与触发是通过依赖管理中心<code>targetMap</code>保存的</li>
<li><code>track</code>进行收集时，他收集的是<code>activeEffect</code>，这个变量存储的就是正在触发的副作用函数，<code>activeEffect</code>通过<code>effect()</code>方法进行收集</li>
<li><code>effect()</code>常用的三个地方<ul>
<li>组件副作用函数</li>
<li><code>watch</code></li>
<li><code>computed</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>颜色选择器的纯JS实现</title>
    <url>/2022/11/05/%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E7%BA%AFJS%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在逛论坛的时候发现了一个新API：<code>EyeDropper</code>，仅需创建一个实例，然后调用open方法，就可以取到你屏幕内所有可以取到的颜色，可惜兼容性不太行，只有Chrome，Edge，Opera支持，<a href="https://developer.mozilla.org/en-US/docs/Web/API/EyeDropper">MDN文档</a><br>知道了这个API后我也有了一个想实现取色器的想法，工作摸鱼期间👻折腾了几天搞了出来，实现步骤大致以下几步</p>
<ol>
<li>所需页面创建实例，初始化所需属性</li>
<li>需开启时调用open方法开启取色器，网页截屏生成canvas，初始化监听事件和浮动元素(放大镜)</li>
<li>鼠标移动时根据坐标获取颜色数据修改放大镜颜色</li>
<li>鼠标点击或者按Esc键后销毁</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>预览地址：<a href="https://songlh.top/page-color-picker/">https://songlh.top/page-color-picker/</a><br>github：<a href="https://github.com/LHRUN/page-color-picker">https://github.com/LHRUN/page-color-picker</a><br><img src="https://s1.ax1x.com/2022/11/05/xOoXo4.png"></p>
<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>初始化方法没什么说的，就是把需要的属性和方法赋值一遍初始值，然后接收一个鼠标点击时的回调</p>
<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ColorPicker</span> &#123;
  <span class="attr">canvasContainer</span>: <span class="title class_">HTMLDivElement</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">// canvas容器元素</span>
  <span class="attr">canvas</span>: <span class="title class_">HTMLCanvasElement</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">// 截屏canvas</span>
  <span class="attr">context</span>: <span class="title class_">CanvasRenderingContext2D</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">// 截屏canvas[context]</span>
  <span class="attr">floatContainer</span>: <span class="title class_">HTMLDivElement</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">// 鼠标移动时的浮动容器元素</span>
  onChange?: <span class="function">(<span class="params">color: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> <span class="comment">// 点击鼠标后的回调</span>
  color = <span class="string">&#x27;&#x27;</span> <span class="comment">// 颜色值</span>
  elementId = <span class="string">&#x27;&#x27;</span> <span class="comment">// 元素唯一id</span>
  <span class="attr">colorArr</span>: &#123;
    <span class="attr">el</span>: <span class="title class_">HTMLDivElement</span>
    <span class="attr">row</span>: <span class="built_in">number</span>
    <span class="attr">col</span>: <span class="built_in">number</span>
  &#125;[] = [] <span class="comment">// 放大镜颜色数组</span>

  <span class="title function_">constructor</span>(<span class="params"></span>
<span class="params">    onChange?: (color: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span> <span class="comment">// 点击后回调</span></span>
<span class="params">  </span>) &#123;
    <span class="variable language_">this</span>.<span class="property">onChange</span> = onChange
  &#125;
  <span class="comment">// ...</span>
&#125;</code></pre>

<h2 id="开启取色器"><a href="#开启取色器" class="headerlink" title="开启取色器"></a>开启取色器</h2><p>开启取色器分为4步</p>
<ol>
<li>初始化canvas容器</li>
<li>生成canvas，我使用的是<a href="https://www.npmjs.com/package/html2canvas">html2canvas</a></li>
<li>初始化监听事件</li>
<li>创建浮动元素</li>
</ol>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment">* 开启取色器</span>
<span class="comment">*/</span>
<span class="title function_">open</span>(<span class="params"></span>) &#123;
  <span class="comment">// 获取随机id</span>
  <span class="variable language_">this</span>.<span class="property">elementId</span> = <span class="title function_">getId</span>()
  <span class="comment">// 初始化canvas容器</span>
  <span class="variable language_">this</span>.<span class="title function_">initContainer</span>()
  <span class="title function_">html2canvas</span>(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">canvas</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (canvas &amp;&amp; <span class="variable language_">this</span>.<span class="property">canvasContainer</span>) &#123;
      <span class="comment">// 初始化事件</span>
      <span class="variable language_">this</span>.<span class="title function_">initEvent</span>(canvas)
      <span class="variable language_">this</span>.<span class="property">canvasContainer</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>
      <span class="variable language_">this</span>.<span class="property">canvasContainer</span>.<span class="title function_">appendChild</span>(canvas)
      <span class="variable language_">this</span>.<span class="property">canvas</span> = canvas
      <span class="variable language_">this</span>.<span class="property">context</span> = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)
      <span class="comment">// 创建浮动元素</span>
      <span class="variable language_">this</span>.<span class="title function_">initFloatContainer</span>()
    &#125;
  &#125;)
&#125;</code></pre>
<ul>
<li><p>初始化canvas容器</p>
<pre><code class="highlight ts"><span class="title function_">initContainer</span>(<span class="params"></span>) &#123;
  <span class="comment">// 创建元素我封装了一个方法</span>
  <span class="keyword">const</span> canvasContainer = <span class="title function_">createDocument</span>(
    <span class="string">&#x27;div&#x27;</span>,
    styleObj.<span class="property">canvasContainer</span>,
    <span class="variable language_">document</span>.<span class="property">body</span>
  )
  <span class="variable language_">this</span>.<span class="property">canvasContainer</span> = canvasContainer
  <span class="keyword">return</span> canvasContainer
&#125;

<span class="comment">/**</span>
<span class="comment"> * 创建元素</span>
<span class="comment"> * <span class="doctag">@param</span> elType 元素类型</span>
<span class="comment"> * <span class="doctag">@param</span> styleObj 样式对象</span>
<span class="comment"> * <span class="doctag">@param</span> parent 父级元素</span>
<span class="comment"> * <span class="doctag">@returns</span> <span class="variable">element</span></span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> createDocument = &lt;T <span class="keyword">extends</span> keyof <span class="title class_">HTMLElementTagNameMap</span>&gt;(
  <span class="attr">elType</span>: T,
  <span class="attr">styleObj</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span> | <span class="built_in">number</span>&gt;,
  <span class="attr">parent</span>: <span class="title class_">HTMLElement</span> | <span class="title class_">DocumentFragment</span>
): <span class="title class_">HTMLElementTagNameMap</span>[T] =&gt; &#123;
  <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(elType)
  <span class="title class_">Object</span>.<span class="title function_">keys</span>(styleObj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (<span class="title function_">isValidKey</span>(key, styleObj)) &#123;
      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(el.<span class="property">style</span>, key, styleObj[key])
    &#125;
  &#125;)
  parent.<span class="title function_">appendChild</span>(el)
  <span class="keyword">return</span> el
&#125;</code></pre>
</li>
<li><p>初始化事件</p>
<pre><code class="highlight ts"><span class="comment">/**</span>
<span class="comment"> * 初始化事件</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">canvas</span></span>
<span class="comment"> */</span>
<span class="title function_">initEvent</span>(<span class="params">canvas: HTMLCanvasElement</span>) &#123;
  canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">canvasMouseMove</span>)
  canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">canvasMouseDown</span>)
  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onKeyDown</span>)
&#125;</code></pre>
</li>
<li><p>创建浮动元素容器</p>
<pre><code class="highlight js"><span class="title function_">initFloatCOntainer</span>(<span class="params"></span>) &#123;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">canvasContainer</span>) &#123;
    <span class="comment">// 创建浮动元素容器</span>
    <span class="keyword">const</span> floatContainer = <span class="title function_">createDocument</span>(
      <span class="string">&#x27;div&#x27;</span>,
      styleObj.<span class="property">floatContainer</span>,
      <span class="variable language_">this</span>.<span class="property">canvasContainer</span>
    )

    <span class="comment">// 创建放大镜的小颜色块</span>
    <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="variable constant_">COLOR_ITEM_SIZE</span> * <span class="variable constant_">COLOR_ITEM_SIZE</span>; i++) &#123;
      <span class="keyword">const</span> row = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(i / <span class="variable constant_">COLOR_ITEM_SIZE</span>)
      <span class="keyword">const</span> col = i - (row - <span class="number">1</span>) * <span class="variable constant_">COLOR_ITEM_SIZE</span>
      <span class="keyword">const</span> <span class="attr">style</span>: <span class="title class_">Record</span>&lt;string, string | number&gt; = &#123;
        ...styleObj.<span class="property">colorItem</span>
      &#125;

      <span class="keyword">if</span> (row === <span class="number">6</span> &amp;&amp; col === <span class="number">6</span>) &#123;
        style.<span class="property">borderColor</span> = <span class="string">&#x27;#000000&#x27;</span>
      &#125;
      <span class="keyword">const</span> itemEl = <span class="title function_">createDocument</span>(<span class="string">&#x27;div&#x27;</span>, style, fragment)
      itemEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.elementId&#125;</span><span class="subst">$&#123;i&#125;</span>`</span>)
      <span class="variable language_">this</span>.<span class="property">colorArr</span>.<span class="title function_">push</span>(&#123;
        <span class="attr">el</span>: itemEl,
        row,
        col
      &#125;)
    &#125;
    floatContainer.<span class="title function_">appendChild</span>(fragment)
    <span class="keyword">const</span> textEl = <span class="title function_">createDocument</span>(<span class="string">&#x27;div&#x27;</span>, styleObj.<span class="property">text</span>, floatContainer)
    textEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.elementId&#125;</span>text`</span>)
    <span class="variable language_">this</span>.<span class="property">floatContainer</span> = floatContainer
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="鼠标移动"><a href="#鼠标移动" class="headerlink" title="鼠标移动"></a>鼠标移动</h2><ul>
<li>根据鼠标移动时的坐标，计算需要处理的颜色区域，然后调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData">CanvasRenderingContext2D.getImageData()</a>方法，这个方法会返回一个ImageData对象，这个对象里就包含RGBA数据，然后把这些数据展示到放大镜元素上，就有了放大的效果<pre><code class="highlight ts">canvasMouseMove = <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> &#123;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">context</span>) &#123;
    <span class="keyword">const</span> x = e.<span class="property">pageX</span> * <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>
    <span class="keyword">const</span> y = e.<span class="property">pageY</span> * <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>
    <span class="comment">// 获取放大镜所需区域颜色</span>
    <span class="keyword">const</span> colors = <span class="variable language_">this</span>.<span class="title function_">getColors</span>(x, y)
    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">floatContainer</span> &amp;&amp; colors) &#123;
      <span class="comment">// 根据坐标改变放大镜位置</span>
      <span class="variable language_">this</span>.<span class="property">floatContainer</span>.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(<span class="subst">$&#123;e.pageX - <span class="number">82.5</span>&#125;</span>px, <span class="subst">$&#123;</span></span>
<span class="subst"><span class="string">        e.pageY - <span class="number">82.5</span></span></span>
<span class="subst"><span class="string">      &#125;</span>px )`</span>
      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">floatContainer</span>.<span class="property">style</span>.<span class="property">visibility</span> === <span class="string">&#x27;hidden&#x27;</span>) &#123;
        <span class="variable language_">this</span>.<span class="property">floatContainer</span>.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;visible&#x27;</span>
      &#125;
      <span class="keyword">const</span> textEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.elementId&#125;</span>text`</span>)

      <span class="comment">// 遍历每个颜色块，修改颜色</span>
      <span class="keyword">for</span> (
        <span class="keyword">let</span> i = <span class="number">0</span>;
        i &lt; <span class="variable constant_">COLOR_ITEM_SIZE</span> * <span class="variable constant_">COLOR_ITEM_SIZE</span>;
        i++
      ) &#123;
        <span class="keyword">const</span> &#123; el, row, col &#125; = <span class="variable language_">this</span>.<span class="property">colorArr</span>[i]
        <span class="keyword">const</span> [r, g, b, a] = colors[i]
        <span class="comment">// toHexString rgba转16进制</span>
        <span class="keyword">const</span> hexStr = <span class="title function_">toHexString</span>(&#123; r, g, b, <span class="attr">a</span>: a / <span class="number">255</span> &#125;)

        <span class="comment">//  最中间的颜色保存起来</span>
        <span class="keyword">if</span> (row === <span class="number">6</span> &amp;&amp; col === <span class="number">6</span> &amp;&amp; textEl) &#123;
          textEl.<span class="property">textContent</span> = hexStr
          textEl.<span class="property">style</span>.<span class="property">color</span> = hexStr
          <span class="variable language_">this</span>.<span class="property">color</span> = hexStr
        &#125;

        el.<span class="property">style</span>.<span class="property">backgroundColor</span> = hexStr
      &#125;
    &#125;
  &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取放大镜所需区域颜色</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">x</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">y</span></span>
<span class="comment"> * <span class="doctag">@returns</span></span>
<span class="comment"> */</span>
<span class="title function_">getColors</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">context</span>) &#123;
    <span class="keyword">const</span> &#123; data &#125; = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">getImageData</span>(
      x - <span class="number">5</span>,
      y - <span class="number">5</span>,
      <span class="variable constant_">COLOR_ITEM_SIZE</span>,
      <span class="variable constant_">COLOR_ITEM_SIZE</span>
    )
    <span class="keyword">const</span> colors = []
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;
      colors.<span class="title function_">push</span>([data[i], data[i + <span class="number">1</span>], data[i + <span class="number">2</span>], data[i + <span class="number">3</span>]])
    &#125;
    <span class="keyword">return</span> colors
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="鼠标点击"><a href="#鼠标点击" class="headerlink" title="鼠标点击"></a>鼠标点击</h2><ul>
<li>鼠标点击触发回调，销毁元素<pre><code class="highlight ts">canvasMouseDown = <span class="function">() =&gt;</span> &#123;
  <span class="variable language_">this</span>?.<span class="property">onChange</span>?.(<span class="variable language_">this</span>.<span class="property">color</span>)
  <span class="variable language_">this</span>.<span class="title function_">destroy</span>()
&#125;

<span class="title function_">destroy</span>(<span class="params"></span>) &#123;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">canvas</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">canvas</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">canvasMouseMove</span>)
    <span class="variable language_">this</span>.<span class="property">canvas</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">canvasMouseDown</span>)
  &#125;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">canvasContainer</span>) &#123;
    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(<span class="variable language_">this</span>.<span class="property">canvasContainer</span>)
  &#125;
  <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onKeyDown</span>)
&#125;</code></pre></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有问题欢迎讨论👻</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序滚动日历组件</title>
    <url>/2021/04/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%BB%9A%E5%8A%A8%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="小程序滚动日历组件"><a href="#小程序滚动日历组件" class="headerlink" title="小程序滚动日历组件"></a>小程序滚动日历组件</h2><p>前段时间产品提出这个需求，要求做一个日历容器，并要求是滚动，不能是那种每个月切换的容器，所以我就在网上大概查找了一下类似组件，滚动的容器较少，于是我就自己写了这个组件，以下是大概的js思路，wxml和css就不附上了，每个UI都有不同的想法</p>
<ol>
<li><p>在ready中初始化组件数据</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * <span class="doctag">@description</span>: 初始化</span>
<span class="comment"> */</span>
<span class="title function_">ready</span>(<span class="params"></span>) &#123;
  <span class="comment">// 这两个数据是从页面中传过来的，起始时间和结束时间</span>
  <span class="comment">// 数组类型 [year, month, day]</span>
  <span class="keyword">const</span> &#123; endDate, startDate &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">let</span> monthList = [] <span class="comment">// 这个用于wxml中遍历，以每月为item</span>

  <span class="comment">// 未跨年</span>
  <span class="keyword">if</span> ( endDate[<span class="number">0</span>] === startDate[<span class="number">0</span>]) &#123;
    <span class="keyword">let</span> rangeMonth = endDate[<span class="number">1</span>] - startDate[<span class="number">1</span>]
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= rangeMonth; i++) &#123;
      <span class="keyword">let</span> date = [startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i + <span class="number">1</span>]
      <span class="comment">// monthInitData()初始化每月数据</span>
      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i)
      monthList.<span class="title function_">push</span>(&#123;
        date,
        days,
      &#125;)
    &#125;
  &#125; <span class="keyword">else</span> &#123;
    <span class="comment">// 跨年前月份</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, lng = <span class="number">12</span> - startDate[<span class="number">1</span>]; i &lt; lng; i++) &#123;
      <span class="keyword">let</span> date = [startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i + <span class="number">1</span>]
      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i)
      monthList.<span class="title function_">push</span>(&#123;
        date,
        days,
      &#125;)
    &#125;

    <span class="comment">// 跨年后月份</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= endDate[<span class="number">1</span>]; i++) &#123;
      <span class="keyword">let</span> date = [endDate[<span class="number">0</span>], i + <span class="number">1</span>]
      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(endDate[<span class="number">0</span>], i)
      monthList.<span class="title function_">push</span>(&#123;
        date,
        days,
      &#125;)
    &#125;
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    monthList,
  &#125;)
&#125;</code></pre>
</li>
<li><p>初始化每月数据: </p>
<blockquote>
<p>逻辑是获取每个月第一天的星期数和每个月的最大天数，然后在之前和之后的空数据填充item占位<br>然后遍历，根据不同的需求，在遍历中处理，最后在html中flex布局即可</p>
</blockquote>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * <span class="doctag">@description</span>: 初始化每月数据</span>
<span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; year 年</span>
<span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; month 月</span>
<span class="comment"> */</span>
<span class="title function_">monthInitData</span>(<span class="params">year, month</span>) &#123;
  <span class="keyword">let</span> &#123; calendarValue, startDate, endDate &#125;= <span class="variable language_">this</span>.<span class="property">data</span>, <span class="comment">// 当前点击时间，起始时间，结束时间</span>
    firstWeek = <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, <span class="number">1</span>).<span class="title function_">getDay</span>(), <span class="comment">// 本月的第一天的星期数</span>
    days = [], <span class="comment">// 日期数组</span>
    max = <span class="variable language_">this</span>.<span class="title function_">getMonthMax</span>(year, month + <span class="number">1</span>), <span class="comment">// 每月最大天数</span>
    lastWeek = <span class="keyword">new</span> <span class="title class_">Date</span>(year, (month + <span class="number">1</span>), <span class="number">0</span>).<span class="title function_">getDay</span>() <span class="comment">// 本月的最后一天的星期数</span>

  <span class="comment">// 填充每月一号之前的空数据</span>
  <span class="keyword">if</span> (firstWeek &gt; <span class="number">0</span>) &#123;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; firstWeek; i++) &#123;
      days.<span class="title function_">push</span>(&#123;
        <span class="attr">day</span>: <span class="number">0</span>
      &#125;)
    &#125;
  &#125;

  <span class="keyword">let</span> currentTime = <span class="number">0</span>, 
      startTime = <span class="number">0</span>,
      endTime = <span class="number">0</span>

  <span class="keyword">if</span> (calendarValue[<span class="number">0</span>]) &#123;
    currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>(calendarValue[<span class="number">0</span>], calendarValue[<span class="number">1</span>], calendarValue[<span class="number">2</span>]).<span class="title function_">getTime</span>()
  &#125;
  <span class="keyword">if</span> (startDate[<span class="number">0</span>]) &#123;
    startTime = <span class="keyword">new</span> <span class="title class_">Date</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>], startDate[<span class="number">2</span>]).<span class="title function_">getTime</span>()
  &#125;
  <span class="keyword">if</span> (endDate[<span class="number">0</span>]) &#123;
    endTime = <span class="keyword">new</span> <span class="title class_">Date</span>(endDate[<span class="number">0</span>], endDate[<span class="number">1</span>], endDate[<span class="number">2</span>]).<span class="title function_">getTime</span>()
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;
    <span class="comment">// 以下状态是需要在html中判断处理，根据自己需求改变</span>
    <span class="keyword">let</span> current = <span class="literal">false</span>, <span class="comment">// 当前点击状态</span>
      disabled = <span class="literal">false</span>, <span class="comment">// 禁止状态</span>
      now = <span class="literal">false</span>, <span class="comment">// 今天显示文案</span>
      time = <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, i).<span class="title function_">getTime</span>(),
      nowTime = [<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>(), <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getMonth</span>(), <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDate</span>()]
    <span class="keyword">if</span> (currentTime &amp;&amp; currentTime == time) current = <span class="literal">true</span>
    <span class="keyword">if</span> (startTime &amp;&amp; startTime &gt; time) disabled = <span class="literal">true</span>
    <span class="keyword">if</span> (endTime &amp;&amp; endTime &lt; time) disabled = <span class="literal">true</span>
    <span class="keyword">if</span> (year === nowTime[<span class="number">0</span>] &amp;&amp; month === nowTime[<span class="number">1</span>] &amp;&amp; i === nowTime[<span class="number">2</span>]) now = <span class="literal">true</span>

    days.<span class="title function_">push</span>(&#123;
      <span class="attr">day</span>: i,
      current,
      disabled,
      now,
    &#125;)
  &#125;

  <span class="comment">// 填充每月最后一天之后的空数据</span>
  <span class="keyword">if</span> (lastWeek != <span class="number">6</span>) &#123;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = (<span class="number">6</span> - lastWeek); i &lt; l; i++) &#123;
      days.<span class="title function_">push</span>(&#123;
        <span class="attr">day</span>: <span class="number">0</span>
      &#125;)
    &#125;
  &#125;
  <span class="keyword">return</span> days
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 获取一个月最大天数</span>
<span class="comment"> * <span class="doctag">@method</span> <span class="variable">getMonthMax</span></span>
<span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; year 年份</span>
<span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; month 月份</span>
<span class="comment"> */</span>
<span class="title function_">getMonthMax</span>(<span class="params">year, month</span>) &#123;
  <span class="keyword">let</span> max = <span class="number">31</span>
  <span class="keyword">if</span> (month == <span class="number">4</span> || month == <span class="number">6</span> || month == <span class="number">9</span> || month == <span class="number">11</span>) &#123;
    max = <span class="number">30</span>
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">2</span>) &#123;
    <span class="keyword">if</span> (((year % <span class="number">4</span>) == <span class="number">0</span> &amp;&amp; (year % <span class="number">100</span>) &gt; <span class="number">0</span>) || (year % <span class="number">400</span>) == <span class="number">0</span>) &#123;
      max = <span class="number">29</span>
    &#125; <span class="keyword">else</span> &#123;
      max = <span class="number">28</span>
    &#125; 
  &#125;

  <span class="keyword">return</span> max
&#125;,
</code></pre></li>
</ol>
<ul>
<li>以上就是核心逻辑，像一些弹窗事件和一些点击事件就不附上来了</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>&#39;tag&#39;</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>👋 Hello there, Here is LH’BLOG<br>👨‍💻 I’m a Frontend Developer. I like to try new technologies and develop some interesting open source projects<br>📜 I will write some tech blogs and life records<br>🌱 I’m currently learning english</p>
<h3 id="contact-me"><a href="#contact-me" class="headerlink" title="contact me"></a>contact me</h3><ul>
<li><a href="https://github.com/LHRUN">Github</a></li>
<li><a href="https://t.me/longhao_song">Telegram</a></li>
<li><a href="mailto:song.lhlh@gmail.com">song.lhlh@gmail.com</a><!-- + [SegmentFault](https://segmentfault.com/u/lh_s)</li>
<li><a href="https://blog.csdn.net/weixin_44719258">CSDN</a> </li>
<li><a href="https://juejin.cn/user/3949101499549518">掘金</a></li>
<li><a href="https://www.zhihu.com/people/wxae77cceaa49dcaf5">知乎</a> –&gt;</li>
</ul>
]]></content>
  </entry>
</search>
