<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>H5跳转微信小程序</title>
    <url>/2021/06/10/H5%E8%B7%B3%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="H5跳转微信小程序"><a href="#H5跳转微信小程序" class="headerlink" title="H5跳转微信小程序"></a>H5跳转微信小程序</h2><blockquote>
<p>H5跳转小程序有两个方法，需要根据浏览器环境判断<br>微信外使用<code>URL Scheme</code>，根据生成的一个link进行location跳转<br>微信内使用<code>wx-open-launch-weapp</code>开放标签进行跳转，实测ios系统微信内也可以使用<code>URL Scheme</code>，根据自己的需求选择</p>
</blockquote>
<h3 id="wx-open-launch-weapp"><a href="#wx-open-launch-weapp" class="headerlink" title="wx-open-launch-weapp"></a><code>wx-open-launch-weapp</code></h3><ul>
<li><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html">官方文档</a></li>
<li>注意事项：微信版本要求为：7.0.12及以上。 系统版本要求为：iOS 10.3及以上、Android 5.0及以上</li>
<li>绑定域名: 登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”  </li>
<li>引入SDK：官网推荐引入方法<code>&lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;</code>;，也可以使用第三方npm包<code>weixin-js-sdk</code>  </li>
<li>校验签名是否正确：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign">微信 JS 接口签名校验工具</a></li>
<li>如果开放标签需要绝对定位，就在外面包裹一个div进行定位，避免直接定位开放标签</li>
<li>调试：好多人在进行调试的时候认为非常麻烦，需要不断切换环境，我推荐一个我的调试方式，在开发过程中，使用SwitchHosts进行IP映射，把本地启动项目的域名映射到公众号平台设置的域名，然后在微信开发工具中调试，就非常轻松了</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 普通H5的写法可参考官方文档，以下是我在vue中的写法</span><br><span class="line"><span class="tag">&lt;<span class="name">wx-open-launch-weapp</span></span></span><br><span class="line"><span class="tag"> <span class="attr">username</span>=<span class="string">&quot;小程序原始id&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">path</span>=<span class="string">&quot;页面路径及参数&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/wxtag-template&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml">           </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;wx-btn&quot;</span>&gt;</span>跳转小程序<span class="tag">&lt;/<span class="name">button</span>&gt;</span>   </span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">  </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">wx-open-launch-weapp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">...</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> wx = <span class="built_in">require</span>(<span class="string">&#x27;weixin-js-sdk&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  wx.<span class="title function_">config</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">debug</span>: <span class="literal">true</span>, <span class="comment">// 开启调试模式，会在移动端以alert的形式打印返回值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，从服务端获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">timestamp</span>: , <span class="comment">// 必填，生成签名的时间戳，从服务端获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">nonceStr</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，生成签名的随机串，从服务端获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">signature</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">// 必填，签名，从服务端获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">jsApiList</span>: [], <span class="comment">// 必填，需要使用的JS接口列表，这个随便填一个就行</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">openTagList</span>: [<span class="string">&#x27;wx-open-launch-weapp&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  wx.<span class="title function_">ready</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span></span><br><span class="line"><span class="language-javascript">  wx.<span class="title function_">error</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a><code>URL Scheme</code></h3><ul>
<li>注意事项：安卓不能直接跳转，需要H5中转，否则Android会出现无法访问</li>
<li>写法很简单，只需<code>location.href=&#39;URL Scheme&#39;</code>，在页面初始化时调用或者在按钮点击事件中调用</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建详细教程</title>
    <url>/2022/09/06/Hexo%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%93%8D%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><ol>
<li>首先需要以下安装环境，直接在官网下载即可</li>
</ol>
<ul>
<li><a href="https://nodejs.org/en/">Node.js</a></li>
<li><a href="https://git-scm.com/">Git</a></li>
</ul>
<ol start="2">
<li>环境准备好后，安装Hexo <code>npm install -g hexo-cli</code></li>
<li>安装后在指定文件夹创建项目<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li>
<li>选择主题</li>
</ol>
<ul>
<li><p>Hexo初始化成功后，然后需要选择一个漂亮的主题，这个推荐直接在官网上找，<a href="https://hexo.io/themes/">主题</a><br><img src="https://img-blog.csdnimg.cn/60988327e65c46ec8becc25b8591c650.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>选中主题后下载到项目themes文件夹</p>
</li>
<li><p>然后修改根目录下的_config.yml文件</p>
</li>
<li><p><code>theme: &#39;主题名,也就是themes文件夹里的名字&#39;</code></p>
</li>
</ul>
<ol start="5">
<li>hexo最常用的有以下几个命令</li>
</ol>
<ul>
<li>启动服务：<code>hexo server</code> 或 <code>hexo s</code></li>
<li>新建文章：<code>hexo new &quot;文章名字&quot;</code></li>
<li>新建静态页面：<code>hexo new page &quot;页面名字&quot;</code></li>
<li>生成public文件夹：<code>hexo generate</code> 或 <code>hexo g</code></li>
<li>清除public文件夹：<code>hexo clean</code></li>
<li>部署：<code>hexo deploy</code> 或 <code>hexo d</code></li>
</ul>
<h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>Github有免费提供搭建静态网站的功能，所以hexo推荐直接放到GitHub Page，按照以下步骤进行部署。  </p>
<ol>
<li>首先新建一个源码repo，建议选择Private，这个用来放hexo项目代码，不对外开放</li>
<li>本地仓库运行以下命令提交代码</li>
</ol>
<ul>
<li><code>git init</code>：git初始化</li>
<li><code>git add .</code>: 将所有代码添加到暂存区</li>
<li><code>git commit -m &quot;first commit&quot;</code>：提交本次commit</li>
<li><code>git remote add origin &#39;远程仓库地址&#39;</code>：添加远程仓库地址</li>
<li><code>git push -u origin main</code>：推送代码</li>
</ul>
<ol start="3">
<li>然后再新建一个仓库，名字为 <code>github名字.github.io</code>，这个仓库用于放部署后的代码</li>
<li>安装Hexo部署插件 <code>npm install hexo-deployer-git</code></li>
<li>修改根目录下的 <code>_config.yml</code><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">部署仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure></li>
<li>最后执行<code>hexo deploy</code>命令就可以在<code>github名字.github.io</code>看到博客了</li>
</ol>
<h2 id="SSH-github-Actions自动部署"><a href="#SSH-github-Actions自动部署" class="headerlink" title="SSH + github Actions自动部署"></a>SSH + github Actions自动部署</h2><ul>
<li><strong>Github Actions</strong>是github专用的持续集成脚本，用于自动执行工作流程，<strong>SSH</strong>可以通过建立密钥免密登录，这两个结合就能达到自动部署的效果</li>
</ul>
<ol>
<li><p>首先通过ssh-keygen生成密钥，<code>ssh-keygen -t rsa -C &quot;Github 的邮箱地址&quot;</code></p>
</li>
<li><p>然后github配置ssh，配置路径：<code>github -&gt; Settings –&gt; SSH and GPG keys</code><br> <img src="https://img-blog.csdnimg.cn/277cd5e70dad47a5af70a9ce9dc06f5a.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>git仓库添加密钥私有变量，配置路径：<code>repo -&gt; Settings -&gt; Secrets</code>，点击<code>New repository secret</code>，name可以自定义，主要是接下来的deploy.yaml文件需要使用，Secret填写你生成的密钥<br><img src="https://img-blog.csdnimg.cn/10897de98a7f44a2b3171371b71b91ac.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>然后根目录下新建<code>.github/workflows/deploy.yaml</code>，并填写以下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">你需要自动化部署的分支</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Repository</span> <span class="string">main</span> <span class="string">branch</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@main</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">14.</span><span class="string">x</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.&#x27;你上一步自定义的变量名&#x27;</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa </span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Git</span> <span class="string">Infomation</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;git名字&quot;</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;git邮箱&quot;</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          hexo clean</span></span><br><span class="line"><span class="string">          hexo generate </span></span><br><span class="line"><span class="string">          hexo deploy    </span></span><br></pre></td></tr></table></figure></li>
<li><p>然后把代码push上去的时候，就可以在仓库的<strong>Actions</strong>上看自动工作流程的情况</p>
</li>
</ol>
<h2 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h2><ol>
<li><p>首先在<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google Search Console</a>登录谷歌账号</p>
</li>
<li><p>然后在网址前缀中填写网址，下载验证文件到主题文件夹的source目录<br><img src="https://img-blog.csdnimg.cn/68c9ef2e3f4c42ec8ca29f46f01905d4.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>下载后再重新部署一下，最后点击验证</p>
</li>
</ol>
<h3 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h3><p>站点地图是一种文件，您可以在其中提供与您网站中的网页、视频或其他文件有关的信息，还可以说明这些内容之间的关系。Google 等搜索引擎会读取此文件，以便更高效地抓取您的网站。站点地图会告诉 Google 您认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。</p>
<ol>
<li><p>安装站点地图插件 <code>npm install hexo-generator-sitemap --save</code></p>
</li>
<li><p>在hexo根目录的_config.yml修改以下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">博客地址</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"> <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure></li>
<li><p>然后部署博客，输入<code>博客地址/sitemap.xml</code>能看见以下内容<br><img src="https://img-blog.csdnimg.cn/74745ec1ca3e4d06a06ba512ddb5e3f1.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>最后在<strong>Google Search Console</strong>上的站点地图上点击提交<br><img src="https://img-blog.csdnimg.cn/371a45539f694c08a207367d47d25d88.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<h2 id="Disqus评论"><a href="#Disqus评论" class="headerlink" title="Disqus评论"></a>Disqus评论</h2><p>Hexo可以搭载的评论系统有很多，比如Valine，Waline，Disqus等等，但是按颜值来看还是Disqus</p>
<ol>
<li>首先在<a href="https://disqus.com/">Disqus官网</a>进行注册，然后点击“Get STARTED”，并选择 “I want to install Disqus on my site” 选项</li>
<li>然后在进入表单页按照提示进行填写即可，但是有两个地方需要注意，<code>Website Name</code>这个是你的专属网址的名字，需要记住，还有就是在“Select Plan”记得选“Basic”</li>
<li>最后修改_config.yml中把shortname替换为你在创建时的名字，一般现在的主题都带的有评论模版，如果没有就需要自己添加了，这个不同的主题不太相同，可以看下官方的安装模版进行修改<br><img src="https://img-blog.csdnimg.cn/d1dc79115212411383a8dbd11971aaee.jpeg#pic_center" alt="在这里插入图片描述"></li>
</ol>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>React源码分析之diff核心算法</title>
    <url>/2022/09/04/React%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdiff%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>React的diff算法是在render的beginWork阶段中进行处理</li>
<li><code>beginWork</code>是在向下深度遍历fiber树时会对途径的每个节点进行状态处理和进行diff对比</li>
<li>首先diff的入口是在<code>reconcileChildFibers</code>中，然后会根据type来判断使用哪种diff函数进行处理<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  newChild: any,</span></span><br><span class="line"><span class="params">  lanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">placeSingleChild</span>(</span><br><span class="line">          <span class="title function_">reconcileSingleElement</span>(</span><br><span class="line">            returnFiber,</span><br><span class="line">            currentFirstChild,</span><br><span class="line">            newChild,</span><br><span class="line">            lanes,</span><br><span class="line">          ),</span><br><span class="line">        );··</span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REACT_PORTAL_TYPE</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> <span class="attr">REACT_LAZY_TYPE</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reconcileChildrenArray</span>(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        lanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">getIteratorFn</span>(newChild)) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我在本篇会针对两种较常用的diff函数进行分析<ul>
<li><code>reconcileSingleElement</code></li>
<li><code>reconcileChildrenArray</code></li>
</ul>
</li>
</ul>
<h2 id="reconcileSingleElement"><a href="#reconcileSingleElement" class="headerlink" title="reconcileSingleElement"></a>reconcileSingleElement</h2><ul>
<li>reconcileSingleElement是针对新newChild是单节点，而oldChild单节点或者是多节点就无法确定了，所以在此diff算法中就会对旧节点进行遍历，然后删除不匹配的oldFiber<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileSingleElement</span>(<span class="params"></span></span><br><span class="line"><span class="params">  returnFiber: Fiber,</span></span><br><span class="line"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  element: ReactElement</span></span><br><span class="line"><span class="params">  lanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.<span class="property">key</span>;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 遍历旧节点，找到与newChild相同key的节点，不匹配的删除</span></span><br><span class="line"><span class="comment">    * 针对匹配的oldFiber, 用newChild中新节点的props来生成新的fiber节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.<span class="property">key</span> === key) &#123;</span><br><span class="line">      <span class="keyword">const</span> elementType = element.<span class="property">type</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 通过useFiber创建一个新的Fiber</span></span><br><span class="line"><span class="comment">        * 如果element是一个Fragment，则以element.props.children建立Fiber</span></span><br><span class="line"><span class="comment">        * 将returnFiber赋给新的fiber的return字段，然后返回这个新的fiber</span></span><br><span class="line"><span class="comment">        */</span>·</span><br><span class="line">      <span class="keyword">if</span> (elementType === <span class="variable constant_">REACT_FRAGMENT_TYPE</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.<span class="property">tag</span> === <span class="title class_">Fragment</span>) &#123;</span><br><span class="line">          <span class="title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="property">sibling</span>);</span><br><span class="line">          <span class="keyword">const</span> existing = <span class="title function_">useFiber</span>(child, element.<span class="property">props</span>.<span class="property">children</span>);</span><br><span class="line">          existing.<span class="property">return</span> = returnFiber;</span><br><span class="line">          <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            existing.<span class="property">_debugSource</span> = element.<span class="property">_source</span>;</span><br><span class="line">            existing.<span class="property">_debugOwner</span> = element.<span class="property">_owner</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> existing;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          child.<span class="property">elementType</span> === elementType ||</span><br><span class="line">          (__DEV__</span><br><span class="line">            ? <span class="title function_">isCompatibleFamilyForHotReloading</span>(child, element)</span><br><span class="line">            : <span class="literal">false</span>) ||</span><br><span class="line">          (<span class="keyword">typeof</span> elementType === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">            elementType !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            elementType.<span class="property">$$typeof</span> === <span class="variable constant_">REACT_LAZY_TYPE</span> &amp;&amp;</span><br><span class="line">            <span class="title function_">resolveLazy</span>(elementType) === child.<span class="property">type</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="property">sibling</span>);</span><br><span class="line">          <span class="keyword">const</span> existing = <span class="title function_">useFiber</span>(child, element.<span class="property">props</span>);</span><br><span class="line">          existing.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, child, element);</span><br><span class="line">          existing.<span class="property">return</span> = returnFiber;</span><br><span class="line">          <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            existing.<span class="property">_debugSource</span> = element.<span class="property">_source</span>;</span><br><span class="line">            existing.<span class="property">_debugOwner</span> = element.<span class="property">_owner</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> existing;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Didn&#x27;t match.</span></span><br><span class="line">      <span class="title function_">deleteRemainingChildren</span>(returnFiber, child);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// key不相同就删除</span></span><br><span class="line">      <span class="title function_">deleteChild</span>(returnFiber, child);</span><br><span class="line">    &#125;</span><br><span class="line">    child = child.<span class="property">sibling</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有命中一个key，则通过createFiberFormElement或CreateFiberFormFragment创建一个新的fiber，然后返回</span></span><br><span class="line">  <span class="keyword">if</span> (element.<span class="property">type</span> === <span class="variable constant_">REACT_FRAGMENT_TYPE</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> created = <span class="title function_">createFiberFromFragment</span>(</span><br><span class="line">      element.<span class="property">props</span>.<span class="property">children</span>,</span><br><span class="line">      returnFiber.<span class="property">mode</span>,</span><br><span class="line">      lanes,</span><br><span class="line">      element.<span class="property">key</span>,</span><br><span class="line">    );</span><br><span class="line">    created.<span class="property">return</span> = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> created = <span class="title function_">createFiberFromElement</span>(element, returnFiber.<span class="property">mode</span>, lanes);</span><br><span class="line">    created.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, currentFirstChild, element);</span><br><span class="line">    created.<span class="property">return</span> = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="reconcileChildrenArray"><a href="#reconcileChildrenArray" class="headerlink" title="reconcileChildrenArray"></a>reconcileChildrenArray</h2><ul>
<li><p>针对<code>newChild</code>是多节点的情况就需要调用<code>reconcileChildrenArray</code>进行diff操作</p>
</li>
<li><p>多节点会有四种可能性的变化：删除、新增、位移、更新</p>
</li>
<li><p><code>reconcileChildrenArray</code>针对这四种变化，首先会处理的是更新，当出现无法匹配的情况时，就会根据遍历的情况来判断是否处理删除或者新增，然后最后会根据情况处理位移</p>
</li>
<li><p>因为fiber是单向链表，所以<code>reconcileChildrenArray</code>的遍历不是双端遍历</p>
</li>
<li><p>首先第一轮遍历，是处理节点更新</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">  <span class="comment">// newChildren遍历完了，oldFiber没有遍历完，中断遍历</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) &#123;</span><br><span class="line">    nextOldFiber = oldFiber;</span><br><span class="line">    oldFiber = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 记录oldFiber的下一个节点</span></span><br><span class="line">    nextOldFiber = oldFiber.<span class="property">sibling</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新节点，如果节点没有匹配上，就会返回null</span></span><br><span class="line">  <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(</span><br><span class="line">    returnFiber,</span><br><span class="line">    oldFiber,</span><br><span class="line">    newChildren[newIdx],</span><br><span class="line">    lanes,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// newFiber为null说明节点没有匹配上，中断遍历</span></span><br><span class="line">  <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// oldFiber为null说明oldFiber也遍历完了</span></span><br><span class="line">    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      oldFiber = nextOldFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * shouldTrackSideEffects为true表示是更新过程</span></span><br><span class="line"><span class="comment">   * mountChildFibers = ChildReconciler(false);</span></span><br><span class="line"><span class="comment">   * reconcileChildFibers = ChildReconciler(true);</span></span><br><span class="line"><span class="comment">   * ChildReconciler接收的就是shouldTrackSideEffects</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 新节点没有现有节点，需要删除</span></span><br><span class="line">      <span class="title function_">deleteChild</span>(returnFiber, oldFiber);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录固定节点的位置</span></span><br><span class="line">  lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将新节点拼接成以sibling为指针的单向链表</span></span><br><span class="line">  <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">    resultingFirstChild = newFiber;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">  &#125;</span><br><span class="line">  previousNewFiber = newFiber;</span><br><span class="line">  oldFiber = nextOldFiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历完匹配的节点后，就判断新节点是否遍历完，如果遍历完，那么剩余的oldFiber都是要删除的</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getIsHydrating</span>()) &#123;</span><br><span class="line">    <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">    <span class="title function_">pushTreeFork</span>(returnFiber, numberOfForks);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果新旧点没有遍历完，就判断旧fiber链是否遍历完，如果遍历完那么剩余的新节点全部作为新fiber插入</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">    <span class="comment">// 创建新fiber节点</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = <span class="title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);</span><br><span class="line">    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录固定节点</span></span><br><span class="line">    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新fiber拼接成以sibling为指针的单向链表</span></span><br><span class="line">    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getIsHydrating</span>()) &#123;</span><br><span class="line">    <span class="keyword">const</span> numberOfForks = newIdx;</span><br><span class="line">    <span class="title function_">pushTreeFork</span>(returnFiber, numberOfForks);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行到这一步，说明新旧节点都没有遍历完，就说明存在有位移的未知序列</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先创建一个以oldFiber key为键，值为oldFiber的map</span></span><br><span class="line"><span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">  <span class="comment">// 然后根据map中的oldFiber创建新fiber</span></span><br><span class="line">  <span class="keyword">const</span> newFiber = <span class="title function_">updateFromMap</span>(</span><br><span class="line">    existingChildren,</span><br><span class="line">    returnFiber,</span><br><span class="line">    newIdx,</span><br><span class="line">    newChildren[newIdx],</span><br><span class="line">    lanes,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newFiber.<span class="property">alternate</span> !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果newFiber.alternate不为null，说明是根据oldFiber创建的，那么就需要在map中删除oldFiber</span></span><br><span class="line">        existingChildren.<span class="title function_">delete</span>(</span><br><span class="line">          newFiber.<span class="property">key</span> === <span class="literal">null</span> ? newIdx : newFiber.<span class="property">key</span>,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据lastPlacedIndex判断是否移动节点</span></span><br><span class="line">    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新fiber拼接成以sibling为指针的单向链表</span></span><br><span class="line">    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">  <span class="comment">// 删除剩余的oldFiber</span></span><br><span class="line">  existingChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">deleteChild</span>(returnFiber, child));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>移动节点的核心是在<code>placeChild</code>这个函数中，如果当前正在遍历的节点的oldIndex是在<code>lastPlacedIndex</code>的右边，就说明它的位置没变化，因为旧节点中就处于右边，新节点中也处于右边。</p>
<ul>
<li>例如：old：A -&gt; B -&gt; C -&gt; D，new：D -&gt; A -&gt; B -&gt; C</li>
<li>遍历到D时，<code>lastPlacedIndex = D的oldIndex = 3</code></li>
<li>然后遍历到A时，A的<code>oldIndex</code>为0，小于3，说明A在旧序列中肯定不是D的右边，所以A肯定产生了位移<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">placeChild</span>(<span class="params"></span></span><br><span class="line"><span class="params">  newFiber: Fiber,</span></span><br><span class="line"><span class="params">  lastPlacedIndex: number,</span></span><br><span class="line"><span class="params">  newIndex: number,</span></span><br><span class="line"><span class="params"></span>): number &#123;</span><br><span class="line">  newFiber.<span class="property">index</span> = newIndex;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">    newFiber.<span class="property">flags</span> |= <span class="title class_">Forked</span>;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> current = newFiber.<span class="property">alternate</span>;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldIndex = current.<span class="property">index</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">      <span class="comment">// 小于lastPlacedIndex 产生了位移</span></span><br><span class="line">      newFiber.<span class="property">flags</span> |= <span class="title class_">Placement</span> | <span class="title class_">PlacementDEV</span>;</span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有位移，返回当前的oldIndex</span></span><br><span class="line">      <span class="keyword">return</span> oldIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newFiber.<span class="property">flags</span> |= <span class="title class_">Placement</span> | <span class="title class_">PlacementDEV</span>;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>针对单节点的diff，会遍历oldFiber链，如果有匹配的fiber，就以匹配的生成新fiber，如果没有就新建一个fiber，然后删除不匹配的fiber</li>
<li>针对多节点diff<ul>
<li>首先是从头向尾遍历，针对复用的fiber进行更新，如果无法复用就中断遍历</li>
<li>然后判断新旧节点的遍历情况，来判断是否新增或者删除</li>
<li>如果都没有遍历完，就创建一个map<code>Map&lt;old key, old Fiber&gt;</code>，然后遍历新节点，基于map来创建新fiber，然后根据<code>lastPlacedIndex</code>来判断是否产生了位移，遍历完最后删除剩余的oldFiber</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3+Vite3 SSR基本搭建</title>
    <url>/2022/08/27/Vue3-Vite3-SSR%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<ul>
<li>首先说明如果是生产使用强烈推荐Nuxt，但是如果想深入服务端渲染的运行原理，可以看本篇，会根据渲染流程搭建一个demo版ssr，源码在最后会贴上</li>
<li>主要技术栈：Vite3 + Vue3 + pinia + VueRouter4 + express</li>
<li>开始搭建之前，先说一下SSR渲染流程</li>
</ul>
<h3 id="SSR渲染流程"><a href="#SSR渲染流程" class="headerlink" title="SSR渲染流程"></a>SSR渲染流程</h3><ul>
<li>首先浏览器向服务器请求，然后服务器根据请求的路由，会匹配相关的路由组件，然后执行组件的自定义服务端生命周期(例：Nuxt的asyncData)或者自定义获取数据的hook，并且把执行后的数据收集起来，统一在window的属性中存储</li>
<li>然后vue的组件会被renderToString渲染成静态HTML字符串，替换掉index.html的提前指定的占位代码。然后index.html改变后的静态字符串发给客户端</li>
<li>客户端拿到后，首先对数据进行初始化，然后进行激活，因为当前html只是静态数据，激活主要做两件事<ul>
<li><ol>
<li>把页面中的DOM元素与虚拟DOM之间建立联系</li>
</ol>
</li>
<li><ol start="2">
<li>为页面中的DOM元素添加事件绑定</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><ul>
<li>首先用vite命令创建项目<code>pnpm create vite vue-ssr --template vue-ts</code><ul>
<li>安装相关依赖：<code>pnpm add express pinia vue-router@4</code></li>
</ul>
</li>
<li>创建三个文件 <code>touch server.js  src/entry-client.ts src/entry-server.js</code><ul>
<li>server.js：服务端启动文件</li>
<li>entry-client.ts：客户端入口，应用挂载元素</li>
<li>entry-server.js：服务端入口，处理服务端逻辑和静态资源</li>
</ul>
</li>
<li>修改<code>package.json</code>运行脚本<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;node server&quot;</span>, <span class="comment">// 运行开发环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后需要把应用创建都改为函数的方式进行调用创建，因为在SSR环境下，和纯客户端不一样，服务器只会初始化一次，所以为了防止状态污染，每次请求必须是全新的实例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createSSRApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">createSSRApp</span>(<span class="title class_">App</span>)</span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">createRouter</span>()</span><br><span class="line">  <span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line">  app.<span class="title function_">use</span>(router)</span><br><span class="line">  app.<span class="title function_">use</span>(pinia)</span><br><span class="line">  <span class="keyword">return</span> &#123; app, router, pinia &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>roter同理<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/router/index</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter <span class="keyword">as</span> _createRrouter, createMemoryHistory, createWebHistory, <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">RouteRecordRaw</span>[] = [</span><br><span class="line">  ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createRrouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">SSR</span> ? <span class="title function_">createMemoryHistory</span>() : <span class="title function_">createWebHistory</span>(),</span><br><span class="line">    routes,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后修改index.html，增加注释占位和客户端入口文件，在之后的服务端渲染时注入<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/vite.svg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vite + Vue + TS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 静态资源占位 .js .css ... --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--preload-links--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 应用代码占位 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="comment">&lt;!--ssr-outlet--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.ts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引用客户端入口文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/entry-client.ts&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      // 服务端获取的数据统一挂载到window上</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">      window.__INITIAL_STATE__ = &#x27;<span class="comment">&lt;!--pinia-state--&gt;</span>&#x27;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-服务端启动文件"><a href="#2-服务端启动文件" class="headerlink" title="2. 服务端启动文件"></a>2. 服务端启动文件</h3><ul>
<li>创建项目后，就开始编写服务端启动文件，也就是项目根路径下的server.js文件</li>
<li>这个文件的功能是启动一个node服务，然后根据请求，读取html文件，处理资源后把注释进行替换，最后把html发送给客户端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> __dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>))</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="title function_">createRequire</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">p</span>) =&gt; path.<span class="title function_">resolve</span>(__dirname, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createServer</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建node服务</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @官方解释</span></span><br><span class="line"><span class="comment">   * 以中间件模式创建vite应用，这将禁用vite自身的HTML服务逻辑</span></span><br><span class="line"><span class="comment">   * 并让上级服务器接管</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> vite = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">&#x27;vite&#x27;</span>).<span class="title function_">createServer</span>(&#123;</span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">      <span class="attr">middlewareMode</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">appType</span>: <span class="string">&#x27;custom&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  app.<span class="title function_">use</span>(vite.<span class="property">middlewares</span>);</span><br><span class="line">  </span><br><span class="line">  app.<span class="title function_">use</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> url = req.<span class="property">originalUrl</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 读取index.html</span></span><br><span class="line">      <span class="keyword">let</span> template = fs.<span class="title function_">readFileSync</span>(</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;index.html&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 应用vite html转换，会注入vite HMR</span></span><br><span class="line">      template = <span class="keyword">await</span> vite.<span class="title function_">transformIndexHtml</span>(url, template)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载服务端入口</span></span><br><span class="line">      <span class="keyword">const</span> render = (<span class="keyword">await</span> vite.<span class="title function_">ssrLoadModule</span>(<span class="string">&#x27;/src/entry-server.js&#x27;</span>)).<span class="property">render</span></span><br><span class="line">      <span class="keyword">const</span> [ appHtml, piniaState ] = <span class="keyword">await</span> <span class="title function_">render</span>(url)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 替换处理过后的模版</span></span><br><span class="line">      <span class="keyword">const</span> html = template</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="string">`&lt;!--ssr-outlet--&gt;`</span>, appHtml)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="string">`&lt;!--pinia-state--&gt;`</span>, piniaState)</span><br><span class="line">      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">set</span>(&#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;).<span class="title function_">end</span>(html)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      vite?.<span class="title function_">ssrFixStacktrace</span>(error)</span><br><span class="line">      <span class="title function_">next</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听5100端口</span></span><br><span class="line">  app.<span class="title function_">listen</span>(<span class="number">5100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createServer</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-服务端入口文件"><a href="#3-服务端入口文件" class="headerlink" title="3. 服务端入口文件"></a>3. 服务端入口文件</h3><ul>
<li>服务端入口文件主要是调用SSR的renderToString和收集需要发送的资源和数据<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&#x27;vue/server-renderer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./main&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">url, manifest</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; app, router, pinia &#125; = <span class="title function_">createApp</span>()</span><br><span class="line"></span><br><span class="line">  router.<span class="title function_">push</span>(url)</span><br><span class="line">  <span class="keyword">await</span> router.<span class="title function_">isReady</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="keyword">await</span> <span class="title function_">renderToString</span>(app, ctx)</span><br><span class="line">  <span class="keyword">return</span> [html, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(pinia.<span class="property">state</span>.<span class="property">value</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-客户端入口文件"><a href="#4-客户端入口文件" class="headerlink" title="4. 客户端入口文件"></a>4. 客户端入口文件</h3><ul>
<li>客户端入口文件主要用于挂载节点和初始化数据<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./main&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, router, pinia &#125; = <span class="title function_">createApp</span>()</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">isReady</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">__INITIAL_STATE__</span>) &#123;</span><br><span class="line">    pinia.<span class="property">state</span>.<span class="property">value</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">window</span>.<span class="property">__INITIAL_STATE__</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-组件和页面"><a href="#5-组件和页面" class="headerlink" title="5. 组件和页面"></a>5. 组件和页面</h3><ul>
<li>组件和页面获取数据主要有两种方式，一种是增加一个<code>asyncData</code>选项，然后在enter-server.js的逻辑中增加遍历当前组件的逻辑，统一触发<code>asyncData</code>，但是现在都是用<code>script setup</code>的方式写业务代码，所以有点麻烦，<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> defualt &#123;</span><br><span class="line">    <span class="title function_">asyncData</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 服务端获取数据逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&#x27;ts&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  ...</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>另一种就是hook的方式，通过<code>import.meta.env.SSR</code>的方式进行判断</li>
<li>对于数据具体存储方式，大概有三种，一种是存在vuex或者pinia这种全局状态库中，一种是存在context上下文中，还有一种是自定义数据</li>
</ul>
<h3 id="6-生产环境"><a href="#6-生产环境" class="headerlink" title="6. 生产环境"></a>6. 生产环境</h3><h4 id="6-1-pacnakge-json"><a href="#6-1-pacnakge-json" class="headerlink" title="6.1 pacnakge.json"></a>6.1 pacnakge.json</h4><ul>
<li>增加构建脚本<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;node server&quot;,</span><br><span class="line"><span class="addition">+ &quot;build&quot;: &quot;npm run build:client &amp;&amp; npm run build:server&quot;,</span></span><br><span class="line"><span class="addition">+  &quot;build:client&quot;: &quot;vite build --ssrManifest --outDir dist/client&quot;,</span></span><br><span class="line"><span class="addition">+  &quot;build:server&quot;: &quot;vite build --ssr src/entry-server.js --outDir dist/server&quot;,</span></span><br><span class="line"><span class="addition">+  &quot;serve&quot;: &quot;cross-env NODE_ENV=production node server&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2-服务端运行文件"><a href="#6-2-服务端运行文件" class="headerlink" title="6.2 服务端运行文件"></a>6.2 服务端运行文件</h4><ul>
<li>针对生产环境，需要启动静态资源服务，引用路径需要改为dist目录下</li>
</ul>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">import fs from &#x27;fs&#x27;</span><br><span class="line">import path from &#x27;path&#x27;</span><br><span class="line">import &#123; fileURLToPath &#125; from &#x27;url&#x27;</span><br><span class="line">import express from &#x27;express&#x27;</span><br><span class="line"></span><br><span class="line">import &#123; createRequire &#125; from &#x27;module&#x27;;</span><br><span class="line">const __dirname = path.dirname(fileURLToPath(import.meta.url))</span><br><span class="line">const require = createRequire(import.meta.url);</span><br><span class="line">const resolve = (p) =&gt; path.resolve(__dirname, p);</span><br><span class="line"></span><br><span class="line">const createServer = async (isProd = process.env.NODE_ENV <span class="comment">=== &#x27;production&#x27;) =&gt; &#123;</span></span><br><span class="line">  const app = express()</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  const vite = await require(&#x27;vite&#x27;).createServer(&#123;</span></span><br><span class="line"><span class="deletion">-    server: &#123;</span></span><br><span class="line"><span class="deletion">-      middlewareMode: true,</span></span><br><span class="line"><span class="deletion">-    &#125;,</span></span><br><span class="line"><span class="deletion">-    appType: &#x27;custom&#x27;</span></span><br><span class="line"><span class="deletion">-  &#125;);</span></span><br><span class="line"><span class="deletion">-  app.use(vite.middlewares);</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+  let vite;</span></span><br><span class="line"><span class="addition">+  if (isProd) &#123;</span></span><br><span class="line"><span class="addition">+    app.use(require(&#x27;compression&#x27;)());</span></span><br><span class="line"><span class="addition">+    app.use(</span></span><br><span class="line"><span class="addition">+      require(&#x27;serve-static&#x27;)(resolve(&#x27;./dist/client&#x27;), &#123;</span></span><br><span class="line"><span class="addition">+        index: false</span></span><br><span class="line"><span class="addition">+      &#125;)</span></span><br><span class="line"><span class="addition">+    );</span></span><br><span class="line"><span class="addition">+  &#125; else &#123;</span></span><br><span class="line"><span class="addition">+    vite = await require(&#x27;vite&#x27;).createServer(&#123;</span></span><br><span class="line"><span class="addition">+      server: &#123;</span></span><br><span class="line"><span class="addition">+        middlewareMode: true,</span></span><br><span class="line"><span class="addition">+      &#125;,</span></span><br><span class="line"><span class="addition">+      appType: &#x27;custom&#x27;</span></span><br><span class="line"><span class="addition">+    &#125;);</span></span><br><span class="line"><span class="addition">+    app.use(vite.middlewares);</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">   // 通过bulid --ssrManifest命令生成的静态资源映射需要在生产环境下引用</span><br><span class="line"><span class="addition">+  const manifest = isProd ? fs.readFileSync(resolve(&#x27;./dist/client/ssr-manifest.json&#x27;), &#x27;utf-8&#x27;) :&#123;&#125;</span></span><br><span class="line">  </span><br><span class="line">  app.use(&#x27;*&#x27;, async (req, res, next) =&gt; &#123;</span><br><span class="line">    const url = req.originalUrl</span><br><span class="line">    try &#123;</span><br><span class="line"><span class="deletion">-      let template = fs.readFileSync(</span></span><br><span class="line"><span class="deletion">-        resolve(&#x27;index.html&#x27;),</span></span><br><span class="line"><span class="deletion">-        &#x27;utf-8&#x27;</span></span><br><span class="line"><span class="deletion">-      )</span></span><br><span class="line"><span class="deletion">-      template = await vite.transformIndexHtml(url, template)</span></span><br><span class="line"><span class="deletion">-      const render = (await vite.ssrLoadModule(&#x27;/src/entry-server.js&#x27;)).render</span></span><br><span class="line"><span class="deletion">-      const [ appHtml, piniaState ] = await render(url)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+      let template, render</span></span><br><span class="line"><span class="addition">+      if (isProd) &#123;</span></span><br><span class="line"><span class="addition">+        template = fs.readFileSync(resolve(&#x27;./dist/client/index.html&#x27;), &#x27;utf-8&#x27;)</span></span><br><span class="line"><span class="addition">+        render = (await import(&#x27;./dist/server/entry-server.js&#x27;)).render</span></span><br><span class="line"><span class="addition">+      &#125; else &#123;</span></span><br><span class="line"><span class="addition">+        template = fs.readFileSync(</span></span><br><span class="line"><span class="addition">+          resolve(&#x27;index.html&#x27;),</span></span><br><span class="line"><span class="addition">+          &#x27;utf-8&#x27;</span></span><br><span class="line"><span class="addition">+        )</span></span><br><span class="line"><span class="addition">+        template = await vite.transformIndexHtml(url, template)</span></span><br><span class="line"><span class="addition">+        render = (await vite.ssrLoadModule(&#x27;/src/entry-server.js&#x27;)).render</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+      const [ appHtml, preloadLinks, piniaState ] = await render(url, manifest)</span></span><br><span class="line">      const html = template</span><br><span class="line">        .replace(`&lt;!--preload-links--&gt;`, preloadLinks)</span><br><span class="line">        .replace(`&lt;!--ssr-outlet--&gt;`, appHtml)</span><br><span class="line"><span class="addition">+        .replace(`&lt;!--pinia-state--&gt;`, piniaState)</span></span><br><span class="line">      res.status(200).set(&#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;).end(html)</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      vite?.ssrFixStacktrace(error)</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  app.listen(5100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createServer();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-3-服务端入口文件"><a href="#6-3-服务端入口文件" class="headerlink" title="6.3 服务端入口文件"></a>6.3 服务端入口文件</h4><ul>
<li>服务端入口文件主要是增加了构建时生成的静态资源映射处理的逻辑<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">import &#123; basename &#125; from &#x27;path&#x27;</span><br><span class="line">import &#123; renderToString &#125; from &#x27;vue/server-renderer&#x27;</span><br><span class="line">import &#123; createApp &#125; from &#x27;./main&#x27;</span><br><span class="line"></span><br><span class="line">export async function render(url, manifest) &#123;</span><br><span class="line">  const &#123; app, router, pinia &#125; = createApp()</span><br><span class="line"></span><br><span class="line">  router.push(url)</span><br><span class="line">  await router.isReady()</span><br><span class="line"></span><br><span class="line">  const ctx = &#123;&#125;</span><br><span class="line">  const html = await renderToString(app, ctx)</span><br><span class="line"><span class="addition">+  const preloadLinks = renderPreloadLinks(ctx.modules, manifest)</span></span><br><span class="line"><span class="addition">+  return [html, preloadLinks, JSON.stringify(pinia.state.value)]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> function renderPreloadLinks(modules, manifest) &#123;</span><br><span class="line">   let links = &#x27;&#x27;</span><br><span class="line">   const seen = new Set()</span><br><span class="line">   modules.forEach((id) =&gt; &#123;</span><br><span class="line">     const files = manifest[id]</span><br><span class="line">     if (files) &#123;</span><br><span class="line">       files.forEach((file) =&gt; &#123;</span><br><span class="line">         if (!seen.has(file)) &#123;</span><br><span class="line">           seen.add(file)</span><br><span class="line">           const filename = basename(file)</span><br><span class="line">           if (manifest[filename]) &#123;</span><br><span class="line">             for (const depFile of manifest[filename]) &#123;</span><br><span class="line">               links += renderPreloadLink(depFile)</span><br><span class="line">               seen.add(depFile)</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           links += renderPreloadLink(file)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   return links</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function renderPreloadLink(file) &#123;</span><br><span class="line">   if (file.endsWith(&#x27;.js&#x27;)) &#123;</span><br><span class="line">     return `&lt;link rel=&quot;modulepreload&quot; crossorigin href=&quot;$&#123;file&#125;&quot;&gt;`</span><br><span class="line">   &#125; else if (file.endsWith(&#x27;.css&#x27;)) &#123;</span><br><span class="line">     return `&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;file&#125;&quot;&gt;`</span><br><span class="line">   &#125; else if (file.endsWith(&#x27;.woff&#x27;)) &#123;</span><br><span class="line">     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;font&quot; type=&quot;font/woff&quot; crossorigin&gt;`</span><br><span class="line">   &#125; else if (file.endsWith(&#x27;.woff2&#x27;)) &#123;</span><br><span class="line">     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;`</span><br><span class="line">   &#125; else if (file.endsWith(&#x27;.gif&#x27;)) &#123;</span><br><span class="line">     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/gif&quot;&gt;`</span><br><span class="line">   &#125; else if (file.endsWith(&#x27;.jpg&#x27;) || file.endsWith(&#x27;.jpeg&#x27;)) &#123;</span><br><span class="line">     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/jpeg&quot;&gt;`</span><br><span class="line">   &#125; else if (file.endsWith(&#x27;.png&#x27;)) &#123;</span><br><span class="line">     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/png&quot;&gt;`</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     return &#x27;&#x27;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><a href="https://github.com/LHRUN/vue-ssr">repo</a></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://vuejs.org/guide/scaling-up/ssr.html">Server-Side Rendering</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vite</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3模版编译原理</title>
    <url>/2022/08/31/Vue3%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="模版编译流程"><a href="#模版编译流程" class="headerlink" title="模版编译流程"></a>模版编译流程</h2><p>Vue3模版编译就是把template字符串编译成渲染函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// template</span></span><br><span class="line">&lt;div&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;LH_R&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render</span></span><br><span class="line"><span class="keyword">import</span> &#123; toDisplayString <span class="keyword">as</span> _toDisplayString, createElementVNode <span class="keyword">as</span> _createElementVNode, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createElementVNode</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">LH_R</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我会按照编译流程分3步分析</p>
<ol>
<li><strong>parse</strong>：将模版字符串转换成模版AST</li>
<li><strong>transform</strong>：将模版AST转换为用于描述渲染函数的AST</li>
<li><strong>generate</strong>：根据AST生成渲染函数<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">baseCompile</span>(<span class="params"></span></span><br><span class="line"><span class="params">  template: <span class="built_in">string</span> | RootNode,</span></span><br><span class="line"><span class="params">  options: CompilerOptions = &#123;&#125;</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">CodegenResult</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> ast = <span class="title function_">isString</span>(template) ? <span class="title function_">baseParse</span>(template, options) : template</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [nodeTransforms, directiveTransforms] = <span class="title function_">getBaseTransformPreset</span>(</span><br><span class="line">    prefixIdentifiers</span><br><span class="line">  )</span><br><span class="line">  <span class="title function_">transform</span>(</span><br><span class="line">    ast,</span><br><span class="line">    <span class="title function_">extend</span>(&#123;&#125;, options, &#123;</span><br><span class="line">      prefixIdentifiers,</span><br><span class="line">      <span class="attr">nodeTransforms</span>: [</span><br><span class="line">        ...nodeTransforms,</span><br><span class="line">        ...(options.<span class="property">nodeTransforms</span> || []) <span class="comment">// user transforms</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">directiveTransforms</span>: <span class="title function_">extend</span>(</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">        directiveTransforms,</span><br><span class="line">        options.<span class="property">directiveTransforms</span> || &#123;&#125; <span class="comment">// user transforms</span></span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">generate</span>(</span><br><span class="line">    ast,</span><br><span class="line">    <span class="title function_">extend</span>(&#123;&#125;, options, &#123;</span><br><span class="line">      prefixIdentifiers</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><ul>
<li><p>parse对模版字符串进行遍历，然后循环判断开始标签和结束标签把字符串分割成一个个<strong>token</strong>，存在一个token列表，然后扫描token列表并维护一个开始标签栈，每当扫描一个开始标签节点，就将其压入栈顶，栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有Token扫描完成后，即可构建成一颗树形AST</p>
</li>
<li><p>以下是简化版<strong>parseChildren</strong>源码，是parse的主入口</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseChildren</span>(<span class="params"></span></span><br><span class="line"><span class="params">  context: ParserContext,</span></span><br><span class="line"><span class="params">  mode: TextModes,</span></span><br><span class="line"><span class="params">  ancestors: ElementNode[] <span class="comment">// 节点栈结构，用于维护节点嵌套关系</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">TemplateChildNode</span>[] &#123;</span><br><span class="line">  <span class="comment">// 获取父节点</span></span><br><span class="line">  <span class="keyword">const</span> parent = <span class="title function_">last</span>(ancestors)</span><br><span class="line">  <span class="keyword">const</span> ns = parent ? parent.<span class="property">ns</span> : <span class="title class_">Namespaces</span>.<span class="property">HTML</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">nodes</span>: <span class="title class_">TemplateChildNode</span>[] = [] <span class="comment">// 存储解析出来的AST子节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遇到闭合标签结束解析</span></span><br><span class="line">  <span class="keyword">while</span> (!<span class="title function_">isEnd</span>(context, mode, ancestors)) &#123;</span><br><span class="line">    <span class="comment">// 切割处理的模版字符串</span></span><br><span class="line">    <span class="keyword">const</span> s = context.<span class="property">source</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">node</span>: <span class="title class_">TemplateChildNode</span> | <span class="title class_">TemplateChildNode</span>[] | <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode === <span class="title class_">TextModes</span>.<span class="property">DATA</span> || mode === <span class="title class_">TextModes</span>.<span class="property">RCDATA</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!context.<span class="property">inVPre</span> &amp;&amp; <span class="title function_">startsWith</span>(s, context.<span class="property">options</span>.<span class="property">delimiters</span>[<span class="number">0</span>])) &#123;</span><br><span class="line">        <span class="comment">// 解析插值表达式&#123;&#123;&#125;&#125;</span></span><br><span class="line">        node = parseInterpolation(context, mode)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode === <span class="title class_">TextModes</span>.<span class="property">DATA</span> &amp;&amp; s[<span class="number">0</span>] === <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// 解析注释节点和文档声明...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (s[<span class="number">2</span>] === <span class="string">&#x27;&gt;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 针对自闭合标签，前进三个字符</span></span><br><span class="line">            <span class="title function_">advanceBy</span>(context, <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(s[<span class="number">2</span>])) &#123;</span><br><span class="line">            <span class="comment">// 解析结束标签</span></span><br><span class="line">            <span class="title function_">parseTag</span>(context, <span class="title class_">TagType</span>.<span class="property">End</span>, parent)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不符合上述情况，就作为伪注释解析</span></span><br><span class="line">            node = <span class="title function_">parseBogusComment</span>(context)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(s[<span class="number">1</span>])) &#123;</span><br><span class="line">          <span class="comment">// 解析html开始标签，获得解析到的AST节点</span></span><br><span class="line">          node = <span class="title function_">parseElement</span>(context, ancestors)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="comment">// 普通文本节点</span></span><br><span class="line">      node = <span class="title function_">parseText</span>(context, mode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果节点是数组，就遍历添加到nodes中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isArray</span>(node)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">pushNode</span>(nodes, node[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">pushNode</span>(nodes, node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>就拿<code>&lt;div&gt;&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;</code>流程举例</p>
</li>
</ul>
<ol>
<li>div开始标签入栈，context.source &#x3D; <code>&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;</code>，ancestors &#x3D; <code>[div]</code></li>
<li>p开始标签入栈，context.source &#x3D; <code>LH_R&lt;/p&gt;&lt;/div&gt;</code>，ancestors &#x3D; <code>[div, p]</code></li>
<li>解析文本<code>LH_R</code></li>
<li>解析p结束标签，p标签出栈</li>
<li>解析div结束标签，div标签出栈</li>
<li>栈空，模版解析完毕</li>
</ol>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul>
<li>transform采用深度优先的方式对AST进行遍历，在遍历过程中，对节点的操作与转换采用插件化架构，都封装为独立的函数，然后转换函数通过<code>context.nodeTransforms</code>来注册</li>
<li>转换过程是优先转换子节点，因为有的父节点的转换依赖子节点</li>
<li>以下是AST遍历<code>traverseNode</code>核心源码<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  遍历AST节点树，通过node转换器对当前节点进行node转换</span></span><br><span class="line"><span class="comment">  子节点全部遍历完成后执行对应指令的onExit回调退出转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">traverseNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  node: RootNode | TemplateChildNode,</span></span><br><span class="line"><span class="params">  context: TransformContext</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 记录当前正在遍历的节点</span></span><br><span class="line">  context.<span class="property">currentNode</span> = node</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    nodeTransforms：transformElement、transformExpression、transformText...</span></span><br><span class="line"><span class="comment">    transformElement：负责整个节点层面的转换</span></span><br><span class="line"><span class="comment">    transformExpression：负责节点中表达式的转化</span></span><br><span class="line"><span class="comment">    transformText：负责节点中文本的转换</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> &#123; nodeTransforms &#125; = context</span><br><span class="line">  <span class="keyword">const</span> exitFns = []</span><br><span class="line">  <span class="comment">// 依次调用转换工具</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodeTransforms.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      转换器只负责生成onExit回调，onExit函数才是执行转换主逻辑的地方，为什么要推到栈中先不执行呢？</span></span><br><span class="line"><span class="comment">      因为要等到子节点都转换完成挂载gencodeNode后，也就是深度遍历完成后</span></span><br><span class="line"><span class="comment">      再执行当前节点栈中的onExit，这样保证了子节点的表达式全部生成完毕</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">const</span> onExit = nodeTransforms[i](node, context)</span><br><span class="line">    <span class="keyword">if</span> (onExit) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isArray</span>(onExit)) &#123;</span><br><span class="line">        <span class="comment">// v-if、v-for为结构化指令，其onExit是数组形式</span></span><br><span class="line">        exitFns.<span class="title function_">push</span>(...onExit)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exitFns.<span class="title function_">push</span>(onExit)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!context.<span class="property">currentNode</span>) &#123;</span><br><span class="line">      <span class="comment">// node was removed 节点被移除</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// node may have been replaced</span></span><br><span class="line">      <span class="comment">// 因为在转换的过程中节点可能被替换，恢复到之前的节点</span></span><br><span class="line">      node = context.<span class="property">currentNode</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">COMMENT</span>:</span><br><span class="line">      <span class="keyword">if</span> (!context.<span class="property">ssr</span>) &#123;</span><br><span class="line">        <span class="comment">// inject import for the Comment symbol, which is needed for creating</span></span><br><span class="line">        <span class="comment">// comment nodes with `createVNode`</span></span><br><span class="line">        <span class="comment">// 需要导入createComment辅助函数</span></span><br><span class="line">        context.<span class="title function_">helper</span>(<span class="variable constant_">CREATE_COMMENT</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">INTERPOLATION</span>:</span><br><span class="line">      <span class="comment">// no need to traverse, but we need to inject toString helper</span></span><br><span class="line">      <span class="keyword">if</span> (!context.<span class="property">ssr</span>) &#123;</span><br><span class="line">        context.<span class="title function_">helper</span>(<span class="variable constant_">TO_DISPLAY_STRING</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for container types, further traverse downwards</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">IF</span>:</span><br><span class="line">      <span class="comment">// 对v-if生成的节点束进行遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">branches</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">traverseNode</span>(node.<span class="property">branches</span>[i], context)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">IF_BRANCH</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">FOR</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">ELEMENT</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">ROOT</span>:</span><br><span class="line">      <span class="comment">// 遍历子节点</span></span><br><span class="line">      <span class="title function_">traverseChildren</span>(node, context)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前节点树遍历完成，依次执行栈中的指令退出回调onExit</span></span><br><span class="line">  context.<span class="property">currentNode</span> = node</span><br><span class="line">  <span class="keyword">let</span> i = exitFns.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    exitFns[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>generate</code>生成代码大致分为3步</p>
<ol>
<li>创建代码生成上下文，因为该上下文对象是用于维护代码生成过程中程序的运行状态，如：</li>
</ol>
<ul>
<li><code>code</code>：最终生成的渲染函数</li>
<li><code>push</code>：拼接代码</li>
<li><code>indent</code>：代码缩进</li>
<li><code>deindent</code>：减少代码缩进</li>
<li>…</li>
</ul>
<ol start="2">
<li>生成渲染函数的前置预设部分<ul>
<li>module模式下：<code>genModulePreamble()</code></li>
<li>function模式下：<code>genFunctionPreamble</code></li>
<li>还有一些函数名，参数，作用域…</li>
</ul>
</li>
<li>生成渲染函数<ul>
<li>通过调用<code>genNode</code>，然后在<code>genNode</code>内部通过switch语句来匹配不同类型的节点，并调用对应的生成器函数</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000023594560">Vue3 模板编译原理</a></li>
<li>《Vue.js设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>pnpm的node_modules结构设计</title>
    <url>/2022/08/24/pnpm%E7%9A%84node-modules%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="pnpm的node-modules结构设计"><a href="#pnpm的node-modules结构设计" class="headerlink" title="pnpm的node_modules结构设计"></a>pnpm的node_modules结构设计</h2><p>分析pnpm之前，先说一下npm现在的一些问题</p>
<h3 id="npm的问题"><a href="#npm的问题" class="headerlink" title="npm的问题"></a>npm的问题</h3><ul>
<li><p>平时我们使用<code>npm install</code>命令后，node_modules就会呈现以下类似内容<br><img src="https://img-blog.csdnimg.cn/7396b28d86f84a21b15b4ef6026ddd45.png#pic_center" alt="npm_node_modules"></p>
</li>
<li><p>之所以出现这种扁平的结构，最初时初衷是好的，为了更好的利用资源，把每个依赖全部放到顶层，这样就不会造成每个依赖嵌套过深，导致很多重复依赖文件</p>
</li>
<li><p>但是随着这种文件结构逐步使用后，就会暴露出来两个问题</p>
<ul>
<li><strong>幽灵依赖</strong></li>
<li><strong>版本冲突</strong></li>
</ul>
</li>
<li><p>幽灵依赖就是你在引用npm包时，你会发现一些没有在<code>package.json</code>中出现的包也能引用，这个就是幽灵依赖，这是因为你在install下载npm包时，npm包也有它的依赖会下载，但是下载的依赖也会存在node_modules同一层级下，这样就会导致可以直接引用</p>
</li>
<li><p>版本冲突是因为不同的依赖可能依赖的包版本也不同，但是node_modules的同一层级只能存在一个包的一个版本号，如果有不同的版本号就只能存在依赖包的node_modules中，这样就会导致出现重复资源</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">├── package-A @<span class="number">1.0</span></span><br><span class="line">|── package-B @<span class="number">1.0</span></span><br><span class="line">├── package-C @<span class="number">1.0</span></span><br><span class="line">│   └── package-A @<span class="number">2.0</span></span><br><span class="line">│   └── package-B @<span class="number">2.0</span></span><br><span class="line">├── package-D @<span class="number">1.0</span></span><br><span class="line">│   └── package-A @<span class="number">2.0</span></span><br><span class="line">│   └── package-B @<span class="number">2.0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pnpm的出现"><a href="#pnpm的出现" class="headerlink" title="pnpm的出现"></a>pnpm的出现</h3><ul>
<li><p>在所有前端苦npm久已时，pnpm出现了，并且在pnpm官网的简介上就简单说明了它的构造：<code>store + link</code><br><img src="https://img-blog.csdnimg.cn/20ef6cd68a0440c9841ea1450297c17a.jpeg#pic_center" alt="pnpm_node_modules"></p>
<ul>
<li>store就是依赖的实际存储位置，Mac&#x2F;linux在<code>&#123;home dir&#125;&gt;/.pnpm-store/v3</code>，windows在<code>当前盘/.pnpm-store/v3</code>。这样就会有个好处，你在多个项目使用的是同一个依赖时，就不用重复下载，这样就极大的减少存储空间</li>
<li>link是指符号链接(<code>SymbolicLink</code>)和硬链接(<code>HardLink</code>)<ul>
<li>SymbolicLink是一种特殊的文件，包含一条以绝对路径或者相对路径的形式指向其他文件或者目录的引用，它的存在不依赖于目标文件，如果目标文件被删除或者移动，指向目标文件的符号链接依然存在，但是它们会指向一个不复存在的文件</li>
<li>相比于SymbolicLink，HardLink不是引用文件，而是引用<strong>inode</strong>，inode是文件系统的一种数据结构，用于描述文件系统对象。所以你即使更改目标文件的内容或位置，HardLink仍然指向目标文件，因为inode指向该文件</li>
</ul>
</li>
</ul>
</li>
<li><p>然后拿react举例，当<code>pnpm add react</code>后，在node_modules终端输入<code>tree -a -L 3</code>会得到以下node_modules结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .<span class="property">modules</span>.<span class="property">yaml</span></span><br><span class="line">├── .<span class="property">pnpm</span></span><br><span class="line">│   ├── js-tokens@<span class="number">4.0</span><span class="number">.0</span></span><br><span class="line">│   │   └── node_modules</span><br><span class="line">│   ├── lock.<span class="property">yaml</span></span><br><span class="line">│   ├── loose-envify@<span class="number">1.4</span><span class="number">.0</span></span><br><span class="line">│   │   └── node_modules</span><br><span class="line">│   ├── node_modules</span><br><span class="line">│   │   ├── .<span class="property">bin</span></span><br><span class="line">│   │   ├── js-tokens -&gt; ../js-tokens@<span class="number">4.0</span><span class="number">.0</span>/node_modules/js-tokens</span><br><span class="line">│   │   └── loose-envify -&gt; ../loose-envify@<span class="number">1.4</span><span class="number">.0</span>/node_modules/loose-envify</span><br><span class="line">│   └── react@<span class="number">18.2</span><span class="number">.0</span></span><br><span class="line">│       └── node_modules</span><br><span class="line">└── react -&gt; .<span class="property">pnpm</span>/react@<span class="number">18.2</span><span class="number">.0</span>/node_modules/react</span><br></pre></td></tr></table></figure></li>
<li><p>node_modules下除了.pnpm外只有一个react，这个react只是一个SymbolicLink，当node.js解析时，会找到react的真实位置<code>node_modules/.pnpm/react@18.2.0/node_modules/react</code></p>
</li>
<li><p>.pnpm就是将所有依赖放在同一层文件夹中，每个包都可以通过<code>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</code>这种路径找到，然后通过<code>hand link</code>的方式在store中引用依赖文件</p>
</li>
<li><p>通过这种文件结构，pnpm就解决了npm的两个问题，首先node_modules下不会有你未在package.json中声明的依赖，这样就不会有幽灵依赖的问题。然后.pnpm下会有name+version的方式链接到store中，这样就不会出现因为版本冲突造成资源重复的问题</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.pnpm.cn/blog/2020/05/27/flat-node-modules-is-not-the-only-way">Flat node_modules is not the only way</a></li>
<li><a href="https://www.pnpm.cn/symlinked-node-modules-structure">Symlinked node_modules structure</a></li>
<li><a href="https://juejin.cn/post/7043998041786810398">One For All：基于pnpm + lerna + typescript的最佳项目实践 - 理论篇</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>基于canvas实现的多功能画板</title>
    <url>/2022/09/21/%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%94%BB%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近空闲时间比较多，就想做点小工具玩玩，方案选了好几个，最终决定做一个基于canvas的画板，目前已经完成了第一版，有以下主要功能</p>
<ol>
<li>画笔（动态宽度设置，颜色设置）</li>
<li>橡皮擦</li>
<li>撤回，反撤回，清除画板，保存</li>
<li>画板拖拽</li>
<li>多图层</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>目前实现效果如下<br><img src="https://img-blog.csdnimg.cn/img_convert/6ee0b9163552f4c61abfde6af199b3ed.png"><br>预览地址：<a href="https://lhrun.github.io/paint-board/">https://lhrun.github.io/paint-board/</a><br>repo：<a href="https://github.com/LHRUN/paint-board">https://github.com/LHRUN/paint-board</a></p>
<h2 id="画板设计"><a href="#画板设计" class="headerlink" title="画板设计"></a>画板设计</h2><ol>
<li>首先是建立一个canvas画板类，所有canvas上的操作和数据全都在此处理，例如初始化，渲染，拖拽画板等等<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;</span><br><span class="line">  <span class="attr">canvas</span>: <span class="title class_">HTMLCanvasElement</span></span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">CanvasRenderingContext2D</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">canvas: HTMLCanvasElement</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 初始化canvas</span></span><br><span class="line">  <span class="title function_">initCanvas</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 拖拽</span></span><br><span class="line">  <span class="title function_">drag</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后基于canvas类，根据当前的操作，建立对应的canvas元素，比如画笔，橡皮擦，基本类型如下<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CanvasElement</span> &#123;</span><br><span class="line">  <span class="attr">type</span>: string <span class="comment">// 元素类型</span></span><br><span class="line">  <span class="attr">layer</span>: number <span class="comment">// 图层</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">type: string, layer: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = type</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">layer</span> = layer</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后根据渲染逻辑，还会封装一些通用的逻辑来改变canvas上最终的展示，比如撤回，反撤回，图层操作等等</li>
</ol>
<h2 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h2><ul>
<li>实现画笔效果首先要在鼠标按下时建立一个画笔元素，然后在构造函数中接受基础宽度，颜色，初始化鼠标移动记录和线宽记录，然后在鼠标移动时记录鼠标移动的坐标</li>
<li>为了体现鼠标移动快，线宽就变窄，移动慢，线宽就恢复正常这个效果，我会计算当前移动的速度，然后根据速度计算线宽<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreeLine</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CanvasElement</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color: string, width: number, layer: number</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">positions</span> = [] <span class="comment">// 鼠标移动位置记录</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lineWidths</span> = [<span class="number">0</span>] <span class="comment">// 线宽记录</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color <span class="comment">// 当前绘线颜色</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxWidth</span> = width <span class="comment">// 最大线宽</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">minWidth</span> = width / <span class="number">2</span> <span class="comment">// 最小线宽</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> = width <span class="comment">// 最后绘线宽度</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>记录鼠标位置和当前线宽<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">MousePosition</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: number</span><br><span class="line">  <span class="attr">y</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addPosition</span>(<span class="params">position: MousePosition</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">positions</span>.<span class="title function_">push</span>(position)</span><br><span class="line">  <span class="comment">// 处理当前线宽</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> mouseSpeed = <span class="variable language_">this</span>.<span class="title function_">_computedSpeed</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">2</span>],</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> lineWidth = <span class="variable language_">this</span>.<span class="title function_">_computedLineWidth</span>(mouseSpeed)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lineWidths</span>.<span class="title function_">push</span>(lineWidth)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算移动速度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 终点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">_computedSpeed</span>(<span class="params">start: MousePosition, end: MousePosition</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取距离</span></span><br><span class="line">  <span class="keyword">const</span> moveDistance = <span class="title function_">getDistance</span>(start, end)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="comment">// 获取移动间隔时间   lastMoveTime：最后鼠标移动时间</span></span><br><span class="line">  <span class="keyword">const</span> moveTime = curTime - <span class="variable language_">this</span>.<span class="property">lastMoveTime</span></span><br><span class="line">  <span class="comment">// 计算速度</span></span><br><span class="line">  <span class="keyword">const</span> mouseSpeed = moveDistance / moveTime</span><br><span class="line">  <span class="comment">// 更新最后移动时间</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastMoveTime</span> = curTime</span><br><span class="line">  <span class="keyword">return</span> mouseSpeed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算画笔宽度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> speed 鼠标移动速度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">_computedLineWidth</span>(<span class="params">speed: number</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lineWidth = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> minWidth = <span class="variable language_">this</span>.<span class="property">minWidth</span></span><br><span class="line">  <span class="keyword">const</span> maxWidth = <span class="variable language_">this</span>.<span class="property">maxWidth</span></span><br><span class="line">  <span class="keyword">if</span> (speed &gt;= <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) &#123;</span><br><span class="line">    lineWidth = minWidth</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (speed &lt;= <span class="variable language_">this</span>.<span class="property">minSpeed</span>) &#123;</span><br><span class="line">    lineWidth = maxWidth</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lineWidth = maxWidth - (speed / <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) * maxWidth</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lineWidth = lineWidth * (<span class="number">1</span> / <span class="number">3</span>) + <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> * (<span class="number">2</span> / <span class="number">3</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> = lineWidth</span><br><span class="line">  <span class="keyword">return</span> lineWidth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>保存坐标后，渲染就是遍历所有坐标<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">freeLineRender</span>(<span class="params"></span></span><br><span class="line"><span class="params">  context: CanvasRenderingContext2D,</span></span><br><span class="line"><span class="params">  instance: FreeLine</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  context.<span class="title function_">save</span>()</span><br><span class="line">  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span></span><br><span class="line">  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span></span><br><span class="line">  context.<span class="property">strokeStyle</span> = instance.<span class="property">color</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">_drawLine</span>(instance, i, context)</span><br><span class="line">  &#125;</span><br><span class="line">  context.<span class="title function_">restore</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 画笔轨迹是借鉴了网上的一些方案，分两种情况</span></span><br><span class="line"><span class="comment"> * 1. 如果是前两个坐标，就通过lineTo连接即可</span></span><br><span class="line"><span class="comment"> * 2. 如果是前两个坐标之后的坐标，就采用贝塞尔曲线进行连接，</span></span><br><span class="line"><span class="comment"> *    比如现在有a, b, c 三个点，到c点时，把ab坐标的中间点作为起点</span></span><br><span class="line"><span class="comment"> *     bc坐标的中间点作为终点，b点作为控制点进行连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_drawLine</span>(<span class="params"></span></span><br><span class="line"><span class="params">  instance: FreeLine,</span></span><br><span class="line"><span class="params">  i: number,</span></span><br><span class="line"><span class="params">  context: CanvasRenderingContext2D</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; positions, lineWidths &#125; = instance</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">x</span>: centerX, <span class="attr">y</span>: centerY &#125; = positions[i - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">x</span>: endX, <span class="attr">y</span>: endY &#125; = positions[i]</span><br><span class="line">  context.<span class="title function_">beginPath</span>()</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    context.<span class="title function_">moveTo</span>(centerX, centerY)</span><br><span class="line">    context.<span class="title function_">lineTo</span>(endX, endY)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125; = positions[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">const</span> lastX = (startX + centerX) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">const</span> lastY = (startY + centerY) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">const</span> x = (centerX + endX) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">const</span> y = (centerY + endY) / <span class="number">2</span></span><br><span class="line">    context.<span class="title function_">moveTo</span>(lastX, lastY)</span><br><span class="line">    context.<span class="title function_">quadraticCurveTo</span>(centerX, centerY, x, y)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.<span class="property">lineWidth</span> = lineWidths[i]</span><br><span class="line">  context.<span class="title function_">stroke</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="橡皮擦"><a href="#橡皮擦" class="headerlink" title="橡皮擦"></a>橡皮擦</h2><ul>
<li>橡皮擦是一个线状擦除，我采用的方案是通过计算每个点的圆弧轨迹和两个点之间的矩形区域，然后通过clip剪切后清除<br><img src="https://img-blog.csdnimg.cn/img_convert/8ae8229d79cd8b69d175d5fbb68e3c43.png"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 橡皮擦渲染</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cleanCanvas 清除画板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> instance CleanLine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cleanLineRender</span>(<span class="params"></span></span><br><span class="line"><span class="params">  context: CanvasRenderingContext2D,</span></span><br><span class="line"><span class="params">  cleanCanvas: () =&gt; <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  instance: CleanLine</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">_cleanLine</span>(</span><br><span class="line">      instance.<span class="property">positions</span>[i],</span><br><span class="line">      instance.<span class="property">positions</span>[i + <span class="number">1</span>],</span><br><span class="line">      context,</span><br><span class="line">      cleanCanvas,</span><br><span class="line">      instance.<span class="property">cleanWidth</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线状清除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 终点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cleanCanvas 清除画板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cleanWidth 清楚宽度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_cleanLine</span>(<span class="params"></span></span><br><span class="line"><span class="params">  start: MousePosition,</span></span><br><span class="line"><span class="params">  end: MousePosition,</span></span><br><span class="line"><span class="params">  context: CanvasRenderingContext2D,</span></span><br><span class="line"><span class="params">  cleanCanvas: () =&gt; <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  cleanWidth: number</span></span><br><span class="line"><span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">x</span>: x1, <span class="attr">y</span>: y1 &#125; = start</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">x</span>: x2, <span class="attr">y</span>: y2 &#125; = end</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取鼠标起点和终点之间的矩形区域端点</span></span><br><span class="line">  <span class="keyword">const</span> asin = cleanWidth * <span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="title class_">Math</span>.<span class="title function_">atan</span>((y2 - y1) / (x2 - x1)))</span><br><span class="line">  <span class="keyword">const</span> acos = cleanWidth * <span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="title class_">Math</span>.<span class="title function_">atan</span>((y2 - y1) / (x2 - x1)))</span><br><span class="line">  <span class="keyword">const</span> x3 = x1 + asin</span><br><span class="line">  <span class="keyword">const</span> y3 = y1 - acos</span><br><span class="line">  <span class="keyword">const</span> x4 = x1 - asin</span><br><span class="line">  <span class="keyword">const</span> y4 = y1 + acos</span><br><span class="line">  <span class="keyword">const</span> x5 = x2 + asin</span><br><span class="line">  <span class="keyword">const</span> y5 = y2 - acos</span><br><span class="line">  <span class="keyword">const</span> x6 = x2 - asin</span><br><span class="line">  <span class="keyword">const</span> y6 = y2 + acos</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除末端圆弧</span></span><br><span class="line">  context.<span class="title function_">save</span>()</span><br><span class="line">  context.<span class="title function_">beginPath</span>()</span><br><span class="line">  context.<span class="title function_">arc</span>(x2, y2, cleanWidth, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>)</span><br><span class="line">  context.<span class="title function_">clip</span>()</span><br><span class="line">  <span class="title function_">cleanCanvas</span>()</span><br><span class="line">  context.<span class="title function_">restore</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除矩形区域</span></span><br><span class="line">  context.<span class="title function_">save</span>()</span><br><span class="line">  context.<span class="title function_">beginPath</span>()</span><br><span class="line">  context.<span class="title function_">moveTo</span>(x3, y3)</span><br><span class="line">  context.<span class="title function_">lineTo</span>(x5, y5)</span><br><span class="line">  context.<span class="title function_">lineTo</span>(x6, y6)</span><br><span class="line">  context.<span class="title function_">lineTo</span>(x4, y4)</span><br><span class="line">  context.<span class="title function_">closePath</span>()</span><br><span class="line">  context.<span class="title function_">clip</span>()</span><br><span class="line">  <span class="title function_">cleanCanvas</span>()</span><br><span class="line">  context.<span class="title function_">restore</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="撤回、反撤回"><a href="#撤回、反撤回" class="headerlink" title="撤回、反撤回"></a>撤回、反撤回</h2><ul>
<li>实现撤回，反撤回就要把canvas上的每个元素的渲染数据进行存储，通过改变控制变量，限制渲染元素的遍历，这样就可以达到撤回的效果</li>
<li>首先画板初始化时建立一个history类，然后建立缓存和step数据，撤回和反撤回时，只需要修改step即可<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">History</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">cacheQueue</span>: T[]</span><br><span class="line">  <span class="attr">step</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">cacheQueue: T[]</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cacheQueue</span> = cacheQueue</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">step</span> = cacheQueue.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加数据</span></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">data: T</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果在回退时添加数据就删除暂存数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> !== <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> = <span class="variable language_">this</span>.<span class="property">step</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="title function_">push</span>(data)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">step</span> = <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历cacheQueue</span></span><br><span class="line">  <span class="title function_">each</span>(<span class="params">cb?: (ele: T, i: number) =&gt; <span class="keyword">void</span></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="variable language_">this</span>.<span class="property">step</span>; i++) &#123;</span><br><span class="line">      cb?.(<span class="variable language_">this</span>.<span class="property">cacheQueue</span>[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后退</span></span><br><span class="line">  <span class="title function_">undo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">step</span>--</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheQueue</span>[<span class="variable language_">this</span>.<span class="property">step</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前进</span></span><br><span class="line">  <span class="title function_">redo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> &lt; <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">step</span>++</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheQueue</span>[<span class="variable language_">this</span>.<span class="property">step</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>针对画板，通过监听鼠标按下操作，在history中添加一个元素，然后对渲染函数的遍历限制到step就达到了撤回的效果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 记录当前元素，并加入history</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">recordCurrent</span>(<span class="params">type: string</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">ele</span>: <span class="variable constant_">ELEMENT_INSTANCE</span> | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="variable constant_">CANVAS_ELE_TYPE</span>.<span class="property">FREE_LINE</span>:</span><br><span class="line">        ele = <span class="keyword">new</span> <span class="title class_">FreeLine</span>(</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">currentLineColor</span>,</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">currentLineWidth</span>,</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">current</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="variable constant_">CANVAS_ELE_TYPE</span>.<span class="property">CLEAN_LINE</span>:</span><br><span class="line">        ele = <span class="keyword">new</span> <span class="title class_">CleanLine</span>(<span class="variable language_">this</span>.<span class="property">cleanWidth</span>, <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">current</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ele) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">add</span>(ele)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentEle</span> = ele</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 遍历history渲染数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 清除画布</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cleanCanvas</span>()</span><br><span class="line">    <span class="comment">// 遍历history</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">each</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">save</span>()</span><br><span class="line">      <span class="comment">// render....</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">context</span>,<span class="title function_">resore</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 缓存数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cache</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="拖拽画布"><a href="#拖拽画布" class="headerlink" title="拖拽画布"></a>拖拽画布</h2><ul>
<li>拖拽画布的实现是通过计算鼠标移动距离，根据距离改变画布的原点位置，达到拖拽的效果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">position: MousePosition</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> mousePosition = &#123;</span><br><span class="line">    <span class="attr">x</span>: position.<span class="property">x</span> - <span class="variable language_">this</span>.<span class="property">canvasRect</span>.<span class="property">left</span>,</span><br><span class="line">    <span class="attr">y</span>: position.<span class="property">y</span> - <span class="variable language_">this</span>.<span class="property">canvasRect</span>.<span class="property">top</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">x</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">y</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> translteX = mousePosition.<span class="property">x</span> - <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">x</span></span><br><span class="line">    <span class="keyword">const</span> translteY = mousePosition.<span class="property">y</span> - <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">y</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">translate</span>(translteX, translteY)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">originTranslate</span> = &#123;</span><br><span class="line">      <span class="attr">x</span>: translteX + <span class="variable language_">this</span>.<span class="property">originTranslate</span>.<span class="property">x</span>,</span><br><span class="line">      <span class="attr">y</span>: translteY + <span class="variable language_">this</span>.<span class="property">originTranslate</span>.<span class="property">y</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">render</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">originPosition</span> = mousePosition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多图层"><a href="#多图层" class="headerlink" title="多图层"></a>多图层</h2><p>实现多图层需要对以下几个地方进行处理</p>
<ol>
<li>画板初始化时建立图层类，所有的图层数据和图层逻辑全在此处</li>
<li>然后对canvas上的元素加layer属性，用于判断归属于哪个图层</li>
<li>画板的渲染函数改为按照图层顺序进行渲染</li>
<li>拖拽或者隐藏图层都需要重新渲染，删除图层把对应的缓存图层元素进行删除</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">ILayer</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: number <span class="comment">// 图层id</span></span><br><span class="line">  <span class="attr">title</span>: string <span class="comment">// 图层名称</span></span><br><span class="line">  <span class="attr">show</span>: boolean <span class="comment">// 图层展示状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span> &#123;</span><br><span class="line">  <span class="attr">stack</span>: <span class="title class_">ILayer</span>[] <span class="comment">// 图层数据</span></span><br><span class="line">  <span class="attr">current</span>: number <span class="comment">// 当前图层</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span> <span class="comment">// 画板渲染事件</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">render: () =&gt; <span class="keyword">void</span>, initData?: Layer</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      stack = [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;item1&#x27;</span>,</span><br><span class="line">          <span class="attr">show</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      id = <span class="number">1</span>,</span><br><span class="line">      current = <span class="number">1</span></span><br><span class="line">    &#125; = initData || &#123;&#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = stack</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = current</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">render</span> = render</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;</span><br><span class="line">  <span class="comment">// 通过图层进行排序</span></span><br><span class="line">   <span class="title function_">sortOnLayer</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> id === b?.<span class="property">layer</span>) -</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> id === a?.<span class="property">layer</span>)</span><br><span class="line">       )</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 渲染函数只渲染图层展示状态的元素</span></span><br><span class="line">   <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> showLayerIds = <span class="keyword">new</span> <span class="title class_">Set</span>(</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="property">reduce</span>&lt;number[]&gt;(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> cur.<span class="property">show</span> ? [...acc, cur.<span class="property">id</span>] : acc</span><br><span class="line">       &#125;, [])</span><br><span class="line">     )</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">each</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (ele?.<span class="property">layer</span> &amp;&amp; showLayerIds.<span class="title function_">has</span>(ele.<span class="property">layer</span>)) &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>我本篇主要是分享一些主要逻辑，还有一些兼容问题和一些UI交互就不叙述了</li>
<li>这个画板写下来大概用了一个星期，有好多功能还没写上，如果过段时间有空的话就继续写下去，并进一步优化，现在还是有点优化问题没有写好，比如画笔宽度显示的还是有点问题，原点位置和一些初始化设计的不太好，不过写完这个画板还是挺有成就感的</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/axes/p/3850309.html">HTML5 实现橡皮擦的擦除效果</a></li>
<li><a href="https://juejin.cn/post/7091276963146530847">我做了一个在线白板！</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序滚动日历组件</title>
    <url>/2021/04/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%BB%9A%E5%8A%A8%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="小程序滚动日历组件"><a href="#小程序滚动日历组件" class="headerlink" title="小程序滚动日历组件"></a>小程序滚动日历组件</h2><p>前段时间产品提出这个需求，要求做一个日历容器，并要求是滚动，不能是那种每个月切换的容器，所以我就在网上大概查找了一下类似组件，滚动的容器较少，于是我就自己写了这个组件，以下是大概的js思路，wxml和css就不附上了，每个UI都有不同的想法</p>
<ol>
<li><p>在ready中初始化组件数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">ready</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这两个数据是从页面中传过来的，起始时间和结束时间</span></span><br><span class="line">  <span class="comment">// 数组类型 [year, month, day]</span></span><br><span class="line">  <span class="keyword">const</span> &#123; endDate, startDate &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">let</span> monthList = [] <span class="comment">// 这个用于wxml中遍历，以每月为item</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未跨年</span></span><br><span class="line">  <span class="keyword">if</span> ( endDate[<span class="number">0</span>] === startDate[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> rangeMonth = endDate[<span class="number">1</span>] - startDate[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= rangeMonth; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> date = [startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i + <span class="number">1</span>]</span><br><span class="line">      <span class="comment">// monthInitData()初始化每月数据</span></span><br><span class="line">      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i)</span><br><span class="line">      monthList.<span class="title function_">push</span>(&#123;</span><br><span class="line">        date,</span><br><span class="line">        days,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 跨年前月份</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, lng = <span class="number">12</span> - startDate[<span class="number">1</span>]; i &lt; lng; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> date = [startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i + <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i)</span><br><span class="line">      monthList.<span class="title function_">push</span>(&#123;</span><br><span class="line">        date,</span><br><span class="line">        days,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跨年后月份</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= endDate[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> date = [endDate[<span class="number">0</span>], i + <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(endDate[<span class="number">0</span>], i)</span><br><span class="line">      monthList.<span class="title function_">push</span>(&#123;</span><br><span class="line">        date,</span><br><span class="line">        days,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    monthList,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化每月数据: </p>
<blockquote>
<p>逻辑是获取每个月第一天的星期数和每个月的最大天数，然后在之前和之后的空数据填充item占位<br>然后遍历，根据不同的需求，在遍历中处理，最后在html中flex布局即可</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 初始化每月数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; year 年</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; month 月</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">monthInitData</span>(<span class="params">year, month</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; calendarValue, startDate, endDate &#125;= <span class="variable language_">this</span>.<span class="property">data</span>, <span class="comment">// 当前点击时间，起始时间，结束时间</span></span><br><span class="line">    firstWeek = <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, <span class="number">1</span>).<span class="title function_">getDay</span>(), <span class="comment">// 本月的第一天的星期数</span></span><br><span class="line">    days = [], <span class="comment">// 日期数组</span></span><br><span class="line">    max = <span class="variable language_">this</span>.<span class="title function_">getMonthMax</span>(year, month + <span class="number">1</span>), <span class="comment">// 每月最大天数</span></span><br><span class="line">    lastWeek = <span class="keyword">new</span> <span class="title class_">Date</span>(year, (month + <span class="number">1</span>), <span class="number">0</span>).<span class="title function_">getDay</span>() <span class="comment">// 本月的最后一天的星期数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 填充每月一号之前的空数据</span></span><br><span class="line">  <span class="keyword">if</span> (firstWeek &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; firstWeek; i++) &#123;</span><br><span class="line">      days.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">day</span>: <span class="number">0</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentTime = <span class="number">0</span>, </span><br><span class="line">      startTime = <span class="number">0</span>,</span><br><span class="line">      endTime = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (calendarValue[<span class="number">0</span>]) &#123;</span><br><span class="line">    currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>(calendarValue[<span class="number">0</span>], calendarValue[<span class="number">1</span>], calendarValue[<span class="number">2</span>]).<span class="title function_">getTime</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate[<span class="number">0</span>]) &#123;</span><br><span class="line">    startTime = <span class="keyword">new</span> <span class="title class_">Date</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>], startDate[<span class="number">2</span>]).<span class="title function_">getTime</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (endDate[<span class="number">0</span>]) &#123;</span><br><span class="line">    endTime = <span class="keyword">new</span> <span class="title class_">Date</span>(endDate[<span class="number">0</span>], endDate[<span class="number">1</span>], endDate[<span class="number">2</span>]).<span class="title function_">getTime</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">    <span class="comment">// 以下状态是需要在html中判断处理，根据自己需求改变</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="literal">false</span>, <span class="comment">// 当前点击状态</span></span><br><span class="line">      disabled = <span class="literal">false</span>, <span class="comment">// 禁止状态</span></span><br><span class="line">      now = <span class="literal">false</span>, <span class="comment">// 今天显示文案</span></span><br><span class="line">      time = <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, i).<span class="title function_">getTime</span>(),</span><br><span class="line">      nowTime = [<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>(), <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getMonth</span>(), <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDate</span>()]</span><br><span class="line">    <span class="keyword">if</span> (currentTime &amp;&amp; currentTime == time) current = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (startTime &amp;&amp; startTime &gt; time) disabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (endTime &amp;&amp; endTime &lt; time) disabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (year === nowTime[<span class="number">0</span>] &amp;&amp; month === nowTime[<span class="number">1</span>] &amp;&amp; i === nowTime[<span class="number">2</span>]) now = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    days.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">day</span>: i,</span><br><span class="line">      current,</span><br><span class="line">      disabled,</span><br><span class="line">      now,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 填充每月最后一天之后的空数据</span></span><br><span class="line">  <span class="keyword">if</span> (lastWeek != <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = (<span class="number">6</span> - lastWeek); i &lt; l; i++) &#123;</span><br><span class="line">      days.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">day</span>: <span class="number">0</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> days</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个月最大天数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> <span class="variable">getMonthMax</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; year 年份</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; month 月份</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getMonthMax</span>(<span class="params">year, month</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">31</span></span><br><span class="line">  <span class="keyword">if</span> (month == <span class="number">4</span> || month == <span class="number">6</span> || month == <span class="number">9</span> || month == <span class="number">11</span>) &#123;</span><br><span class="line">    max = <span class="number">30</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((year % <span class="number">4</span>) == <span class="number">0</span> &amp;&amp; (year % <span class="number">100</span>) &gt; <span class="number">0</span>) || (year % <span class="number">400</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      max = <span class="number">29</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max = <span class="number">28</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>以上就是核心逻辑，像一些弹窗事件和一些点击事件就不附上来了</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序前端登录模块设计</title>
    <url>/2022/09/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信小程序登录基本上是每个小程序都必备的功能，但是随着业务的逐渐复杂，需要考虑的情况会越来越多，所以登录功能的健壮和高效是值得重点关注的，我会按照以往经验实现一个较优雅的登录方案</p>
<h2 id="基本登录流程"><a href="#基本登录流程" class="headerlink" title="基本登录流程"></a>基本登录流程</h2><ol>
<li>获取微信登录凭证，通过<code>wx.login</code>获取，这个api会返回一个带有时效性的code</li>
<li>发送code给服务端，这一步就是通过你和后端定义的接口发送</li>
<li>服务端根据前端发送的code获取用户身份信息，当然这一步就不是前端的逻辑了</li>
<li>服务端处理完后，会把用户信息和sessinId发送给前端，然后前端把需要的信息进行存储，接下来的请求就可以带着sessinId来表示身份</li>
<li>下面是微信官方的流程图<br><img src="https://img-blog.csdnimg.cn/3b0b114c140247ebbc666b027dfbda66.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h2 id="逻辑封装"><a href="#逻辑封装" class="headerlink" title="逻辑封装"></a>逻辑封装</h2><p>针对以上登录流程，我会封装以下几个方法供业务层调用</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>getLoginCode</code></td>
<td>获取微信登录凭证</td>
</tr>
<tr>
<td><code>staticLogin</code></td>
<td>静默登录</td>
</tr>
<tr>
<td><code>singleLogin</code></td>
<td>登录请求封装</td>
</tr>
<tr>
<td><code>checkLogin</code></td>
<td>判断是否登录</td>
</tr>
<tr>
<td><code>getPhoneNum</code></td>
<td>获取微信授权手机号</td>
</tr>
</tbody></table>
<ul>
<li><p>我习惯在promise请求中使用await-to方法，这是一个针对异步比较优雅的方案</p>
<ul>
<li><a href="https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/">How to write async await without try-catch blocks in Javascript</a></li>
</ul>
</li>
<li><p>getLoginCode，一个简单的promise封装获取code</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getLoginCode</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      wx.<span class="title function_">login</span>(&#123;</span><br><span class="line">        success (res) &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.<span class="property">code</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res.<span class="property">code</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">fail</span>(<span class="params">err</span>) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静默登录封装，获取用户信息，并进行存储</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">staticLogin</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 如果已经登录，直接返回登录信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">checkLogin</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getLoginInfo</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">singleLogin</span>());</span><br><span class="line">  <span class="keyword">if</span> (loginErr) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(loginErr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储用户信息，这个就根据自己的情况了，我这随便定个方法</span></span><br><span class="line">  <span class="title function_">setLoginInfo</span>(&#123;</span><br><span class="line">    ...loginRes,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> loginRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录请求封装，这里我是用单例模式并返回了一个promise，这样做是为了，你多次调用singleLogin时，比如快速切换页面，快速点击多个需登录区域，在数据没有返回的时候，都会等待，而不是触发多次请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loginInstance = <span class="literal">null</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">singleLogin</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (loginInstance) &#123;</span><br><span class="line">    <span class="keyword">return</span> loginInstance</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// loginReq：封装请求，包括请求后端和getLoginCode</span></span><br><span class="line">  loginInstance = <span class="title function_">loginReq</span>()</span><br><span class="line">  loginInstance.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    loginInstance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> loginInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>checkLogin，检查是否登录，这个就看你存储在那个地方了，视情况而定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">checkLogin</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Boolean</span>(loginInfo?.<span class="property">sid</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>getPhoneNum</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPhoneNum</span> = <span class="keyword">async</span> (<span class="params">iv, encryptedData</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [codeErr, codeRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">getLoginCode</span>())</span><br><span class="line">  <span class="keyword">if</span> (codeErr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(codeErr);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(codeErr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// decrypt：请求后端</span></span><br><span class="line">  <span class="keyword">const</span> [phoneErr, phoneRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">decrypt</span>(&#123;</span><br><span class="line">    iv,</span><br><span class="line">    encryptedData,</span><br><span class="line">    <span class="attr">code</span>: codeRes.<span class="property">code</span></span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="keyword">if</span> (phoneErr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(phoneErr);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(phoneErr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> phoneNumber = phoneRes.<span class="property">result</span>.<span class="property">phoneNumber</span></span><br><span class="line">  <span class="title function_">setLoginInfo</span>(&#123;</span><br><span class="line">    phoneNumber,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> phoneNumber</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p>业务层我会在以下几个地方调用</p>
<ol>
<li><p>请求前根据options判断是否需登录，并进行处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">REQUEST</span> = <span class="keyword">async</span> (<span class="params">requestObj</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// isLogin 当前接口请求是否需要登录</span></span><br><span class="line">  <span class="keyword">if</span> (requestObj.<span class="property">isLogin</span> &amp;&amp; !<span class="title function_">checkLogin</span>()) &#123;</span><br><span class="line">    <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">staticLogin</span>());</span><br><span class="line">    <span class="keyword">if</span> (loginErr) &#123;</span><br><span class="line">      <span class="title class_">Toast</span>(<span class="string">&#x27;登录失败&#x27;</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(loginErr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录按钮，这个主要用于登录失败兜底的情况，让用户主动点击，用于登录弹窗等组件，只需调用<code>staticLogin</code>即可</p>
</li>
<li><p>获取用户授权手机号按钮</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="comment">// 用户主动触发进行授权手机号</span></span><br><span class="line">&lt;button open-type=<span class="string">&quot;getPhoneNumber&quot;</span> bindgetphonenumber=<span class="string">&quot;bindPhoneNumber&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">bindPhoneNumber</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> iv = e.<span class="property">detail</span>.<span class="property">iv</span>;</span><br><span class="line">  <span class="keyword">const</span> encryptedData = e.<span class="property">detail</span>.<span class="property">encryptedData</span>;</span><br><span class="line">  <span class="keyword">const</span> [phoneErr, phoneRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">getPhoneNum</span>(iv, encryptedData));</span><br><span class="line">  <span class="keyword">if</span> (phoneErr) &#123;</span><br><span class="line">    <span class="title class_">Toast</span>(<span class="string">&#x27;获取手机号失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;getPhoneNumber&#x27;</span>, phoneRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页面组件，在小程序中一般都有一个页面组件，用于封装一些页面必需的功能，比如loading，导航栏，无效页面等等，登录也是必需的，所以我把登录逻辑封装到页面组件上，如果成功会通过triggerEvent触发给页面，如果失败就弹出登录弹窗，当然这种处理不太细，根据业务的不同改变相关的逻辑<br><img src="https://img-blog.csdnimg.cn/f6cd710acc4d45a1a7d88042623ad4bc.png#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;view&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;login-modal show=&#123;loginShow&#125; &#123;...props&#125; /&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">staticLogin</span>());</span><br><span class="line">  <span class="keyword">if</span> (loginErr) &#123;</span><br><span class="line">    <span class="title class_">Toast</span>(<span class="string">&#x27;登录失败&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">loginShow</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;login&#x27;</span>, loginRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>还有一些不是太通用的业务组件就不叙述了…</li>
</ol>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序单指拖拽和双指缩放旋转</title>
    <url>/2021/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%95%E6%8C%87%E6%8B%96%E6%8B%BD%E5%92%8C%E5%8F%8C%E6%8C%87%E7%BC%A9%E6%94%BE%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小程序单指拖拽和双指操作是一个比较常用的功能，效果如下图<br><img src="https://img-blog.csdnimg.cn/babbbc7162d241e9b0fb01e0b18531eb.gif#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>实现这三个功能，主要用三个触摸事件<code>touchstart</code>、<code>touchmove</code>、<code>touchend</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;height: 100vh; width: 100vw&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">image</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;...&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;translateX&#125;&#125;px, &#123;&#123;translateY&#125;&#125;px) scale(&#123;&#123;scale&#125;&#125;) rotate(&#123;&#123;rotate&#125;&#125;deg);&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:touchstart</span>=<span class="string">&quot;touchStart&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>用了以下变量<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">translateX</span>: <span class="number">0</span>, <span class="comment">// 位移x坐标 单位px</span></span><br><span class="line">    <span class="attr">translateY</span>: <span class="number">0</span>, <span class="comment">// 位移y坐标 单位px</span></span><br><span class="line">    <span class="attr">distance</span>: <span class="number">0</span>, <span class="comment">// 双指接触点距离</span></span><br><span class="line">    <span class="attr">scale</span>: <span class="number">1</span>, <span class="comment">// 缩放倍数</span></span><br><span class="line">    <span class="attr">rotate</span>: <span class="number">0</span>, <span class="comment">// 旋转角度</span></span><br><span class="line">    <span class="attr">oldRotate</span>: <span class="number">0</span>, <span class="comment">// 上一次旋转停止后的角度</span></span><br><span class="line">    <span class="attr">startMove</span>: &#123; <span class="comment">// 起始位移距离</span></span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">startTouches</span>: [] <span class="comment">// 起始点touch数组</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="单指拖拽"><a href="#单指拖拽" class="headerlink" title="单指拖拽"></a>单指拖拽</h2><ul>
<li>实现单指拖拽比较简单，只需要记录移动的点坐标，然后减去起始点坐标，就可以求出相对页面的移动距离</li>
<li><code>touchstart</code><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">touchStart</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> touches = e.<span class="property">touches</span></span><br><span class="line">  <span class="keyword">const</span> &#123; translateX, translateY &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">const</span> &#123; pageX, pageY &#125; = touches[<span class="number">0</span>]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">startMove</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: pageX - translateX,</span><br><span class="line">    <span class="attr">y</span>: pageY - translateY</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">startTouches</span> = touches</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><code>touchmove</code><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> touches = e.<span class="property">touches</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> &#123; startMove &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,</span><br><span class="line">    <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="双指缩放"><a href="#双指缩放" class="headerlink" title="双指缩放"></a>双指缩放</h2><ul>
<li>双指缩放的原理是根据两点坐标求出距离(勾股定理)，然后在用移动坐标的距离比就可以求出缩放倍数</li>
<li><code>touchmove</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> touches = e.<span class="property">touches</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> &#123; startMove, scale, <span class="attr">distance</span>: oldDistance, startTouches &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">if</span> (touches.<span class="property">length</span> === <span class="number">2</span> &amp;&amp; startTouches.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 双指缩放</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: twoPageX, <span class="attr">pageY</span>: twoPageY &#125; = touches[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 求出当前双指距离</span></span><br><span class="line">    <span class="keyword">const</span> distance = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((twoPageX - onePageX) ** <span class="number">2</span> + (twoPageY - onePageY) ** <span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">distance</span> = distance</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">scale</span>: scale * (distance / (oldDistance || distance))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startTouches.<span class="property">length</span> !== <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 单指拖拽</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,</span><br><span class="line">      <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>startTouches.length !== 2</code>这个判断的原因是防止图片跳动，因为如果你两个手指触摸，然后离开一个手指，我是禁止拖拽的，只有双指都离开后再次触摸才能单指拖拽</li>
</ul>
<h2 id="双指旋转"><a href="#双指旋转" class="headerlink" title="双指旋转"></a>双指旋转</h2><ul>
<li>双指旋转的原理是根据三角函数求出起始点的角度，然后再求出移动坐标的角度，相减然后加上上一次旋转的角度就等于你当前所需的选择角度</li>
<li><code>touchmove</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> touches = e.<span class="property">touches</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> &#123; startMove, scale, <span class="attr">distance</span>: oldDistance, startTouches, oldRotate &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">if</span> (touches.<span class="property">length</span> === <span class="number">2</span> &amp;&amp; startTouches.<span class="property">length</span> === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: twoPageX, <span class="attr">pageY</span>: twoPageY &#125; = touches[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> distance = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((twoPageX - onePageX) ** <span class="number">2</span> + (twoPageY - onePageY) ** <span class="number">2</span>)</span><br><span class="line">+   <span class="keyword">let</span> rotate = <span class="variable language_">this</span>.<span class="title function_">getAngle</span>(touches[<span class="number">0</span>], touches[<span class="number">1</span>]) - <span class="variable language_">this</span>.<span class="title function_">getAngle</span>(startTouches[<span class="number">0</span>], startTouches[<span class="number">1</span>]) + oldRotate</span><br><span class="line">  <span class="comment">// 如果大于360度，就减去360</span></span><br><span class="line">+   rotate = rotate &gt; <span class="number">360</span> ? rotate - <span class="number">360</span> : rotate</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">distance</span> = distance</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">scale</span>: scale * (distance / (oldDistance || distance)),</span><br><span class="line">+     rotate</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startTouches.<span class="property">length</span> !== <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,</span><br><span class="line">      <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getAngle</code><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getAngle</span>(<span class="params">p1, p2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = p1.<span class="property">pageX</span> - p2.<span class="property">pageX</span></span><br><span class="line">  <span class="keyword">const</span> y = p1.<span class="property">pageY</span>- p2.<span class="property">pageY</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">atan2</span>(y, x) * <span class="number">180</span> / <span class="title class_">Math</span>.<span class="property">PI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>touchend</code><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 保存当前旋转角度</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">oldRotate</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">rotate</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/0nS1tImU7Rs5</code></li>
<li>H5原理一致，只需改一下语法即可</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序瀑布流和虚拟列表</title>
    <url>/2022/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%80%91%E5%B8%83%E6%B5%81%E5%92%8C%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="微信小程序瀑布流和虚拟列表"><a href="#微信小程序瀑布流和虚拟列表" class="headerlink" title="微信小程序瀑布流和虚拟列表"></a>微信小程序瀑布流和虚拟列表</h2><p>首先声明虽然本篇是写的微信小程序的案例，但是也可用于H5，思路是想通的，只是有些api的差异，最后会贴代码片段<br><img src="https://img-blog.csdnimg.cn/40f9275783f14ed4a2a020ec733b3043.gif#pic_center" alt="example"></p>
<h3 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h3><ul>
<li>一般在做长列表优化时，特别是面试时，虚拟列表就是个高频词。这个名词听起来很高级，其实原理很简单</li>
<li>虚拟列表就是将需要渲染的数组数据改造成二维数组，然后通过监听DOM在合适的地方切换为占位元素，达到长列表无限滚动时减少DOM的优化</li>
<li>JS <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理占位元素，就是在获取新的数据后</span></span><br><span class="line"><span class="comment"> * 通过SelectQuery获取当前数据的实际高度，然后把这个高度设置到占位元素上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getCurrentItemHeight</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> query = <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>();</span><br><span class="line">  <span class="keyword">const</span> &#123; virtualId &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  query.<span class="title function_">select</span>(<span class="string">`#<span class="subst">$&#123;virtualId&#125;</span>`</span>).<span class="title function_">boundingClientRect</span>()</span><br><span class="line">  query.<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">height</span>: res[<span class="number">0</span>].<span class="property">height</span></span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="title function_">observePage</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听元素与页面的相交</span></span><br><span class="line"><span class="comment"> * 可以选择指定元素为参照区域，也可以选择页面为参照元素，只是API不同</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@doc</span> https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">observePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; virtualId, observeDistance, wrapId &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">IntersectionObserver</span> = wx.<span class="title function_">createIntersectionObserver</span>(<span class="variable language_">this</span>);</span><br><span class="line">  (wrapId ? <span class="title class_">IntersectionObserver</span>.<span class="title function_">relativeTo</span>(<span class="string">`#<span class="subst">$&#123;wrapId&#125;</span>`</span>) : <span class="title class_">IntersectionObserver</span>.<span class="title function_">relativeToViewport</span>(&#123; <span class="attr">top</span>: observeDistance, <span class="attr">bottom</span>: observeDistance &#125;))</span><br><span class="line">  .<span class="title function_">observe</span>(<span class="string">`#<span class="subst">$&#123;virtualId&#125;</span>`</span>, <span class="function">(<span class="params">&#123; intersectionRatio &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">isShow</span>: intersectionRatio &gt; <span class="number">0</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>html<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view id=<span class="string">&quot;&#123;&#123;virtualId&#125;&#125;&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;isShow&#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span> <span class="attr">style</span>=<span class="string">&quot;height: &#123;&#123; height &#125;&#125;px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h3><ul>
<li>瀑布流，又称瀑布流式布局。视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部</li>
<li>瀑布流有多种写法，有通过纯CSS完成的，也有借助JS完成的，方法很多，但是我为了接下来能与虚拟列表相结合，就采用JS的写法，就是通过列数把每一列分为一个单独的子元素，然后会记录每一列的高度，通过判断哪一列高度最小，然后将数据push到高度最小的那一列<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取列表数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span> 瀑布流处理，哪列高度小，就往哪列push新数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; <span class="attr">listQuery</span>: &#123; pageIndex, pageSize &#125;, columns, columnsHeight &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pageSize; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">const</span> item = height &lt; <span class="number">50</span> ? height + <span class="number">50</span> : height</span><br><span class="line">    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">computePosition</span>(columnsHeight)</span><br><span class="line">    columns[position].<span class="title function_">push</span>(item)</span><br><span class="line">    columnsHeight += item</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在html中双重遍历columns，然后通过flex：1均匀分布</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    columns,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">columnsHeight</span> = columnsHeight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取高度最小列下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">computePosition</span>(<span class="params">heights</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...heights);</span><br><span class="line">  <span class="keyword">return</span> heights.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item === min)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="瀑布流结合虚拟列表"><a href="#瀑布流结合虚拟列表" class="headerlink" title="瀑布流结合虚拟列表"></a>瀑布流结合虚拟列表</h3><ul>
<li>让瀑布流有虚拟滚动的能力，思路很简单，就是计算每列的偏移量，因为瀑布流被我们分成了二维数组，所以每块子元素之间就会因为列高度的不一致产生空白区域，所以需要计算这个空白区域的大小，然后通过<code>margin-top</code>移动列元素达到视觉上的瀑布流衔接效果<br><img src="https://img-blog.csdnimg.cn/070e8c72d982470ca8808ad8121e6110.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; <span class="attr">listQuery</span>: &#123; pageIndex &#125;, column, columnsHeights &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> columns = [];</span><br><span class="line">  <span class="comment">// 上一组的高度数据，用于计算偏移值</span></span><br><span class="line">  <span class="keyword">const</span> lastHeights = [...columnsHeights];</span><br><span class="line">  <span class="comment">// 获取数据</span></span><br><span class="line">  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="title function_">getListData</span>();</span><br><span class="line">  <span class="comment">// 初始化当前屏数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; column; i++ ) &#123;</span><br><span class="line">    columns.<span class="title function_">push</span>([]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历新数据，分配至各列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">computePosition</span>(columnsHeights);</span><br><span class="line">    columns[position].<span class="title function_">push</span>(list[i]);</span><br><span class="line">    columnsHeights[position] += <span class="title class_">Number</span>(list[i].<span class="property">height</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    [<span class="string">`listData[<span class="subst">$&#123;pageIndex&#125;</span>]`</span>]: &#123;</span><br><span class="line">      columns,</span><br><span class="line">      <span class="attr">columnOffset</span>: <span class="variable language_">this</span>.<span class="title function_">computeOffset</span>(lastHeights),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">listQuery</span>.<span class="property">pageIndex</span> = pageIndex + <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">columnsHeights</span> = columnsHeights;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取列表数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getListData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">listQuery</span>.<span class="property">pageSize</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">300</span>);</span><br><span class="line">    <span class="keyword">const</span> item = &#123;</span><br><span class="line">      <span class="attr">height</span>: height &lt; <span class="number">150</span> ? height + <span class="number">150</span> : height,</span><br><span class="line">      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="title function_">randomRgbColor</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    result.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机生成RGB颜色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">randomRgbColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> r = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内r值</span></span><br><span class="line">  <span class="keyword">var</span> g = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内g值</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内b值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>)`</span>; <span class="comment">//返回rgb(r,g,b)格式颜色</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取最小高度列下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">computePosition</span>(<span class="params">heights</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...heights);</span><br><span class="line">  <span class="keyword">return</span> heights.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item === min);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">computeOffset</span>(<span class="params">heights</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...heights);</span><br><span class="line">  <span class="keyword">return</span> heights.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> max - item);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="title function_">onScrollLower</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getList</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WXML<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">class</span>=<span class="string">&quot;virtualScrollView&quot;</span> <span class="attr">eventhandle</span> <span class="attr">scroll-y</span> <span class="attr">bindscrolltolower</span>=<span class="string">&quot;onScrollLower&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; listData &#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;screenIndex&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;screenIndex&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;screenItem&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">VirtualItem</span> <span class="attr">virtualId</span>=<span class="string">&quot;virtual_&#123;&#123;pageIndex&#125;&#125;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;fall&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; screenItem.columns &#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;columnIndex&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;columnIndex&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;column&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: -&#123;&#123;screenItem.columnOffset[columnIndex]&#125;&#125;px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fallCol&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;column&#125;&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: &#123;&#123; item.height &#125;&#125;px; background-color: &#123;&#123; item.color &#125;&#125;;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                screen: &#123;&#123; screenIndex &#125;&#125;, column: &#123;&#123; columnIndex &#125;&#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">VirtualItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span></span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段：<a href="https://developers.weixin.qq.com/s/5P3DpGmI7PBc">https://developers.weixin.qq.com/s/5P3DpGmI7PBc</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>瀑布流</tag>
        <tag>虚拟列表</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序图片拖拽排序组件</title>
    <url>/2022/09/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>图片拖拽排序是一个比较常用的组件，常用于发帖或者评论等内容上传模块，我借鉴了<a href="https://www.cnblogs.com/haha1212/p/11562944.html">《一款优雅的小程序拖拽排序组件实现》</a>这篇文章的拖拽思路，并封装成<a href="https://github.com/LHRUN/wx-drag-img">wx-drag-img</a>发布到npm</li>
<li>实现原理：每个图片初始化我都会封装成一个拖拽的数据结构，然后触发touch事件时，通过改变图片的key来计算transform位置，从而达到拖拽效果</li>
<li>功能包括图片上传拖拽删除，源码和npm地址我会贴在结尾，如果感觉好的话，欢迎star</li>
<li>我会在下面逐步分析这个组件的实现思路</li>
<li>使用了以下变量<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拖拽数据结构</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDragImg</span> &#123;</span><br><span class="line">  <span class="attr">src</span>: <span class="built_in">string</span>; <span class="comment">// 图片路径</span></span><br><span class="line">  <span class="attr">key</span>: <span class="built_in">number</span>; <span class="comment">// </span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>; <span class="comment">// for循环遍历使用, 不会改变, 创建时自增id</span></span><br><span class="line">  <span class="attr">tranX</span>: <span class="built_in">number</span>; <span class="comment">// x轴位移距离</span></span><br><span class="line">  <span class="attr">tranY</span>: <span class="built_in">number</span>; <span class="comment">// y轴位移距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// props</span></span><br><span class="line">&#123;</span><br><span class="line">  previewSize <span class="comment">// 图片大小</span></span><br><span class="line">  defaultImgList <span class="comment">// 初始化图片数组</span></span><br><span class="line">  maxCount <span class="comment">// 图片上传数量限制</span></span><br><span class="line">  columns <span class="comment">// 列数</span></span><br><span class="line">  gap <span class="comment">// 图片间隔</span></span><br><span class="line">  deleteStyle <span class="comment">// 删除样式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">dragImgList</span>: <span class="title class_">IDragImg</span>[],</span><br><span class="line">  <span class="attr">containerRes</span>: &#123;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">0</span>, <span class="comment">// 容器距离页面顶部距离 px</span></span><br><span class="line">    <span class="attr">left</span>: <span class="number">0</span>, <span class="comment">// 容器距离页面左边距离 px</span></span><br><span class="line">    <span class="attr">width</span>: <span class="number">0</span>, <span class="comment">// 容器宽度 px</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">0</span>, <span class="comment">// 容器高度 px</span></span><br><span class="line">  &#125;, <span class="comment">// 拖拽容器属性</span></span><br><span class="line">  <span class="attr">currentKey</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的key</span></span><br><span class="line">  <span class="attr">currentIndex</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的index</span></span><br><span class="line">  <span class="attr">tranX</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的x距离</span></span><br><span class="line">  <span class="attr">tranY</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的y距离</span></span><br><span class="line">  <span class="attr">uploadPosition</span>: &#123; <span class="comment">// upload上传图标位移距离</span></span><br><span class="line">    <span class="attr">tranX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">tranY</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;width: &#123;&#123;containerRes.width&#125;&#125;px; height: &#123;&#123;containerRes.height&#125;&#125;px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;dragImgList&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;index === currentIndex ? tranX : item.tranX&#125;&#125;px, &#123;&#123;index === currentIndex ? tranY : item.tranY&#125;&#125;px); z-index: &#123;&#123;index === currentIndex ? 10 : 1&#125;&#125;; width: &#123;&#123;previewSize&#125;&#125;px; height: &#123;&#123;previewSize&#125;&#125;px;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;drag-item drag-item-transition&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">mark:index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:longpress</span>=<span class="string">&quot;longPress&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.src&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 删除图标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">catch:tap</span>=<span class="string">&quot;deleteImg&quot;</span> <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete_default&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&#123;&#123;deleteStyle&#125;&#125;&quot;</span>&gt;</span>x<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 上传图片 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span></span></span><br><span class="line"><span class="tag">    <span class="attr">bindtap</span>=<span class="string">&quot;uploadImage&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;drag-item drag-upload&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123;dragImgList.length &gt;= maxCount&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;uploadPosition.tranX&#125;&#125;px, &#123;&#123;uploadPosition.tranY&#125;&#125;px); width: &#123;&#123;previewSize&#125;&#125;px; height: &#123;&#123;previewSize&#125;&#125;px;&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-upload_solt&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-upload_default&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span>&gt;</span>+<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><ul>
<li>图片上传很简单，就是初始化上传的图片，然后拼接到现有图片，最后修改上传图标位置即可</li>
<li>点击上传区域回调函数<code>uploadImage</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">uploadImage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; dragImgList, maxCount &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> wx.<span class="title function_">chooseMedia</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: maxCount - dragImgList.<span class="property">length</span>,</span><br><span class="line">      <span class="attr">mediaType</span>: [<span class="string">&#x27;image&#x27;</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 获取上传图片数据后需要初始化图片拽结构</span></span><br><span class="line">    <span class="keyword">const</span> imgList = <span class="variable language_">this</span>.<span class="title function_">getDragImgList</span>(res?.<span class="property">tempFiles</span>?.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; tempFilePath &#125;</span>) =&gt;</span> tempFilePath) || [], <span class="literal">false</span>);</span><br><span class="line">    dragImgList = dragImgList.<span class="title function_">concat</span>(imgList);</span><br><span class="line">    <span class="comment">// 修改上传区域位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(dragImgList.<span class="property">length</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      dragImgList,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">updateEvent</span>(dragImgList);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>上传后需要初始化拖拽的数据结构<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图片列表生成拖拽列表数据结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 图片src列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> init 是否是初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="title function_">getDragImgList</span>(<span class="params">list, init = <span class="literal">true</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; dragImgList, previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">return</span> list.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> i = (init ? <span class="number">0</span> : dragImgList.<span class="property">length</span>) + index;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">tranX</span>: (previewSize + gap) * (i % columns),</span><br><span class="line">      <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(i / columns) * (previewSize + gap),</span><br><span class="line">      <span class="attr">src</span>: item,</span><br><span class="line">      <span class="attr">id</span>: i,</span><br><span class="line">      <span class="attr">key</span>: i,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>修改上传区域位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改上传区域位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listLength 数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">setUploaPosition</span>(<span class="params">listLength</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> uploadPosition = &#123;</span><br><span class="line">    <span class="attr">tranX</span>: listLength % columns * (previewSize + gap),</span><br><span class="line">    <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(listLength / columns) * (previewSize + gap),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> &#123; width, height &#125; = <span class="variable language_">this</span>.<span class="title function_">getContainerRect</span>(listLength);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    uploadPosition,</span><br><span class="line">    [<span class="string">&#x27;containerRes.width&#x27;</span>]: width,</span><br><span class="line">    [<span class="string">&#x27;containerRes.height&#x27;</span>]: height,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>图片数量改变后就要重新获取容器宽高了<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改变图片数量后获取容器宽高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@parma</span> listLength 数组长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getContainerRect</span>(<span class="params">listLength</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; columns, previewSize, maxCount, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> number = listLength === maxCount ? listLength : listLength + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> row = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(number / columns)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">width</span>: columns * previewSize + (columns - <span class="number">1</span>) * gap,</span><br><span class="line">    <span class="attr">height</span>: row * previewSize + gap * (row - <span class="number">1</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>updateEvent<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * updateEvent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span> 上传删除拖拽后触发事件把列表数据发给页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">updateEvent</span>(<span class="params">dragImgList</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> list = [...dragImgList].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">key</span> - b.<span class="property">key</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">src</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;updateImageList&#x27;</span>, &#123;</span><br><span class="line">      list,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h3><ul>
<li>首先从图片列表中删除所需图片，然后修改列表，把大于所选图片key的key全部减一，最后计算剩余图片位置和上传图标位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">deleteImg</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = e.<span class="property">mark</span>.<span class="property">key</span>;</span><br><span class="line">  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> !== key);</span><br><span class="line">  <span class="comment">// 大于删除图片key的key全部减1</span></span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.<span class="property">key</span> &gt; key &amp;&amp; item.<span class="property">key</span>--;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 获取</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(list);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(list.<span class="property">length</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算数组的位移位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 拖拽图片数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getListPosition</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> dragImgList = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.<span class="property">tranX</span> = (previewSize + gap) * (item.<span class="property">key</span> % columns);</span><br><span class="line">    item.<span class="property">tranY</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(item.<span class="property">key</span> / columns) * (previewSize + gap);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    dragImgList,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">updateEvent</span>(dragImgList);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="图片拖拽"><a href="#图片拖拽" class="headerlink" title="图片拖拽"></a>图片拖拽</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化只需获取容器的位置信息即可，因为拖拽组件不一定是在页面的左上角，所以需要知道容器的位置信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">lifetimes</span>: &#123;</span><br><span class="line">  <span class="title function_">ready</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>()</span><br><span class="line">      .<span class="title function_">select</span>(<span class="string">&quot;.drag-container&quot;</span>)</span><br><span class="line">      .<span class="title function_">boundingClientRect</span>(<span class="function">(<span class="params">&#123; top, left &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          [<span class="string">&#x27;containerRes.top&#x27;</span>]: top,</span><br><span class="line">          [<span class="string">&#x27;containerRes.left&#x27;</span>]: left,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;).<span class="title function_">exec</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="longPress"><a href="#longPress" class="headerlink" title="longPress"></a>longPress</h3><ul>
<li>这里采用longPress，而不是touchStart的原因，一是为了优化体验，二是touchStart与删除按钮冲突<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 长按图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">longPress</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = e.<span class="property">mark</span>.<span class="property">index</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> &#123; previewSize, <span class="attr">containerRes</span>: &#123; top, left &#125; &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">currentIndex</span>: index,</span><br><span class="line">    <span class="attr">tranX</span>: pageX - previewSize / <span class="number">2</span> - left,</span><br><span class="line">    <span class="attr">tranY</span>: pageY - previewSize / <span class="number">2</span> - top,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="touchMove"><a href="#touchMove" class="headerlink" title="touchMove"></a>touchMove</h3><ul>
<li>touchMove首先计算出位移距离，然后根据位移距离求出停放位置的key，如果不一样就修改位置</li>
<li>touchMove<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * touchMove</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果currentIndex &lt; 0，说明并没有触发longPress</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentIndex</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> &#123; previewSize, <span class="attr">containerRes</span>: &#123; top, left &#125; &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> tranX = pageX - previewSize / <span class="number">2</span> - left;</span><br><span class="line">  <span class="keyword">const</span> tranY = pageY - previewSize / <span class="number">2</span> - top;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    tranX,</span><br><span class="line">    tranY</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 对比当前移动的key和停放位置的key，如果不一样就修改位置</span></span><br><span class="line">  <span class="keyword">const</span> currentKey = e.<span class="property">mark</span>.<span class="property">key</span>;</span><br><span class="line">  <span class="keyword">const</span> moveKey = <span class="variable language_">this</span>.<span class="title function_">getMoveKey</span>(tranX, tranY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当移动的key和正在停放位置的key相等，就无须处理</span></span><br><span class="line">  <span class="keyword">if</span> (currentKey === moveKey || <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> === currentKey) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = currentKey;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">replace</span>(currentKey, moveKey);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>getMoveKey<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算移动中的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tranX 正在拖拽图片的tranX</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tranY 正在拖拽图片的tranY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">getMoveKey</span>(<span class="params">tranX, tranY</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">dragImgList</span>: list, previewSize, columns &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">_getPositionNumber</span> = (<span class="params">drag, limit</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> positionNumber = <span class="title class_">Math</span>.<span class="title function_">round</span>(drag / previewSize);</span><br><span class="line">    <span class="keyword">return</span> positionNumber &gt;= limit ? limit - <span class="number">1</span> : positionNumber &lt; <span class="number">0</span> ? <span class="number">0</span> : positionNumber;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> endKey = columns * <span class="title function_">_getPositionNumber</span>(tranY, <span class="title class_">Math</span>.<span class="title function_">ceil</span>(list.<span class="property">length</span> / columns)) + <span class="title function_">_getPositionNumber</span>(tranX, columns);</span><br><span class="line">  <span class="keyword">return</span> endKey &gt;= list.<span class="property">length</span> ? list.<span class="property">length</span> - <span class="number">1</span> : endKey;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>replace<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成拖拽后的新数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 拖拽起始的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end 拖拽结束的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">replace</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dragImgList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>;</span><br><span class="line">  dragImgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">key</span> &gt; start &amp;&amp; item.<span class="property">key</span> &lt;= end) item.<span class="property">key</span>--;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === start) item.<span class="property">key</span> = end;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">key</span> &gt;= end &amp;&amp; item.<span class="property">key</span> &lt; start) item.<span class="property">key</span>++;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === start) item.<span class="property">key</span> = end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(dragImgList);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="touchEnd"><a href="#touchEnd" class="headerlink" title="touchEnd"></a>touchEnd</h3><ul>
<li>touchEnd用于重置数据<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * touchEnd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">tranX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">tranY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">currentIndex</span>: -<span class="number">1</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = -<span class="number">1</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><a href="https://github.com/LHRUN/wx-drag-img">repo</a></li>
<li><a href="https://www.npmjs.com/package/wx-drag-img">npm</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/haha1212/p/11562944.html">一款优雅的小程序拖拽排序组件实现</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序蓝牙控制开门</title>
    <url>/2020/01/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%93%9D%E7%89%99%E6%8E%A7%E5%88%B6%E5%BC%80%E9%97%A8/</url>
    <content><![CDATA[<h2 id="小程序低功耗蓝牙控制开门"><a href="#小程序低功耗蓝牙控制开门" class="headerlink" title="小程序低功耗蓝牙控制开门"></a>小程序低功耗蓝牙控制开门</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><blockquote>
<ol>
<li>初始化蓝牙模块<code>openBluetoothAdapter</code></li>
<li>获取本机蓝牙适配器状态<code>getBluetoothAdapterState</code></li>
<li>搜索外围蓝牙设备<code>startBluetoothDevicesDiscovery</code></li>
<li>监听寻找到新设备<code>onBluetoothDeviceFound</code></li>
<li>连接蓝牙<code>createBLEConnection</code></li>
<li>获取蓝牙设备的服务<code>getBLEDeviceServices</code></li>
<li>获取服务中的特征值<code>getBLEDeviceCharacteristics</code></li>
<li>启用特征值变化时的notify功能<code>notifyBLECharacteristicValueChange</code></li>
<li>向蓝牙设备写入数据<code>writeBLECharacteristicValue</code></li>
<li>关闭蓝牙模块<code>closeBluetoothAdapter</code></li>
</ol>
</blockquote>
<h3 id="1-初始化蓝牙模块"><a href="#1-初始化蓝牙模块" class="headerlink" title="1. 初始化蓝牙模块"></a>1. 初始化蓝牙模块</h3><ul>
<li>初始化蓝牙模块使用的是：<code>wx.openBluetoothAdapter</code>，初始化之前对蓝牙功能做一个判断，看手机微信版本是否支持此功能</li>
<li>初始化之前需要关闭蓝牙模块：<code>wx.closeBluetoothAdapter</code>，否则容易搜索失败<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">if</span> (!wx.<span class="property">openBluetoothAdapter</span>) &#123;</span><br><span class="line">  wx.<span class="title function_">showModal</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">    <span class="attr">showCancel</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  wx.<span class="title function_">closeBluetoothAdapter</span>(&#123;</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      wx.<span class="title function_">openBluetoothAdapter</span>(&#123; <span class="comment">// 初始化蓝牙模块</span></span><br><span class="line">        <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始化蓝牙成功&#x27;</span>)</span><br><span class="line">          _this.<span class="title function_">getBluetoothAdapterState</span>()</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-获取本机蓝牙适配器状态"><a href="#2-获取本机蓝牙适配器状态" class="headerlink" title="2. 获取本机蓝牙适配器状态"></a>2. 获取本机蓝牙适配器状态</h3><ul>
<li>获取本机蓝牙适配器状态使用的是<code>wx.getBluetoothAdapterState</code>，调用成功后，会返回两个参数<ul>
<li><code>discovering</code>判断是否正在搜索设备</li>
<li><code>available</code>判断蓝牙适配器是否可用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">getBluetoothAdapterState</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  wx.<span class="title function_">getBluetoothAdapterState</span>(&#123;</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">available</span> == <span class="literal">false</span>) &#123;</span><br><span class="line">        wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;设备无法开启蓝牙连接&#x27;</span>,</span><br><span class="line">          <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">          <span class="attr">duration</span>: <span class="number">2000</span></span><br><span class="line">        &#125;)</span><br><span class="line">        wx.<span class="title function_">closeBluetoothAdapter</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">discovering</span> == <span class="literal">false</span>) &#123;</span><br><span class="line">        _this.<span class="title function_">startBluetoothDevicesDiscovery</span>() <span class="comment">// 开启搜索外围设备</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">available</span>)&#123;</span><br><span class="line">        _this.<span class="title function_">startBluetoothDevicesDiscovery</span>() <span class="comment">// 蓝牙适配器正常，去执行搜索外围设备</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-搜索外围蓝牙设备"><a href="#3-搜索外围蓝牙设备" class="headerlink" title="3. 搜索外围蓝牙设备"></a>3. 搜索外围蓝牙设备</h3><ul>
<li>搜索外围蓝牙设备使用的是<code>wx.startBluetoothDevicesDiscovery</code>，连接设备后一定要使用<code>wx.stopBluetoothDevicesDiscovery</code>停止搜索<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">startBluetoothDevicesDiscovery</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">    wx.<span class="title function_">startBluetoothDevicesDiscovery</span>(&#123;</span><br><span class="line">      <span class="attr">allowDuplicatesKey</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!res.<span class="property">isDiscovering</span>)&#123; <span class="comment">// 是否在搜索设备</span></span><br><span class="line">          _this.<span class="title function_">getBluetoothAdapterState</span>()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          _this.<span class="title function_">onBluetoothDeviceFound</span>() <span class="comment">// 搜索成功后，执行监听设备的api</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;蓝牙搜寻失败&quot;</span>)</span><br><span class="line">        wx.<span class="title function_">stopBluetoothDevicesDiscovery</span>() <span class="comment">// 没有搜索到设备</span></span><br><span class="line">        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-监听寻找到新设备"><a href="#4-监听寻找到新设备" class="headerlink" title="4. 监听寻找到新设备"></a>4. 监听寻找到新设备</h3><ul>
<li>监听寻找到新设备使用的是<code>wx.onBluetoothDeviceFound</code>，每搜到一个新设备就会触发一次，然后返回一个搜索到的设备列表，包含了设备名称和mac地址，一般都是使用设备名称和mac地址来匹配设备的<ul>
<li>安卓和IOS返回的deviceId不一样，安卓返回的是mac地址，IOS返回的是UUID，如果想通过mac地址来匹配设备，可以让mac地址存储在<code>advertisData</code>数据段中，然后解析这个数据段得到mac地址</li>
<li>我使用的是通过设备名称来进行匹配<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">onBluetoothDeviceFound</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  wx.<span class="title function_">onBluetoothDeviceFound</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">devices</span>.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(res.<span class="property">devices</span>[i].<span class="property">name</span> == <span class="string">&quot;设备名称&quot;</span> || res.<span class="property">devices</span>[i].<span class="property">localName</span> == <span class="string">&quot;设备名称&quot;</span>)&#123;</span><br><span class="line">        _this.<span class="title function_">setData</span>(&#123;</span><br><span class="line">          <span class="attr">deviceId</span>: res.<span class="property">devices</span>[i].<span class="property">deviceId</span> <span class="comment">// 把匹配设备的deviceId存到data中</span></span><br><span class="line">        &#125;)</span><br><span class="line">        wx.<span class="title function_">stopBluetoothDevicesDiscovery</span>() <span class="comment">// 匹配到设备后关闭搜索</span></span><br><span class="line">        _this.<span class="title function_">createBLEConnection</span>() <span class="comment">// 连接蓝牙</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-连接蓝牙"><a href="#5-连接蓝牙" class="headerlink" title="5. 连接蓝牙"></a>5. 连接蓝牙</h3><ul>
<li>连接蓝牙使用的是<code>wx.createBLEConnection</code>，连接蓝牙是通过<code>deviceId</code>连接，<code>deviceId</code>是通过<code>wx.onBluetoothDeviceFound</code>获取的</li>
<li>连接蓝牙容易失败，所以可以定一个变量<code>count</code>用来计算连接的次数，如果超出特定的次数就判断为连接失败，关闭蓝牙模块<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">createBLEConnection</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 连接低功耗蓝牙</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  wx.<span class="title function_">createBLEConnection</span>(&#123;</span><br><span class="line">    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      _this.<span class="title function_">getBLEDeviceServices</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接失败&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span>( count &lt; <span class="number">6</span> )&#123;</span><br><span class="line">        count++</span><br><span class="line">        _this.<span class="title function_">createBLEConnection</span>()</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 连接失败关闭蓝牙模块</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-获取蓝牙设备的服务"><a href="#6-获取蓝牙设备的服务" class="headerlink" title="6. 获取蓝牙设备的服务"></a>6. 获取蓝牙设备的服务</h3><ul>
<li>获取蓝牙设备的服务列表使用的是<code>wx.getBLEDeviceServices</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">getBLEDeviceServices</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  wx.<span class="title function_">getBLEDeviceServices</span>(&#123;</span><br><span class="line">    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">services</span>.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 如果提前得知可以直接判断，如果不知道可以用蓝牙工具看一下服务所需的功能</span></span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">services</span>[i].<span class="property">uuid</span> == _this.<span class="property">data</span>.<span class="property">service</span>)&#123;</span><br><span class="line">          _this.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">serviceId</span>: res.<span class="property">services</span>[i].<span class="property">uuid</span></span><br><span class="line">          &#125;)</span><br><span class="line">          _this.<span class="title function_">getBLEDeviceCharacteristics</span>()</span><br><span class="line">        &#125;   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取服务失败&quot;</span>)</span><br><span class="line">      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-获取服务中的特征值"><a href="#7-获取服务中的特征值" class="headerlink" title="7. 获取服务中的特征值"></a>7. 获取服务中的特征值</h3><ul>
<li>获取服务中的特征值使用的是<code>wx.getBLEDeviceCharacteristics</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">getBLEDeviceCharacteristics</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 获取服务中的特征值</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  wx.<span class="title function_">getBLEDeviceCharacteristics</span>(&#123;</span><br><span class="line">    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,</span><br><span class="line">    <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">characteristics</span>.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> model = res.<span class="property">characteristics</span>[i]</span><br><span class="line">        <span class="keyword">if</span> ((model.<span class="property">properties</span>.<span class="property">notify</span> || model.<span class="property">properties</span>.<span class="property">indicate</span>) &amp;&amp; (model.<span class="property">properties</span>.<span class="property">read</span> &amp;&amp; model.<span class="property">properties</span>.<span class="property">write</span>))&#123;</span><br><span class="line">          _this.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">characteristicId</span>: model.<span class="property">uuid</span></span><br><span class="line">          &#125;)</span><br><span class="line">          _this.<span class="title function_">notifyBLECharacteristicValueChange</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取服务中的特征值失败&quot;</span>)</span><br><span class="line">      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-启用特征值变化时的notify功能"><a href="#8-启用特征值变化时的notify功能" class="headerlink" title="8. 启用特征值变化时的notify功能"></a>8. 启用特征值变化时的notify功能</h3><ul>
<li>启用特征值变化时的notify功能使用的是<code>wx.notifyBLECharacteristicValueChange</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">notifyBLECharacteristicValueChange</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 启用蓝牙特征值变化时的notify功能</span></span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">    wx.<span class="title function_">notifyBLECharacteristicValueChange</span>(&#123;</span><br><span class="line">      <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,</span><br><span class="line">      <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,</span><br><span class="line">      <span class="attr">characteristicId</span>: _thisa.<span class="property">characteristicId</span>,</span><br><span class="line">      <span class="attr">state</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        wx.<span class="title function_">onBLECharacteristicValueChange</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(如果要打印需要从arraybuffer格式转为字符串或<span class="number">16</span>进制)</span><br><span class="line">        &#125;)</span><br><span class="line">        _this.<span class="title function_">writeBLECharacteristicValue</span>() <span class="comment">// 向蓝牙设备写入数据</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;启用BLE蓝牙特征值变化时的notify功能错误&quot;</span>)</span><br><span class="line">        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-向蓝牙设备写入数据"><a href="#9-向蓝牙设备写入数据" class="headerlink" title="9. 向蓝牙设备写入数据"></a>9. 向蓝牙设备写入数据</h3><ul>
<li>向蓝牙设备写入数据<code>wx.writeBLECharacteristicValue</code>，这时候就是输入提前设定好的指令<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">writeBLECharacteristicValue</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 向蓝牙设备写入数据</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  wx.<span class="title function_">writeBLECharacteristicValue</span>(&#123;</span><br><span class="line">    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,</span><br><span class="line">    <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,</span><br><span class="line">    <span class="attr">characteristicId</span>: _this.<span class="property">data</span>.<span class="property">characteristicId</span>,</span><br><span class="line">    <span class="attr">value</span>: buffer, <span class="comment">// 这个输入的指令，需要转换成ArrayBuffer</span></span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功&quot;</span>)</span><br><span class="line">      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;输入指令失败&quot;</span>)</span><br><span class="line">      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="转换格式"><a href="#转换格式" class="headerlink" title="转换格式"></a>转换格式</h3><ul>
<li><p>字符串转为arraybuffer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">string2buffer</span>: <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先将字符串转为16进制</span></span><br><span class="line">    <span class="keyword">let</span> val = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        val = str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">16</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val += <span class="string">&#x27;,&#x27;</span> + str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">16</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将16进制转化为ArrayBuffer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(val.<span class="title function_">match</span>(<span class="regexp">/[\da-f]&#123;2&#125;/gi</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">h</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">parseInt</span>(h, <span class="number">16</span>)</span><br><span class="line">    &#125;)).<span class="property">buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>arraybuffer转为字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ab2str</span>(<span class="params">u,f</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Blob</span>([u]);</span><br><span class="line">   <span class="keyword">var</span> r = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    r.<span class="title function_">readAsText</span>(b, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    r.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;<span class="keyword">if</span>(f)f.<span class="title function_">call</span>(<span class="literal">null</span>,r.<span class="property">result</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="蓝牙遇见的坑"><a href="#蓝牙遇见的坑" class="headerlink" title="蓝牙遇见的坑"></a>蓝牙遇见的坑</h3><ul>
<li>1.苹果手机有时候输入指令会显示发送成功，但是设备并没有反应<ul>
<li><pre><code>解决方法：把需要输入的指令改成每10毫秒输入一个字节
</code></pre>
</li>
<li>如果改成每10毫秒输入一个字节，安卓手机就会频繁出现10008错误</li>
<li>针对这个问题我用了一个不太好的方法，我判断了一下手机的类型，如果是ios的就分10毫秒输入，如果是安卓的就一次性输入</li>
</ul>
</li>
<li>2.在调用<code>wx.onBluetoothDeviceFound</code>这个api时ios会监听两次，然后就会导致最后设备会有两次指令输入<ul>
<li>解决方法：我在搜索蓝牙设备之前做了一个定时器，然后用<code>getBluetoothDevices</code>来查看所有已搜索到的蓝牙，在这个里面做判断来连接蓝牙设备</li>
</ul>
</li>
<li>我上面的步骤没有把这些坑的解决步骤加上，如果碰见此类问题，可以自己在合适的位置修改一下</li>
</ul>
<h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>我自己做了一个小程序的蓝牙调试器，下面是小程序码，欢迎大家体验<br><img src="https://img-blog.csdnimg.cn/20200123154720532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>解决react状态管理---React Query</title>
    <url>/2021/06/12/%E8%A7%A3%E5%86%B3react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-ReactQuery/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210612171112847.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="React Query"></p>
<h3 id="什么是React-Query"><a href="#什么是React-Query" class="headerlink" title="什么是React Query"></a>什么是React Query</h3><ul>
<li><code>react-query</code>是一个适用于react hooks的请求库，它可以为任何类型的异步数据提供React状态管理功能，使React中的获取、缓存、同步和更新服务器数据变得轻而易举</li>
<li><code>react-query</code>与一些传统的状态管理库如redux,mobx不同，它是负责管理服务器与客户端之间的状态，一些用户交互的中间状态，如loading状态，错误信息等都是通过hooks直接返回</li>
<li><a href="https://react-query-v2.tanstack.com/">React Query官网</a></li>
</ul>
<h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><ol>
<li><code>yarn add react-query</code> or <code>npm i react-query</code>安装react-query</li>
<li>使用<code>QueryClientProvider</code>组件连接并提供一个<code>QueryClient</code>到你的应用程序<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">QueryClient</span>, <span class="title class_">QueryClientProvider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">QueryClientProvider</span> client=&#123;<span class="keyword">new</span> <span class="title class_">QueryClient</span>()&#125;&gt;</span><br><span class="line">  &#123; ... &#125;</span><br><span class="line">&lt;/<span class="title class_">QueryClientProvider</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Devtools"><a href="#Devtools" class="headerlink" title="Devtools"></a>Devtools</h4><ul>
<li><code>yarn add react-query-devtools</code> or <code>npm i --save react-query-devtools</code>安装Devtools</li>
<li><code>react-query-devtools</code>是与<code>react-query</code>相匹配的开发工具</li>
<li>可在开发中实时查看缓存，手动获取和删除查询等等<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactQueryDevtools</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query-devtools&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span>    </span></span><br><span class="line"><span class="language-xml">      &#123; ... &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ReactQueryDevtools</span> <span class="attr">initialIsOpen</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><ul>
<li>react-query最常用的两个hook，查询(<code>useQuery</code>)、增删改(<code>useMutation</code>)</li>
</ul>
<h4 id="useQuery"><a href="#useQuery" class="headerlink" title="useQuery"></a>useQuery</h4><ul>
<li><code>useQuery</code>：在<code>React Query</code>中，查询是对某些异步数据源的声明性依赖。查询可以与任何基于Promise的方法(GET)一起使用，从服务器获取数据<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useTodos</span> = (<span class="params">param</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> request = <span class="title function_">useHttp</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一个参数是QueryKey，是查询的关键，是一个独一无二的key，并在之后的增删改中需要，</span></span><br><span class="line"><span class="comment">   *   如果需要动态的QueryKey，可以使用数组的方式，如[&#x27;todos&#x27;, params]</span></span><br><span class="line"><span class="comment">   * 第二个参数是用于获取数据的异步函数</span></span><br><span class="line"><span class="comment">   * useQuery的响应返回就是获取到的数据和一些中间状态，如isLoading，error，isIdle...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useQuery</span>(<span class="string">&#x27;todos&#x27;</span>, <span class="function">() =&gt;</span></span><br><span class="line">    <span class="title function_">request</span>(<span class="string">&#x27;todos&#x27;</span>, &#123; <span class="attr">data</span>: param &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在UI组件调用</span></span><br><span class="line"><span class="keyword">const</span> &#123; isLoading, error, <span class="attr">data</span>: todos &#125; = <span class="title function_">useTodos</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="useMutation"><a href="#useMutation" class="headerlink" title="useMutation"></a>useMutation</h4><ul>
<li><code>useMutation</code>：常用于创建&#x2F;更新&#x2F;删除数据或执行服务器副作用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useAddTodo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> request = <span class="title function_">useHttp</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 第一个参数是执行操作的异步函数，在返回的mutate中触发</span></span><br><span class="line"><span class="comment">   * 第二个参数是执行成功或者失败的一些配置函数，可用于一些处理缓存的操作，例如乐观更新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMutation</span>(</span><br><span class="line">    <span class="function">(<span class="params">data</span>) =&gt;</span></span><br><span class="line">      <span class="title function_">request</span>(<span class="string">`todos`</span>, &#123;</span><br><span class="line">        data,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="title function_">onSuccess</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">      <span class="title function_">onError</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">      <span class="title function_">onSettled</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作组件调用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TodosAddBtn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> &#123; mutateAsync, isLoading, error &#125; = <span class="title function_">useAddTodo</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> mutateAsync(todoData)&#125;&gt;add<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="例：用第二个参数配置乐观更新"><a href="#例：用第二个参数配置乐观更新" class="headerlink" title="例：用第二个参数配置乐观更新"></a>例：用第二个参数配置乐观更新</h5><ul>
<li>乐观更新就是在一些请求或者数据处理没有结束的时候，提前给用户显示理想的结果，如果失败就回滚更新<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">useAddConfig</span> = (<span class="params">queryKey</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取当前QueryClient的实例</span></span><br><span class="line">  <span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 当mutate被调用时触发</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">onMutate</span>(<span class="params">target</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取当前数据快照，用于错误时回滚更新</span></span><br><span class="line">      <span class="keyword">const</span> previousItems = queryClient.<span class="title function_">getQueryData</span>(queryKey)</span><br><span class="line">      <span class="comment">// 乐观更新为新值</span></span><br><span class="line">      queryClient.<span class="title function_">setQueryData</span>(queryKey, <span class="function">(<span class="params">old</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">target, old</span>) =&gt;</span> (old ? [...old, target] : [])</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这个返回值会作为最后一个参数传递给onError和onSettled</span></span><br><span class="line">      <span class="keyword">return</span> &#123; previousItems &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 成功回调 清除缓存</span></span><br><span class="line">    <span class="attr">onSuccess</span>: <span class="function">() =&gt;</span> queryClient.<span class="title function_">invalidateQueries</span>(queryKey),</span><br><span class="line">    <span class="comment">// 失败回调</span></span><br><span class="line">    <span class="title function_">onError</span>(<span class="params">error, newItem, context</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前queryKey的数据回滚</span></span><br><span class="line">      queryClient.<span class="title function_">setQueryData</span>(</span><br><span class="line">        queryKey,</span><br><span class="line">        context.<span class="property">previousItems</span></span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 无论错误或者成功都会触发，此例子没有使用</span></span><br><span class="line">    <span class="title function_">onSettled</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>本地&#x2F;客户端中间状态<ul>
<li>redux与react-query都可，没有较大的优缺点</li>
</ul>
</li>
<li>服务端中间状态<ul>
<li>推荐react-query，将服务器状态从全局状态中解放出来，用更少的代码实现复杂的需求，让你的状态管理更优雅</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>ReactQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>解析Vue3patch核心算法patchKeyedChildren</title>
    <url>/2022/08/25/%E8%A7%A3%E6%9E%90Vue3patch%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95patchKeyedChildren/</url>
    <content><![CDATA[<h3 id="解析Vue3patch核心算法patchKeyedChildren"><a href="#解析Vue3patch核心算法patchKeyedChildren" class="headerlink" title="解析Vue3patch核心算法patchKeyedChildren"></a>解析Vue3patch核心算法patchKeyedChildren</h3><ul>
<li>locate：<code>runtime-core &gt; renderer &gt; baseCreateRenderer &gt; patchKeyedChildren</code></li>
<li>patchKeyedChildren是patch算法中较为复杂的一段，更是vue技术栈面试的高频点，最初我是在vue3.0 beta版本时大概看过源码，后来在《vue设计与分析》中看了霍春阳大佬的解析，本篇就简要分析一下做个记录</li>
<li>首先patchKeyedChildren是在子列表对比并且有key的情况会进入，并且逻辑大致分为5步，这个看源码官方注释就可以看出</li>
</ul>
<h4 id="第一步，从前向后遍历"><a href="#第一步，从前向后遍历" class="headerlink" title="第一步，从前向后遍历"></a>第一步，从前向后遍历</h4><p>这一步是从节点组头部向尾部遍历，如果遍历过程中遇到相似节点，就进行patch对比，否则就退出遍历，并记录当前遍历的最新下标</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">  <span class="keyword">const</span> n1 = c1[i]</span><br><span class="line">  <span class="keyword">const</span> n2 = (c2[i] = optimized</span><br><span class="line">    ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">    : <span class="title function_">normalizeVNode</span>(c2[i]))</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      n1,</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二步，从后向前遍历"><a href="#第二步，从后向前遍历" class="headerlink" title="第二步，从后向前遍历"></a>第二步，从后向前遍历</h4><p>从后向前遍历，如果遇到第一步记录的下标就停止，然后遍历过程中，如果遇到相似节点也是直接进行patch对比，如果不相同就是直接退出遍历，并且记录旧节点组和新节点组的尾指针</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">  <span class="keyword">const</span> n1 = c1[e1]</span><br><span class="line">  <span class="keyword">const</span> n2 = (c2[e2] = optimized</span><br><span class="line">    ? <span class="title function_">cloneIfMounted</span>(c2[e2] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">    : <span class="title function_">normalizeVNode</span>(c2[e2]))</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      n1,</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  e1--</span><br><span class="line">  e2--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三步，检查旧节点组"><a href="#第三步，检查旧节点组" class="headerlink" title="第三步，检查旧节点组"></a>第三步，检查旧节点组</h4><p>这一步就是检查旧节点组在上两步的遍历后是否遍历完，如果遍历完，那么新节点组没有遍历完的就都是新的dom，可以全部当作新增节点进行挂载处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> anchor = nextPos &lt; l2 ? (c2[nextPos] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">      <span class="comment">// patch第一个参数为null，就是代表没有旧节点，直接将新节点插入</span></span><br><span class="line">      <span class="title function_">patch</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        (c2[i] = optimized</span><br><span class="line">          ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">          : <span class="title function_">normalizeVNode</span>(c2[i])),</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        slotScopeIds,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第四步，检查新节点组"><a href="#第四步，检查新节点组" class="headerlink" title="第四步，检查新节点组"></a>第四步，检查新节点组</h4><p>如果上一步检查旧节点未遍历完，那么就检查新节点组是否遍历完，如果遍历完，那么旧的节点组剩余的节点说明都是要卸载的，因为都不需要了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">  <span class="comment">// 旧子节点未被遍历完</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第五步，未知序列"><a href="#第五步，未知序列" class="headerlink" title="第五步，未知序列"></a>第五步，未知序列</h4><ul>
<li>如果新旧节点组都未遍历完，说明存在未知序列，可能存在位移等情况，就需要进一步处理</li>
<li>首先创建一个数组，用于记录新旧节点的对应关系<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// toBePatched是新序列的节点数量 e2 - s2 + 1</span></span><br><span class="line"><span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li>然后会遍历旧节点组，这里会用两个变量记录<ul>
<li><code>let moved = false</code>：位移标识，用于判断是否需要位移</li>
<li><code>let patched = 0</code>：记录已执行patch的新节点数量，用于处理如果在更新时更新过的数量大于需要更新的节点数量，就卸载对应旧节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevChild = c1[i]</span><br><span class="line">  <span class="comment">// 如果已更新数量大于新节点数量，就卸载节点</span></span><br><span class="line">  <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newIndex <span class="comment">//新旧节点key相同的新节点index</span></span><br><span class="line">  <span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="title function_">isSameVNodeType</span>(prevChild, c2[j] <span class="keyword">as</span> <span class="title class_">VNode</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        newIndex = j</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果newIndex为空，则说明未找到与旧节点对应的新节点，直接卸载</span></span><br><span class="line">  <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新新旧节点关系表</span></span><br><span class="line">    newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的maxNexIndexSoFar是记录每次patch最大index</span></span><br><span class="line"><span class="comment">     * 也是用于判断是否产生了位移，因为如果新节点index比最大index小，就说明发生了位移</span></span><br><span class="line"><span class="comment">     * 例如：</span></span><br><span class="line"><span class="comment">     *  (a b) c</span></span><br><span class="line"><span class="comment">     *  (a c  b)</span></span><br><span class="line"><span class="comment">     * 在新旧序列对比b，c时，由于c最新的newIndex已经小于b对应的newIndex，因此会记录需要位移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">      maxNewIndexSoFar = newIndex</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      moved = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      prevChild,</span><br><span class="line">      c2[newIndex] <span class="keyword">as</span> <span class="title class_">VNode</span>,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">    patched++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>遍历完旧序列后，就需要确定如何位移</li>
<li>首先是根据新旧节点关系表生成最长递增子序列(这个算法就不陈述了，较复杂，可以看<a href="https://juejin.cn/post/6952674285311754276#comment">精读《DOM diff 最长上升子序列》</a>)，然后倒序遍历新子节点<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最长递增子序列</span></span><br><span class="line"><span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">  ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap)</span><br><span class="line">  : <span class="variable constant_">EMPTY_ARR</span></span><br><span class="line">j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"><span class="comment">// 从新序列尾部向前遍历，目的是为了使用上一个遍历的节点做锚点</span></span><br><span class="line"><span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextIndex = s2 + i</span><br><span class="line">  <span class="keyword">const</span> nextChild = c2[nextIndex] <span class="keyword">as</span> <span class="title class_">VNode</span></span><br><span class="line">  <span class="comment">// 如果是序列的最后一个节点，anchor就是父节点对应的anchor，否则就是上一个子节点</span></span><br><span class="line">  <span class="keyword">const</span> anchor =</span><br><span class="line">    nextIndex + <span class="number">1</span> &lt; l2 ? (c2[nextIndex + <span class="number">1</span>] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor</span><br><span class="line">  <span class="comment">// 如果newIndexToOldIndexMap[i]还是0，那么说明新节点没有对应的旧节点，说明是新节点，直接挂载</span></span><br><span class="line">  <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">patch</span>(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChild,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      slotScopeIds,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">    <span class="comment">// 然后在moved为true的情况下，如果最长子序列为空或者最长子序列和当前访问的新节点index不同，说明就需要进行位移</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">      <span class="title function_">move</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>解析nextTick---vue3任务调度</title>
    <url>/2021/07/17/%E8%A7%A3%E6%9E%90nextTick-vue3%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><ul>
<li>定义：将回调推迟到下一个 DOM 更新周期之后执行，在更改了一些数据以等待 DOM 更新后立即使用它</li>
<li>在实际中使用这个方法一般是用于组件更新，你需要获取更新后的数据，所以使用nextTick等待DOM更新<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello!&#x27;</span>)</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">changeMessage</span> = <span class="keyword">async</span> newMessage =&gt; &#123;</span><br><span class="line">        message.<span class="property">value</span> = newMessage</span><br><span class="line">        <span class="comment">// 这里的value是旧值</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">nextTick</span>()</span><br><span class="line">        <span class="comment">// nextTick后获取的就是DOM更新后的value</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Now DOM is updated&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>这个api使用时相当简单，而且相当容易理解，但是为了知其意，还是要翻一下源码了解它的执行机制<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="variable language_">this</span>: ComponentPublicInstance | <span class="built_in">void</span>,</span></span><br><span class="line"><span class="params">  fn?: () =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise</span><br><span class="line">  <span class="keyword">return</span> fn ? p.<span class="title function_">then</span>(<span class="variable language_">this</span> ? fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>) : fn) : p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上面是vue源码中nextTick的实现，为了搞清楚实现逻辑，就必须搞懂<code>currentFlushPromise</code>这个变量的含义，所以要从任务的调度机制开始分析</li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>首先这个调度机制的功能在<code>runtime-core</code>的<code>scheduler</code>文件</p>
<ul>
<li><p>API</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个文件会抛出以下几个API函数</span></span><br><span class="line"><span class="title function_">nextTick</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 将函数在任务队列清空后执行</span></span><br><span class="line"><span class="title function_">queueJob</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加任务并开始执行任务队列</span></span><br><span class="line"><span class="title function_">invalidateJob</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 删除任务</span></span><br><span class="line"><span class="title function_">queuePreFlushCb</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加前置回调函数并开始执行任务队列</span></span><br><span class="line"><span class="title function_">queuePostFlushCb</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加后置回调函数并开始执行任务队列</span></span><br><span class="line"><span class="title function_">flushPreFlushCbs</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 执行前置回调函数</span></span><br><span class="line"><span class="title function_">flushPostFlushCbs</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 执行后置回调函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>我们首先要知道几个关键变量</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isFlushing = <span class="literal">false</span> <span class="comment">// 是否正在清空任务队列</span></span><br><span class="line"><span class="keyword">let</span> isFlushPending = <span class="literal">false</span> <span class="comment">// 清队任务已创建，等待清空状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">SchedulerJob</span>[] = [] <span class="comment">// 任务队列</span></span><br><span class="line"><span class="keyword">let</span> flushIndex = <span class="number">0</span> <span class="comment">// 当前正在执行的任务在任务队列中的索引</span></span><br></pre></td></tr></table></figure></li>
<li><p>然后我们从<code>queueJob</code>这个函数开始</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  这个函数主要是将一个任务进行入队操作</span></span><br><span class="line"><span class="comment">  然后在满足条件的情况下启动queueFlush</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueJob</span>(<span class="params">job: SchedulerJob</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务可入队逻辑</span></span><br><span class="line"><span class="comment">     * 1. 任务队列为空</span></span><br><span class="line"><span class="comment">     * 2. 待入队任务不能存在于任务队列中(按情况分析)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (!queue.<span class="property">length</span> ||</span><br><span class="line">        !queue.<span class="title function_">includes</span>(</span><br><span class="line">          job,</span><br><span class="line">          <span class="comment">/* </span></span><br><span class="line"><span class="comment">            在正在清空队列且当前待入队任务是可以递归时，</span></span><br><span class="line"><span class="comment">            说明当前任务一定和当前正在执行任务是同一任务，所以+1，</span></span><br><span class="line"><span class="comment">            就是为了保证待入队任务和正在执行任务相同，但不能和后面待执行任务相同</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          isFlushing &amp;&amp; job.<span class="property">allowRecurse</span> ? flushIndex + <span class="number">1</span> : flushIndex</span><br><span class="line">        )) &amp;&amp;</span><br><span class="line">      job !== currentPreFlushParentJob</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 二分查找任务在队列中的位置</span></span><br><span class="line">      <span class="keyword">const</span> pos = <span class="title function_">findInsertionIndex</span>(job)</span><br><span class="line">      <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">splice</span>(pos, <span class="number">0</span>, job)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(job)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">queueFlush</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>queueFlush</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      清队任务创建后禁止再次创建更多的清队任务</span></span><br><span class="line"><span class="comment">      因为在入队操作完成后，flushJobs会在一次递归中将任务队列全部清空，所以只需要一次清队任务即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">      isFlushPending = <span class="literal">true</span></span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">        清队任务创建成功，并记录下当前清队任务，这个标记可以用于nextTick创建自定义函数，</span></span><br><span class="line"><span class="comment">        说明nextTick的执行时机是在清队任务后的，其实从这个地方就可以理解nextTick的执行原理了</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>flushJobs</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空任务队列</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params">seen?: CountMap</span>) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">false</span> <span class="comment">// 关闭清队任务等待状态</span></span><br><span class="line">    isFlushing = <span class="literal">true</span> <span class="comment">// 开启正在清空队列状态</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      seen = seen || <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空前置回调任务队列</span></span><br><span class="line">    <span class="title function_">flushPreFlushCbs</span>(seen)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      任务队列中的任务根据ID进行排序的原因</span></span><br><span class="line"><span class="comment">        1. 因为组件更新是从父组件到子组件的，而任务更新是在数据源更新时触发的，所以为了更新任务的顺序就需要进行排序</span></span><br><span class="line"><span class="comment">        2. 如果在父组件更新期间已经卸载了组件，那么子组件的更新任务就可以跳过</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    queue.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">getId</span>(a) - <span class="title function_">getId</span>(b))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历任务队列</span></span><br><span class="line">      <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.<span class="property">length</span>; flushIndex++) &#123;</span><br><span class="line">        <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">        <span class="keyword">if</span> (job &amp;&amp; job.<span class="property">active</span> !== <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="title function_">checkRecursiveUpdates</span>(seen!, job)) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 执行当前任务</span></span><br><span class="line">          <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="title class_">ErrorCodes</span>.<span class="property">SCHEDULER</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 重置当前任务索引</span></span><br><span class="line">      flushIndex = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 清空任务队列</span></span><br><span class="line">      queue.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行后置回调任务队列</span></span><br><span class="line">      <span class="title function_">flushPostFlushCbs</span>(seen)</span><br><span class="line">        <span class="comment">// 重置清队任务的状态</span></span><br><span class="line">      isFlushing = <span class="literal">false</span></span><br><span class="line">      currentFlushPromise = <span class="literal">null</span></span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">        因为清队任务执行期间也会有任务入队，所以为了清队执行完成</span></span><br><span class="line"><span class="comment">        就需要判断各任务队列的长度，然后递归执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        queue.<span class="property">length</span> ||</span><br><span class="line">        pendingPreFlushCbs.<span class="property">length</span> ||</span><br><span class="line">        pendingPostFlushCbs.<span class="property">length</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="title function_">flushJobs</span>(seen)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>nextTick的执行时机是在任务队列(前置、主任务、后置)清除后的，<code>currentFlushPromise</code>是清队任务的promise标记</li>
<li>任务队列执行顺序：执行前置回调任务队列 -&gt; 执行主任务队列 -&gt; 执行后置回调任务队列</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3响应式分析</title>
    <url>/2021/08/01/%E8%A7%A3%E6%9E%90reactive-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="vue3响应式分析"><a href="#vue3响应式分析" class="headerlink" title="vue3响应式分析"></a>vue3响应式分析</h2><ol>
<li>首先对vue3响应式分析之前，需要对前置知识<code>Proxy</code>和<code>Reflect</code>有所了解，，关于这两个知识我推荐看阮一峰老师的<a href="https://es6.ruanyifeng.com/#README">ES6入门教程</a></li>
<li>vue3的响应式我是以reactive为入口进行梳理，流程如下图<br><img src="https://img-blog.csdnimg.cn/83a41b1d8a3044d6b8135850ea972ed1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>源码位置：<code>reactivity/src/...</code>，分四部分解析</li>
</ol>
<ul>
<li>reactive文件：目标对象转化为proxy实例</li>
<li>baseHandler文件：基本类型处理器</li>
<li>collectionHandlers文件：Map、Set处理器</li>
<li>effect文件：收集触发依赖</li>
</ul>
<ol start="4">
<li>如果不想看源码解析，可以直接看总结🐶</li>
</ol>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul>
<li><code>reactive</code>：将一个JS对象转为具有响应式的proxy实例<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是只读数据，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (target &amp;&amp; (target <span class="keyword">as</span> <span class="title class_">Target</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(</span><br><span class="line">      target,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      mutableHandlers,</span><br><span class="line">      mutableCollectionHandlers,</span><br><span class="line">      reactiveMap</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>createReactiveObject</code><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: Target, <span class="comment">// 源对象</span></span></span><br><span class="line"><span class="params">    isReadonly: <span class="built_in">boolean</span>, <span class="comment">// 是否只读</span></span></span><br><span class="line"><span class="params">    baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;, <span class="comment">// 基本类型的handlers</span></span></span><br><span class="line"><span class="params">    collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;, <span class="comment">// 主要针对(set、map、weakSet、weakMap)的handlers</span></span></span><br><span class="line"><span class="params">    proxyMap: <span class="built_in">WeakMap</span>&lt;Target, <span class="built_in">any</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果不是一个对象，直接返回，并且在开发环境发出警告</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经是响应式，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      target[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>] &amp;&amp;</span><br><span class="line">      !(isReadonly &amp;&amp; target[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目标对象已经存在代理，直接返回</span></span><br><span class="line">    <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">      <span class="keyword">return</span> existingProxy</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果类型值不是Object、Array、Map、Set、WeakMap、WeakSet的，直接返回</span></span><br><span class="line">    <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target)</span><br><span class="line">    <span class="keyword">if</span> (targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的类型值赋予不同的handlers，就是我之前图上画的分开处理</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      把set、Map这种数据与基础数据分开处理，是因为Map、Set中存储的数据必须通过this进行访问</span></span><br><span class="line"><span class="comment">      但是被proxy劫持后，this就变成了proxy，</span></span><br><span class="line"><span class="comment">      所以需要特殊处理，把劫持方法进行重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">      target,</span><br><span class="line">      targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers</span><br><span class="line">    )</span><br><span class="line">    proxyMap.<span class="title function_">set</span>(target, proxy)</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h3><p><code>baseHandler</code>主要分析reactive的处理器对象<code>mutableHandlers</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对get set delete has onwKeys做了拦截处理</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | <span class="built_in">symbol</span>, receiver: <span class="built_in">object</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 访问标志位时的逻辑处理</span></span><br><span class="line">    <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span> &amp;&amp;</span><br><span class="line">      receiver ===</span><br><span class="line">        (isReadonly</span><br><span class="line">          ? shallow</span><br><span class="line">            ? shallowReadonlyMap</span><br><span class="line">            : readonlyMap</span><br><span class="line">          : shallow</span><br><span class="line">            ? shallowReactiveMap</span><br><span class="line">            : reactiveMap</span><br><span class="line">        ).<span class="title function_">get</span>(target)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果target是数组并且key属于一些数组的原始方法，即触发拦截</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key是symbol的内置方法，或者是原型对象，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只读对象不收集依赖，因为不会触发依赖更新</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅层响应立即返回，不递归转化</span></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是ref对象(数组除外)，返回真正的值，</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;</span><br><span class="line">      <span class="keyword">const</span> shouldUnwrap = !targetIsArray || !<span class="title function_">isIntegerKey</span>(key)</span><br><span class="line">      <span class="keyword">return</span> shouldUnwrap ? res.<span class="property">value</span> : res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;</span><br><span class="line">      <span class="comment">// 由于proxy只能代理一层，所以target[key]的值如果是对象，就继续对其进行代理</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组方法拦截: 对数组的两种原生方法进行了拦截</p>
<ul>
<li>遍历查找的方法：includes、indexOf、lastIndexOf</li>
<li>改变数组长度的方法：push、pop、shift、unshift、splice<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArrayInstrumentations</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">instrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;&#125;</span><br><span class="line">    ;([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> method = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">      instrumentations[key] = <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;</span><br><span class="line">        <span class="comment">// 这一步是为了取原始实例，因为当前的this是receiver</span></span><br><span class="line">        <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)</span><br><span class="line">        <span class="comment">// 搜集依赖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">          <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 触发方法，如果没有找到对应的值，就取原始值再遍历</span></span><br><span class="line">        <span class="keyword">const</span> res = method.<span class="title function_">apply</span>(arr, args)</span><br><span class="line">        <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> method.<span class="title function_">apply</span>(arr, args.<span class="title function_">map</span>(toRaw))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      因为改变数组长度的方法，执行期间会触发length的get和set</span></span><br><span class="line"><span class="comment">      就回导致无限循环track和trigger</span></span><br><span class="line"><span class="comment">      所以就用pauseTracking()禁用依赖收集，触发方法后，</span></span><br><span class="line"><span class="comment">      再用resetTracking()恢复track</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ;([<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> method = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[key] <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">      instrumentations[key] = <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;</span><br><span class="line">        <span class="title function_">pauseTracking</span>()</span><br><span class="line">        <span class="keyword">const</span> res = method.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        <span class="title function_">resetTracking</span>()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instrumentations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">    key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span></span><br><span class="line"><span class="params">    value: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">    receiver: <span class="built_in">object</span></span></span><br><span class="line"><span class="params">  </span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key]</span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      value = <span class="title function_">toRaw</span>(value)</span><br><span class="line">      oldValue = <span class="title function_">toRaw</span>(oldValue)</span><br><span class="line">      <span class="comment">// 如果原来的值是ref，但新的值不是，则将新的值赋给oldValue.value</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;</span><br><span class="line">        oldValue.<span class="property">value</span> = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key)</span><br><span class="line">        ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span></span><br><span class="line">        : <span class="title function_">hasOwn</span>(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断receiver是当前对象的proxy实例，防止原型链上的proxy触发更新</span></span><br><span class="line">    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;</span><br><span class="line">      <span class="comment">// 判断新增属性还是修改属性</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="deleteProperty、has…"><a href="#deleteProperty、has…" class="headerlink" title="deleteProperty、has…"></a>deleteProperty、has…</h4><ul>
<li>deleteProperty、has、ownKeys的源码就不贴了，都是判断key的属性，然后选择触发或者收集依赖</li>
</ul>
<h3 id="collectionHandlers"><a href="#collectionHandlers" class="headerlink" title="collectionHandlers"></a>collectionHandlers</h3><ul>
<li>collection主要分析reactive的重写方法对象mutableInstrumentations<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要对以下原生api进行了改写</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">mutableInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">size</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span>) <span class="keyword">as</span> <span class="title class_">IterableCollections</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    has,</span><br><span class="line">    add,</span><br><span class="line">    set,</span><br><span class="line">    <span class="attr">delete</span>: deleteEntry,</span><br><span class="line">    clear,</span><br><span class="line">    <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span></span><br><span class="line"><span class="params">    target: MapTypes,</span></span><br><span class="line"><span class="params">    key: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">    isReadonly = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">    isShallow = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取原始值重新赋值给target</span></span><br><span class="line">    target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对target源对象和key进一步获取原始值</span></span><br><span class="line">    <span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target)</span><br><span class="line">    <span class="keyword">const</span> rawKey = <span class="title function_">toRaw</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前key和原始key均进行依赖收集(track)</span></span><br><span class="line">    <span class="keyword">if</span> (key !== rawKey) &#123;</span><br><span class="line">      !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">    !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, rawKey)</span><br><span class="line">    <span class="keyword">const</span> &#123; has &#125; = <span class="title function_">getProto</span>(rawTarget)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的转换函数</span></span><br><span class="line">    <span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      如果源对象有key对应的属性，就通过原生get方法取到值，</span></span><br><span class="line"><span class="comment">      并对该值进行响应式转换，返回转换后的响应式对象，</span></span><br><span class="line"><span class="comment">      如果没有，就去key原始值中去查找</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(key))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, rawKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(rawKey))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target !== rawTarget) &#123;</span><br><span class="line">      target.<span class="title function_">get</span>(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对size属性做get拦截</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">size</span>(<span class="params">target: IterableCollections, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]</span><br><span class="line">  <span class="comment">// 获取size和获取数组的length类似，都用专门的key做依赖收集</span></span><br><span class="line">  !isReadonly &amp;&amp; <span class="title function_">track</span>(<span class="title function_">toRaw</span>(target), <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, <span class="string">&#x27;size&#x27;</span>, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span>, value: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取value和this上下文的原始值</span></span><br><span class="line">  value = <span class="title function_">toRaw</span>(value)</span><br><span class="line">  <span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123; has, get &#125; = <span class="title function_">getProto</span>(target)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    判断源对象是否已经存在对应的key</span></span><br><span class="line"><span class="comment">    1. 首先查找源对象是否已有key对应的属性</span></span><br><span class="line"><span class="comment">    2. 如果没有，再查找key对应的原始值在源对象的属性是否存在</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> hadKey = has.<span class="title function_">call</span>(target, key)</span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    key = <span class="title function_">toRaw</span>(key)</span><br><span class="line">    hadKey = has.<span class="title function_">call</span>(target, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="title function_">checkIdentityKeys</span>(target, has, key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldValue = get.<span class="title function_">call</span>(target, key)</span><br><span class="line">  target.<span class="title function_">set</span>(key, value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发依赖，新增属性和修改属性分开进行trigger</span></span><br><span class="line">  <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;</span><br><span class="line">    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="has、clear…"><a href="#has、clear…" class="headerlink" title="has、clear…"></a>has、clear…</h4><ul>
<li>其余重写方法我就不上代码了，不同点是单个属性触发单个的依赖，如果是遍历所有属性的方法就触发所有依赖</li>
</ul>
<h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><ul>
<li>effect文件作为响应式的核心，主要负责收集依赖，触发依赖</li>
</ul>
<h4 id="effect-1"><a href="#effect-1" class="headerlink" title="effect"></a>effect</h4><ul>
<li>effect函数主要是生成收集依赖所需的依赖函数<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> effect&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">    <span class="attr">options</span>: <span class="title class_">ReactiveEffectOptions</span> = <span class="variable constant_">EMPTY_OBJ</span></span><br><span class="line">): <span class="title class_">ReactiveEffect</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果已经是effect函数，取得原来的fn</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isEffect</span>(fn)) &#123;</span><br><span class="line">      fn = fn.<span class="property">raw</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> effect = <span class="title function_">createReactiveEffect</span>(fn, options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果lazy为false，立即执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>createReactiveEffect</code>：生成effect对象<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> createReactiveEffect&lt;T = <span class="built_in">any</span>&gt;(</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">    <span class="attr">options</span>: <span class="title class_">ReactiveEffectOptions</span></span><br><span class="line">): <span class="title class_">ReactiveEffect</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> effect = <span class="keyword">function</span> <span class="title function_">reactiveEffect</span>(<span class="params"></span>): <span class="built_in">unknown</span> &#123;</span><br><span class="line">      <span class="comment">// 没有激活，已经调用stop函数停止监听</span></span><br><span class="line">      <span class="keyword">if</span> (!effect.<span class="property">active</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * effectStack是一个全局的effect栈结构</span></span><br><span class="line"><span class="comment">       * 设计为栈结构是因为如果effect是嵌套时，为了防止内层副作用函数覆盖外层副作用函数，在收集时只收集栈顶的，这样就不会收集到错误的副作用函数</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!effectStack.<span class="title function_">includes</span>(effect)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为了保证当前effect的dep是最新，因为在一些判断处理中，可能会导致一些无效的副作用函数</span></span><br><span class="line"><span class="comment">         * 所以为了取消这些不必要的更新，就要清除effect依赖</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title function_">cleanup</span>(effect)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="title function_">enableTracking</span>() <span class="comment">// 重新收集依赖</span></span><br><span class="line">          effectStack.<span class="title function_">push</span>(effect)</span><br><span class="line">          activeEffect = effect</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">/* </span></span><br><span class="line"><span class="comment">            track将依赖函数activeEffect添加到对应的dep中，</span></span><br><span class="line"><span class="comment">            然后将activeEffect重置为上一个effect的值</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          effectStack.<span class="title function_">pop</span>()</span><br><span class="line">          <span class="title function_">resetTracking</span>()</span><br><span class="line">          activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">as</span> <span class="title class_">ReactiveEffect</span></span><br><span class="line">    effect.<span class="property">id</span> = uid++ <span class="comment">// 自增ID</span></span><br><span class="line">    effect.<span class="property">allowRecurse</span> = !!options.<span class="property">allowRecurse</span> <span class="comment">// 递归状态</span></span><br><span class="line">    effect.<span class="property">_isEffect</span> = <span class="literal">true</span> <span class="comment">// 用于标识方法是不是effect</span></span><br><span class="line">    effect.<span class="property">active</span> = <span class="literal">true</span> <span class="comment">// 用于判断当前effect是否激活，有一个stop()来将它设为false</span></span><br><span class="line">    effect.<span class="property">raw</span> = fn <span class="comment">// effect的执行函数</span></span><br><span class="line">    effect.<span class="property">deps</span> = [] <span class="comment">// 用于收集依赖</span></span><br><span class="line">    effect.<span class="property">options</span> = options <span class="comment">// 创建effect传入的options</span></span><br><span class="line">    <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>activeEffect就是标记track所需的依赖函数</li>
</ul>
<h4 id="track"><a href="#track" class="headerlink" title="track"></a>track</h4><ul>
<li>track就是baseHandler和collectionHandlers文件中频繁使用的收集依赖函数</li>
<li>首先需要看一个关键变量targetMap<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// targetMap是依赖管理中心，收集依赖和触发依赖都依托于这个Map数据</span></span><br><span class="line"><span class="comment">// 下面是targetMap的定义(target -&gt; key -&gt; dep)</span></span><br><span class="line"><span class="comment">// target: 监听的对象源</span></span><br><span class="line"><span class="comment">// key: 监听的键值</span></span><br><span class="line"><span class="comment">// dep：依赖函数</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Dep</span> = <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KeyToDepMap</span> = <span class="title class_">Map</span>&lt;<span class="built_in">any</span>, <span class="title class_">Dep</span>&gt;</span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">any</span>, <span class="title class_">KeyToDepMap</span>&gt;()</span><br><span class="line"><span class="comment">// 格式大致为</span></span><br><span class="line">targetMap = &#123;</span><br><span class="line">  <span class="attr">target</span>: &#123;</span><br><span class="line">    <span class="attr">key1</span>: &#123; fn1, fn2 &#125;</span><br><span class="line">    <span class="attr">key2</span>: &#123; fn1, fn2 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">target</span>&#125; 目标对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">type</span>&#125; 收集类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">key</span>&#125; 需要收集依赖的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">    <span class="comment">// activeEffect为空，就表示当前没有依赖，就没必要做依赖收集了</span></span><br><span class="line">    <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前依赖数据</span></span><br><span class="line">    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前数据中没有所属的依赖key，就重新设置一个</span></span><br><span class="line">    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">      depsMap.<span class="title function_">set</span>(key, (dep = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加依赖函数</span></span><br><span class="line">    <span class="keyword">if</span> (!dep.<span class="title function_">has</span>(activeEffect)) &#123;</span><br><span class="line">      dep.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">      activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.<span class="property">options</span>.<span class="property">onTrack</span>) &#123;</span><br><span class="line">        activeEffect.<span class="property">options</span>.<span class="title function_">onTrack</span>(&#123;</span><br><span class="line">          <span class="attr">effect</span>: activeEffect,</span><br><span class="line">          target,</span><br><span class="line">          <span class="keyword">type</span>,</span><br><span class="line">          key</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发依赖</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span></span><br><span class="line"><span class="params">  target: <span class="built_in">object</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span><br><span class="line"><span class="params">  key?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  newValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldValue?: <span class="built_in">unknown</span>,</span></span><br><span class="line"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;<span class="built_in">unknown</span>, <span class="built_in">unknown</span>&gt; | <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="comment">// 如果没有收集过依赖，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;()</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">effectsToAdd: <span class="built_in">Set</span>&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 避免循环触发依赖 类似`effect(() =&gt; obj.foo++)`</span></span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || effect.<span class="property">allowRecurse</span>) &#123;</span><br><span class="line">          effects.<span class="title function_">add</span>(effect)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>) &#123;</span><br><span class="line">    <span class="comment">// 在清空前，将对应的依赖全部添加到局部Set</span></span><br><span class="line">    depsMap.<span class="title function_">forEach</span>(add)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; <span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">    <span class="comment">// 当数组的length属性变化时触发</span></span><br><span class="line">    depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;</span><br><span class="line">        <span class="title function_">add</span>(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="comment">// 往相应队列添加依赖</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(key))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="comment">// 通过不同的TriggerOpTypes将depsMap的数据取出，添加到effects</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">            <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isIntegerKey</span>(key)) &#123;</span><br><span class="line">          <span class="comment">// new index added to array -&gt; length changes</span></span><br><span class="line">          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="string">&#x27;length&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">            <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;</span><br><span class="line">          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect: ReactiveEffect</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.<span class="property">options</span>.<span class="property">onTrigger</span>) &#123;</span><br><span class="line">      effect.<span class="property">options</span>.<span class="title function_">onTrigger</span>(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有调度属性，就通过scheduler处理执行</span></span><br><span class="line">      effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  effects.<span class="title function_">forEach</span>(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>vue3响应式是通过数据劫持和发布订阅的模式进行处理，首先vue3中的数据是通过<code>proxy</code>做了一层代理，然后处理<code>proxy</code>的<code>handler</code>，基本类型的<code>handler</code>是通过<code>baseHandlers</code>，特殊类型(map，set)的<code>handler</code>是通过<code>collectHandlers</code>。</li>
<li><code>handler</code>中获取属性的操作通过<code>track</code>进行依赖收集，修改属性的操作通过<code>trigger</code>进行依赖触发，依赖的收集与触发是通过依赖管理中心<code>targetMap</code>保存的</li>
<li><code>track</code>进行收集时，他收集的是<code>activeEffect</code>，这个变量存储的就是正在触发的副作用函数，<code>activeEffect</code>通过<code>effect()</code>方法进行收集</li>
<li><code>effect()</code>常用的三个地方<ul>
<li>组件副作用函数</li>
<li><code>watch</code></li>
<li><code>computed</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序图片上传&amp;九宫格拖拽组件</title>
    <url>/2021/09/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="微信小程序图片上传-amp-九宫格拖拽组件"><a href="#微信小程序图片上传-amp-九宫格拖拽组件" class="headerlink" title="微信小程序图片上传&amp;九宫格拖拽组件"></a>微信小程序图片上传&amp;九宫格拖拽组件</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>图片上传加九宫格拖拽是一个比较常用的组件，常用于发帖或者评论等内容上传模块，我这篇九宫格拖拽的思路是借鉴了<a href="https://www.cnblogs.com/haha1212/p/11562944.html"><strong>一款优雅的小程序拖拽排序组件实现</strong></a>这篇文章</p>
</li>
<li><p>实现效果如下图<br><img src="https://img-blog.csdnimg.cn/cc8c84d6bc3049349e94b95f540916c7.gif" alt="请添加图片描述"></p>
</li>
<li><p>实现原理：新增图片时，为每一个图片增加一个key属性，和tranX、tranY属性，用于transform位移，然后这个九宫格的拖拽新增删除都是以key为标记来修改tranX和tranY，从而达到拖拽效果</p>
</li>
<li><p>使用了以下变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">ITEM_SIZE</span>: <span class="number">100</span>, <span class="comment">// 图片大小 单位px</span></span><br><span class="line">  <span class="attr">dragImgList</span>: [], <span class="comment">// 图片列表 &#123; src: string, key: number, tranX: number, tranY: number &#125;[]</span></span><br><span class="line">  <span class="attr">containerRes</span>: &#123;&#125;, <span class="comment">// 拖拽容器属性</span></span><br><span class="line">  <span class="attr">currentKey</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的key</span></span><br><span class="line">  <span class="attr">currentIndex</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的index</span></span><br><span class="line">  <span class="attr">tranX</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的x距离</span></span><br><span class="line">  <span class="attr">tranY</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的y距离</span></span><br><span class="line">  <span class="attr">uploadPosition</span>: &#123; <span class="comment">// upload上传图标位移距离</span></span><br><span class="line">    <span class="attr">tranX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">tranY</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="WXML-amp-WXSS"><a href="#WXML-amp-WXSS" class="headerlink" title="WXML &amp; WXSS"></a>WXML &amp; WXSS</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span></span></span><br><span class="line"><span class="tag">    <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;dragImgList&#125;&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;index === currentIndex ? tranX : item.tranX&#125;&#125;px, &#123;&#123;index === currentIndex ? tranY : item.tranY&#125;&#125;px); z-index: &#123;&#123;index === currentIndex ? 10 : 1&#125;&#125;;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;darg-item item-transition&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">mark:index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:longpress</span>=<span class="string">&quot;longPress&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;darg-item-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.src&#125;&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">catch:tap</span>=<span class="string">&quot;deleteImg&quot;</span> <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete&quot;</span>&gt;</span>×<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span></span></span><br><span class="line"><span class="tag">    <span class="attr">bindtap</span>=<span class="string">&quot;uploadImage&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;darg-item drag-item-upload&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123;dragImgList.length &gt;= 9&#125;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;uploadPosition.tranX&#125;&#125;px, &#123;&#123;uploadPosition.tranY&#125;&#125;px);&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>+<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.drag-container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-transition</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: transform <span class="number">0.1s</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.darg-item</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.darg-item-img</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.drag-item-delete</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">58</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">33</span>rpx;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.7</span>);</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">47</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">25</span>rpx;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">64</span>rpx;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.drag-item-upload</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: burlywood;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">200</span>rpx;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">200</span>rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><ul>
<li>图片上传很简单，就是初始化上传的图片，然后拼接图片列表，最后修改上传图标位置即可<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">uploadImage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; dragImgList, <span class="variable constant_">ITEM_SIZE</span> &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  wx.<span class="title function_">chooseImage</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">9</span> - dragImgList.<span class="property">length</span>,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> imgList = res.<span class="property">tempFilePaths</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">tranX</span>: <span class="variable constant_">ITEM_SIZE</span> * ((dragImgList.<span class="property">length</span> + index) % <span class="number">3</span>),</span><br><span class="line">        <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>((dragImgList.<span class="property">length</span> + index) / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>,</span><br><span class="line">        <span class="attr">src</span>: item,</span><br><span class="line">        <span class="attr">key</span>: dragImgList.<span class="property">length</span> + index</span><br><span class="line">      &#125;))</span><br><span class="line">      dragImgList = dragImgList.<span class="title function_">concat</span>(imgList)</span><br><span class="line">      <span class="comment">// 修改上传图标位置</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(dragImgList.<span class="property">length</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        dragImgList,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setUploaPosition</span>(<span class="params">listLength</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">ITEM_SIZE</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">ITEM_SIZE</span></span><br><span class="line">  <span class="keyword">const</span> uploadPosition = &#123;</span><br><span class="line">    <span class="attr">tranX</span>: listLength % <span class="number">3</span> * <span class="variable constant_">ITEM_SIZE</span>,</span><br><span class="line">    <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(listLength / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    uploadPosition,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h3><ul>
<li>首先从图片列表中删除所需图片，然后修改列表，把大于所选图片key的key全部减一，最后修改剩余图片位置和上传图标位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">deleteImg</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = e.<span class="property">mark</span>.<span class="property">key</span></span><br><span class="line">  <span class="comment">// 删除图片</span></span><br><span class="line">  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> !== key)</span><br><span class="line">  <span class="comment">// 修改key值</span></span><br><span class="line">  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> &gt; key &amp;&amp; item.<span class="property">key</span>--)</span><br><span class="line">  <span class="comment">// 修改剩余图片位置</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(list)</span><br><span class="line">  <span class="comment">// 修改上传图标位置</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(list.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getListPosition</span>(<span class="params">list</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">ITEM_SIZE</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">ITEM_SIZE</span></span><br><span class="line">  <span class="keyword">const</span> dragImgList = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.<span class="property">tranX</span> = <span class="variable constant_">ITEM_SIZE</span> * (item.<span class="property">key</span> % <span class="number">3</span>);</span><br><span class="line">    item.<span class="property">tranY</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(item.<span class="property">key</span> / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>;</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    dragImgList,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向页面传递最新图片列表</span></span><br><span class="line">  <span class="keyword">const</span> urlList = [...dragImgList].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">key</span> - b.<span class="property">key</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">src</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;updateImage&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">list</span>: urlList</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="九宫格拖拽"><a href="#九宫格拖拽" class="headerlink" title="九宫格拖拽"></a>九宫格拖拽</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>初始化只需获取容器的位置信息即可，因为拖拽组件不一定是在页面的左上角，所以需要知道容器的位置信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">lifetimes</span>: &#123;</span><br><span class="line">  <span class="title function_">ready</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>()</span><br><span class="line">      .<span class="title function_">select</span>(<span class="string">&quot;.drag-container&quot;</span>)</span><br><span class="line">      .<span class="title function_">boundingClientRect</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span> = res</span><br><span class="line">      &#125;).<span class="title function_">exec</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="longPress"><a href="#longPress" class="headerlink" title="longPress"></a>longPress</h4><ul>
<li>这里采用longPress，而不是touchStart的原因，一是为了优化体验，二是touchStart与删除按钮冲突<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">longPress</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = e.<span class="property">mark</span>.<span class="property">index</span></span><br><span class="line">  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> &#123; top, left &#125; = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">currentIndex</span>: index,</span><br><span class="line">    <span class="attr">tranX</span>: pageX - <span class="number">50</span> - left,</span><br><span class="line">    <span class="attr">tranY</span>: pageY - <span class="number">50</span> - top</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="touchMove"><a href="#touchMove" class="headerlink" title="touchMove"></a>touchMove</h4><ul>
<li>touchMove首先计算出位移距离，然后根据位移距离求出停放位置的key，如果不一样就修改位置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果currentIndex &lt; 0，说明并没有触发longPress</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentIndex</span> &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> &#123; top, left &#125; = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span></span><br><span class="line">  <span class="keyword">const</span> tranX = pageX - <span class="number">50</span> - left</span><br><span class="line">  <span class="keyword">const</span> tranY = pageY - <span class="number">50</span> - top</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    tranX,</span><br><span class="line">    tranY</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 对比当前移动的key和停放位置的key，如果不一样就修改位置</span></span><br><span class="line">  <span class="keyword">const</span> currentKey = e.<span class="property">mark</span>.<span class="property">key</span></span><br><span class="line">  <span class="keyword">const</span> moveKey = <span class="variable language_">this</span>.<span class="title function_">getMoveKey</span>(tranX, tranY)</span><br><span class="line">  <span class="keyword">if</span> (currentKey === moveKey || <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> === currentKey) <span class="keyword">return</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = currentKey</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">insert</span>(currentKey, moveKey)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getMoveKey</span>(<span class="params">tranX, tranY</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">dragImgList</span>: list, <span class="variable constant_">ITEM_SIZE</span> &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">_getPositionNumber</span> = (<span class="params">position</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> positionNumber = <span class="title class_">Math</span>.<span class="title function_">round</span>(position/ <span class="variable constant_">ITEM_SIZE</span>)</span><br><span class="line">    <span class="keyword">return</span> positionNumber &gt; <span class="number">2</span> ? <span class="number">2</span> : positionNumber &lt; <span class="number">0</span> ? <span class="number">0</span> : positionNumber</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> endKey = <span class="number">3</span> * <span class="title function_">_getPositionNumber</span>(tranY) + <span class="title function_">_getPositionNumber</span>(tranX)</span><br><span class="line">  <span class="keyword">return</span> endKey &gt;= list.<span class="property">length</span> ? list.<span class="property">length</span> - <span class="number">1</span> : endKey</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">insert</span>(<span class="params">origin, end</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dragImgList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span></span><br><span class="line">  dragImgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (origin &lt; end) &#123;</span><br><span class="line">      <span class="comment">// 如果起始key小于结束key，就把区间内的key全部减一</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">key</span> &gt; origin &amp;&amp; item.<span class="property">key</span> &lt;= end) item.<span class="property">key</span>--</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === origin) item.<span class="property">key</span> = end</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (origin &gt; end) &#123;</span><br><span class="line">      <span class="comment">// 如果起始key大于结束key，就把区间内的key全部加一</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">key</span> &gt;= end &amp;&amp; item.<span class="property">key</span> &lt; origin) item.<span class="property">key</span>++</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === origin) item.<span class="property">key</span> = end</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(dragImgList)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="touchEnd"><a href="#touchEnd" class="headerlink" title="touchEnd"></a>touchEnd</h4><ul>
<li>touchEnd用于重置数据<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">tranX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">tranY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">currentIndex</span>: -<span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = -<span class="number">1</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/2rFIJamX7xty</code></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>基于markdown-it打造的markdown编辑器</title>
    <url>/2022/10/12/%E5%9F%BA%E4%BA%8Emarkdown-it%E6%89%93%E9%80%A0%E7%9A%84markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>markdown-it是一个用来解析markdown的库，它可以将markdown编译为html，然后解析时markdown-it会根据规则生成tokens，如果需要自定义，就通过rules函数对token进行处理<br>我现在基于markdown-it已完成第一版编辑器，现有以下功能：</p>
<ol>
<li>快捷编辑按钮</li>
<li>代码块主题切换</li>
<li>同步滚动</li>
<li>目录列表生成</li>
<li>内容状态缓存</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>目前实现效果如下<br><img src="https://s1.ax1x.com/2022/10/12/xaMejs.jpg"></p>
<p>预览地址：<a href="https://lhrun.github.io/md-editor/">https://lhrun.github.io/md-editor/</a><br>repo：<a href="https://github.com/LHRUN/md-editor">https://github.com/LHRUN/md-editor</a> 欢迎star⭐️</p>
<h2 id="编辑器设计"><a href="#编辑器设计" class="headerlink" title="编辑器设计"></a>编辑器设计</h2><ol>
<li>页面布局分四部分，顶部是快捷工具栏，然后主体内容分三部分，编辑区域(textarea)、html展示区域、目录列表(可展示隐藏)，因为我是用react开发的，所以html字符串我是通过<a href="https://zh-hans.reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml">dangerouslySetInnerHTML</a>设置</li>
<li>markdown-it初始化<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">MD</span> = <span class="keyword">new</span> <span class="title class_">MarkdownIt</span>(&#123;</span><br><span class="line">  <span class="attr">html</span>: <span class="literal">true</span>, <span class="comment">// 在源码中启用HTML标签</span></span><br><span class="line">  <span class="attr">linkify</span>: <span class="literal">true</span>, <span class="comment">// 将类似URL的文本自动转换为链接</span></span><br><span class="line">  <span class="attr">breaks</span>: <span class="literal">true</span>, <span class="comment">// 转换段落里的 &#x27;\n&#x27; 到 &lt;br&gt;</span></span><br><span class="line">  <span class="attr">highlight</span>: <span class="keyword">function</span> (<span class="params">str, lang</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">highlightFormatCode</span>(str, lang)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title class_">MarkdownItSub</span>)</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title class_">MarkdownItSup</span>)</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title class_">MarkdownItMark</span>)</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title class_">MarkdownItDeflist</span>)</span><br><span class="line">  .<span class="title function_">use</span>(<span class="title class_">MarkdownItTaskLists</span>)</span><br><span class="line">  .<span class="title function_">use</span>(markdownItAbbr)</span><br><span class="line">  .<span class="title function_">use</span>(markdownItFootnote)</span><br><span class="line">  <span class="comment">// 其余的markdownIt插件...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> highlightFormatCode = (<span class="attr">str</span>: string, <span class="attr">lang</span>: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (lang &amp;&amp; hljs.<span class="title function_">getLanguage</span>(lang)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">codeBlockStyle</span>(hljs.<span class="title function_">highlight</span>(lang, str, <span class="literal">true</span>).<span class="property">value</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">codeBlockStyle</span>(<span class="variable constant_">MD</span>.<span class="property">utils</span>.escapeHtml(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> codeBlockStyle = (<span class="attr">val</span>: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;pre class=&quot;hljs&quot; style=&quot;padding: 10px;border-radius: 10px;&quot;&gt;&lt;code&gt;<span class="subst">$&#123;val&#125;</span>&lt;/code&gt;&lt;/pre&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="快捷编辑按钮"><a href="#快捷编辑按钮" class="headerlink" title="快捷编辑按钮"></a>快捷编辑按钮</h2><p>快捷便捷按钮主要是通过判断textarea的光标位置，然后通过光标位置改变编辑器文本内容，比如添加图片</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取光标位置</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getCursorPosition</span> = (<span class="params">editor: HTMLTextAreaElement</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; selectionStart, selectionEnd &#125; = editor</span><br><span class="line">  <span class="keyword">return</span> [selectionStart, selectionEnd]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addImage</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  editor: HTMLTextAreaElement,</span></span><br><span class="line"><span class="params">  source: string,</span></span><br><span class="line"><span class="params">  setSource: (v: string) =&gt; <span class="keyword">void</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [start, end] = <span class="title function_">getCursorPosition</span>(editor)</span><br><span class="line">  <span class="keyword">let</span> val = source</span><br><span class="line">  <span class="keyword">if</span> (start === end) &#123;</span><br><span class="line">    val = <span class="string">`<span class="subst">$&#123;source.slice(<span class="number">0</span>, start)&#125;</span>\n![图片描述](url)\n<span class="subst">$&#123;source.slice(end)&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = <span class="string">`<span class="subst">$&#123;source.slice(<span class="number">0</span>, start)&#125;</span>\n![<span class="subst">$&#123;source.slice(</span></span></span><br><span class="line"><span class="subst"><span class="string">      start,</span></span></span><br><span class="line"><span class="subst"><span class="string">      end</span></span></span><br><span class="line"><span class="subst"><span class="string">    )&#125;</span>](url)\n<span class="subst">$&#123;source.slice(end)&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setSource</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码块主题切换"><a href="#代码块主题切换" class="headerlink" title="代码块主题切换"></a>代码块主题切换</h2><ul>
<li>代码块高亮我是采用了<strong>highlight.js</strong>，因为这个库提供了很多主题样式，所以主题切换，我只需要改变css link即可<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// codeTheme就是已选的主题名字</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (codeTheme) &#123;</span><br><span class="line">    <span class="title function_">switchLink</span>(</span><br><span class="line">      <span class="string">&#x27;code-style&#x27;</span>,</span><br><span class="line">      <span class="string">`https://cdn.bootcdn.net/ajax/libs/highlight.js/11.6.0/styles/<span class="subst">$&#123;codeTheme&#125;</span>.min.css`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [codeTheme])</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切换html css link</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key link key 指定唯一标识，用于切换link</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> href link href</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">switchLink</span> = (<span class="params">key: string, href: string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="variable language_">document</span>.<span class="property">head</span></span><br><span class="line">  <span class="keyword">const</span> oldLink = head.<span class="title function_">getElementsByClassName</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (oldLink.<span class="property">length</span>) head.<span class="title function_">removeChild</span>(oldLink[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newLink = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>)</span><br><span class="line">  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>)</span><br><span class="line">  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>)</span><br><span class="line">  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, key)</span><br><span class="line">  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, href)</span><br><span class="line">  newLink.<span class="property">onerror</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(e)</span><br><span class="line">    message.<span class="title function_">error</span>(<span class="string">&#x27;获取css link失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  head.<span class="title function_">appendChild</span>(newLink)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="同步滚动"><a href="#同步滚动" class="headerlink" title="同步滚动"></a>同步滚动</h2><p>同步滚动是我认为最难搞的一个功能，因为我不想仅仅通过百分比来计算滚动距离，因为这样的话如果编辑区域添加了一堆图片，预览就会有非常大的高度差。<br>我在网上找了许多方案，最后发现markdown-it的官方实现是我能找到并能实现的最佳方案，大致实现思路是如下</p>
<ol>
<li><p>首先在编译时对标题元素和段落元素添加行号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注入行号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">injectLineNumbers</span>: <span class="title class_">Renderer</span>.<span class="property">RenderRule</span> = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  tokens,</span></span></span><br><span class="line"><span class="params"><span class="function">  idx,</span></span></span><br><span class="line"><span class="params"><span class="function">  options,</span></span></span><br><span class="line"><span class="params"><span class="function">  _env,</span></span></span><br><span class="line"><span class="params"><span class="function">  slf</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> line</span><br><span class="line">  <span class="keyword">if</span> (tokens[idx].<span class="property">map</span> &amp;&amp; tokens[idx].<span class="property">level</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    line = (tokens[idx].<span class="property">map</span> <span class="keyword">as</span> [number, number])[<span class="number">0</span>]</span><br><span class="line">    tokens[idx].<span class="title function_">attrJoin</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;line&#x27;</span>)</span><br><span class="line">    tokens[idx].<span class="title function_">attrSet</span>(<span class="string">&#x27;data-line&#x27;</span>, <span class="title class_">String</span>(line))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slf.<span class="title function_">renderToken</span>(tokens, idx, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">MD</span>.<span class="property">renderer</span>.<span class="property">rules</span>.<span class="property">heading_open</span> = <span class="variable constant_">MD</span>.<span class="property">renderer</span>.<span class="property">rules</span>.<span class="property">paragraph_open</span> = injectLineNumbers</span><br></pre></td></tr></table></figure>
</li>
<li><p>滚动前计算出当前编辑区域每行对应的预览偏移距离，有标记行号的元素直接计算offset，未标记行号的元素就等比计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取编辑区域每行对应的预览偏移距离</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> editor 编辑元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> review 预览元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> number[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">buildScrollMap</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  editor: HTMLTextAreaElement,</span></span><br><span class="line"><span class="params">  review: HTMLDivElement</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">lineHeightMap</span>: number[] = []</span><br><span class="line">  <span class="keyword">let</span> linesCount = <span class="number">0</span> <span class="comment">// 编辑区总行数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 临时创建元素获取每次换行之间的总行数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> sourceLine = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  sourceLine.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span></span><br><span class="line">  sourceLine.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span></span><br><span class="line">  sourceLine.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;auto&#x27;</span></span><br><span class="line">  sourceLine.<span class="property">style</span>.<span class="property">width</span> = <span class="string">`<span class="subst">$&#123;editor.clientWidth&#125;</span>px`</span></span><br><span class="line">  sourceLine.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;15px&#x27;</span></span><br><span class="line">  sourceLine.<span class="property">style</span>.<span class="property">lineHeight</span> = <span class="string">`<span class="subst">$&#123;LINE_HEIGHT&#125;</span>px`</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(sourceLine)</span><br><span class="line">  <span class="keyword">let</span> acc = <span class="number">0</span></span><br><span class="line">  editor.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    lineHeightMap.<span class="title function_">push</span>(acc)</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      acc++</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sourceLine.<span class="property">textContent</span> = str</span><br><span class="line">    <span class="keyword">const</span> h = sourceLine.<span class="property">offsetHeight</span></span><br><span class="line">    acc += <span class="title class_">Math</span>.<span class="title function_">round</span>(h / <span class="variable constant_">LINE_HEIGHT</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  sourceLine.<span class="title function_">remove</span>()</span><br><span class="line">  lineHeightMap.<span class="title function_">push</span>(acc)</span><br><span class="line">  linesCount = acc</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最终输出的偏移map</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">_scrollMap</span>: number[] = <span class="keyword">new</span> <span class="title class_">Array</span>(linesCount).<span class="title function_">fill</span>(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取标记行号的offset距离</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> nonEmptyList = []</span><br><span class="line">  nonEmptyList.<span class="title function_">push</span>(<span class="number">0</span>)</span><br><span class="line">  _scrollMap[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.line&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">t</span>: string | number = el.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-line&#x27;</span>) <span class="keyword">as</span> string</span><br><span class="line">    <span class="keyword">if</span> (t === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    t = lineHeightMap[<span class="title class_">Number</span>(t)]</span><br><span class="line">    <span class="keyword">if</span> (t !== <span class="number">0</span>) &#123;</span><br><span class="line">      nonEmptyList.<span class="title function_">push</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    _scrollMap[t] = <span class="title class_">Math</span>.<span class="title function_">round</span>((el <span class="keyword">as</span> <span class="title class_">HTMLElement</span>).<span class="property">offsetTop</span> - review.<span class="property">offsetTop</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  nonEmptyList.<span class="title function_">push</span>(linesCount)</span><br><span class="line">  _scrollMap[linesCount] = review.<span class="property">scrollHeight</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 未标记行号的元素等比计算</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; linesCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_scrollMap[i] !== -<span class="number">1</span>) &#123;</span><br><span class="line">      pos++</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> a = nonEmptyList[pos]</span><br><span class="line">    <span class="keyword">const</span> b = nonEmptyList[pos + <span class="number">1</span>]</span><br><span class="line">    _scrollMap[i] = <span class="title class_">Math</span>.<span class="title function_">round</span>(</span><br><span class="line">      (_scrollMap[b] * (i - a) + _scrollMap[a] * (b - i)) / (b - a)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _scrollMap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>滚动时根据计算结果匹配滚动高度</p>
</li>
</ol>
<h3 id="同步滚动注意点"><a href="#同步滚动注意点" class="headerlink" title="同步滚动注意点"></a>同步滚动注意点</h3><ol>
<li>在改变编辑内容和窗口大小时需清空计算结果，因为这两个一改变，每行的偏移距离就会发生变化，在滚动时需要重新计算</li>
<li>同步滚动时会有一个无限触发的问题，因为编辑区域滚动，会触发预览区域的<code>scrollTo()</code>，然后预览区域的滚动监听方法就会被触发，然后这样就会无限触发下去，所以需要一个变量记住当前的手动滚动的区域，进行限制</li>
</ol>
<h2 id="目录列表生成"><a href="#目录列表生成" class="headerlink" title="目录列表生成"></a>目录列表生成</h2><p>目录列表通过rules的<code>heading_open</code>方法，获取当前标题的token，然后通过token得出标题的具体内容进行拼接，最后根据level计算字体大小</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getTitle</span> = (<span class="params">tokens: Token[], idx: number</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = tokens[idx + <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> &#123; markup &#125; = tokens[idx]</span><br><span class="line">  <span class="keyword">const</span> val = children?.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;acc&#125;</span><span class="subst">$&#123;cur.content&#125;</span>`</span>, <span class="string">&#x27;&#x27;</span>) || <span class="string">&#x27;&#x27;</span></span><br><span class="line">  toc.<span class="title function_">push</span>(&#123;</span><br><span class="line">    val,</span><br><span class="line">    <span class="attr">level</span>: markup.<span class="property">length</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能完成的有点粗糙，以后有时间继续完善细节，有问题欢迎讨论👻</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/m0_67393295/article/details/123220722">手把手带你10分钟手撸一个简易的Markdown编辑器</a></li>
<li><a href="https://github.com/markdown-it/markdown-it/blob/master/support/demo_template/index.js">markdown-it.github.io</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>markdown-it</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>Hi, 这里是LH’BLOG<br>🏀勇士球迷 | 🎮菜狗玩家 | 👨‍💻Front End<br>💻技术分享 | 📝实践总结 | 🏞随手记录</p>
<h3 id="找到我"><a href="#找到我" class="headerlink" title="找到我"></a>找到我</h3><ul>
<li><a href="https://github.com/LHRUN">Github</a></li>
<li><a href="https://segmentfault.com/u/lh_s">SegmentFault</a></li>
<li><a href="https://blog.csdn.net/weixin_44719258">CSDN</a> </li>
<li><a href="https://juejin.cn/user/3949101499549518">掘金</a></li>
<li><a href="https://www.zhihu.com/people/wxae77cceaa49dcaf5">知乎</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>&#39;tag&#39;</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
