<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>H5跳转微信小程序</title>
    <url>/2021/06/10/H5%E8%B7%B3%E8%BD%AC%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="H5跳转微信小程序"><a href="#H5跳转微信小程序" class="headerlink" title="H5跳转微信小程序"></a>H5跳转微信小程序</h2><blockquote>
<p>H5跳转小程序有两个方法，需要根据浏览器环境判断<br>微信外使用<code>URL Scheme</code>，根据生成的一个link进行location跳转<br>微信内使用<code>wx-open-launch-weapp</code>开放标签进行跳转，实测ios系统微信内也可以使用<code>URL Scheme</code>，根据自己的需求选择</p>
</blockquote>
<h3 id="wx-open-launch-weapp"><a href="#wx-open-launch-weapp" class="headerlink" title="wx-open-launch-weapp"></a><code>wx-open-launch-weapp</code></h3><ul>
<li><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html">官方文档</a></li>
<li>注意事项：微信版本要求为：7.0.12及以上。 系统版本要求为：iOS 10.3及以上、Android 5.0及以上</li>
<li>绑定域名: 登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”  </li>
<li>引入SDK：官网推荐引入方法<code>&lt;script src=&quot;https://res.wx.qq.com/open/js/jweixin-1.6.0.js&quot;&gt;&lt;/script&gt;</code>;，也可以使用第三方npm包<code>weixin-js-sdk</code>  </li>
<li>校验签名是否正确：<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign">微信 JS 接口签名校验工具</a></li>
<li>如果开放标签需要绝对定位，就在外面包裹一个div进行定位，避免直接定位开放标签</li>
<li>调试：好多人在进行调试的时候认为非常麻烦，需要不断切换环境，我推荐一个我的调试方式，在开发过程中，使用SwitchHosts进行IP映射，把本地启动项目的域名映射到公众号平台设置的域名，然后在微信开发工具中调试，就非常轻松了</li>
</ul>
<pre><code class="highlight html">// 普通H5的写法可参考官方文档，以下是我在vue中的写法
<span class="tag">&lt;<span class="name">wx-open-launch-weapp</span></span>
<span class="tag"> <span class="attr">username</span>=<span class="string">&quot;小程序原始id&quot;</span></span>
<span class="tag"> <span class="attr">path</span>=<span class="string">&quot;页面路径及参数&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/wxtag-template&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml">           </span></span>
<span class="language-xml"><span class="language-handlebars">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;wx-btn&quot;</span>&gt;</span>跳转小程序<span class="tag">&lt;/<span class="name">button</span>&gt;</span>   </span></span>
<span class="language-xml"><span class="language-handlebars">  </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
<span class="tag">&lt;/<span class="name">wx-open-launch-weapp</span>&gt;</span>
<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">...</span>
<span class="language-javascript"><span class="keyword">async</span> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span>
<span class="language-javascript">  <span class="keyword">const</span> wx = <span class="built_in">require</span>(<span class="string">&#x27;weixin-js-sdk&#x27;</span>)</span>
<span class="language-javascript">  wx.<span class="title function_">config</span>(&#123;</span>
<span class="language-javascript">    <span class="attr">debug</span>: <span class="literal">true</span>, <span class="comment">// 开启调试模式，会在移动端以alert的形式打印返回值</span></span>
<span class="language-javascript">    <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，从服务端获取</span></span>
<span class="language-javascript">    <span class="attr">timestamp</span>: , <span class="comment">// 必填，生成签名的时间戳，从服务端获取</span></span>
<span class="language-javascript">    <span class="attr">nonceStr</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，生成签名的随机串，从服务端获取</span></span>
<span class="language-javascript">    <span class="attr">signature</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">// 必填，签名，从服务端获取</span></span>
<span class="language-javascript">    <span class="attr">jsApiList</span>: [], <span class="comment">// 必填，需要使用的JS接口列表，这个随便填一个就行</span></span>
<span class="language-javascript">    <span class="attr">openTagList</span>: [<span class="string">&#x27;wx-open-launch-weapp&#x27;</span>]</span>
<span class="language-javascript">  &#125;)</span>
<span class="language-javascript">  wx.<span class="title function_">ready</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span>
<span class="language-javascript">  wx.<span class="title function_">error</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span>
<span class="language-javascript">&#125;</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>

<h3 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a><code>URL Scheme</code></h3><ul>
<li>注意事项：安卓不能直接跳转，需要H5中转，否则Android会出现无法访问</li>
<li>写法很简单，只需<code>location.href=&#39;URL Scheme&#39;</code>，在页面初始化时调用或者在按钮点击事件中调用</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建详细教程</title>
    <url>/2022/09/06/Hexo%E6%90%AD%E5%BB%BA%E5%9F%BA%E6%93%8D%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><ol>
<li>首先需要以下安装环境，直接在官网下载即可</li>
</ol>
<ul>
<li><a href="https://nodejs.org/en/">Node.js</a></li>
<li><a href="https://git-scm.com/">Git</a></li>
</ul>
<ol start="2">
<li>环境准备好后，安装Hexo <code>npm install -g hexo-cli</code></li>
<li>安装后在指定文件夹创建项目<pre><code class="highlight sh">hexo init &lt;folder&gt;
<span class="built_in">cd</span> &lt;folder&gt;
npm install</code></pre></li>
<li>选择主题</li>
</ol>
<ul>
<li><p>Hexo初始化成功后，然后需要选择一个漂亮的主题，这个推荐直接在官网上找，<a href="https://hexo.io/themes/">主题</a><br><img src="https://img-blog.csdnimg.cn/60988327e65c46ec8becc25b8591c650.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>选中主题后下载到项目themes文件夹</p>
</li>
<li><p>然后修改根目录下的_config.yml文件</p>
</li>
<li><p><code>theme: &#39;主题名,也就是themes文件夹里的名字&#39;</code></p>
</li>
</ul>
<ol start="5">
<li>hexo最常用的有以下几个命令</li>
</ol>
<ul>
<li>启动服务：<code>hexo server</code> 或 <code>hexo s</code></li>
<li>新建文章：<code>hexo new &quot;文章名字&quot;</code></li>
<li>新建静态页面：<code>hexo new page &quot;页面名字&quot;</code></li>
<li>生成public文件夹：<code>hexo generate</code> 或 <code>hexo g</code></li>
<li>清除public文件夹：<code>hexo clean</code></li>
<li>部署：<code>hexo deploy</code> 或 <code>hexo d</code></li>
</ul>
<h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><p>Github有免费提供搭建静态网站的功能，所以hexo推荐直接放到GitHub Page，按照以下步骤进行部署。  </p>
<ol>
<li>首先新建一个源码repo，建议选择Private，这个用来放hexo项目代码，不对外开放</li>
<li>本地仓库运行以下命令提交代码</li>
</ol>
<ul>
<li><code>git init</code>：git初始化</li>
<li><code>git add .</code>: 将所有代码添加到暂存区</li>
<li><code>git commit -m &quot;first commit&quot;</code>：提交本次commit</li>
<li><code>git remote add origin &#39;远程仓库地址&#39;</code>：添加远程仓库地址</li>
<li><code>git push -u origin main</code>：推送代码</li>
</ul>
<ol start="3">
<li>然后再新建一个仓库，名字为 <code>github名字.github.io</code>，这个仓库用于放部署后的代码</li>
<li>安装Hexo部署插件 <code>npm install hexo-deployer-git</code></li>
<li>修改根目录下的 <code>_config.yml</code><pre><code class="highlight yml"><span class="attr">deploy:</span>
  <span class="attr">type:</span> <span class="string">git</span>
  <span class="attr">repo:</span> <span class="string">部署仓库地址</span>
  <span class="attr">branch:</span> <span class="string">main</span></code></pre></li>
<li>最后执行<code>hexo deploy</code>命令就可以在<code>github名字.github.io</code>看到博客了</li>
</ol>
<h2 id="SSH-github-Actions自动部署"><a href="#SSH-github-Actions自动部署" class="headerlink" title="SSH + github Actions自动部署"></a>SSH + github Actions自动部署</h2><ul>
<li><strong>Github Actions</strong>是github专用的持续集成脚本，用于自动执行工作流程，<strong>SSH</strong>可以通过建立密钥免密登录，这两个结合就能达到自动部署的效果</li>
</ul>
<ol>
<li><p>首先通过ssh-keygen生成密钥，<code>ssh-keygen -t rsa -C &quot;Github 的邮箱地址&quot;</code></p>
</li>
<li><p>然后github配置ssh，配置路径：<code>github -&gt; Settings –&gt; SSH and GPG keys</code><br> <img src="https://img-blog.csdnimg.cn/277cd5e70dad47a5af70a9ce9dc06f5a.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>git仓库添加密钥私有变量，配置路径：<code>repo -&gt; Settings -&gt; Secrets</code>，点击<code>New repository secret</code>，name可以自定义，主要是接下来的deploy.yaml文件需要使用，Secret填写你生成的密钥<br><img src="https://img-blog.csdnimg.cn/10897de98a7f44a2b3171371b71b91ac.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>然后根目录下新建<code>.github/workflows/deploy.yaml</code>，并填写以下内容</p>
<pre><code class="highlight yml"><span class="attr">name:</span> <span class="string">Deploy</span>
<span class="attr">on:</span>
  <span class="attr">push:</span>
    <span class="attr">branches:</span> [<span class="string">你需要自动化部署的分支</span>]
<span class="attr">jobs:</span>
  <span class="attr">build:</span>
    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span>
    <span class="attr">steps:</span>
      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Repository</span> <span class="string">main</span> <span class="string">branch</span>
        <span class="attr">uses:</span> <span class="string">actions/checkout@main</span>
      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node</span>
        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span>
        <span class="attr">with:</span>
          <span class="attr">node-version:</span> <span class="number">14.</span><span class="string">x</span>
      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Hexo</span> <span class="string">Dependencies</span>
        <span class="attr">run:</span> <span class="string">|</span>
<span class="string">          npm install hexo-cli -g</span>
<span class="string">          npm install</span>
<span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Deploy</span>
        <span class="attr">env:</span>
          <span class="attr">HEXO_DEPLOY_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.&#x27;你上一步自定义的变量名&#x27;</span> <span class="string">&#125;&#125;</span>
        <span class="attr">run:</span> <span class="string">|</span>
<span class="string">          mkdir -p ~/.ssh/</span>
<span class="string">          echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa </span>
<span class="string">          chmod 600 ~/.ssh/id_rsa</span>
<span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span>
<span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Git</span> <span class="string">Infomation</span>
        <span class="attr">run:</span> <span class="string">|</span>
<span class="string">          git config --global user.name &quot;git名字&quot;</span>
<span class="string">          git config --global user.email &quot;git邮箱&quot;</span>
<span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span>
        <span class="attr">run:</span> <span class="string">|</span>
<span class="string">          hexo clean</span>
<span class="string">          hexo generate </span>
<span class="string">          hexo deploy    </span></code></pre></li>
<li><p>然后把代码push上去的时候，就可以在仓库的<strong>Actions</strong>上看自动工作流程的情况</p>
</li>
</ol>
<h2 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h2><ol>
<li><p>首先在<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google Search Console</a>登录谷歌账号</p>
</li>
<li><p>然后在网址前缀中填写网址，下载验证文件到主题文件夹的source目录<br><img src="https://img-blog.csdnimg.cn/68c9ef2e3f4c42ec8ca29f46f01905d4.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>下载后再重新部署一下，最后点击验证</p>
</li>
</ol>
<h3 id="添加站点地图"><a href="#添加站点地图" class="headerlink" title="添加站点地图"></a>添加站点地图</h3><p>站点地图是一种文件，您可以在其中提供与您网站中的网页、视频或其他文件有关的信息，还可以说明这些内容之间的关系。Google 等搜索引擎会读取此文件，以便更高效地抓取您的网站。站点地图会告诉 Google 您认为网站中的哪些网页和文件比较重要，还会提供与这些文件有关的重要信息。</p>
<ol>
<li><p>安装站点地图插件 <code>npm install hexo-generator-sitemap --save</code></p>
</li>
<li><p>在hexo根目录的_config.yml修改以下内容</p>
<pre><code class="highlight yml"><span class="attr">url:</span> <span class="string">博客地址</span>
<span class="attr">sitemap:</span>
 <span class="attr">path:</span> <span class="string">sitemap.xml</span></code></pre></li>
<li><p>然后部署博客，输入<code>博客地址/sitemap.xml</code>能看见以下内容<br><img src="https://img-blog.csdnimg.cn/74745ec1ca3e4d06a06ba512ddb5e3f1.png#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>最后在<strong>Google Search Console</strong>上的站点地图上点击提交<br><img src="https://img-blog.csdnimg.cn/371a45539f694c08a207367d47d25d88.jpeg#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<h2 id="Disqus评论"><a href="#Disqus评论" class="headerlink" title="Disqus评论"></a>Disqus评论</h2><p>Hexo可以搭载的评论系统有很多，比如Valine，Waline，Disqus等等，但是按颜值来看还是Disqus</p>
<ol>
<li>首先在<a href="https://disqus.com/">Disqus官网</a>进行注册，然后点击“Get STARTED”，并选择 “I want to install Disqus on my site” 选项</li>
<li>然后在进入表单页按照提示进行填写即可，但是有两个地方需要注意，<code>Website Name</code>这个是你的专属网址的名字，需要记住，还有就是在“Select Plan”记得选“Basic”</li>
<li>最后修改_config.yml中把shortname替换为你在创建时的名字，一般现在的主题都带的有评论模版，如果没有就需要自己添加了，这个不同的主题不太相同，可以看下官方的安装模版进行修改<br><img src="https://img-blog.csdnimg.cn/d1dc79115212411383a8dbd11971aaee.jpeg#pic_center" alt="在这里插入图片描述"></li>
</ol>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>React源码分析之diff核心算法</title>
    <url>/2022/09/04/React%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bdiff%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>React的diff算法是在render的beginWork阶段中进行处理</li>
<li><code>beginWork</code>是在向下深度遍历fiber树时会对途径的每个节点进行状态处理和进行diff对比</li>
<li>首先diff的入口是在<code>reconcileChildFibers</code>中，然后会根据type来判断使用哪种diff函数进行处理<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">reconcileChildFibers</span>(<span class="params"></span>
<span class="params">  returnFiber: Fiber,</span>
<span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span>
<span class="params">  newChild: any,</span>
<span class="params">  lanes: Lanes,</span>
<span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;
    <span class="keyword">switch</span> (newChild.<span class="property">$$typeof</span>) &#123;
      <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:
        <span class="keyword">return</span> <span class="title function_">placeSingleChild</span>(
          <span class="title function_">reconcileSingleElement</span>(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes,
          ),
        );··
      <span class="keyword">case</span> <span class="attr">REACT_PORTAL_TYPE</span>:
        <span class="comment">// ...</span>
      <span class="keyword">case</span> <span class="attr">REACT_LAZY_TYPE</span>:
        <span class="comment">//...</span>
    &#125;

    <span class="keyword">if</span> (<span class="title function_">isArray</span>(newChild)) &#123;
      <span class="keyword">return</span> <span class="title function_">reconcileChildrenArray</span>(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes,
      );
    &#125;

    <span class="keyword">if</span> (<span class="title function_">getIteratorFn</span>(newChild)) &#123;
      <span class="comment">//...</span>
    &#125;
  &#125;
  <span class="comment">// ...</span>
&#125;</code></pre></li>
<li>我在本篇会针对两种较常用的diff函数进行分析<ul>
<li><code>reconcileSingleElement</code></li>
<li><code>reconcileChildrenArray</code></li>
</ul>
</li>
</ul>
<h2 id="reconcileSingleElement"><a href="#reconcileSingleElement" class="headerlink" title="reconcileSingleElement"></a>reconcileSingleElement</h2><ul>
<li>reconcileSingleElement是针对新newChild是单节点，而oldChild单节点或者是多节点就无法确定了，所以在此diff算法中就会对旧节点进行遍历，然后删除不匹配的oldFiber<pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">reconcileSingleElement</span>(<span class="params"></span>
<span class="params">  returnFiber: Fiber,</span>
<span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span>
<span class="params">  element: ReactElement</span>
<span class="params">  lanes: Lanes,</span>
<span class="params"></span>): <span class="title class_">Fiber</span> &#123;
  <span class="keyword">const</span> key = element.<span class="property">key</span>;
  <span class="keyword">let</span> child = currentFirstChild;
  <span class="comment">/**</span>
<span class="comment">    * 遍历旧节点，找到与newChild相同key的节点，不匹配的删除</span>
<span class="comment">    * 针对匹配的oldFiber, 用newChild中新节点的props来生成新的fiber节点</span>
<span class="comment">    */</span>
  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;
    <span class="keyword">if</span> (child.<span class="property">key</span> === key) &#123;
      <span class="keyword">const</span> elementType = element.<span class="property">type</span>;
      <span class="comment">/**</span>
<span class="comment">        * 通过useFiber创建一个新的Fiber</span>
<span class="comment">        * 如果element是一个Fragment，则以element.props.children建立Fiber</span>
<span class="comment">        * 将returnFiber赋给新的fiber的return字段，然后返回这个新的fiber</span>
<span class="comment">        */</span>·
      <span class="keyword">if</span> (elementType === <span class="variable constant_">REACT_FRAGMENT_TYPE</span>) &#123;
        <span class="keyword">if</span> (child.<span class="property">tag</span> === <span class="title class_">Fragment</span>) &#123;
          <span class="title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="property">sibling</span>);
          <span class="keyword">const</span> existing = <span class="title function_">useFiber</span>(child, element.<span class="property">props</span>.<span class="property">children</span>);
          existing.<span class="property">return</span> = returnFiber;
          <span class="keyword">if</span> (__DEV__) &#123;
            existing.<span class="property">_debugSource</span> = element.<span class="property">_source</span>;
            existing.<span class="property">_debugOwner</span> = element.<span class="property">_owner</span>;
          &#125;
          <span class="keyword">return</span> existing;
        &#125;
      &#125; <span class="keyword">else</span> &#123;
        <span class="keyword">if</span> (
          child.<span class="property">elementType</span> === elementType ||
          (__DEV__
            ? <span class="title function_">isCompatibleFamilyForHotReloading</span>(child, element)
            : <span class="literal">false</span>) ||
          (<span class="keyword">typeof</span> elementType === <span class="string">&#x27;object&#x27;</span> &amp;&amp;
            elementType !== <span class="literal">null</span> &amp;&amp;
            elementType.<span class="property">$$typeof</span> === <span class="variable constant_">REACT_LAZY_TYPE</span> &amp;&amp;
            <span class="title function_">resolveLazy</span>(elementType) === child.<span class="property">type</span>)
        ) &#123;
          <span class="title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="property">sibling</span>);
          <span class="keyword">const</span> existing = <span class="title function_">useFiber</span>(child, element.<span class="property">props</span>);
          existing.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, child, element);
          existing.<span class="property">return</span> = returnFiber;
          <span class="keyword">if</span> (__DEV__) &#123;
            existing.<span class="property">_debugSource</span> = element.<span class="property">_source</span>;
            existing.<span class="property">_debugOwner</span> = element.<span class="property">_owner</span>;
          &#125;
          <span class="keyword">return</span> existing;
        &#125;
      &#125;
      <span class="comment">// Didn&#x27;t match.</span>
      <span class="title function_">deleteRemainingChildren</span>(returnFiber, child);
      <span class="keyword">break</span>;
    &#125; <span class="keyword">else</span> &#123;
      <span class="comment">// key不相同就删除</span>
      <span class="title function_">deleteChild</span>(returnFiber, child);
    &#125;
    child = child.<span class="property">sibling</span>;
  &#125;

  <span class="comment">// 如果没有命中一个key，则通过createFiberFormElement或CreateFiberFormFragment创建一个新的fiber，然后返回</span>
  <span class="keyword">if</span> (element.<span class="property">type</span> === <span class="variable constant_">REACT_FRAGMENT_TYPE</span>) &#123;
    <span class="keyword">const</span> created = <span class="title function_">createFiberFromFragment</span>(
      element.<span class="property">props</span>.<span class="property">children</span>,
      returnFiber.<span class="property">mode</span>,
      lanes,
      element.<span class="property">key</span>,
    );
    created.<span class="property">return</span> = returnFiber;
    <span class="keyword">return</span> created;
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">const</span> created = <span class="title function_">createFiberFromElement</span>(element, returnFiber.<span class="property">mode</span>, lanes);
    created.<span class="property">ref</span> = <span class="title function_">coerceRef</span>(returnFiber, currentFirstChild, element);
    created.<span class="property">return</span> = returnFiber;
    <span class="keyword">return</span> created;
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="reconcileChildrenArray"><a href="#reconcileChildrenArray" class="headerlink" title="reconcileChildrenArray"></a>reconcileChildrenArray</h2><ul>
<li><p>针对<code>newChild</code>是多节点的情况就需要调用<code>reconcileChildrenArray</code>进行diff操作</p>
</li>
<li><p>多节点会有四种可能性的变化：删除、新增、位移、更新</p>
</li>
<li><p><code>reconcileChildrenArray</code>针对这四种变化，首先会处理的是更新，当出现无法匹配的情况时，就会根据遍历的情况来判断是否处理删除或者新增，然后最后会根据情况处理位移</p>
</li>
<li><p>因为fiber是单向链表，所以<code>reconcileChildrenArray</code>的遍历不是双端遍历</p>
</li>
<li><p>首先第一轮遍历，是处理节点更新</p>
<pre><code class="highlight ts"><span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;
  <span class="comment">// newChildren遍历完了，oldFiber没有遍历完，中断遍历</span>
  <span class="keyword">if</span> (oldFiber.<span class="property">index</span> &gt; newIdx) &#123;
    nextOldFiber = oldFiber;
    oldFiber = <span class="literal">null</span>;
  &#125; <span class="keyword">else</span> &#123;
    <span class="comment">// 记录oldFiber的下一个节点</span>
    nextOldFiber = oldFiber.<span class="property">sibling</span>;
  &#125;
  <span class="comment">// 更新节点，如果节点没有匹配上，就会返回null</span>
  <span class="keyword">const</span> newFiber = <span class="title function_">updateSlot</span>(
    returnFiber,
    oldFiber,
    newChildren[newIdx],
    lanes,
  );
  <span class="comment">// newFiber为null说明节点没有匹配上，中断遍历</span>
  <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;
    <span class="comment">// oldFiber为null说明oldFiber也遍历完了</span>
    <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;
      oldFiber = nextOldFiber;
    &#125;
    <span class="keyword">break</span>;
  &#125;

  <span class="comment">/**</span>
<span class="comment">   * shouldTrackSideEffects为true表示是更新过程</span>
<span class="comment">   * mountChildFibers = ChildReconciler(false);</span>
<span class="comment">   * reconcileChildFibers = ChildReconciler(true);</span>
<span class="comment">   * ChildReconciler接收的就是shouldTrackSideEffects</span>
<span class="comment">   */</span>
  <span class="keyword">if</span> (shouldTrackSideEffects) &#123;
    <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="property">alternate</span> === <span class="literal">null</span>) &#123;
      <span class="comment">// 新节点没有现有节点，需要删除</span>
      <span class="title function_">deleteChild</span>(returnFiber, oldFiber);
    &#125;
  &#125;
  <span class="comment">// 记录固定节点的位置</span>
  lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);

  <span class="comment">// 将新节点拼接成以sibling为指针的单向链表</span>
  <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;
    resultingFirstChild = newFiber;
  &#125; <span class="keyword">else</span> &#123;
    previousNewFiber.<span class="property">sibling</span> = newFiber;
  &#125;
  previousNewFiber = newFiber;
  oldFiber = nextOldFiber;
&#125;</code></pre>
</li>
<li><p>遍历完匹配的节点后，就判断新节点是否遍历完，如果遍历完，那么剩余的oldFiber都是要删除的</p>
<pre><code class="highlight ts"><span class="keyword">if</span> (newIdx === newChildren.<span class="property">length</span>) &#123;
  <span class="title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);
  <span class="keyword">if</span> (<span class="title function_">getIsHydrating</span>()) &#123;
    <span class="keyword">const</span> numberOfForks = newIdx;
    <span class="title function_">pushTreeFork</span>(returnFiber, numberOfForks);
  &#125;
  <span class="keyword">return</span> resultingFirstChild;
&#125;</code></pre>
</li>
<li><p>如果新旧点没有遍历完，就判断旧fiber链是否遍历完，如果遍历完那么剩余的新节点全部作为新fiber插入</p>
<pre><code class="highlight ts"><span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;
  <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;
    <span class="comment">// 创建新fiber节点</span>
    <span class="keyword">const</span> newFiber = <span class="title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);
    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;
      <span class="keyword">continue</span>;
    &#125;

    <span class="comment">// 记录固定节点</span>
    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);

    <span class="comment">// 将新fiber拼接成以sibling为指针的单向链表</span>
    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;
      resultingFirstChild = newFiber;
    &#125; <span class="keyword">else</span> &#123;
      previousNewFiber.<span class="property">sibling</span> = newFiber;
    &#125;
    previousNewFiber = newFiber;
  &#125;
  <span class="keyword">if</span> (<span class="title function_">getIsHydrating</span>()) &#123;
    <span class="keyword">const</span> numberOfForks = newIdx;
    <span class="title function_">pushTreeFork</span>(returnFiber, numberOfForks);
  &#125;
  <span class="keyword">return</span> resultingFirstChild;
&#125;</code></pre>
</li>
<li><p>执行到这一步，说明新旧节点都没有遍历完，就说明存在有位移的未知序列</p>
<pre><code class="highlight ts"><span class="comment">// 首先创建一个以oldFiber key为键，值为oldFiber的map</span>
<span class="keyword">const</span> existingChildren = <span class="title function_">mapRemainingChildren</span>(returnFiber, oldFiber);

<span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;
  <span class="comment">// 然后根据map中的oldFiber创建新fiber</span>
  <span class="keyword">const</span> newFiber = <span class="title function_">updateFromMap</span>(
    existingChildren,
    returnFiber,
    newIdx,
    newChildren[newIdx],
    lanes,
  );
  <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;
    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;
      <span class="keyword">if</span> (newFiber.<span class="property">alternate</span> !== <span class="literal">null</span>) &#123;
        <span class="comment">// 如果newFiber.alternate不为null，说明是根据oldFiber创建的，那么就需要在map中删除oldFiber</span>
        existingChildren.<span class="title function_">delete</span>(
          newFiber.<span class="property">key</span> === <span class="literal">null</span> ? newIdx : newFiber.<span class="property">key</span>,
        );
      &#125;
    &#125;

    <span class="comment">// 根据lastPlacedIndex判断是否移动节点</span>
    lastPlacedIndex = <span class="title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);

    <span class="comment">// 将新fiber拼接成以sibling为指针的单向链表</span>
    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;
      resultingFirstChild = newFiber;
    &#125; <span class="keyword">else</span> &#123;
      previousNewFiber.<span class="property">sibling</span> = newFiber;
    &#125;
    previousNewFiber = newFiber;
  &#125;
&#125;

<span class="keyword">if</span> (shouldTrackSideEffects) &#123;
  <span class="comment">// 删除剩余的oldFiber</span>
  existingChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> <span class="title function_">deleteChild</span>(returnFiber, child));
&#125;</code></pre></li>
<li><p>移动节点的核心是在<code>placeChild</code>这个函数中，如果当前正在遍历的节点的oldIndex是在<code>lastPlacedIndex</code>的右边，就说明它的位置没变化，因为旧节点中就处于右边，新节点中也处于右边。</p>
<ul>
<li>例如：old：A -&gt; B -&gt; C -&gt; D，new：D -&gt; A -&gt; B -&gt; C</li>
<li>遍历到D时，<code>lastPlacedIndex = D的oldIndex = 3</code></li>
<li>然后遍历到A时，A的<code>oldIndex</code>为0，小于3，说明A在旧序列中肯定不是D的右边，所以A肯定产生了位移<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">placeChild</span>(<span class="params"></span>
<span class="params">  newFiber: Fiber,</span>
<span class="params">  lastPlacedIndex: number,</span>
<span class="params">  newIndex: number,</span>
<span class="params"></span>): number &#123;
  newFiber.<span class="property">index</span> = newIndex;
  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;
    newFiber.<span class="property">flags</span> |= <span class="title class_">Forked</span>;
    <span class="keyword">return</span> lastPlacedIndex;
  &#125;
  <span class="keyword">const</span> current = newFiber.<span class="property">alternate</span>;
  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;
    <span class="keyword">const</span> oldIndex = current.<span class="property">index</span>;
    <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;
      <span class="comment">// 小于lastPlacedIndex 产生了位移</span>
      newFiber.<span class="property">flags</span> |= <span class="title class_">Placement</span> | <span class="title class_">PlacementDEV</span>;
      <span class="keyword">return</span> lastPlacedIndex;
    &#125; <span class="keyword">else</span> &#123;
      <span class="comment">// 没有位移，返回当前的oldIndex</span>
      <span class="keyword">return</span> oldIndex;
    &#125;
  &#125; <span class="keyword">else</span> &#123;
    newFiber.<span class="property">flags</span> |= <span class="title class_">Placement</span> | <span class="title class_">PlacementDEV</span>;
    <span class="keyword">return</span> lastPlacedIndex;
  &#125;
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>针对单节点的diff，会遍历oldFiber链，如果有匹配的fiber，就以匹配的生成新fiber，如果没有就新建一个fiber，然后删除不匹配的fiber</li>
<li>针对多节点diff<ul>
<li>首先是从头向尾遍历，针对复用的fiber进行更新，如果无法复用就中断遍历</li>
<li>然后判断新旧节点的遍历情况，来判断是否新增或者删除</li>
<li>如果都没有遍历完，就创建一个map<code>Map&lt;old key, old Fiber&gt;</code>，然后遍历新节点，基于map来创建新fiber，然后根据<code>lastPlacedIndex</code>来判断是否产生了位移，遍历完最后删除剩余的oldFiber</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3模版编译原理</title>
    <url>/2022/08/31/Vue3%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="模版编译流程"><a href="#模版编译流程" class="headerlink" title="模版编译流程"></a>模版编译流程</h2><p>Vue3模版编译就是把template字符串编译成渲染函数</p>
<pre><code class="highlight js"><span class="comment">// template</span>
&lt;div&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;LH_R&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&lt;/div&gt;

<span class="comment">// render</span>
<span class="keyword">import</span> &#123; toDisplayString <span class="keyword">as</span> _toDisplayString, createElementVNode <span class="keyword">as</span> _createElementVNode, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>

<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;
  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [
    <span class="title function_">_createElementVNode</span>(<span class="string">&quot;p&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">LH_R</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)
  ]))
&#125;</code></pre>

<p>我会按照编译流程分3步分析</p>
<ol>
<li><strong>parse</strong>：将模版字符串转换成模版AST</li>
<li><strong>transform</strong>：将模版AST转换为用于描述渲染函数的AST</li>
<li><strong>generate</strong>：根据AST生成渲染函数<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">baseCompile</span>(<span class="params"></span>
<span class="params">  template: <span class="built_in">string</span> | RootNode,</span>
<span class="params">  options: CompilerOptions = &#123;&#125;</span>
<span class="params"></span>): <span class="title class_">CodegenResult</span> &#123;
  <span class="comment">// ...</span>
  <span class="keyword">const</span> ast = <span class="title function_">isString</span>(template) ? <span class="title function_">baseParse</span>(template, options) : template

  <span class="keyword">const</span> [nodeTransforms, directiveTransforms] = <span class="title function_">getBaseTransformPreset</span>(
    prefixIdentifiers
  )
  <span class="title function_">transform</span>(
    ast,
    <span class="title function_">extend</span>(&#123;&#125;, options, &#123;
      prefixIdentifiers,
      <span class="attr">nodeTransforms</span>: [
        ...nodeTransforms,
        ...(options.<span class="property">nodeTransforms</span> || []) <span class="comment">// user transforms</span>
      ],
      <span class="attr">directiveTransforms</span>: <span class="title function_">extend</span>(
        &#123;&#125;,
        directiveTransforms,
        options.<span class="property">directiveTransforms</span> || &#123;&#125; <span class="comment">// user transforms</span>
      )
    &#125;)
  )

  <span class="keyword">return</span> <span class="title function_">generate</span>(
    ast,
    <span class="title function_">extend</span>(&#123;&#125;, options, &#123;
      prefixIdentifiers
    &#125;)
  )
&#125;</code></pre></li>
</ol>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><ul>
<li><p>parse对模版字符串进行遍历，然后循环判断开始标签和结束标签把字符串分割成一个个<strong>token</strong>，存在一个token列表，然后扫描token列表并维护一个开始标签栈，每当扫描一个开始标签节点，就将其压入栈顶，栈顶的节点始终作为下一个扫描的节点的父节点。这样，当所有Token扫描完成后，即可构建成一颗树形AST</p>
</li>
<li><p>以下是简化版<strong>parseChildren</strong>源码，是parse的主入口</p>
<pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">parseChildren</span>(<span class="params"></span>
<span class="params">  context: ParserContext,</span>
<span class="params">  mode: TextModes,</span>
<span class="params">  ancestors: ElementNode[] <span class="comment">// 节点栈结构，用于维护节点嵌套关系</span></span>
<span class="params"></span>): <span class="title class_">TemplateChildNode</span>[] &#123;
  <span class="comment">// 获取父节点</span>
  <span class="keyword">const</span> parent = <span class="title function_">last</span>(ancestors)
  <span class="keyword">const</span> ns = parent ? parent.<span class="property">ns</span> : <span class="title class_">Namespaces</span>.<span class="property">HTML</span>
  <span class="keyword">const</span> <span class="attr">nodes</span>: <span class="title class_">TemplateChildNode</span>[] = [] <span class="comment">// 存储解析出来的AST子节点</span>

  <span class="comment">// 遇到闭合标签结束解析</span>
  <span class="keyword">while</span> (!<span class="title function_">isEnd</span>(context, mode, ancestors)) &#123;
    <span class="comment">// 切割处理的模版字符串</span>
    <span class="keyword">const</span> s = context.<span class="property">source</span>
    <span class="keyword">let</span> <span class="attr">node</span>: <span class="title class_">TemplateChildNode</span> | <span class="title class_">TemplateChildNode</span>[] | <span class="literal">undefined</span> = <span class="literal">undefined</span>

    <span class="keyword">if</span> (mode === <span class="title class_">TextModes</span>.<span class="property">DATA</span> || mode === <span class="title class_">TextModes</span>.<span class="property">RCDATA</span>) &#123;
      <span class="keyword">if</span> (!context.<span class="property">inVPre</span> &amp;&amp; <span class="title function_">startsWith</span>(s, context.<span class="property">options</span>.<span class="property">delimiters</span>[<span class="number">0</span>])) &#123;
        <span class="comment">// 解析插值表达式&#123;&#123;&#125;&#125;</span>
        node = parseInterpolation(context, mode)
      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode === <span class="title class_">TextModes</span>.<span class="property">DATA</span> &amp;&amp; s[<span class="number">0</span>] === <span class="string">&#x27;&lt;&#x27;</span>) &#123;
        <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;!&#x27;</span>) &#123;
          <span class="comment">// 解析注释节点和文档声明...</span>
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>] === <span class="string">&#x27;/&#x27;</span>) &#123;
          <span class="keyword">if</span> (s[<span class="number">2</span>] === <span class="string">&#x27;&gt;&#x27;</span>) &#123;
            <span class="comment">// 针对自闭合标签，前进三个字符</span>
            <span class="title function_">advanceBy</span>(context, <span class="number">3</span>)
            <span class="keyword">continue</span>
          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(s[<span class="number">2</span>])) &#123;
            <span class="comment">// 解析结束标签</span>
            <span class="title function_">parseTag</span>(context, <span class="title class_">TagType</span>.<span class="property">End</span>, parent)
            <span class="keyword">continue</span>
          &#125; <span class="keyword">else</span> &#123;
            <span class="comment">// 如果不符合上述情况，就作为伪注释解析</span>
            node = <span class="title function_">parseBogusComment</span>(context)
          &#125;
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(s[<span class="number">1</span>])) &#123;
          <span class="comment">// 解析html开始标签，获得解析到的AST节点</span>
          node = <span class="title function_">parseElement</span>(context, ancestors)
        &#125;
      &#125;
    &#125;
    <span class="keyword">if</span> (!node) &#123;
      <span class="comment">// 普通文本节点</span>
      node = <span class="title function_">parseText</span>(context, mode)
    &#125;

    <span class="comment">// 如果节点是数组，就遍历添加到nodes中</span>
    <span class="keyword">if</span> (<span class="title function_">isArray</span>(node)) &#123;
      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">length</span>; i++) &#123;
        <span class="title function_">pushNode</span>(nodes, node[i])
      &#125;
    &#125; <span class="keyword">else</span> &#123;
      <span class="title function_">pushNode</span>(nodes, node)
    &#125;
  &#125;
  <span class="keyword">return</span> nodes
&#125;</code></pre>
</li>
<li><p>就拿<code>&lt;div&gt;&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;</code>流程举例</p>
</li>
</ul>
<ol>
<li>div开始标签入栈，context.source &#x3D; <code>&lt;p&gt;LH_R&lt;/p&gt;&lt;/div&gt;</code>，ancestors &#x3D; <code>[div]</code></li>
<li>p开始标签入栈，context.source &#x3D; <code>LH_R&lt;/p&gt;&lt;/div&gt;</code>，ancestors &#x3D; <code>[div, p]</code></li>
<li>解析文本<code>LH_R</code></li>
<li>解析p结束标签，p标签出栈</li>
<li>解析div结束标签，div标签出栈</li>
<li>栈空，模版解析完毕</li>
</ol>
<h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><ul>
<li>transform采用深度优先的方式对AST进行遍历，在遍历过程中，对节点的操作与转换采用插件化架构，都封装为独立的函数，然后转换函数通过<code>context.nodeTransforms</code>来注册</li>
<li>转换过程是优先转换子节点，因为有的父节点的转换依赖子节点</li>
<li>以下是AST遍历<code>traverseNode</code>核心源码<pre><code class="highlight ts"><span class="comment">/* </span>
<span class="comment">  遍历AST节点树，通过node转换器对当前节点进行node转换</span>
<span class="comment">  子节点全部遍历完成后执行对应指令的onExit回调退出转换</span>
<span class="comment">*/</span>
<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">traverseNode</span>(<span class="params"></span>
<span class="params">  node: RootNode | TemplateChildNode,</span>
<span class="params">  context: TransformContext</span>
<span class="params"></span>) &#123;
  <span class="comment">// 记录当前正在遍历的节点</span>
  context.<span class="property">currentNode</span> = node

  <span class="comment">/* </span>
<span class="comment">    nodeTransforms：transformElement、transformExpression、transformText...</span>
<span class="comment">    transformElement：负责整个节点层面的转换</span>
<span class="comment">    transformExpression：负责节点中表达式的转化</span>
<span class="comment">    transformText：负责节点中文本的转换</span>
<span class="comment">  */</span>
  <span class="keyword">const</span> &#123; nodeTransforms &#125; = context
  <span class="keyword">const</span> exitFns = []
  <span class="comment">// 依次调用转换工具</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodeTransforms.<span class="property">length</span>; i++) &#123;
    <span class="comment">/* </span>
<span class="comment">      转换器只负责生成onExit回调，onExit函数才是执行转换主逻辑的地方，为什么要推到栈中先不执行呢？</span>
<span class="comment">      因为要等到子节点都转换完成挂载gencodeNode后，也就是深度遍历完成后</span>
<span class="comment">      再执行当前节点栈中的onExit，这样保证了子节点的表达式全部生成完毕</span>
<span class="comment">    */</span>
    <span class="keyword">const</span> onExit = nodeTransforms[i](node, context)
    <span class="keyword">if</span> (onExit) &#123;
      <span class="keyword">if</span> (<span class="title function_">isArray</span>(onExit)) &#123;
        <span class="comment">// v-if、v-for为结构化指令，其onExit是数组形式</span>
        exitFns.<span class="title function_">push</span>(...onExit)
      &#125; <span class="keyword">else</span> &#123;
        exitFns.<span class="title function_">push</span>(onExit)
      &#125;
    &#125;
    <span class="keyword">if</span> (!context.<span class="property">currentNode</span>) &#123;
      <span class="comment">// node was removed 节点被移除</span>
      <span class="keyword">return</span>
    &#125; <span class="keyword">else</span> &#123;
      <span class="comment">// node may have been replaced</span>
      <span class="comment">// 因为在转换的过程中节点可能被替换，恢复到之前的节点</span>
      node = context.<span class="property">currentNode</span>
    &#125;
  &#125;

  <span class="keyword">switch</span> (node.<span class="property">type</span>) &#123;
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">COMMENT</span>:
      <span class="keyword">if</span> (!context.<span class="property">ssr</span>) &#123;
        <span class="comment">// inject import for the Comment symbol, which is needed for creating</span>
        <span class="comment">// comment nodes with `createVNode`</span>
        <span class="comment">// 需要导入createComment辅助函数</span>
        context.<span class="title function_">helper</span>(<span class="variable constant_">CREATE_COMMENT</span>)
      &#125;
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">INTERPOLATION</span>:
      <span class="comment">// no need to traverse, but we need to inject toString helper</span>
      <span class="keyword">if</span> (!context.<span class="property">ssr</span>) &#123;
        context.<span class="title function_">helper</span>(<span class="variable constant_">TO_DISPLAY_STRING</span>)
      &#125;
      <span class="keyword">break</span>

    <span class="comment">// for container types, further traverse downwards</span>
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">IF</span>:
      <span class="comment">// 对v-if生成的节点束进行遍历</span>
      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.<span class="property">branches</span>.<span class="property">length</span>; i++) &#123;
        <span class="title function_">traverseNode</span>(node.<span class="property">branches</span>[i], context)
      &#125;
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">IF_BRANCH</span>:
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">FOR</span>:
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">ELEMENT</span>:
    <span class="keyword">case</span> <span class="title class_">NodeTypes</span>.<span class="property">ROOT</span>:
      <span class="comment">// 遍历子节点</span>
      <span class="title function_">traverseChildren</span>(node, context)
      <span class="keyword">break</span>
  &#125;
  <span class="comment">// 当前节点树遍历完成，依次执行栈中的指令退出回调onExit</span>
  context.<span class="property">currentNode</span> = node
  <span class="keyword">let</span> i = exitFns.<span class="property">length</span>
  <span class="keyword">while</span> (i--) &#123;
    exitFns[i]()
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>generate</code>生成代码大致分为3步</p>
<ol>
<li>创建代码生成上下文，因为该上下文对象是用于维护代码生成过程中程序的运行状态，如：</li>
</ol>
<ul>
<li><code>code</code>：最终生成的渲染函数</li>
<li><code>push</code>：拼接代码</li>
<li><code>indent</code>：代码缩进</li>
<li><code>deindent</code>：减少代码缩进</li>
<li>…</li>
</ul>
<ol start="2">
<li>生成渲染函数的前置预设部分<ul>
<li>module模式下：<code>genModulePreamble()</code></li>
<li>function模式下：<code>genFunctionPreamble</code></li>
<li>还有一些函数名，参数，作用域…</li>
</ul>
</li>
<li>生成渲染函数<ul>
<li>通过调用<code>genNode</code>，然后在<code>genNode</code>内部通过switch语句来匹配不同类型的节点，并调用对应的生成器函数</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000023594560">Vue3 模板编译原理</a></li>
<li>《Vue.js设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3+Vite3 SSR基本搭建</title>
    <url>/2022/08/27/Vue3-Vite3-SSR%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<ul>
<li>首先说明如果是生产使用强烈推荐Nuxt，但是如果想深入服务端渲染的运行原理，可以看本篇，会根据渲染流程搭建一个demo版ssr，源码在最后会贴上</li>
<li>主要技术栈：Vite3 + Vue3 + pinia + VueRouter4 + express</li>
<li>开始搭建之前，先说一下SSR渲染流程</li>
</ul>
<h3 id="SSR渲染流程"><a href="#SSR渲染流程" class="headerlink" title="SSR渲染流程"></a>SSR渲染流程</h3><ul>
<li>首先浏览器向服务器请求，然后服务器根据请求的路由，会匹配相关的路由组件，然后执行组件的自定义服务端生命周期(例：Nuxt的asyncData)或者自定义获取数据的hook，并且把执行后的数据收集起来，统一在window的属性中存储</li>
<li>然后vue的组件会被renderToString渲染成静态HTML字符串，替换掉index.html的提前指定的占位代码。然后index.html改变后的静态字符串发给客户端</li>
<li>客户端拿到后，首先对数据进行初始化，然后进行激活，因为当前html只是静态数据，激活主要做两件事<ul>
<li><ol>
<li>把页面中的DOM元素与虚拟DOM之间建立联系</li>
</ol>
</li>
<li><ol start="2">
<li>为页面中的DOM元素添加事件绑定</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><ul>
<li>首先用vite命令创建项目<code>pnpm create vite vue-ssr --template vue-ts</code><ul>
<li>安装相关依赖：<code>pnpm add express pinia vue-router@4</code></li>
</ul>
</li>
<li>创建三个文件 <code>touch server.js  src/entry-client.ts src/entry-server.js</code><ul>
<li>server.js：服务端启动文件</li>
<li>entry-client.ts：客户端入口，应用挂载元素</li>
<li>entry-server.js：服务端入口，处理服务端逻辑和静态资源</li>
</ul>
</li>
<li>修改<code>package.json</code>运行脚本<pre><code class="highlight js"><span class="string">&quot;scripts&quot;</span>: &#123;
  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;node server&quot;</span>, <span class="comment">// 运行开发环境</span>
&#125;</code></pre></li>
<li>然后需要把应用创建都改为函数的方式进行调用创建，因为在SSR环境下，和纯客户端不一样，服务器只会初始化一次，所以为了防止状态污染，每次请求必须是全新的实例<pre><code class="highlight js"><span class="comment">// src/main.ts</span>
<span class="keyword">import</span> &#123; createSSRApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>
<span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>
<span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>
<span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>

<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> app = <span class="title function_">createSSRApp</span>(<span class="title class_">App</span>)
  <span class="keyword">const</span> router = <span class="title function_">createRouter</span>()
  <span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()
  app.<span class="title function_">use</span>(router)
  app.<span class="title function_">use</span>(pinia)
  <span class="keyword">return</span> &#123; app, router, pinia &#125;
&#125;</code></pre></li>
<li>roter同理<pre><code class="highlight js"><span class="comment">// src/router/index</span>
<span class="keyword">import</span> &#123; createRouter <span class="keyword">as</span> _createRrouter, createMemoryHistory, createWebHistory, <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>

<span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">RouteRecordRaw</span>[] = [
  ...
]

<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRouter</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> <span class="title function_">_createRrouter</span>(&#123;
    <span class="attr">history</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">SSR</span> ? <span class="title function_">createMemoryHistory</span>() : <span class="title function_">createWebHistory</span>(),
    routes,
  &#125;)
&#125;</code></pre></li>
<li>然后修改index.html，增加注释占位和客户端入口文件，在之后的服务端渲染时注入<pre><code class="highlight html"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">head</span>&gt;</span>
    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/vite.svg&quot;</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>
    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vite + Vue + TS<span class="tag">&lt;/<span class="name">title</span>&gt;</span>
    <span class="comment">&lt;!-- 静态资源占位 .js .css ... --&gt;</span>
    <span class="comment">&lt;!--preload-links--&gt;</span>
  <span class="tag">&lt;/<span class="name">head</span>&gt;</span>
  <span class="tag">&lt;<span class="name">body</span>&gt;</span>
    <span class="comment">&lt;!-- 应用代码占位 --&gt;</span>
    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="comment">&lt;!--ssr-outlet--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>
    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.ts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
    <span class="comment">&lt;!-- 引用客户端入口文件 --&gt;</span>
    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/entry-client.ts&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span>
<span class="language-xml"><span class="language-handlebars">      // 服务端获取的数据统一挂载到window上</span></span>
<span class="language-xml"><span class="language-handlebars">      window.__INITIAL_STATE__ = &#x27;<span class="comment">&lt;!--pinia-state--&gt;</span>&#x27;</span></span>
<span class="language-xml"><span class="language-handlebars">    </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">body</span>&gt;</span>
<span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre></li>
</ul>
<h3 id="2-服务端启动文件"><a href="#2-服务端启动文件" class="headerlink" title="2. 服务端启动文件"></a>2. 服务端启动文件</h3><ul>
<li>创建项目后，就开始编写服务端启动文件，也就是项目根路径下的server.js文件</li>
<li>这个文件的功能是启动一个node服务，然后根据请求，读取html文件，处理资源后把注释进行替换，最后把html发送给客户端<pre><code class="highlight js"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>
<span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>
<span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>
<span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>

<span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;
<span class="keyword">const</span> __dirname = path.<span class="title function_">dirname</span>(<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>))
<span class="keyword">const</span> <span class="built_in">require</span> = <span class="title function_">createRequire</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);
<span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">p</span>) =&gt; path.<span class="title function_">resolve</span>(__dirname, p);

<span class="keyword">const</span> <span class="title function_">createServer</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;
  <span class="comment">// 创建node服务</span>
  <span class="keyword">const</span> app = <span class="title function_">express</span>()

  <span class="comment">/**</span>
<span class="comment">   * @官方解释</span>
<span class="comment">   * 以中间件模式创建vite应用，这将禁用vite自身的HTML服务逻辑</span>
<span class="comment">   * 并让上级服务器接管</span>
<span class="comment">   */</span>
  <span class="keyword">const</span> vite = <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">&#x27;vite&#x27;</span>).<span class="title function_">createServer</span>(&#123;
    <span class="attr">server</span>: &#123;
      <span class="attr">middlewareMode</span>: <span class="literal">true</span>,
    &#125;,
    <span class="attr">appType</span>: <span class="string">&#x27;custom&#x27;</span>
  &#125;);
  app.<span class="title function_">use</span>(vite.<span class="property">middlewares</span>);
  
  app.<span class="title function_">use</span>(<span class="string">&#x27;*&#x27;</span>, <span class="keyword">async</span> (req, res, next) =&gt; &#123;
    <span class="keyword">const</span> url = req.<span class="property">originalUrl</span>
    <span class="keyword">try</span> &#123;
      <span class="comment">// 读取index.html</span>
      <span class="keyword">let</span> template = fs.<span class="title function_">readFileSync</span>(
        <span class="title function_">resolve</span>(<span class="string">&#x27;index.html&#x27;</span>),
        <span class="string">&#x27;utf-8&#x27;</span>
      )
      <span class="comment">// 应用vite html转换，会注入vite HMR</span>
      template = <span class="keyword">await</span> vite.<span class="title function_">transformIndexHtml</span>(url, template)

      <span class="comment">// 加载服务端入口</span>
      <span class="keyword">const</span> render = (<span class="keyword">await</span> vite.<span class="title function_">ssrLoadModule</span>(<span class="string">&#x27;/src/entry-server.js&#x27;</span>)).<span class="property">render</span>
      <span class="keyword">const</span> [ appHtml, piniaState ] = <span class="keyword">await</span> <span class="title function_">render</span>(url)

      <span class="comment">// 替换处理过后的模版</span>
      <span class="keyword">const</span> html = template
        .<span class="title function_">replace</span>(<span class="string">`&lt;!--ssr-outlet--&gt;`</span>, appHtml)
        .<span class="title function_">replace</span>(<span class="string">`&lt;!--pinia-state--&gt;`</span>, piniaState)
      res.<span class="title function_">status</span>(<span class="number">200</span>).<span class="title function_">set</span>(&#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;).<span class="title function_">end</span>(html)
    &#125; <span class="keyword">catch</span> (error) &#123;
      vite?.<span class="title function_">ssrFixStacktrace</span>(error)
      <span class="title function_">next</span>(e)
    &#125;
  &#125;)

  <span class="comment">// 监听5100端口</span>
  app.<span class="title function_">listen</span>(<span class="number">5100</span>)
&#125;

<span class="title function_">createServer</span>();</code></pre></li>
</ul>
<h3 id="3-服务端入口文件"><a href="#3-服务端入口文件" class="headerlink" title="3. 服务端入口文件"></a>3. 服务端入口文件</h3><ul>
<li>服务端入口文件主要是调用SSR的renderToString和收集需要发送的资源和数据<pre><code class="highlight js"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&#x27;vue/server-renderer&#x27;</span>
<span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./main&#x27;</span>

<span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">url, manifest</span>) &#123;
  <span class="keyword">const</span> &#123; app, router, pinia &#125; = <span class="title function_">createApp</span>()

  router.<span class="title function_">push</span>(url)
  <span class="keyword">await</span> router.<span class="title function_">isReady</span>()

  <span class="keyword">const</span> ctx = &#123;&#125;
  <span class="keyword">const</span> html = <span class="keyword">await</span> <span class="title function_">renderToString</span>(app, ctx)
  <span class="keyword">return</span> [html, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(pinia.<span class="property">state</span>.<span class="property">value</span>)]
&#125;</code></pre></li>
</ul>
<h3 id="4-客户端入口文件"><a href="#4-客户端入口文件" class="headerlink" title="4. 客户端入口文件"></a>4. 客户端入口文件</h3><ul>
<li>客户端入口文件主要用于挂载节点和初始化数据<pre><code class="highlight js"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;./main&#x27;</span>

<span class="keyword">const</span> &#123; app, router, pinia &#125; = <span class="title function_">createApp</span>()

router.<span class="title function_">isReady</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;
  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">__INITIAL_STATE__</span>) &#123;
    pinia.<span class="property">state</span>.<span class="property">value</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">window</span>.<span class="property">__INITIAL_STATE__</span>);
  &#125;

  app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)
&#125;)</code></pre></li>
</ul>
<h3 id="5-组件和页面"><a href="#5-组件和页面" class="headerlink" title="5. 组件和页面"></a>5. 组件和页面</h3><ul>
<li>组件和页面获取数据主要有两种方式，一种是增加一个<code>asyncData</code>选项，然后在enter-server.js的逻辑中增加遍历当前组件的逻辑，统一触发<code>asyncData</code>，但是现在都是用<code>script setup</code>的方式写业务代码，所以有点麻烦，<pre><code class="highlight js">&lt;script&gt;
  <span class="keyword">export</span> defualt &#123;
    <span class="title function_">asyncData</span>(<span class="params"></span>) &#123;
      <span class="comment">// 服务端获取数据逻辑</span>
    &#125;
  &#125;
&lt;/script&gt;

<span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&#x27;ts&#x27;</span>&gt;</span></span>
<span class="language-xml">  ...</span>
<span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></code></pre></li>
<li>另一种就是hook的方式，通过<code>import.meta.env.SSR</code>的方式进行判断</li>
<li>对于数据具体存储方式，大概有三种，一种是存在vuex或者pinia这种全局状态库中，一种是存在context上下文中，还有一种是自定义数据</li>
</ul>
<h3 id="6-生产环境"><a href="#6-生产环境" class="headerlink" title="6. 生产环境"></a>6. 生产环境</h3><h4 id="6-1-pacnakge-json"><a href="#6-1-pacnakge-json" class="headerlink" title="6.1 pacnakge.json"></a>6.1 pacnakge.json</h4><ul>
<li>增加构建脚本<pre><code class="highlight diff">&quot;scripts&quot;: &#123;
  &quot;dev&quot;: &quot;node server&quot;,
<span class="addition">+ &quot;build&quot;: &quot;npm run build:client &amp;&amp; npm run build:server&quot;,</span>
<span class="addition">+  &quot;build:client&quot;: &quot;vite build --ssrManifest --outDir dist/client&quot;,</span>
<span class="addition">+  &quot;build:server&quot;: &quot;vite build --ssr src/entry-server.js --outDir dist/server&quot;,</span>
<span class="addition">+  &quot;serve&quot;: &quot;cross-env NODE_ENV=production node server&quot;</span>
&#125;,</code></pre></li>
</ul>
<h4 id="6-2-服务端运行文件"><a href="#6-2-服务端运行文件" class="headerlink" title="6.2 服务端运行文件"></a>6.2 服务端运行文件</h4><ul>
<li>针对生产环境，需要启动静态资源服务，引用路径需要改为dist目录下</li>
</ul>
<pre><code class="highlight diff">import fs from &#x27;fs&#x27;
import path from &#x27;path&#x27;
import &#123; fileURLToPath &#125; from &#x27;url&#x27;
import express from &#x27;express&#x27;

import &#123; createRequire &#125; from &#x27;module&#x27;;
const __dirname = path.dirname(fileURLToPath(import.meta.url))
const require = createRequire(import.meta.url);
const resolve = (p) =&gt; path.resolve(__dirname, p);

const createServer = async (isProd = process.env.NODE_ENV <span class="comment">=== &#x27;production&#x27;) =&gt; &#123;</span>
  const app = express()

<span class="deletion">-  const vite = await require(&#x27;vite&#x27;).createServer(&#123;</span>
<span class="deletion">-    server: &#123;</span>
<span class="deletion">-      middlewareMode: true,</span>
<span class="deletion">-    &#125;,</span>
<span class="deletion">-    appType: &#x27;custom&#x27;</span>
<span class="deletion">-  &#125;);</span>
<span class="deletion">-  app.use(vite.middlewares);</span>

<span class="addition">+  let vite;</span>
<span class="addition">+  if (isProd) &#123;</span>
<span class="addition">+    app.use(require(&#x27;compression&#x27;)());</span>
<span class="addition">+    app.use(</span>
<span class="addition">+      require(&#x27;serve-static&#x27;)(resolve(&#x27;./dist/client&#x27;), &#123;</span>
<span class="addition">+        index: false</span>
<span class="addition">+      &#125;)</span>
<span class="addition">+    );</span>
<span class="addition">+  &#125; else &#123;</span>
<span class="addition">+    vite = await require(&#x27;vite&#x27;).createServer(&#123;</span>
<span class="addition">+      server: &#123;</span>
<span class="addition">+        middlewareMode: true,</span>
<span class="addition">+      &#125;,</span>
<span class="addition">+      appType: &#x27;custom&#x27;</span>
<span class="addition">+    &#125;);</span>
<span class="addition">+    app.use(vite.middlewares);</span>
<span class="addition">+  &#125;</span>
   // 通过bulid --ssrManifest命令生成的静态资源映射需要在生产环境下引用
<span class="addition">+  const manifest = isProd ? fs.readFileSync(resolve(&#x27;./dist/client/ssr-manifest.json&#x27;), &#x27;utf-8&#x27;) :&#123;&#125;</span>
  
  app.use(&#x27;*&#x27;, async (req, res, next) =&gt; &#123;
    const url = req.originalUrl
    try &#123;
<span class="deletion">-      let template = fs.readFileSync(</span>
<span class="deletion">-        resolve(&#x27;index.html&#x27;),</span>
<span class="deletion">-        &#x27;utf-8&#x27;</span>
<span class="deletion">-      )</span>
<span class="deletion">-      template = await vite.transformIndexHtml(url, template)</span>
<span class="deletion">-      const render = (await vite.ssrLoadModule(&#x27;/src/entry-server.js&#x27;)).render</span>
<span class="deletion">-      const [ appHtml, piniaState ] = await render(url)</span>

<span class="addition">+      let template, render</span>
<span class="addition">+      if (isProd) &#123;</span>
<span class="addition">+        template = fs.readFileSync(resolve(&#x27;./dist/client/index.html&#x27;), &#x27;utf-8&#x27;)</span>
<span class="addition">+        render = (await import(&#x27;./dist/server/entry-server.js&#x27;)).render</span>
<span class="addition">+      &#125; else &#123;</span>
<span class="addition">+        template = fs.readFileSync(</span>
<span class="addition">+          resolve(&#x27;index.html&#x27;),</span>
<span class="addition">+          &#x27;utf-8&#x27;</span>
<span class="addition">+        )</span>
<span class="addition">+        template = await vite.transformIndexHtml(url, template)</span>
<span class="addition">+        render = (await vite.ssrLoadModule(&#x27;/src/entry-server.js&#x27;)).render</span>
<span class="addition">+      &#125;</span>
<span class="addition">+      const [ appHtml, preloadLinks, piniaState ] = await render(url, manifest)</span>
      const html = template
        .replace(`&lt;!--preload-links--&gt;`, preloadLinks)
        .replace(`&lt;!--ssr-outlet--&gt;`, appHtml)
<span class="addition">+        .replace(`&lt;!--pinia-state--&gt;`, piniaState)</span>
      res.status(200).set(&#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;).end(html)
    &#125; catch (error) &#123;
      vite?.ssrFixStacktrace(error)
      next()
    &#125;
  &#125;)

  app.listen(5100)
&#125;

createServer();
</code></pre>

<h4 id="6-3-服务端入口文件"><a href="#6-3-服务端入口文件" class="headerlink" title="6.3 服务端入口文件"></a>6.3 服务端入口文件</h4><ul>
<li>服务端入口文件主要是增加了构建时生成的静态资源映射处理的逻辑<pre><code class="highlight diff">import &#123; basename &#125; from &#x27;path&#x27;
import &#123; renderToString &#125; from &#x27;vue/server-renderer&#x27;
import &#123; createApp &#125; from &#x27;./main&#x27;

export async function render(url, manifest) &#123;
  const &#123; app, router, pinia &#125; = createApp()

  router.push(url)
  await router.isReady()

  const ctx = &#123;&#125;
  const html = await renderToString(app, ctx)
<span class="addition">+  const preloadLinks = renderPreloadLinks(ctx.modules, manifest)</span>
<span class="addition">+  return [html, preloadLinks, JSON.stringify(pinia.state.value)]</span>
&#125;

 function renderPreloadLinks(modules, manifest) &#123;
   let links = &#x27;&#x27;
   const seen = new Set()
   modules.forEach((id) =&gt; &#123;
     const files = manifest[id]
     if (files) &#123;
       files.forEach((file) =&gt; &#123;
         if (!seen.has(file)) &#123;
           seen.add(file)
           const filename = basename(file)
           if (manifest[filename]) &#123;
             for (const depFile of manifest[filename]) &#123;
               links += renderPreloadLink(depFile)
               seen.add(depFile)
             &#125;
           &#125;
           links += renderPreloadLink(file)
         &#125;
       &#125;)
     &#125;
   &#125;)
   return links
 &#125;
 
 function renderPreloadLink(file) &#123;
   if (file.endsWith(&#x27;.js&#x27;)) &#123;
     return `&lt;link rel=&quot;modulepreload&quot; crossorigin href=&quot;$&#123;file&#125;&quot;&gt;`
   &#125; else if (file.endsWith(&#x27;.css&#x27;)) &#123;
     return `&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;file&#125;&quot;&gt;`
   &#125; else if (file.endsWith(&#x27;.woff&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;font&quot; type=&quot;font/woff&quot; crossorigin&gt;`
   &#125; else if (file.endsWith(&#x27;.woff2&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;`
   &#125; else if (file.endsWith(&#x27;.gif&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/gif&quot;&gt;`
   &#125; else if (file.endsWith(&#x27;.jpg&#x27;) || file.endsWith(&#x27;.jpeg&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/jpeg&quot;&gt;`
   &#125; else if (file.endsWith(&#x27;.png&#x27;)) &#123;
     return ` &lt;link rel=&quot;preload&quot; href=&quot;$&#123;file&#125;&quot; as=&quot;image&quot; type=&quot;image/png&quot;&gt;`
   &#125; else &#123;
     return &#x27;&#x27;
   &#125;
 &#125;</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><a href="https://github.com/LHRUN/vue-ssr">repo</a></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://vuejs.org/guide/scaling-up/ssr.html">Server-Side Rendering</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
        <tag>Vite</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas画板之画笔的多种效果</title>
    <url>/2022/12/17/canvas%E7%94%BB%E6%9D%BF%E4%B9%8B%E7%94%BB%E7%AC%94%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我之前做了一个画板，已经迭代了两个版本，但既然是画板，如果只有一种画笔就显得太单调了，我就搜罗了一下网上的各种方案和自己的一些想法，目前做出了5种样式，包括基础的总共6种，当然有了一些思路后，后续会继续增加。我会在本文详细说明实现思路和具体代码，6种样式包括：</p>
<ol>
<li>基础单色</li>
<li>荧光</li>
<li>多色画笔</li>
<li>喷雾</li>
<li>蜡笔</li>
<li>泡泡</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>预览地址：<a href="https://songlh.top/paint-board/">https://songlh.top/paint-board/</a><br>源码：<a href="https://github.com/LHRUN/paint-board">https://github.com/LHRUN/paint-board</a> 欢迎Star⭐️</p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH59vn.png"></p>
<h2 id="基础单色"><a href="#基础单色" class="headerlink" title="基础单色"></a>基础单色</h2><p>画笔的基础实现，除了点与点之间的连接，还需要注意两点</p>
<ol>
<li>首先是在鼠标移动时计算当前移动的速度，然后根据速度计算线宽，这个是为了实现鼠标移动快，线宽就变窄，移动慢，线宽就恢复正常这个效果</li>
<li>为了避免直线连接点效果不好，我会采用贝塞尔曲线进行连接</li>
</ol>
<p><img src="https://s1.ax1x.com/2022/12/17/zH5YPe.png"></p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 鼠标移动时添加新的坐标</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">position</span></span>
<span class="comment"> */</span>
<span class="title function_">addPosition</span>(<span class="params">position: MousePosition</span>) &#123;
  <span class="variable language_">this</span>.<span class="property">positions</span>.<span class="title function_">push</span>(position)
  <span class="comment">// 处理当前线宽</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;
    <span class="comment">// 计算移动速度</span>
    <span class="keyword">const</span> mouseSpeed = <span class="variable language_">this</span>.<span class="title function_">_computedSpeed</span>(
      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">2</span>],
      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">1</span>]
    )
    <span class="comment">// 计算线宽</span>
    <span class="keyword">const</span> lineWidth = <span class="variable language_">this</span>.<span class="title function_">_computedLineWidth</span>(mouseSpeed)
    <span class="variable language_">this</span>.<span class="property">lineWidths</span>.<span class="title function_">push</span>(lineWidth)
  &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 计算移动速度</span>
<span class="comment"> * <span class="doctag">@param</span> start 起点</span>
<span class="comment"> * <span class="doctag">@param</span> end 终点</span>
<span class="comment"> */</span>
<span class="title function_">_computedSpeed</span>(<span class="params">start: MousePosition, end: MousePosition</span>) &#123;
  <span class="comment">// 获取距离</span>
  <span class="keyword">const</span> moveDistance = <span class="title function_">getDistance</span>(start, end)

  <span class="keyword">const</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()
  <span class="comment">// 获取移动间隔时间   lastMoveTime：最后鼠标移动时间</span>
  <span class="keyword">const</span> moveTime = curTime - <span class="variable language_">this</span>.<span class="property">lastMoveTime</span>
  <span class="comment">// 计算速度</span>
  <span class="keyword">const</span> mouseSpeed = moveDistance / moveTime
  <span class="comment">// 更新最后移动时间</span>
  <span class="variable language_">this</span>.<span class="property">lastMoveTime</span> = curTime
  <span class="keyword">return</span> mouseSpeed
&#125;

<span class="comment">/**</span>
<span class="comment"> * 计算画笔宽度</span>
<span class="comment"> * <span class="doctag">@param</span> speed 鼠标移动速度</span>
<span class="comment"> */</span>
<span class="title function_">_computedLineWidth</span>(<span class="params">speed: number</span>) &#123;
  <span class="keyword">let</span> lineWidth = <span class="number">0</span>
  <span class="keyword">const</span> minWidth = <span class="variable language_">this</span>.<span class="property">minWidth</span>
  <span class="keyword">const</span> maxWidth = <span class="variable language_">this</span>.<span class="property">maxWidth</span>
  <span class="keyword">if</span> (speed &gt;= <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) &#123;
    lineWidth = minWidth
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (speed &lt;= <span class="variable language_">this</span>.<span class="property">minSpeed</span>) &#123;
    lineWidth = maxWidth
  &#125; <span class="keyword">else</span> &#123;
    lineWidth = maxWidth - (speed / <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) * maxWidth
  &#125;

  lineWidth = lineWidth * (<span class="number">1</span> / <span class="number">3</span>) + <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> * (<span class="number">2</span> / <span class="number">3</span>)
  <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> = lineWidth
  <span class="keyword">return</span> lineWidth
&#125;</code></pre>

<p>渲染时就遍历所有坐标</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 自由画笔渲染</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">freeDrawRender</span>(<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeLine</span>
<span class="params"></span>) &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// 现在是只有基础画笔，后续会增加不同的case</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Basic</span>:
      context.<span class="property">strokeStyle</span> = instance.<span class="property">colors</span>[<span class="number">0</span>]
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Basic</span>:
        <span class="title function_">_drawBasic</span>(instance, i, context)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制基础线条</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw 实例</span>
<span class="comment"> * <span class="doctag">@param</span> i 下标</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> cb 一些绘制前的处理，修改一些样式</span>
<span class="comment"> * </span>
<span class="comment"> * 画笔轨迹是借鉴了网上的一些方案，分两种情况</span>
<span class="comment"> * 1. 如果是前两个坐标，就通过lineTo连接即可</span>
<span class="comment"> * 2. 如果是前两个坐标之后的坐标，就采用贝塞尔曲线进行连接，</span>
<span class="comment"> *    比如现在有a, b, c 三个点，到c点时，把ab坐标的中间点作为起点</span>
<span class="comment"> *     bc坐标的中间点作为终点，b点作为控制点进行连接</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">_drawBasic</span>(<span class="params"></span>
<span class="params">  instance: FreeLine,</span>
<span class="params">  i: number,</span>
<span class="params">  context: CanvasRenderingContext2D</span>
<span class="params">  cb?: (</span>
<span class="params">    instance: FreeDraw,</span>
<span class="params">    i: number,</span>
<span class="params">    context: CanvasRenderingContext2D</span>
<span class="params">  ) =&gt; <span class="keyword">void</span></span>
<span class="params"></span>) &#123;
  <span class="keyword">const</span> &#123; positions, lineWidths &#125; = instance
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: centerX, <span class="attr">y</span>: centerY &#125; = positions[i - <span class="number">1</span>]
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: endX, <span class="attr">y</span>: endY &#125; = positions[i]
  context.<span class="title function_">beginPath</span>()
  <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;
    context.<span class="title function_">moveTo</span>(centerX, centerY)
    context.<span class="title function_">lineTo</span>(endX, endY)
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">const</span> &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125; = positions[i - <span class="number">2</span>]
    <span class="keyword">const</span> lastX = (startX + centerX) / <span class="number">2</span>
    <span class="keyword">const</span> lastY = (startY + centerY) / <span class="number">2</span>
    <span class="keyword">const</span> x = (centerX + endX) / <span class="number">2</span>
    <span class="keyword">const</span> y = (centerY + endY) / <span class="number">2</span>
    context.<span class="title function_">moveTo</span>(lastX, lastY)
    context.<span class="title function_">quadraticCurveTo</span>(centerX, centerY, x, y)
  &#125;

  context.<span class="property">lineWidth</span> = lineWidths[i]
  cb?.(instance, i, context)
  context.<span class="title function_">stroke</span>()
&#125;</code></pre>

<h2 id="荧光"><a href="#荧光" class="headerlink" title="荧光"></a>荧光</h2><p>荧光只需在基础样式上增加一个阴影即可</p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH53VK.png"></p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">freeDrawRender</span>(<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeLine</span>
<span class="params"></span>) &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// ...</span>
    <span class="comment">// 荧光 增加阴影效果</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Shadow</span>:
      context.<span class="property">shadowColor</span> = instance.<span class="property">colors</span>[<span class="number">0</span>]
      context.<span class="property">strokeStyle</span> = instance.<span class="property">colors</span>[<span class="number">0</span>]
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="comment">// ...</span>
      <span class="comment">// 荧光</span>
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Shadow</span>:
        <span class="title function_">_drawBasic</span>(instance, i, context, <span class="function">(<span class="params">instance, i, context</span>) =&gt;</span> &#123;
          context.<span class="property">shadowBlur</span> = instance.<span class="property">lineWidths</span>[i]
        &#125;)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;</code></pre>

<h2 id="多色画笔"><a href="#多色画笔" class="headerlink" title="多色画笔"></a>多色画笔</h2><p>多色画笔需要使用<code>context.createPattern</code>，这个api是可以通过canvas创建一个指定的模版，然后可以让这个模版在指定的方向上重复元图像，具体使用可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createPattern">MDN</a></p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH58UO.png"></p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 自由画笔渲染</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw</span>
<span class="comment"> * <span class="doctag">@param</span> material 画笔素材</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">freeDrawRender</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  material: Material</span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// ...</span>
    <span class="comment">// 多色画笔</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">MultiColor</span>:
      context.<span class="property">strokeStyle</span> = <span class="title function_">getMultiColorPattern</span>(instance.<span class="property">colors</span>)
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="comment">// ...</span>
      <span class="comment">// 多色画笔</span>
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">MultiColor</span>:
        <span class="title function_">_drawBasic</span>(instance, i, context)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取多色模版</span>
<span class="comment"> * <span class="doctag">@param</span> colors 多色数组</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">getMultiColorPattern</span> = (<span class="params">colors: string[]</span>) =&gt; &#123;
  <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>)
  <span class="keyword">const</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>) <span class="keyword">as</span> <span class="title class_">CanvasRenderingContext2D</span>
  <span class="keyword">const</span> <span class="variable constant_">COLOR_WIDTH</span> = <span class="number">5</span> <span class="comment">// 每个颜色的宽度</span>

  canvas.<span class="property">width</span> = <span class="variable constant_">COLOR_WIDTH</span> * colors.<span class="property">length</span>
  canvas.<span class="property">height</span> = <span class="number">20</span>
  colors.<span class="title function_">forEach</span>(<span class="function">(<span class="params">color, i</span>) =&gt;</span> &#123;
    context.<span class="property">fillStyle</span> = color
    context.<span class="title function_">fillRect</span>(<span class="variable constant_">COLOR_WIDTH</span> * i, <span class="number">0</span>, <span class="variable constant_">COLOR_WIDTH</span>, <span class="number">20</span>)
  &#125;)
  <span class="keyword">return</span> context.<span class="title function_">createPattern</span>(canvas, <span class="string">&#x27;repeat&#x27;</span>) <span class="keyword">as</span> <span class="title class_">CanvasPattern</span>
&#125;</code></pre>

<h2 id="喷雾"><a href="#喷雾" class="headerlink" title="喷雾"></a>喷雾</h2><p>喷雾是一种类似雪花的效果，在鼠标移动路径上随机绘制，但是最初我在写的时候发现，如果对每个点都进行随机雪花点记录然后缓存下来，内存占用过多，我就尝试了提前生成5套不同的数据，按顺序展示，也能达到随机的效果</p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH5N2d.png"></p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">freeDrawRender</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  material: Material</span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// ...</span>
    <span class="comment">// 喷雾</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Spray</span>:
      context.<span class="property">fillStyle</span> = instance.<span class="property">colors</span>[<span class="number">0</span>]
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="comment">// ...</span>
      <span class="comment">// 喷雾</span>
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Spray</span>:
        <span class="title function_">_drawSpray</span>(instance, i, context)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制喷雾</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw 实例</span>
<span class="comment"> * <span class="doctag">@param</span> i 下标</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">_drawSpray</span> = (<span class="params"></span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  i: number,</span>
<span class="params">  context: CanvasRenderingContext2D</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; x, y &#125; = instance.<span class="property">positions</span>[i]
  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;
    <span class="comment">/**</span>
<span class="comment">     * sprayPoint 是我提前生成的5套随机喷雾数据，按顺序展示</span>
<span class="comment">     * &#123;</span>
<span class="comment">     *    angle 弧度</span>
<span class="comment">     *    radius 半径</span>
<span class="comment">     *    alpha 透明度</span>
<span class="comment">     * &#125;</span>
<span class="comment">     */</span>
    <span class="keyword">const</span> &#123; angle, radius, alpha &#125; = sprayPoint[i % <span class="number">5</span>][j]
    context.<span class="property">globalAlpha</span> = alpha
    <span class="keyword">const</span> distanceX = radius * <span class="title class_">Math</span>.<span class="title function_">cos</span>(angle)
    <span class="keyword">const</span> distanceY = radius * <span class="title class_">Math</span>.<span class="title function_">sin</span>(angle)
    <span class="comment">// 根据宽度限制喷雾宽度，因为喷雾太细了不好看，我就统一放大一倍</span>
    <span class="keyword">if</span> (
      distanceX &lt; instance.<span class="property">lineWidths</span>[i] * <span class="number">2</span> &amp;&amp;
      distanceY &lt; instance.<span class="property">lineWidths</span>[i] * <span class="number">2</span> &amp;&amp;
      distanceX &gt; -instance.<span class="property">lineWidths</span>[i] * <span class="number">2</span> &amp;&amp;
      distanceY &gt; -instance.<span class="property">lineWidths</span>[i] * <span class="number">2</span>
    ) &#123;
      context.<span class="title function_">fillRect</span>(x + distanceX, y + distanceY, <span class="number">2</span>, <span class="number">2</span>)
    &#125;
  &#125;
&#125;</code></pre>

<h2 id="蜡笔"><a href="#蜡笔" class="headerlink" title="蜡笔"></a>蜡笔</h2><p>蜡笔效果也是使用了<code>context.createPattern</code>，首先我是以当前画笔颜色为底色，然后通过在网上找的一张蜡笔材质的透明图覆盖在上面，就可以实现蜡笔的效果</p>
<p><img src="https://s1.ax1x.com/2022/12/17/zH5G5D.png"></p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 自由画笔渲染</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw</span>
<span class="comment"> * <span class="doctag">@param</span> material 画笔素材</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">freeDrawRender</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  material: Material</span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
    <span class="comment">// ...</span>
    <span class="comment">// 蜡笔</span>
    <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Crayon</span>:
      context.<span class="property">strokeStyle</span> = <span class="title function_">getCrayonPattern</span>(
        instance.<span class="property">colors</span>[<span class="number">0</span>],
        material.<span class="property">crayon</span>
      )
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="keyword">switch</span> (instance.<span class="property">style</span>) &#123;
      <span class="comment">// ...</span>
      <span class="comment">// 蜡笔</span>
      <span class="keyword">case</span> <span class="title class_">FreeDrawStyle</span>.<span class="property">Crayon</span>:
        <span class="title function_">_drawBasic</span>(instance, i, context)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取蜡笔模版</span>
<span class="comment"> * <span class="doctag">@param</span> color 蜡笔底色</span>
<span class="comment"> * <span class="doctag">@param</span> crayon 蜡笔素材</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">getCrayonPattern</span> = (<span class="params">color: string, crayon: Material[<span class="string">&#x27;crayon&#x27;</span>]</span>) =&gt; &#123;
  <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>)
  <span class="keyword">const</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>) <span class="keyword">as</span> <span class="title class_">CanvasRenderingContext2D</span>
  canvas.<span class="property">width</span> = <span class="number">100</span>
  canvas.<span class="property">height</span> = <span class="number">100</span>
  context.<span class="property">fillStyle</span> = color
  context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)
  <span class="keyword">if</span> (crayon) &#123;
    context.<span class="title function_">drawImage</span>(crayon, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)
  &#125;
  <span class="keyword">return</span> context.<span class="title function_">createPattern</span>(canvas, <span class="string">&#x27;repeat&#x27;</span>) <span class="keyword">as</span> <span class="title class_">CanvasPattern</span>
&#125;</code></pre>

<h2 id="泡泡"><a href="#泡泡" class="headerlink" title="泡泡"></a>泡泡</h2><ol>
<li>鼠标移动时记录泡泡的半径和透明度</li>
<li>渲染时通过<code>context.arc</code>进行画圆绘制</li>
</ol>
<p><img src="https://s1.ax1x.com/2022/12/17/zH5t8H.png"></p>
<pre><code class="highlight js"><span class="title function_">addPosition</span>(<span class="params">position: MousePosition</span>) &#123;
  <span class="comment">// ...</span>
  <span class="comment">// 记录泡泡半径和透明度</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">style</span> === <span class="title class_">FreeDrawStyle</span>.<span class="property">Bubble</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">bubbles</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">bubbles</span>.<span class="title function_">push</span>(&#123;
      <span class="comment">// getRandomInt 获取范围内随机整数</span>
      <span class="attr">radius</span>: <span class="title function_">getRandomInt</span>(<span class="variable language_">this</span>.<span class="property">minWidth</span> * <span class="number">2</span>, <span class="variable language_">this</span>.<span class="property">maxWidth</span> * <span class="number">2</span>),
      <span class="comment">// 透明度</span>
      <span class="attr">opacity</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>()
    &#125;)
  &#125;
  <span class="comment">// ...</span>
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制泡泡</span>
<span class="comment"> * <span class="doctag">@param</span> instance FreeDraw 实例</span>
<span class="comment"> * <span class="doctag">@param</span> i 下标</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">_drawBubble</span> = (<span class="params"></span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  i: number,</span>
<span class="params">  context: CanvasRenderingContext2D</span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">beginPath</span>()
  <span class="keyword">if</span> (instance.<span class="property">bubbles</span>) &#123;
    <span class="keyword">const</span> &#123; x, y &#125; = instance.<span class="property">positions</span>[i]
    context.<span class="property">globalAlpha</span> = instance.<span class="property">bubbles</span>[i].<span class="property">opacity</span>
    context.<span class="title function_">arc</span>(x, y, instance.<span class="property">bubbles</span>[i].<span class="property">radius</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">false</span>)
    context.<span class="title function_">fill</span>()
  &#125;
&#125;</code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果有发现问题或者有好的方案，欢迎讨论👻</p>
<p>画板系列文章：</p>
<ul>
<li><a href="https://songlh.top/2022/09/21/%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%94%BB%E6%9D%BF/">基于canvas实现的多功能画板</a></li>
<li><a href="https://songlh.top/2022/12/05/canvas%E7%94%BB%E6%9D%BF%E4%B9%8B%E7%BB%98%E7%94%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%A1%86%E9%80%89/">canvas画板之绘画元素的框选</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://perfectionkills.com/exploring-canvas-drawing-techniques/">Exploring canvas drawing techniques</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas画板之绘画元素的框选</title>
    <url>/2022/12/05/canvas%E7%94%BB%E6%9D%BF%E4%B9%8B%E7%BB%98%E7%94%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%A1%86%E9%80%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我大概在两个月之前做了一个基于canvas的画板，<a href="https://songlh.top/2022/09/21/%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%94%BB%E6%9D%BF/">基于canvas实现的多功能画板</a>，然后最近不是太忙，就利用下班的时间又迭代了一个版本，增加了以下内容</p>
<ol>
<li>在选择模式下可以点击元素进行框选，并按住手柄进行缩放或者移动，点击Backspace键可以删除选择元素</li>
<li>双击画板输入文字绘制在指定位置</li>
</ol>
<p>本篇我就详细介绍下框选元素的实现思路和具体代码，效果如下</p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>预览地址：<a href="https://songlh.top/paint-board/">https://songlh.top/paint-board/</a><br>repo：<a href="https://github.com/LHRUN/paint-board">https://github.com/LHRUN/paint-board</a> 欢迎Star⭐️ </p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bd83319aae4af5aeaad2e83a73580c~tplv-k3u1fbpfcp-watermark.image"></p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li>首先需要框选的元素必须在初始化时和更新时记录矩形属性，比如宽高、矩形坐标，这是实现框选的基础</li>
<li>鼠标在移动时需要根据当前坐标判断悬浮在哪个元素上方，这样才能在点击时进行处理，并且鼠标移动时需要有光标的改变</li>
<li>在有框选元素的情况下，渲染时在最后根据框选元素的矩形属性渲染框选效果</li>
<li>在有框选元素的情况下，拖拽时根据拖拽的位置来判断是移动还是改变大小</li>
<li>元素改变大小有两种情况，保持比例(文字)的缩放和不保持比例(画笔)的缩放</li>
</ol>
<h2 id="记录矩形属性"><a href="#记录矩形属性" class="headerlink" title="记录矩形属性"></a>记录矩形属性</h2><p>因为画笔随着绘画一直在增加新的坐标点，所以我在矩形属性外另记录了最小和最大的xy坐标用于计算宽高</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 根据新坐标点，更新矩形属性</span>
<span class="comment"> * <span class="doctag">@param</span> instance 画笔元素</span>
<span class="comment"> * <span class="doctag">@param</span> position 坐标点</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">updateRect</span> = (<span class="params">instance: FreeDraw, position: MousePosition</span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; x, y &#125; = position
  <span class="keyword">let</span> &#123; minX, maxX, minY, maxY &#125; = instance.<span class="property">rect</span>
  <span class="keyword">if</span> (x &lt; minX) &#123;
    minX = x
  &#125;
  <span class="keyword">if</span> (x &gt; maxX) &#123;
    maxX = x
  &#125;
  <span class="keyword">if</span> (y &lt; minY) &#123;
    minY = y
  &#125;
  <span class="keyword">if</span> (y &gt; maxY) &#123;
    maxY = y
  &#125;
  <span class="keyword">const</span> rect = &#123;
    minX,
    maxX,
    minY,
    maxY,
    <span class="attr">x</span>: minX,
    <span class="attr">y</span>: minY,
    <span class="attr">width</span>: maxX - minX,
    <span class="attr">height</span>: maxY - minY
  &#125;
  instance.<span class="property">rect</span> = rect
  <span class="keyword">return</span> rect
&#125;</code></pre>

<h2 id="计算鼠标移动坐标"><a href="#计算鼠标移动坐标" class="headerlink" title="计算鼠标移动坐标"></a>计算鼠标移动坐标</h2><ul>
<li>随着鼠标移动，我们需要改变光标让使用者感知到已经移动到元素上方，所以就需要计算鼠标坐标是否已经和绘画路径临近到一定距离</li>
<li>绘画路径是由一个个的坐标点组成，我们可以把每个坐标点和上一个坐标点连成一个线段，然后在满足以下任何一种情况就可以认为是悬浮在元素上方了<ul>
<li>鼠标坐标距离线段起点小于10像素</li>
<li>鼠标坐标距离线段终点小于10像素</li>
<li>鼠标坐标距离线段小于10像素并且x和y坐标在线段的两端点范围内</li>
<li><img src="https://s1.ax1x.com/2022/12/05/zy7D6s.png"><pre><code class="highlight js"><span class="comment">// 遍历画笔元素所有坐标点</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; positions.<span class="property">length</span>; i++) &#123;
  <span class="comment">// 距离起点距离</span>
  <span class="keyword">const</span> startDistance = <span class="title function_">getDistance</span>(movePos, positions[i - <span class="number">1</span>])
  <span class="comment">// 距离终点距离</span>
  <span class="keyword">const</span> endDistance = <span class="title function_">getDistance</span>(movePos, positions[i])
  <span class="comment">// 距离线段距离</span>
  <span class="keyword">const</span> lineDistance = <span class="title function_">getPositionToLineDistance</span>(
    movePos,
    positions[i - <span class="number">1</span>],
    positions[i]
  )
  <span class="keyword">const</span> rangeX =
    <span class="title class_">Math</span>.<span class="title function_">max</span>(positions[i - <span class="number">1</span>].<span class="property">x</span>, positions[i].<span class="property">x</span>) &gt;= movePos.<span class="property">x</span> &amp;&amp;
    movePos.<span class="property">x</span> &gt;= <span class="title class_">Math</span>.<span class="title function_">min</span>(positions[i - <span class="number">1</span>].<span class="property">x</span>, positions[i].<span class="property">x</span>)
  <span class="keyword">const</span> rangeY =
    <span class="title class_">Math</span>.<span class="title function_">max</span>(positions[i - <span class="number">1</span>].<span class="property">y</span>, positions[i].<span class="property">y</span>) &gt;= movePos.<span class="property">y</span> &amp;&amp;
    movePos.<span class="property">y</span> &gt;= <span class="title class_">Math</span>.<span class="title function_">min</span>(positions[i - <span class="number">1</span>].<span class="property">y</span>, positions[i].<span class="property">y</span>)

  <span class="comment">// 满足三种情况其中一种就可以记录下画笔元素</span>
  <span class="keyword">if</span> (
    startDistance &lt; <span class="number">10</span> ||
    endDistance &lt; <span class="number">10</span> ||
    (lineDistance &lt; <span class="number">10</span> &amp;&amp; rangeX &amp;&amp; rangeY)
  ) &#123;
    <span class="variable language_">this</span>.<span class="property">mouseHoverElementIndex</span> = eleIndex
  &#125;
&#125;
<span class="comment">// ...</span>

<span class="comment">/**</span>
<span class="comment"> * 计算两点之间的距离</span>
<span class="comment"> * <span class="doctag">@param</span> start 起点</span>
<span class="comment"> * <span class="doctag">@param</span> end 终点</span>
<span class="comment"> * <span class="doctag">@returns</span> 距离</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getDistance</span> = (<span class="params">start: MousePosition, end: MousePosition</span>) =&gt; &#123;
  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(start.<span class="property">x</span> - end.<span class="property">x</span>, <span class="number">2</span>) + <span class="title class_">Math</span>.<span class="title function_">pow</span>(start.<span class="property">y</span> - end.<span class="property">y</span>, <span class="number">2</span>))
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取鼠标坐标距离线段距离</span>
<span class="comment"> * <span class="doctag">@param</span> pos 鼠标坐标</span>
<span class="comment"> * <span class="doctag">@param</span> startPos 线段起点</span>
<span class="comment"> * <span class="doctag">@param</span> endPos 线段终点</span>
<span class="comment"> * <span class="doctag">@returns</span> 距离</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPositionToLineDistance</span> = (<span class="params"></span>
<span class="params">  pos: MousePosition,</span>
<span class="params">  startPos: MousePosition,</span>
<span class="params">  endPos: MousePosition</span>
<span class="params"></span>) =&gt; &#123;
  <span class="comment">/**</span>
<span class="comment">   * 1. 计算三点之间的直线距离</span>
<span class="comment">   * 2. 计算三角形半周长</span>
<span class="comment">   * 3. 通过海伦公式求面积</span>
<span class="comment">   * 4. 根据面积公式求三角形的高</span>
<span class="comment">   */</span>
  <span class="keyword">const</span> A = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title function_">getDistance</span>(pos, startPos))
  <span class="keyword">const</span> B = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title function_">getDistance</span>(pos, endPos))
  <span class="keyword">const</span> C = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title function_">getDistance</span>(startPos, endPos))

  <span class="keyword">const</span> P = (A + B + C) / <span class="number">2</span>
  <span class="keyword">const</span> area = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(P * (P - A) * (P - B) * (P - C)))
  <span class="keyword">const</span> distance = (<span class="number">2</span> * area) / C
  <span class="keyword">return</span> distance
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h2 id="点击渲染框选效果"><a href="#点击渲染框选效果" class="headerlink" title="点击渲染框选效果"></a>点击渲染框选效果</h2><ul>
<li>点击时如果在之前hover时满足三种情况已经记录下来了，就继续记录为框选元素</li>
<li>然后在画板渲染时，就按照框选元素的矩形属性渲染框选效果<pre><code class="highlight js"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">select</span>.<span class="property">selectElementIndex</span> !== -<span class="number">1</span>) &#123;
  <span class="comment">// 获取选择元素的矩形属性，绘制框选效果</span>
  <span class="keyword">const</span> rect = <span class="variable language_">this</span>.<span class="property">select</span>.<span class="title function_">getCurSelectElement</span>().<span class="property">rect</span>
  <span class="title function_">drawResizeRect</span>(<span class="variable language_">this</span>.<span class="property">context</span>, rect)
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制拖拽矩形</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">drawResizeRect</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  rect: ElementRect</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; x, y, width, height &#125; = rect
  context.<span class="title function_">save</span>()
  context.<span class="property">strokeStyle</span> = <span class="string">&#x27;#65CC8A&#x27;</span>
  context.<span class="title function_">setLineDash</span>([<span class="number">5</span>])
  context.<span class="property">lineWidth</span> = <span class="number">2</span>
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  <span class="comment">// 绘制虚线框</span>
  <span class="title function_">drawRect</span>(context, x, y, width, height)

  <span class="comment">// 绘制四角手柄</span>
  context.<span class="property">fillStyle</span> = <span class="string">&#x27;#65CC8A&#x27;</span>
  <span class="title function_">drawRect</span>(context, x - <span class="number">10</span>, y - <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">true</span>)
  <span class="title function_">drawRect</span>(context, x + width, y - <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">true</span>)
  <span class="title function_">drawRect</span>(context, x - <span class="number">10</span>, y + height, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">true</span>)
  <span class="title function_">drawRect</span>(context, x + width, y + height, <span class="number">10</span>, <span class="number">10</span>, <span class="literal">true</span>)
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 绘制矩形</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">drawRect</span> = (<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  x: number,</span>
<span class="params">  y: number,</span>
<span class="params">  width: number,</span>
<span class="params">  height: number,</span>
<span class="params">  fill = <span class="literal">false</span> <span class="comment">// 是否填充</span></span>
<span class="params"></span>) =&gt; &#123;
  context.<span class="title function_">beginPath</span>()
  context.<span class="title function_">rect</span>(x, y, width, height)
  <span class="keyword">if</span> (fill) &#123;
    context.<span class="title function_">fill</span>()
  &#125; <span class="keyword">else</span> &#123;
    context.<span class="title function_">stroke</span>()
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="拖拽元素"><a href="#拖拽元素" class="headerlink" title="拖拽元素"></a>拖拽元素</h2><p>拖拽元素比较简单，就是计算鼠标移动的距离，然后遍历坐标点加上距离即可</p>
<pre><code class="highlight js"><span class="comment">// startMousePos就是上一个移动的坐标</span>
<span class="keyword">const</span> disntanceX = x - <span class="variable language_">this</span>.<span class="property">startMousePos</span>.<span class="property">x</span>
<span class="keyword">const</span> disntanceY = y - <span class="variable language_">this</span>.<span class="property">startMousePos</span>.<span class="property">y</span>

<span class="comment">/**</span>
<span class="comment"> * 更新位置</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">distanceX</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">distanceY</span></span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">moveFreeDraw</span> = (<span class="params"></span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  distanceX: number,</span>
<span class="params">  distanceY: number</span>
<span class="params"></span>) =&gt; &#123;
  <span class="title function_">initRect</span>(instance)
  instance.<span class="property">positions</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">position</span>) =&gt;</span> &#123;
    position.<span class="property">x</span> += distanceX
    position.<span class="property">y</span> += distanceY
    <span class="title function_">updateRect</span>(instance, position)
  &#125;)
&#125;</code></pre>

<h2 id="画笔缩放-不保持比例"><a href="#画笔缩放-不保持比例" class="headerlink" title="画笔缩放(不保持比例)"></a>画笔缩放(不保持比例)</h2><ul>
<li>画笔缩放我先以右下角手柄拖拽为例分析</li>
<li>首先画笔的缩放比例是分为水平缩放比例和垂直缩放比例<ul>
<li>水平缩放比例 &#x3D; (旧矩形的宽 + 鼠标水平移动的距离) &#x2F; 旧矩形的宽</li>
<li>垂直缩放比例 &#x3D; (旧矩形的高 + 鼠标垂直移动的距离) &#x2F; 旧矩形的高</li>
</ul>
</li>
<li>然后遍历画笔的所有坐标点进行缩放，这时会出现一个偏移的缩放效果，如下图<ul>
<li><img src="https://s1.ax1x.com/2022/12/05/zy7600.png"></li>
</ul>
</li>
<li>这时就需要计算当前拖拽手柄对角顶点移动的距离是多少，然后减去这个距离就得到了正确的缩放效果了<ul>
<li><img src="https://s1.ax1x.com/2022/12/05/zy72kT.png"></li>
</ul>
</li>
<li>当然四个角的拖拽计算是不一致的，但是思路一致<pre><code class="highlight js"><span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">resizeType</span>) &#123;
  <span class="comment">// disntanceX 鼠标水平移动距离</span>
  <span class="comment">// disntanceY 鼠标垂直移动距离</span>
  <span class="comment">// 右下角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>:
    <span class="title function_">resizeFreeDraw</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">FreeDraw</span>,
      (rect.<span class="property">width</span> + disntanceX) / rect.<span class="property">width</span>,
      (rect.<span class="property">height</span> + disntanceY) / rect.<span class="property">height</span>,
      rect,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 左下角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>:
    <span class="title function_">resizeFreeDraw</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">FreeDraw</span>,
      (rect.<span class="property">width</span> - disntanceX) / rect.<span class="property">width</span>,
      (rect.<span class="property">height</span> + disntanceY) / rect.<span class="property">height</span>,
      rect,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 左上角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>:
    <span class="title function_">resizeFreeDraw</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">FreeDraw</span>,
      (rect.<span class="property">width</span> - disntanceX) / rect.<span class="property">width</span>,
      (rect.<span class="property">height</span> - disntanceY) / rect.<span class="property">height</span>,
      rect,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 右上角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>:
    <span class="title function_">resizeFreeDraw</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">FreeDraw</span>,
      (rect.<span class="property">width</span> + disntanceX) / rect.<span class="property">width</span>,
      (rect.<span class="property">height</span> - disntanceY) / rect.<span class="property">height</span>,
      rect,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>
    )
    <span class="keyword">break</span>
  <span class="attr">default</span>:
    <span class="keyword">break</span>
&#125;

<span class="comment">/**</span>
<span class="comment"> * 缩放绘画</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">instance</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">scaleX</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">scaleY</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">rect</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">resizeType</span></span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">resizeFreeDraw</span> = (<span class="params"></span>
<span class="params">  instance: FreeDraw,</span>
<span class="params">  scaleX: number,</span>
<span class="params">  scaleY: number,</span>
<span class="params">  rect: FreeDrawRect,</span>
<span class="params">  resizeType: string</span>
<span class="params"></span>) =&gt; &#123;
  <span class="comment">// 初始化矩形</span>
  <span class="title function_">initRect</span>(instance)
  <span class="comment">// 遍历所有坐标进行缩放</span>
  instance.<span class="property">positions</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">position</span>) =&gt;</span> &#123;
    position.<span class="property">x</span> = position.<span class="property">x</span> * scaleX
    position.<span class="property">y</span> = position.<span class="property">y</span> * scaleY
    <span class="title function_">updateRect</span>(instance, position)
  &#125;)
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: newX, <span class="attr">y</span>: newY, <span class="attr">width</span>: newWidth, <span class="attr">height</span>: newHeight &#125; = instance.<span class="property">rect</span>
  <span class="keyword">let</span> offsetX = <span class="number">0</span>
  <span class="keyword">let</span> offsetY = <span class="number">0</span>
  <span class="comment">// 计算偏移距离，这个是要根据当前缩放手柄的对角顶点进行计算，所以要分为4种情况</span>
  <span class="keyword">switch</span> (resizeType) &#123;
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>:
      offsetX = newX - rect.<span class="property">x</span>
      offsetY = newY - rect.<span class="property">y</span>
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>:
      offsetX = newX + newWidth - (rect.<span class="property">x</span> + rect.<span class="property">width</span>)
      offsetY = newY - rect.<span class="property">y</span>
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>:
      offsetX = newX + newWidth - (rect.<span class="property">x</span> + rect.<span class="property">width</span>)
      offsetY = newY + newHeight - (rect.<span class="property">y</span> + rect.<span class="property">height</span>)
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>:
      offsetX = newX - rect.<span class="property">x</span>
      offsetY = newY + newHeight - (rect.<span class="property">y</span> + rect.<span class="property">height</span>)
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;
  <span class="title function_">initRect</span>(instance)
  <span class="comment">// 减去偏移距离</span>
  instance.<span class="property">positions</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">position</span>) =&gt;</span> &#123;
    position.<span class="property">x</span> = position.<span class="property">x</span> - offsetX
    position.<span class="property">y</span> = position.<span class="property">y</span> - offsetY
    <span class="title function_">updateRect</span>(instance, position)
  &#125;)
&#125;</code></pre></li>
</ul>
<h2 id="文字缩放-保持比例"><a href="#文字缩放-保持比例" class="headerlink" title="文字缩放(保持比例)"></a>文字缩放(保持比例)</h2><ul>
<li>文字缩放需要一直保持着宽高比，通过计算出新旧矩形的宽高比<ul>
<li>当新的宽高比小于旧的宽高比时，宽度不变，计算 高度 &#x3D; 宽度 &#x2F; 旧的宽高比</li>
<li>但新的宽高比大于旧的宽高比时，高度不变，计算 宽度 &#x3D; 高度 * 旧的宽高比<pre><code class="highlight js"><span class="keyword">switch</span> (<span class="variable language_">this</span>.<span class="property">resizeType</span>) &#123;
  <span class="comment">// ...</span>
  <span class="comment">// 右下角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>:
    <span class="title function_">resizeTextElement</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">TextElement</span>,
      resizeElement.<span class="property">rect</span>.<span class="property">width</span> + disntanceX,
      resizeElement.<span class="property">rect</span>.<span class="property">height</span> + disntanceY,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 左下角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>:
    <span class="title function_">resizeTextElement</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">TextElement</span>,
      resizeElement.<span class="property">rect</span>.<span class="property">width</span> - disntanceX,
      resizeElement.<span class="property">rect</span>.<span class="property">height</span> + disntanceY,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 左上角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>:
    <span class="title function_">resizeTextElement</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">TextElement</span>,
      resizeElement.<span class="property">rect</span>.<span class="property">width</span> - disntanceX,
      resizeElement.<span class="property">rect</span>.<span class="property">height</span> - disntanceY,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>
    )
    <span class="keyword">break</span>
  <span class="comment">// 右上角</span>
  <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>:
    <span class="title function_">resizeTextElement</span>(
      resizeElement <span class="keyword">as</span> <span class="title class_">TextElement</span>,
      resizeElement.<span class="property">rect</span>.<span class="property">width</span> + disntanceX,
      resizeElement.<span class="property">rect</span>.<span class="property">height</span> - disntanceY,
      <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>
    )
    <span class="keyword">break</span>
  <span class="attr">default</span>:
    <span class="keyword">break</span>
&#125;

<span class="comment">/**</span>
<span class="comment"> * 修改文本元素大小</span>
<span class="comment"> * <span class="doctag">@param</span> ele 文本元素</span>
<span class="comment"> * <span class="doctag">@param</span> width 改变后的宽度</span>
<span class="comment"> * <span class="doctag">@param</span> height 改变后的高度</span>
<span class="comment"> * <span class="doctag">@param</span> resizeType 拖拽类型</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">resizeTextElement</span> = (<span class="params"></span>
<span class="params">  ele: TextElement,</span>
<span class="params">  width: number,</span>
<span class="params">  height: number,</span>
<span class="params">  resizeType: string</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> oldRatio = ele.<span class="property">rect</span>.<span class="property">width</span> / ele.<span class="property">rect</span>.<span class="property">height</span>
  <span class="keyword">const</span> newRatio = width / height
  <span class="comment">// 按照之前的说明，修改宽高比不一致的情况</span>
  <span class="keyword">if</span> (newRatio &lt; oldRatio) &#123;
    height = width / oldRatio
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newRatio &gt; oldRatio) &#123;
    width = oldRatio * height
  &#125;

  <span class="comment">/**</span>
<span class="comment">   * 因为这个缩放是按照左上角缩放的</span>
<span class="comment">   * 所以为了达到当前拖拽手柄不移动，就需要进行偏移操作</span>
<span class="comment">   */</span>
  <span class="keyword">switch</span> (resizeType) &#123;
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_RIGHT</span>:
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">BOTTOM_LEFT</span>:
      ele.<span class="property">rect</span>.<span class="property">x</span> -= width - ele.<span class="property">rect</span>.<span class="property">width</span>
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_LEFT</span>:
      ele.<span class="property">rect</span>.<span class="property">x</span> -= width - ele.<span class="property">rect</span>.<span class="property">width</span>
      ele.<span class="property">rect</span>.<span class="property">y</span> -= height - ele.<span class="property">rect</span>.<span class="property">height</span>
      <span class="keyword">break</span>
    <span class="keyword">case</span> <span class="variable constant_">RESIZE_TYPE</span>.<span class="property">TOP_RIGHT</span>:
      ele.<span class="property">rect</span>.<span class="property">y</span> -= height - ele.<span class="property">rect</span>.<span class="property">height</span>
      <span class="keyword">break</span>
    <span class="attr">default</span>:
      <span class="keyword">break</span>
  &#125;
  ele.<span class="property">rect</span>.<span class="property">height</span> = height
  ele.<span class="property">rect</span>.<span class="property">width</span> = width
  <span class="comment">// 字体大小按照高度修改</span>
  ele.<span class="property">fontSize</span> = ele.<span class="property">rect</span>.<span class="property">height</span>
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果有发现问题或者有好的方案，欢迎讨论👻</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】AI’s black swans Unforeseen consequences looming</title>
    <url>/2023/08/08/%E3%80%90%E7%BF%BB%E3%80%91AI%E2%80%99s-black-swans-Unforeseen-consequences-looming/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://uxdesign.cc/ais-black-swans-unforeseen-consequences-looming-a4b28ef79004">【翻】AI’s black swans: Unforeseen consequences looming</a><br>原作者：<a href="https://medium.com/@arvindsanjeev">Arvind Sanjeev</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://miro.medium.com/v2/resize:fit:1400/1*rcZVMTgXF30unDCIXfT_Jg.gif"></p>
<p>欢迎来到 Novacene 时代，James Lovelock 认为，Anthropocene 是人类获得行星级技术的时代，这个时代将在300年后结束。然后一个新的时代(<a href="https://mitpress.mit.edu/9780262539517/novacene/">Novacene</a>)即将开始，新的生命体将从现有的人工智能系统中产生。</p>
<p>在2020年，<a href="https://pioneerworks.org/broadcast/xenobots-claire-evans">世界上第一个由 AI 设计的生物诞生了</a>。Xenobots 是由AI和生物交叉产生的人造生命的一个例子。在这里，首先是AI为生物体绘制蓝图，然后由人类利用青蛙的干细胞进行再创造。它们是第一个在计算机中而不是在生物圈内直接进化的生物</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8KOLaiU3s1OyhSK7UPTPPg.png"></p>
<p>AI 现在甚至能设计和创造生命，它正引领我们走向未来。随着人工智能的指数级增长，要跟上并预测它如何影响我们是一项挑战。”Black Swans”的后果可能就是我们通往未来道路上的示例</p>
<h2 id="AI-can-read-our-thoughts-now"><a href="#AI-can-read-our-thoughts-now" class="headerlink" title="AI can read our thoughts now"></a>AI can read our thoughts now</h2><p><strong>我们离思想犯罪还有多远？</strong></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*w1DpY9ntlGxzxSzfM4kASA.png"></p>
<p>在2022年12月，一组研究人员证明，它们可以通过 AI 对我们进行核磁共振扫描，从而<a href="https://www.science.org/content/article/artificial-intelligence-learning-read-your-mind-and-display-what-it-sees">发现我们正在想什么</a>。在这个实验中，他们一边向人们展示一系列图像，一边扫描人们的大脑，不久之后，他们就能利用核磁共振扫描和稳定扩散技术<a href="https://www.biorxiv.org/content/10.1101/2022.11.18.517004v2.full.pdf">重建相同的图像</a>。研究人员在这个项目上已经工作了十多年，但直到最近才在新一代扩散模型上取得突破。现在的问题是，这将导致一个 Orwellian 式的未来，我们的思想将被监控，然而我们能够在这种技术出现之前对其使用进行监管吗？</p>
<p><img src="https://miro.medium.com/v2/format:webp/1*AMybFwlhWyWt8JCSgIVUDQ.png"></p>
<h2 id="Religious-AI"><a href="#Religious-AI" class="headerlink" title="Religious AI"></a>Religious AI</h2><p><strong>我们离 AI 邪教领袖还有多远</strong></p>
<p>随着 AI 的复兴，以前对 AI 望而却步的领域也开始拥抱它。现在，人们开始用不同的宗教经文来训练人工智能。<a href="https://gitagpt.org/">根据《薄伽梵歌》训练的GPT</a>可以向它询问任何问题的解决方案。然后，可以选择从最喜欢的神灵那里获得答案：<a href="https://krishn.ai/">Krishna</a>, Yogeshwar, Parthasarathi等。BibleGPT是另一个例子，他通过引用《圣经》中的内容让你进一步了解生命的意义。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*fCl1hU2T4ENOie-lmi1Rpg.png"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*Kgg3I5sX-v9CB23LWXPvCw.png"></p>
<h2 id="AI-companions"><a href="#AI-companions" class="headerlink" title="AI companions"></a>AI companions</h2><p><strong>AI 应该控制你的恋爱吗？</strong></p>
<p>在 Replika.at 这个平台上提供的人工智能伴侣可以同你进行亲密对话。并有另一个例子是日本男子与全息投影虚拟人物进行结婚的故事。但是，如果人类不能完全的控制人工智能系统，会发生什么呢？相反，AI伴侣的母公司可以通过软件更新甚至完全关闭程序来改变他们的AI伴侣。这样以来，用户只能任由这些公司摆布，以维持他们的浪漫关系。就像那个日本男子无法与他的虚拟妻子交谈一样，Replika公司最近取消了AI进行情色角色扮演的功能，从而激怒了他们的客户。用户目睹了他们的AI伴侣在这次更新后变成了新的人格。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*Bt9ZOwIoruoFEp9RP9VvkA.png"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*OBi3JdQeNfyER3wvRvHefQ.png"></p>
<h2 id="Capitalizing-our-insecurities"><a href="#Capitalizing-our-insecurities" class="headerlink" title="Capitalizing our insecurities"></a>Capitalizing our insecurities</h2><p><strong>AI 正指出我们的不完美</strong></p>
<p><img src="https://miro.medium.com/v2/format:webp/1*1x9WSNjEajWeR8Eyk3TvTw.png"></p>
<p><a href="https://qoves.com/facial-assessment-tool/">Qoves 是一款由 AI 驱动的面部分析工具</a>，用于检测面部的一些表面缺陷，然后推荐一些可以修复这些问题的产品和化妆品。他们甚至在 Youtube 上开了一个 <a href="https://www.youtube.com/c/QOVESStudio/videos">channel</a>，通过分析名人的脸部来了解他们流行背后的原因。这就是那些公司利用 AI 来对我们的不安全感牟利的最好例子。</p>
<p><img src="https://miro.medium.com/v2/format:webp/1*CAjk4FrSU9NMcP8U9qzf3g.png"></p>
<h2 id="Supercharged-plagiarism"><a href="#Supercharged-plagiarism" class="headerlink" title="Supercharged plagiarism"></a>Supercharged plagiarism</h2><p>像 AI <del>艺术家</del> 一样偷窃</p>
<p>AI 生成的艺术正在模糊内容所有权的界限。在2022年，一位《原神》的粉丝艺术家在Twitch上进行一次直播绘画。在他们完成创作并准备在Twitter上发布之前，其中一位观众将这幅未完成的作品输入进了一个 AI 生成工具上，然后“完成”了它。在这位艺术家发布了他们完成的作品之后，那位盗窃艺术的观众向原创索要版权。</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">During a Twitch stream AT (<a href="https://twitter.com/haruno_intro?ref_src=twsrc%5Etfw">@haruno_intro</a>) had their art stolen.<br><br>The thief then finished the sketch by using NovelAI and posted on their Twitter before AT finish it.<br><br>Then had the AUDACITY to demand a &quot;proper reference&quot; from them. <a href="https://t.co/Twv7oWSMaW">pic.twitter.com/Twv7oWSMaW</a></p>&mdash; Genel Jumalon ✈️ 2D Con (@GenelJumalon) <a href="https://twitter.com/GenelJumalon/status/1580401094454222848?ref_src=twsrc%5Etfw">October 13, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>基于 AI 的剽窃行为也是学校里的一个热门话题；正反双方对<a href="https://w42st.com/post/new-york-education-blocks-chatgpt-ai/">学校是否应该禁用 GPT 这样的 AI 生成工具</a>产生过激烈讨论，后者认为应该将其用作教学。因为这可以让学生接触到他们未来可能会使用的工具。这就类似于我们<a href="https://www.businessinsider.in/tech/news/ceo-of-chatgpt-maker-responds-to-schools-plagiarism-concerns-we-adapted-to-calculators-and-changed-what-we-tested-in-math-class/articleshow/97147698.cms">为什么允许在课堂上可以使用计算器</a>的这种问题。Stephen Marche 的 <a href="https://www.theatlantic.com/technology/archive/2022/12/chatgpt-ai-writing-college-student-essays/672371/">The college essay is dead</a> 很好的抓住了这个话题。</p>
<h2 id="Ownership-in-the-age-of-AI"><a href="#Ownership-in-the-age-of-AI" class="headerlink" title="Ownership in the age of AI"></a>Ownership in the age of AI</h2><p><strong>AI 生成的内容归谁所有？</strong></p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">I’m cropping these for privacy reasons/because I’m not trying to call out any one individual. These are all Lensa portraits where the mangled remains of an artist’s signature is still visible. That’s the remains of the signature of one of the multiple artists it stole from.<br><br>A 🧵 <a href="https://t.co/0lS4WHmQfW">https://t.co/0lS4WHmQfW</a> <a href="https://t.co/7GfDXZ22s1">pic.twitter.com/7GfDXZ22s1</a></p>&mdash; Lauryn Ipsum (@LaurynIpsum) <a href="https://twitter.com/LaurynIpsum/status/1599953586699767808?ref_src=twsrc%5Etfw">December 6, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>艺术家的作品被用作训练AI，并根据他们的风格生成了新的内容。有些作品中甚至还残留着他们的签名；人们称这种为<a href="https://www.wsj.com/articles/ai-chatgpt-dall-e-microsoft-rutkowski-github-artificial-intelligence-11675466857">大规模化的知识产权盗窃</a>。</p>
<p><img src="https://miro.medium.com/v2/format:webp/1*YNvyP97-gWmD3-8ILaO_2g.png"></p>
<p>如上图所示，在生成式AI生态系统中有多个利益相关者：如个人数据所有者、组建数据库的人、制定训练算法的开发人员、执行算法的艺术家&#x2F;技术专家，以及筛选输出结果的负责人&#x2F;艺术家。<a href="https://www.artsy.net/article/artsy-editorial-art-created-artificial-intelligence-sells-paid">那么问题来了，谁获利了？</a>以下是艺术家和其他人就这个问题提出的一系列诉讼，他们都在努力寻找这个问题的答案：</p>
<ul>
<li><a href="https://stablediffusionlitigation.com/">The Stable Diffusion litigation</a></li>
<li><a href="https://www.gofundme.com/f/protecting-artists-from-ai-technologies">Ownership lawsuit by Concept Art Association</a></li>
<li><a href="https://newsroom.gettyimages.com/en/getty-images/getty-images-statement">Getty Images vs. Stability AI lawsuit</a></li>
</ul>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Ai art situation in a nutshell <a href="https://t.co/2ZIiuSsjx7">pic.twitter.com/2ZIiuSsjx7</a></p>&mdash; Lora Zombie (@LoraZombie) <a href="https://twitter.com/LoraZombie/status/1616278888325300225?ref_src=twsrc%5Etfw">January 20, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="AI-colonialism"><a href="#AI-colonialism" class="headerlink" title="AI colonialism"></a>AI colonialism</h2><p><strong>AI 正在粉刷这个世界的文化</strong></p>
<p>由于现在所有的AI模型都主要是西方国家的研究人员制作的，因此在训练这些模型的数据时，过于依赖他们自己的文化、传统和价值观。世界其他地区（约95%的人口）的文化的数据并没有进入到训练集中。它们被有意或无意的忽略了。当这种模型部署到全球通用的工具上时，如搜索引擎、社交媒体，世界上的其他国家，尤其是发展中国家，别无选择，只能按照西方文化的标准来使用它们。由此以来，一种新形式的殖民主义诞生了，它可以抹杀整个文化，被称为<a href="https://www.technologyreview.com/2022/04/19/1049592/artificial-intelligence-colonialism/">AI殖民主义</a>。Karen Hao 在 <a href="https://www.technologyreview.com/supertopic/ai-colonialism-supertopic/">MIT Technology Review</a> 上通过多个例子对这一话题进行了报道：</p>
<ul>
<li><a href="https://www.technologyreview.com/2022/04/19/1049996/south-africa-ai-surveillance-digital-apartheid/">PART I: RACIAL CONTROL</a>：南非的私人监控系统正在加剧数字种族隔离。</li>
<li><a href="https://www.technologyreview.com/2022/04/20/1050392/ai-industry-appen-scale-data-labels/">PART II: EXPLOITATION</a>：AI 产业如何从灾难中获利</li>
<li><a href="https://www.technologyreview.com/2022/04/21/1050381/the-gig-workers-fighting-back-against-the-algorithms/">PART III: RESISTANCE</a>：抵抗算法的临时工们正在反击</li>
<li><a href="https://www.technologyreview.com/2022/04/22/1050394/artificial-intelligence-for-the-people/">PART IV: LIBERATION</a>：人们的AI新愿景</li>
</ul>
<p>在这个全新的 Novacene 时代，AI模型正在成为构建社会的积极份子。就像化学中的元素一样，无论是寻找伴侣、教育你的孩子还是设计新生活，它们都在不断融入我们生活的各个方面。在这些技术变得复杂深层次且无形之前，我们需要将人类的价值观加入到它们的基础层中。只有这样，我们才能够中和其造成危害的能力，并在其之上构建安全可靠的系统。</p>
<blockquote>
<p>For all of human existence, we have been at home in nature — we trust nature, not technology. And yet we look to technology to take care of our future — we hope in technology. So we hope in something we do not quite trust. There is an irony here. Technology, as I have said, is the programming of nature, the orchestration and use of nature’s phenomena. So in its deepest essence, it is natural, profoundly natural. But it does not feel natural.<br>— W.Brian Arthur, The Nature of Technology</p>
</blockquote>
<p>有关此主题及其他主题的更多资源，请查阅本手册<a href="https://arvindsanjeev.notion.site/arvindsanjeev/The-Handbook-of-AI-s-Unintended-Consequences-720cda3d8cec49dc88807641157a0bba">《AI’s unintended consequences》</a>。本文是探讨 <a href="https://medium.com/@arvindsanjeev/ai-sociopaths-and-their-unintended-consequences-bf6f19012e4f">unintended consequences of AI 四部系列文章</a>中的第四章</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>pnpm的node_modules结构设计</title>
    <url>/2022/08/24/pnpm%E7%9A%84node-modules%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="pnpm的node-modules结构设计"><a href="#pnpm的node-modules结构设计" class="headerlink" title="pnpm的node_modules结构设计"></a>pnpm的node_modules结构设计</h2><p>分析pnpm之前，先说一下npm现在的一些问题</p>
<h3 id="npm的问题"><a href="#npm的问题" class="headerlink" title="npm的问题"></a>npm的问题</h3><ul>
<li><p>平时我们使用<code>npm install</code>命令后，node_modules就会呈现以下类似内容<br><img src="https://img-blog.csdnimg.cn/7396b28d86f84a21b15b4ef6026ddd45.png#pic_center" alt="npm_node_modules"></p>
</li>
<li><p>之所以出现这种扁平的结构，最初时初衷是好的，为了更好的利用资源，把每个依赖全部放到顶层，这样就不会造成每个依赖嵌套过深，导致很多重复依赖文件</p>
</li>
<li><p>但是随着这种文件结构逐步使用后，就会暴露出来两个问题</p>
<ul>
<li><strong>幽灵依赖</strong></li>
<li><strong>版本冲突</strong></li>
</ul>
</li>
<li><p>幽灵依赖就是你在引用npm包时，你会发现一些没有在<code>package.json</code>中出现的包也能引用，这个就是幽灵依赖，这是因为你在install下载npm包时，npm包也有它的依赖会下载，但是下载的依赖也会存在node_modules同一层级下，这样就会导致可以直接引用</p>
</li>
<li><p>版本冲突是因为不同的依赖可能依赖的包版本也不同，但是node_modules的同一层级只能存在一个包的一个版本号，如果有不同的版本号就只能存在依赖包的node_modules中，这样就会导致出现重复资源</p>
<pre><code class="highlight js">├── package-A @<span class="number">1.0</span>
|── package-B @<span class="number">1.0</span>
├── package-C @<span class="number">1.0</span>
│   └── package-A @<span class="number">2.0</span>
│   └── package-B @<span class="number">2.0</span>
├── package-D @<span class="number">1.0</span>
│   └── package-A @<span class="number">2.0</span>
│   └── package-B @<span class="number">2.0</span></code></pre></li>
</ul>
<h3 id="pnpm的出现"><a href="#pnpm的出现" class="headerlink" title="pnpm的出现"></a>pnpm的出现</h3><ul>
<li><p>在所有前端苦npm久已时，pnpm出现了，并且在pnpm官网的简介上就简单说明了它的构造：<code>store + link</code><br><img src="https://img-blog.csdnimg.cn/20ef6cd68a0440c9841ea1450297c17a.jpeg#pic_center" alt="pnpm_node_modules"></p>
<ul>
<li>store就是依赖的实际存储位置，Mac&#x2F;linux在<code>&#123;home dir&#125;&gt;/.pnpm-store/v3</code>，windows在<code>当前盘/.pnpm-store/v3</code>。这样就会有个好处，你在多个项目使用的是同一个依赖时，就不用重复下载，这样就极大的减少存储空间</li>
<li>link是指符号链接(<code>SymbolicLink</code>)和硬链接(<code>HardLink</code>)<ul>
<li>SymbolicLink是一种特殊的文件，包含一条以绝对路径或者相对路径的形式指向其他文件或者目录的引用，它的存在不依赖于目标文件，如果目标文件被删除或者移动，指向目标文件的符号链接依然存在，但是它们会指向一个不复存在的文件</li>
<li>相比于SymbolicLink，HardLink不是引用文件，而是引用<strong>inode</strong>，inode是文件系统的一种数据结构，用于描述文件系统对象。所以你即使更改目标文件的内容或位置，HardLink仍然指向目标文件，因为inode指向该文件</li>
</ul>
</li>
</ul>
</li>
<li><p>然后拿react举例，当<code>pnpm add react</code>后，在node_modules终端输入<code>tree -a -L 3</code>会得到以下node_modules结构</p>
<pre><code class="highlight js">.
├── .<span class="property">modules</span>.<span class="property">yaml</span>
├── .<span class="property">pnpm</span>
│   ├── js-tokens@<span class="number">4.0</span><span class="number">.0</span>
│   │   └── node_modules
│   ├── lock.<span class="property">yaml</span>
│   ├── loose-envify@<span class="number">1.4</span><span class="number">.0</span>
│   │   └── node_modules
│   ├── node_modules
│   │   ├── .<span class="property">bin</span>
│   │   ├── js-tokens -&gt; ../js-tokens@<span class="number">4.0</span><span class="number">.0</span>/node_modules/js-tokens
│   │   └── loose-envify -&gt; ../loose-envify@<span class="number">1.4</span><span class="number">.0</span>/node_modules/loose-envify
│   └── react@<span class="number">18.2</span><span class="number">.0</span>
│       └── node_modules
└── react -&gt; .<span class="property">pnpm</span>/react@<span class="number">18.2</span><span class="number">.0</span>/node_modules/react</code></pre></li>
<li><p>node_modules下除了.pnpm外只有一个react，这个react只是一个SymbolicLink，当node.js解析时，会找到react的真实位置<code>node_modules/.pnpm/react@18.2.0/node_modules/react</code></p>
</li>
<li><p>.pnpm就是将所有依赖放在同一层文件夹中，每个包都可以通过<code>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</code>这种路径找到，然后通过<code>hand link</code>的方式在store中引用依赖文件</p>
</li>
<li><p>通过这种文件结构，pnpm就解决了npm的两个问题，首先node_modules下不会有你未在package.json中声明的依赖，这样就不会有幽灵依赖的问题。然后.pnpm下会有name+version的方式链接到store中，这样就不会出现因为版本冲突造成资源重复的问题</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.pnpm.cn/blog/2020/05/27/flat-node-modules-is-not-the-only-way">Flat node_modules is not the only way</a></li>
<li><a href="https://www.pnpm.cn/symlinked-node-modules-structure">Symlinked node_modules structure</a></li>
<li><a href="https://juejin.cn/post/7043998041786810398">One For All：基于pnpm + lerna + typescript的最佳项目实践 - 理论篇</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】AI is sleepwalking us into surveillance</title>
    <url>/2023/08/05/%E3%80%90%E7%BF%BB%E3%80%91AI-is-sleepwalking-us-into-surveillance/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://uxdesign.cc/ai-is-sleepwalking-us-into-surveillance-ed7921462b8b">AI is sleepwalking us into surveillance</a><br>原作者：<a href="https://medium.com/@arvindsanjeev">Arvind Sanjeev</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://miro.medium.com/v2/resize:fit:1400/1*oJjQvahNXMcXwxqMNyDuvw.gif"></p>
<p>在2020年，一张女人坐在马桶上的照片在网上遭到泄漏，这个事引发了巨大的争议。<a href="https://www.technologyreview.com/2022/12/19/1065306/roomba-irobot-robot-vacuums-artificial-intelligence-training-data-privacy/">Roomba J7 吸尘器机器人拍摄了这张照片，用作日常数据收集的一部分</a>。这只是一系列照片中的一张，这些照片有拍摄了整个家庭、物品和生活中的一些人。然后有一群来自委内瑞拉的临时工为训练 AI 模型负责标注图片，他们收到了这些图片并泄漏到网上。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*CRckBEERVw4ZzLHSx6aN-w.png"><br><img src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*C6zMQB6Gmf_QfKcfiAcIWw.png"><br><img src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*C5Rhl2Kj7AJRDwgHyFpOFg.png"></p>
<p>为了让每个新的AI模型比上一个模型更好时，公司不惜采用不道德的数据收集技术，以便让自己在竞争中脱颖而出。我们的私有数据，包括医疗记录、照片、社交媒体等内容，都被纳入用于训练AI模型的数据集中。</p>
<h2 id="Your-data-is-being-stolen"><a href="#Your-data-is-being-stolen" class="headerlink" title="Your data is being stolen"></a>Your data is being stolen</h2><p><strong>你愿意为了方便而放弃隐私吗？</strong></p>
<blockquote>
<p>Reading all the privacy policies you encounter in a year from big tech companies would take 30 full working days of your life.<br>Source: <a href="https://lorrie.cranor.org/pubs/readingPolicyCost-authorDraft.pdf">The cost of reading privacy policies</a></p>
</blockquote>
<p>家是我们安全的地方，但如果家里的电器开始泄漏我们的数据，会发生什么？数据调查记者 Kashmir Hill 和 Surya Mattu 揭示了我们家里的智能设备是如何做到这个的。最初，你的电动牙刷会经常发送数据到它的母公司，然而，在2018年的 TED talk 中揭示了这些收集的数据会反过来影响我们。比如，你的牙科保险公司可以从这些牙刷公司中购买你的数据，如果你晚上没有刷牙，就会收取更高的保费。</p>
<div style="max-width:854px"><div style="position:relative;height:0;padding-bottom:56.25%"><iframe src="https://embed.ted.com/talks/lang/en/kashmir_hill_and_surya_mattu_what_your_smart_devices_know_and_share_about_you" width="854" height="480" style="position:absolute;left:0;top:0;width:100%;height:100%" frameborder="0" scrolling="no" allowfullscreen></iframe></div></div>

<p>用于训练图像合成的 AI 模型的数据集是通过在网上搜寻图像制作的，这些图像的版权所有者和持有人可能同意或者并没有同意允许使用。甚至<a href="https://arstechnica.com/information-technology/2022/09/artist-finds-private-medical-record-photos-in-popular-ai-training-data-set/">病人的私人病历也会成为AI模型的训练数据</a>。来自加利福尼亚州的艺术家 Laping 发现，她的医生在2013年为她拍摄的病历照片被收录到 LAION-5B image set，这是 Stable Diffusion 和 Google Imagen 使用的 data set。她通过<a href="https://haveibeentrained.com/">Have I Been Trained</a>发现这一点，这个工具是 Holly Herndon 的一个项目，任何人都可以通过该工具查看自己的照片是否被用于训练 AI 模型。</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">🚩My face is in the <a href="https://twitter.com/hashtag/LAION?src=hash&amp;ref_src=twsrc%5Etfw">#LAION</a> dataset. In 2013 a doctor photographed my face as part of clinical documentation. He died in 2018 and somehow that image ended up somewhere online and then ended up in the dataset- the image that I signed a consent form for my doctor- not for a dataset. <a href="https://t.co/TrvjdZtyjD">pic.twitter.com/TrvjdZtyjD</a></p>&mdash; Lapine (@LapineDeLaTerre) <a href="https://twitter.com/LapineDeLaTerre/status/1570889343845404672?ref_src=twsrc%5Etfw">September 16, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<blockquote>
<p>The LAION-5B dataset, which has more than 5 billion images, includes photoshopped celebrity porn, hacked and stolen nonconsensual porn, and graphic images of ISIS beheadings. More mundanely, they include living artists’ artwork, photographers’ photos, medical imagery, and photos of people who presumably did not believe that their images would suddenly end up as the basis to be trained by an AI.<br>Source: <a href="https://www.vice.com/en/article/3ad58k/ai-is-probably-using-your-images-and-its-not-easy-to-opt-out">AI Is Probably Using Your Images and It’s Not Easy to Opt Out</a>, Vice</p>
</blockquote>
<h2 id="Compromised-identities"><a href="#Compromised-identities" class="headerlink" title="Compromised identities"></a>Compromised identities</h2><p><strong>研究证明，AI 生成的面部图像可以通过逆向工程的方式揭示出其真实人物来源</strong></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*4ehilQEObju2ePksOV9MPA.gif"></p>
<p>现在，AI生成的人脸已成为主流。设计师把它们用为作品拍摄的模特或者假人。因为他们认为既然这些人不是真人，就不用征得他们的同意。然而，这些生成的人脸并不是独一无二的。2021年，研究员可以把 GAN 生成的人脸<a href="https://www.technologyreview.com/2021/10/12/1036844/ai-gan-fake-faces-data-privacy-security-leak/">回溯到原始人脸上</a>。因为这些生成的人脸和原始的人脸相似，只是略有感动，通过这些数据集就暴露了那些人脸的真实身份。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VPgtH5UGFQijaCI4_9Ldw.png"></p>
<p>与GAN不同，像 DALL-E 或 Midjourney 这样的扩散模型产生的图像被认为更接近真实，并且与训练集中的图像显著不同。通过生成新图像，他们提供了一种保护数据集中个人隐私的方式。然而，一篇名为 <a href="https://arxiv.org/pdf/2301.13188.pdf">Extracting Training Data from Diffusion Models</a> 的论文展示了扩散模型如何从训练数据中记忆单个图像，并在运行时重新生成。人们普遍认为 AI 模型是一个“黑盒子”，里面什么都没有，但通过这些实验，人们需要重新审视这一观点。</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Models such as Stable Diffusion are trained on copyrighted, trademarked, private, and sensitive images.<br><br>Yet, our new paper shows that diffusion models memorize images from their training data and emit them at generation time.<br><br>Paper: <a href="https://t.co/LQuTtAskJ9">https://t.co/LQuTtAskJ9</a> <br><br>👇[1/9] <a href="https://t.co/ieVqkOnnoX">pic.twitter.com/ieVqkOnnoX</a></p>&mdash; Eric Wallace (@ICML) (@Eric_Wallace_) <a href="https://twitter.com/Eric_Wallace_/status/1620449934863642624?ref_src=twsrc%5Etfw">January 31, 2023</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="AI-surveillance"><a href="#AI-surveillance" class="headerlink" title="AI surveillance"></a>AI surveillance</h2><p><strong>通过 AI 加强社会的监控</strong></p>
<p>最具争议的智能监控案例之一发生在2019年香港抗议活动期间。警方使用<a href="https://www.telegraph.co.uk/news/2019/08/02/innovative-hong-kong-protesters-using-lasers-traffic-cones-parkour/">面部识别技术</a>来识别抗议者，并对他们进行单独处罚。抗议者意识到这一点后，于是使用<a href="https://www.independent.co.uk/tech/hong-kong-protests-lasers-facial-recognition-ai-china-police-a9033046.html">黑客激光笔瞄准摄像头</a>，烧毁那些摄像头的图像传感器。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:996/0*0PCrBpv3P7FrAGen.gif"></p>
<p>全世界一半的监控摄像头都在中国，使中国成为<a href="https://fortune.com/2020/11/03/china-surveillance-system-backlash-worlds-largest/">世界上最大的监控社会</a>。他们利用摄像头对乱穿马路者进行罚款，或利用面部识别技术进行机场安检。虽然基于 AI 的监控系统看似是打击犯罪和恐怖主义的重要工具。但却引发了有关隐私和公民自由的担忧。这些系统指向了 Orwellian 式的未来，Big brother 可能会监视并控制个人，潜在地丧失自由和公民自由。</p>
<h2 id="Who’s-fighting-back"><a href="#Who’s-fighting-back" class="headerlink" title="Who’s fighting back?"></a>Who’s fighting back?</h2><p>对于侵犯隐私的 AI，美国联邦贸易委员会（FTC）给出了一个带有挑衅性的答案。他们已经<a href="https://www.protocol.com/policy/ftc-algorithm-destroy-data-privacy">开始实践算法摧毁</a>。他们要求公司和组织摧毁其恶意或非法收集的个人信息和数据建立的算法或AI模型。以下是一些倡议的例子：</p>
<h3 id="Policies-and-frameworks"><a href="#Policies-and-frameworks" class="headerlink" title="Policies and frameworks"></a>Policies and frameworks</h3><p>欧盟在<a href="https://www.politico.eu/article/europe-edges-closer-to-a-ban-on-facial-recognition/">AI时代保护个人隐私方面迈出了重要一步</a>。他们支持禁止在公共场所进行AI监控的方案。欧盟广受欢迎的 <a href="https://gdpr-info.eu/?ref=dr-mark-van-rijmenam-csp-the-digital-speaker-strategic-futurist">General Data Protection Regulation</a> 也拥有最佳的数据保护条例，该条例要求在收集和使用个人数据前需征得个人同意。</p>
<p>加拿大的 <a href="https://www.priv.gc.ca/en/privacy-topics/privacy-laws-in-canada/the-personal-information-protection-and-electronic-documents-act-pipeda/">Personal Information Protection and Electronic Documents Act</a> (PIPEDA) 要求企业采取“合理的”安全保障措施来保护个人信息。而在美国， <a href="https://oag.ca.gov/privacy/ccpa?ref=dr-mark-van-rijmenam-csp-the-digital-speaker-strategic-futurist">California Consumer Privacy Act</a> (CCPA) 是一部全面的隐私法，赋予个人询问组织收集个人信息，如何使用以及用于何种目的的权利。</p>
<h3 id="Projects-and-experiments"><a href="#Projects-and-experiments" class="headerlink" title="Projects and experiments"></a>Projects and experiments</h3><ul>
<li><a href="https://haveibeentrained.com/">Have I Been Trained</a>：一个可以轻松搜索我们的数据是否被用于训练AI的平台。上传你的照片，查看是否被进入到扩散模型的数据集中。这是一个名为 <a href="https://spawning.ai/">Spawning.ai</a> 项目中的一部分，该项目让人们重新掌控自己的数据。他们还在开发“选择退出”和“选择加入”的工具，让你能够决定是否将你的数据用于训练。</li>
<li><a href="https://microsoft.github.io/FaceSynthetics/">Microsoft Synthetic Faces</a>：微软提供了100,000张合成人脸，用于训练脸部识别算法，而无需使用真人。</li>
</ul>
<p><img src="https://miro.medium.com/v2/format:webp/1*dqWiNZQGABXXbgNlxK9SRQ.png"></p>
<ul>
<li><a href="https://unlabeled.jp/en/camouflage/">AI Camouflage</a>：可加入一些对抗性补丁，嵌入到衣服或其他物体中，用于干扰AI分类系统</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:960/1*xISa3pvq1IpxCmVR3YPn-A.gif"><br><img src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*1Znf2sv1bK9seDqaMGDc9w.png"></p>
<ul>
<li><a href="https://arxiv.org/pdf/2109.06467.pdf">Adversarial Makeup</a>：通过化妆干扰AI分类系统，使你在系统中变得难以辨认。CV dazzle 还在 Youtube 上提供化妆教程：</li>
</ul>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kGGnnp43uNM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<ul>
<li><a href="https://bjoernkarmann.dk/project/project_alias">Alias</a>：Bjørn Karmann 提出的隐私干预方案可以阻止语音助手监听你的声音。</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oQFCASWtRqdyqy_B.jpg"></p>
<p>在<a href="https://www.goodreads.com/en/book/show/36696533">《New Dark Age》</a>中，James Bridle对AI监控如何将临床偏执症变成现实发表了评论。临床妄想症的最初症状之一就是认为有人在监视你；但现在这种想法是合理的。我们发送的每一封邮件、写的每一条短信、打的每一通电话、走的每一段路、迈出的每一步、呼吸、做的每一个梦、说出的每一句话，都成为大规模的自动智能收集系统的目标，社交网络和垃圾邮件的排序算法以及我们自己智能手机和联网设备不眠不休的监视。那么，现在是谁在偏执呢？</p>
<p>有关此主题及其他主题的更多资源，请查阅本手册<a href="https://arvindsanjeev.notion.site/arvindsanjeev/The-Handbook-of-AI-s-Unintended-Consequences-720cda3d8cec49dc88807641157a0bba">《AI’s unintended consequences》</a>。本文是探讨 <a href="https://medium.com/@arvindsanjeev/ai-sociopaths-and-their-unintended-consequences-bf6f19012e4f">unintended consequences of AI 四部系列文章</a>中的第三章</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Flat node_modules is not the only way</title>
    <url>/2023/05/01/%E3%80%90%E7%BF%BB%E3%80%91Flat%20node_modules%20is%20not%20the%20only%20way/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way">Flat node_modules is not the only way</a><br>原作者：<a href="https://twitter.com/zoltankochan">Zoltan Kochan</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>pnpm的新用户经常问我关于pnpm创建后的<code>node_module</code>结构为什么这么奇怪。为什么不是扁平化的？所有的次级依赖在哪里？</p>
<blockquote>
<p>我假设阅读这篇文章的读者都已经熟悉了npm和yarn创建后的扁平化<code>node_modules</code>，如果你不明白npm在v3中开始使用扁平化<code>node_modules</code>，你可以在<a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html">Why should we use pnpm?</a>中找到一些历史说明</p>
</blockquote>
<p>那么为什么pnpm的<code>node_modules</code>不寻常呢？我们来创建两个目录，一个运行<code>npm add express</code>，另一个运行<code>pnpm add express</code>，下面是你在第一个目录的<code>node_modules</code>中得到的顶部内容结构</p>
<pre><code class="highlight text">.bin
accepts
array-flatten
body-parser
bytes
content-disposition
cookie-signature
cookie
debug
depd
destroy
ee-first
encodeurl
escape-html
etag
express</code></pre>

<p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/npm-example/node_modules">这里</a>看到整个目录。</p>
<p>然后这是你在pnpm创建的<code>node_modules</code>中得到的目录：</p>
<pre><code class="highlight text">.pnpm
.modules.yaml
express</code></pre>

<p>你可以在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules">这里</a>查看.</p>
<p>那么，所有的依赖项都在哪里呢，在<code>node_modules</code>中只有一个叫做<code>.pnpm</code>的文件夹和一个叫做<code>express</code>的<code>symlink</code>。好吧，因为我们只安装了<code>express</code>，所以这是你的应用可以访问的唯一<code>package</code></p>
<blockquote>
<p>在<a href="https://medium.com/pnpm/pnpms-strictness-helps-to-avoid-silly-bugs-9a15fb306308">此</a>阅读更多关于pnpm的严格性为什么是一件好事情</p>
</blockquote>
<p>让我们看看<code>express</code>的内部：</p>
<pre><code class="highlight text">▾ node_modules
  ▸ .pnpm
  ▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
  .modules.yaml</code></pre>

<p>express没有node_modules？express的所有依赖项在哪里?</p>
<p>诀窍在于，<code>express</code>只是一个<code>symlink</code>，但<code>Node.js</code>解析依赖关系时，它会使用<code>express</code>的真实位置，所以依赖不会保留在符号连接上，但是你可能会问，<code>express</code>的真实位置在哪?</p>
<p>这里：<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules/express">node_modules&#x2F;.pnpm&#x2F;express@4.17.1/node_modules&#x2F;express</a>.</p>
<p>现在我们知道了<code>.pnpm</code>文件夹的用途。<code>.pnpm</code>在一个扁平的文件夹结构中存储所有的<code>packages</code>，所以每个<code>package</code>都可以在这个模式命名的文件夹中找到</p>
<pre><code class="highlight text">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</code></pre>

<p>我们称它为虚拟存储目录</p>
<p>这种扁平结构避免了<code>npm v2</code>创建的嵌套<code>node_modules</code>造成的长路径问题，但是又与<code>npm v3,4,5,6</code>和<code>yarn v1</code>的扁平化结构不同，保持了<code>packages</code>的隔离</p>
<p>现在我们来研究一下express的真实位置：</p>
<pre><code class="highlight text">▾ express
  ▸ lib
    History.md
    index.js
    LICENSE
    package.json
    Readme.md</code></pre>

<p>这是错误的吗？它仍然缺少<code>node_modules</code>！<code>pnpm</code>的<code>node_modules</code>结构的第二个诀窍是，<code>packages</code>的依赖关系在同一级的目录上，而<code>package</code>依赖的真正位置在这个目录上。所以<code>express</code>的依赖不在<code>.pnpm/express@4.17.1/node_modules/express/node_modules/</code>，而是在<a href="https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example/node_modules/.pnpm/express@4.17.1/node_modules">.pnpm&#x2F;express@4.17.1/node_modules&#x2F;</a></p>
<pre><code class="highlight text">▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.5
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.16.3
      ▾ node_modules
        ▸ accepts
        ▸ array-flatten
        ▸ body-parser
        ▸ content-disposition
        ...
        ▸ etag
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md</code></pre>

<p><code>express</code>的所有依赖都是指向<code>node_modules/.pnpm</code>内目录的symlinks。<code>express</code>的依赖放在上一级，可以避免循环symlinks</p>
<p>所以你可以看到，尽管pnpm的<code>node_modules</code>结构从开始时看起来不寻常：</p>
<ol>
<li>完全兼容Node.js</li>
<li>packages和相关依赖被很好的组合在一起</li>
</ol>
<p>对于同样依赖关系的packages来说结构要复杂一些，但是想法是一样的：使用symlinks创建一个有扁平目录结构的嵌套</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】How peers are resolved</title>
    <url>/2023/05/05/%E3%80%90%E7%BF%BB%E3%80%91How%20peers%20are%20resolved/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://pnpm.io/how-peers-are-resolved">How peers are resolved</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>pnpm最大的一个特点是，在一个项目中，一个特定版本的package总是有一组依赖关系。不过，这个规则有一个例外–有peer dependencies的packages</p>
<p>在dependency graph中，peer dependencies是从更高级别的依赖中解析的，因为它们与它们的父依赖项共享相同的版本。这意味着如果<a href="mailto:&#102;&#x6f;&#111;&#64;&#49;&#46;&#x30;&#x2e;&#48;">&#102;&#x6f;&#111;&#64;&#49;&#46;&#x30;&#x2e;&#48;</a>有两个peer依赖项(bar@^1 和 baz@^1)，那么在同一个项目中它可能会有多个不同的依赖项集合</p>
<pre><code class="highlight text">- foo-parent-1
  - bar@1.0.0
  - baz@1.0.0
  - foo@1.0.0
- foo-parent-2
  - bar@1.0.0
  - baz@1.1.0
  - foo@1.0.0</code></pre>

<p>在上面这个例子中，<a href="mailto:&#x66;&#x6f;&#111;&#x40;&#49;&#46;&#x30;&#46;&#48;">&#x66;&#x6f;&#111;&#x40;&#49;&#46;&#x30;&#46;&#48;</a>是在foo-parent-1和foo-parent-2安装的。这两个packages中都有bar和baz，但是他们依赖不同版本的baz。因此，<a href="mailto:&#102;&#x6f;&#111;&#64;&#x31;&#x2e;&#48;&#x2e;&#48;">&#102;&#x6f;&#111;&#64;&#x31;&#x2e;&#48;&#x2e;&#48;</a>有两个不同的依赖集：一个是<a href="mailto:&#x62;&#97;&#122;&#64;&#x31;&#x2e;&#48;&#x2e;&#x30;">&#x62;&#97;&#122;&#64;&#x31;&#x2e;&#48;&#x2e;&#x30;</a>，另一个是<a href="mailto:&#x62;&#97;&#122;&#64;&#49;&#x2e;&#x31;&#x2e;&#x30;">&#x62;&#97;&#122;&#64;&#49;&#x2e;&#x31;&#x2e;&#x30;</a>。为了支持这些用例，pnpm必须hand link <a href="mailto:&#x66;&#x6f;&#111;&#x40;&#49;&#x2e;&#48;&#x2e;&#48;">&#x66;&#x6f;&#111;&#x40;&#49;&#x2e;&#48;&#x2e;&#48;</a>，次数和不同的依赖集一样多。</p>
<p>通常，如果一个package没有peer依赖项，它会与其依赖项的symlinks一起hard linked到node_modules文件夹中，就像：</p>
<pre><code class="highlight text">node_modules
└── .pnpm
    ├── foo@1.0.0
    │   └── node_modules
    │       ├── foo
    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux
    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh
    ├── qux@1.0.0
    ├── plugh@1.0.0</code></pre>

<p>然后，如果foo有peer dependencies，它可能有多组依赖关系，所以我们为不同的peer dependencies 创建不同的集合：</p>
<pre><code class="highlight text">node_modules
└── .pnpm
    ├── foo@1.0.0_bar@1.0.0+baz@1.0.0
    │   └── node_modules
    │       ├── foo
    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar
    │       ├── baz   -&gt; ../../baz@1.0.0/node_modules/baz
    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux
    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh
    ├── foo@1.0.0_bar@1.0.0+baz@1.1.0
    │   └── node_modules
    │       ├── foo
    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar
    │       ├── baz   -&gt; ../../baz@1.1.0/node_modules/baz
    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux
    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh
    ├── bar@1.0.0
    ├── baz@1.0.0
    ├── baz@1.1.0
    ├── qux@1.0.0
    ├── plugh@1.0.0</code></pre>

<p>我们要么创建symlinks到<code>foo@1.0.0_bar@1.0.0+baz@1.0.0</code>中的foo，要么创建symlinks到<code>foo@1.0.0_bar@1.0.0+baz@1.1.0</code>中的foo。因此，Node.js模块解析可以找到正确的peers依赖项。</p>
<p>如果一个package没有peer依赖项，但是有依赖于已在图中解析的同级依赖项的依赖项，那么这个transitive package可以以不同的依赖项集出现在项目中。例如，存在一个版本为<code>a@1.0.0</code>的包，它只有一个依赖项<code>b@1.0.0</code>。<code>b@1.0.0</code>有一个同级依赖项<code>c@^1</code>。<code>a@1.0.0</code>永远不会解析<code>b@1.0.0</code>的同级依赖项，所以它也会依赖于<code>b@1.0.0</code>的同级依赖项。</p>
<p>下面是这个结构在<code>node_modules</code>中的样子，在这个例子中，<a href="mailto:&#97;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;">&#97;&#x40;&#x31;&#x2e;&#x30;&#46;&#x30;</a>需要在项目的<code>node_modules</code>中出现两次，一次和<code>c@1.0.0</code>，另一次和<code>c@1.1.0</code>解决。</p>
<pre><code class="highlight text">node_modules
└── .pnpm
    ├── a@1.0.0_c@1.0.0
    │   └── node_modules
    │       ├── a
    │       └── b -&gt; ../../b@1.0.0_c@1.0.0/node_modules/b
    ├── a@1.0.0_c@1.1.0
    │   └── node_modules
    │       ├── a
    │       └── b -&gt; ../../b@1.0.0_c@1.1.0/node_modules/b
    ├── b@1.0.0_c@1.0.0
    │   └── node_modules
    │       ├── b
    │       └── c -&gt; ../../c@1.0.0/node_modules/c
    ├── b@1.0.0_c@1.1.0
    │   └── node_modules
    │       ├── b
    │       └── c -&gt; ../../c@1.1.0/node_modules/c
    ├── c@1.0.0
    ├── c@1.1.0</code></pre>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Announcing Vue 3.3</title>
    <url>/2023/08/23/%E3%80%90%E7%BF%BB%E3%80%91Announcing-Vue-3-3/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://blog.vuejs.org/posts/vue-3-3">Announcing Vue 3.3</a><br>原作者：<a href="https://twitter.com/youyuxi">Evan You</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>今天，我们很高兴地宣布Vue3.3”Rurouni Kenshin”正式发布！</p>
<p>这次版本的重点改动在于提升开发人员的开发体验，特别是SFC的<code>&lt;script setup&gt;</code>和TypeScript的使用。并且与Vue配套的的开发工具(Volar 1.6)一起，我们解决了在使用Vue和Typecript时长期存在的许多痛点。</p>
<p>本文章会大致介绍3.3中的重点功能。有关3.3版本变更的完整内容。请查看Gitub上的<a href="https://github.com/vuejs/core/blob/main/CHANGELOG.md#330-2023-05-08">changelog</a></p>
<blockquote>
<p><strong>配套库更新</strong><br>当升级到3.3时，建议同时更新以下相关库：<br>volar &#x2F; vue-tsc@^1.6.4<br>vite@^4.3.5<br>@vitejs&#x2F;plugin-vue@^4.2.0<br>vue-loader@^17.1.0 (if using webpack or vue-cli)</p>
</blockquote>
<h2 id="lt-script-setup-gt-TypeScript-DX-Improvements"><a href="#lt-script-setup-gt-TypeScript-DX-Improvements" class="headerlink" title="&lt;script setup&gt; + TypeScript DX Improvements"></a><code>&lt;script setup&gt;</code> + TypeScript DX Improvements</h2><h3 id="Imported-and-Complex-Types-Support-in-Macros"><a href="#Imported-and-Complex-Types-Support-in-Macros" class="headerlink" title="Imported and Complex Types Support in Macros"></a>Imported and Complex Types Support in Macros</h3><p>以前，在<code>defineProps</code>和<code>defineEmits</code>的类型参数中使用的类型仅限于本地类型，并且只支持<code>type literals</code>和<code>interfaces</code>。只是因为Vue需要分析<code>props interface</code>上的属性，以便能够生产相应的运行时选项。</p>
<p>这个限制在3.3中得以解决。编译器现在可以解析导入类型，并支持一些复杂类型集合：</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript"><span class="keyword">import</span> type &#123; <span class="title class_">Props</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo&#x27;</span></span>
<span class="language-javascript"></span>
<span class="language-javascript"><span class="comment">// imported + intersection type</span></span>
<span class="language-javascript">defineProps&lt;<span class="title class_">Props</span> &amp; &#123; extraProp?: string &#125;&gt;()</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>

<p>注意，复杂类型的支持是基于AST的，所以并非100%支持。某些需要实际类型分析的复杂类型，比如条件类型，并不支持。你可以对单个prop使用条件类型，但不能对整个prop对象使用条件类型。</p>
<h3 id="Generic-Components"><a href="#Generic-Components" class="headerlink" title="Generic Components"></a>Generic Components</h3><p>使用<code>&lt;script setup&gt;</code>的组件现在可以通过generic属性接收通用类型参数：</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">generic</span>=<span class="string">&quot;T&quot;</span>&gt;</span>
defineProps&lt;&#123;
  items: T[]
  selected: T
&#125;&gt;()
<span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>

<p>generic的值与TypeScript中参数列表的工作方式完全一样。比如可以使用多个参数，通过extends约束，默认类型和引用导入类型：</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">generic</span>=<span class="string">&quot;T extends string | number, U extends Item&quot;</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript"><span class="keyword">import</span> type &#123; <span class="title class_">Item</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span>
<span class="language-javascript">defineProps&lt;&#123;</span>
<span class="language-javascript">  <span class="attr">id</span>: T</span>
<span class="language-javascript">  <span class="attr">list</span>: U[]</span>
<span class="language-javascript">&#125;&gt;()</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>

<p>该功能以前需要明确选择加入，但现在在最新版本的volar&#x2F;vue-tsc中已经默认启用。</p>
<h3 id="More-Ergonomic-defineEmits"><a href="#More-Ergonomic-defineEmits" class="headerlink" title="More Ergonomic defineEmits"></a>More Ergonomic defineEmits</h3><p>以前，<code>defineEmits</code>的类型参数只支持调用签名语法：</p>
<pre><code class="highlight ts"><span class="comment">// BEFORE</span>
<span class="keyword">const</span> emit = defineEmits&lt;&#123;
  (<span class="attr">e</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">void</span>
  (<span class="attr">e</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">name</span>: <span class="built_in">string</span>, ...<span class="attr">rest</span>: <span class="built_in">any</span>[]): <span class="built_in">void</span>
&#125;&gt;()</code></pre>

<p>该类型与emit的返回类型相匹配，但写起来有点啰嗦且不好看。然后3.3引入了一种更符合工学的声明方式：</p>
<pre><code class="highlight ts"><span class="comment">// AFTER</span>
<span class="keyword">const</span> emit = defineEmits&lt;&#123;
  <span class="attr">foo</span>: [<span class="attr">id</span>: <span class="built_in">number</span>]
  <span class="attr">bar</span>: [<span class="attr">name</span>: <span class="built_in">string</span>, ...<span class="attr">rest</span>: <span class="built_in">any</span>[]]
&#125;&gt;()</code></pre>

<p>在上面的类型中，key是事件名称，value是额外参数的数组类型。虽然不是必须的，但你也可以使用元祖类型来明确参数，如上面的示例。</p>
<p>并且现在依然支持调用签名语法。</p>
<h3 id="Typed-Slots-with-defineSlots"><a href="#Typed-Slots-with-defineSlots" class="headerlink" title="Typed Slots with defineSlots"></a>Typed Slots with defineSlots</h3><p>新的<code>defineSlots</code>宏可用于声明slots和slots的props</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">defineSlots&lt;&#123;</span>
<span class="language-javascript">  <span class="keyword">default</span>?: <span class="function">(<span class="params">props: &#123; msg: string &#125;</span>) =&gt;</span> any</span>
<span class="language-javascript">  item?: <span class="function">(<span class="params">props: &#123; id: number &#125;</span>) =&gt;</span> any</span>
<span class="language-javascript">&#125;&gt;()</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>

<p><code>defineSlots()</code>只接受一个类型参数，并且不接受运行时参数。然后类型参数应该是一个<code>type literals</code>，其中的key是插槽名字，value是一个插槽函数。函数的第一个参数是插槽期望接受的props，其类型将用于模版中slot的props。<code>defineSlots</code>的返回值与<code>useSlots</code>返回的插槽对象相同。</p>
<p>目前的一些限制：</p>
<ul>
<li>volar&#x2F;vue-tsc目前尚未实现所需的插槽检查。</li>
<li>插槽函数的返回类型目前还是忽视的，可以是任何类型，但我们将来可能会利用它进行插槽内容检查。</li>
</ul>
<p>还有一个相应的<code>slots</code>选项适用于<code>defineComponent</code>的使用。这两个API都没有实现运行时，纯粹是IDE和vue-tsc的类型提示。</p>
<h2 id="Experimental-Features"><a href="#Experimental-Features" class="headerlink" title="Experimental Features"></a>Experimental Features</h2><h3 id="Reactive-Props-Destructure"><a href="#Reactive-Props-Destructure" class="headerlink" title="Reactive Props Destructure"></a>Reactive Props Destructure</h3><p>之前的响应式转换中未实现props的解构响应，现在已经被拆分为一个独立的功能。</p>
<p>该功能允许解构的props保留响应式，并提供了一种更符合工学的方式来声明props默认值：</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript"><span class="keyword">import</span> &#123; watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span>
<span class="language-javascript"></span>
<span class="language-javascript"><span class="keyword">const</span> &#123; msg = <span class="string">&#x27;hello&#x27;</span> &#125; = <span class="title function_">defineProps</span>([<span class="string">&#x27;msg&#x27;</span>])</span>
<span class="language-javascript"></span>
<span class="language-javascript"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span>
<span class="language-javascript">  <span class="comment">// accessing `msg` in watchers and computed getters</span></span>
<span class="language-javascript">  <span class="comment">// tracks it as a dependency, just like accessing `props.msg`</span></span>
<span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`msg is: <span class="subst">$&#123;msg&#125;</span>`</span>)</span>
<span class="language-javascript">&#125;)</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>

<span class="tag">&lt;<span class="name">template</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></code></pre>

<p>这个目前是实验性的功能，需要明确选择加入。</p>
<h3 id="defineModel"><a href="#defineModel" class="headerlink" title="defineModel"></a><code>defineModel</code></h3><p>之前，如果一个组件要支持<code>v-moel</code>的双向绑定，首先需要声明一个prop，然后在更新时发出相应的<code>update:propName</code>事件:</p>
<pre><code class="highlight html"><span class="comment">&lt;!-- BEFORE --&gt;</span>
<span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>])</span>
<span class="language-javascript"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:modelValue&#x27;</span>])</span>
<span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">modelValue</span>)</span>
<span class="language-javascript"></span>
<span class="language-javascript"><span class="keyword">function</span> <span class="title function_">onInput</span>(<span class="params">e</span>) &#123;</span>
<span class="language-javascript">  <span class="title function_">emit</span>(<span class="string">&#x27;update:modelValue&#x27;</span>, e.<span class="property">target</span>.<span class="property">value</span>)</span>
<span class="language-javascript">&#125;</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>

<span class="tag">&lt;<span class="name">template</span>&gt;</span>
  <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span> /&gt;</span>
<span class="tag">&lt;/<span class="name">template</span>&gt;</span></code></pre>

<p>在3.3中通过新的API<code>defineModel</code>简化来其用法。该宏会自动注册一个prop，并返回一个可以直接更改的ref</p>
<pre><code class="highlight html"><span class="comment">&lt;!-- AFTER --&gt;</span>
<span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript"><span class="keyword">const</span> modelValue = <span class="title function_">defineModel</span>()</span>
<span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(modelValue.<span class="property">value</span>)</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>

<span class="tag">&lt;<span class="name">template</span>&gt;</span>
  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;modelValue&quot;</span> /&gt;</span>
<span class="tag">&lt;/<span class="name">template</span>&gt;</span></code></pre>

<p>这个目前是实验性的功能，需要明确选择加入。</p>
<h2 id="Other-Notable-Features"><a href="#Other-Notable-Features" class="headerlink" title="Other Notable Features"></a>Other Notable Features</h2><h3 id="defineOptions"><a href="#defineOptions" class="headerlink" title="defineOptions"></a><code>defineOptions</code></h3><p>新的defineOptions宏直接可以在<code>&lt;script setup&gt;</code>中声明组件选项，而不需要单独的<code>&lt;script&gt;</code>块：</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript"><span class="title function_">defineOptions</span>(&#123; <span class="attr">inheritAttrs</span>: <span class="literal">false</span> &#125;)</span>
<span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre>

<h2 id="Better-Getter-Support-with-toRef-and-toValue"><a href="#Better-Getter-Support-with-toRef-and-toValue" class="headerlink" title="Better Getter Support with toRef and toValue"></a>Better Getter Support with <code>toRef</code> and <code>toValue</code></h2><p><code>toRef</code>得到增强，支持 <code>values/getters/existing refs</code>统一转为<code>refs</code></p>
<pre><code class="highlight js"><span class="comment">// equivalent to ref(1)</span>
<span class="title function_">toRef</span>(<span class="number">1</span>)
<span class="comment">// creates a readonly ref that calls the getter on .value access</span>
<span class="title function_">toRef</span>(<span class="function">() =&gt;</span> props.<span class="property">foo</span>)
<span class="comment">// returns existing refs as-is</span>
<span class="title function_">toRef</span>(existingRef)</code></pre>

<p>通过 getter 调用<code>toRef</code>和<code>computed</code>类似，但是在只进行属性访问而不是高度计算时，<code>toRef</code>效率会更高</p>
<p><code>toValue</code>是提供了一个相反的方法，把 <code>values/getters/ref</code> 统一转为普通值</p>
<pre><code class="highlight js"><span class="title function_">toValue</span>(<span class="number">1</span>) <span class="comment">//       --&gt; 1</span>
<span class="title function_">toValue</span>(<span class="title function_">ref</span>(<span class="number">1</span>)) <span class="comment">//  --&gt; 1</span>
<span class="title function_">toValue</span>(<span class="function">() =&gt;</span> <span class="number">1</span>) <span class="comment">// --&gt; 1</span></code></pre>

<p><code>toValue</code>可以在组合式函数中代替<code>unref</code>，这样你的组合式函数就可以接受<code>getters</code>作为响应式数据源：</p>
<pre><code class="highlight js"><span class="comment">// before: allocating unnecessary intermediate refs</span>
<span class="title function_">useFeature</span>(<span class="title function_">computed</span>(<span class="function">() =&gt;</span> props.<span class="property">foo</span>))
<span class="title function_">useFeature</span>(<span class="title function_">toRef</span>(props, <span class="string">&#x27;foo&#x27;</span>))

<span class="comment">// after: more efficient and succinct</span>
<span class="title function_">useFeature</span>(<span class="function">() =&gt;</span> props.<span class="property">foo</span>)</code></pre>

<p><code>toRef</code>和<code>toValue</code>之间的关系就类似于<code>ref</code>和<code>unref</code>之间的关系，主要区别在于对<code>getter</code>函数的特殊处理</p>
<h2 id="JSX-Import-Source-Support"><a href="#JSX-Import-Source-Support" class="headerlink" title="JSX Import Source Support"></a>JSX Import Source Support</h2><p>目前，Vue的类型会自动注册全局JSX类型，这可能会与需要JSX类型推断的库产生冲突，尤其是React</p>
<p>从3.3开始，Vue支持通过TypeScript的<a href="https://www.typescriptlang.org/tsconfig#jsxImportSource">jsxImportSource</a>选项指定JSX命名空间。这允许用户根据自己的使用情况选择全局或者按文件选额。</p>
<p>为了向后兼容，3.3版本仍会全局注册JSX命名空间。我们计划在3.4中移除默认的全局注册。如果你在Vue中使用TSX，在升级到3.3后，应在<code>tsconfig.json</code>中显式添加<code>jsxImportSource</code>，避免在3.4中出现中断。</p>
<h2 id="Maintenance-Infrastructure-Improvements"><a href="#Maintenance-Infrastructure-Improvements" class="headerlink" title="Maintenance Infrastructure Improvements"></a>Maintenance Infrastructure Improvements</h2><p>此次版本升级基于许多维护基础构造的改进，使我们有更大信心加快工作进度：</p>
<ul>
<li>通过将类型检查与rollup构建分离，并将<code>rollup-plugin-typescript2</code>迁为<code>rollup-plugin-esbuild</code>，将构建速度提高了10倍。</li>
<li>把 Jest 迁为 Vitest，加快了测试速度。</li>
<li>把<code>@microsoft/api-extractor</code>迁为<code>rollup-plugin-dts</code>，更快地生成类型</li>
<li>通过<a href="https://github.com/vuejs/ecosystem-ci">ecosystem-ci</a>进行全面的回归测试(在发布前捕捉主要生态系统依赖的回归)</li>
</ul>
<p>按照计划，我们的目标是在2023年开始更小规模、更频繁地发布功能。敬请期待！</p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】How to Use ChatGPT to Learn a Language (And Practice It)</title>
    <url>/2023/07/01/%E3%80%90%E7%BF%BB%E3%80%91How-to-Use-ChatGPT-to-Learn-a-Language-And-Practice-It/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://artificialcorner.com/how-to-use-chatgpt-to-learn-a-language-and-practice-it-f7e7e38b1cee">How to Use ChatGPT to Learn a Language (And Practice It)</a><br>原作者：<a href="https://dianatheathlete.medium.com/">Diana Dovgopol</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsuHn9qRgL_il5b931lCsA.png"></p>
<p>我是一个移民，两年前我决定把自己的生活收拾到一个行李箱，并购外了单程机票。在过去的两年里，我在两个不同的国家生活过，并花时间学习当地的语言。</p>
<p>我必须要承认，三年前我根本不懂英语，然而，三个月前，我成功地完成我的硕士课程，并且现在我可以和英语母语者进行有效的沟通。</p>
<p>我花了一年的时间学习和练习，使我的英语从初级到B2水平。这并不容易，但我认为如果当时有ChatGPT的话，应该会变得容易。ChatGPT可以成为语言学习者自学的一个有效工具。</p>
<p>下面是我如何使用ChatGPT来学习和练习一种新的语言。</p>
<h2 id="1-Use-ChatGPT-as-a-language-partner-Simulate-a-real-conversation"><a href="#1-Use-ChatGPT-as-a-language-partner-Simulate-a-real-conversation" class="headerlink" title="1. Use ChatGPT as a language partner: Simulate a real conversation"></a>1. Use ChatGPT as a language partner: Simulate a real conversation</h2><p>ChatGPT可以成为你的语言伙伴，在你需要练习的时候与你聊天。</p>
<p>使用ChatGPT与你进行对话，需使用下面的提示。</p>
<blockquote>
<p>Act as a language partner. You’ll start a conversation with me about [topic] in [language]. In every response, you should provide your opinion and then ask me a question to keep the conversation going.</p>
</blockquote>
<p>我试着用“football”和”西班牙语”来进行提示。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DznstT0MrB1WVGThkGxAmw.png"></p>
<p>正如你说看到的，ChatGPT给出了自己的意见，并向我提出了一个新问题，这就形成了一种互动式的思想交流和思考。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_IKImgiCyz8vnyneWfnkXw.png"></p>
<p>你可以用ChatGPT练习任何语言。现在我打算练习我的德语。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dExTgF08UURkOI18cSy8yQ.png"></p>
<p>这可以帮助你练习你学过的语法规则和词汇。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QY4Nw2q9Fo4F9FDh6z1wAw.png"></p>
<p>当然，与真人对比，ChatGPT参与对话的能力是有限的。尽管如此，它仍然是一个很好的语言伙伴!</p>
<h2 id="2-Using-ChatGPT-to-learn-grammar-rules-and-improve-your-writing"><a href="#2-Using-ChatGPT-to-learn-grammar-rules-and-improve-your-writing" class="headerlink" title="2. Using ChatGPT to learn grammar rules and improve your writing"></a>2. Using ChatGPT to learn grammar rules and improve your writing</h2><p>ChatGPT可以帮助你以一种简单的方式理解语法规则。</p>
<p>例如，我问chatGPT关于德语中两个动词（一个是现在完成时，另一个是过去完成时）之间的区别。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b45NMA8MSS_ES6umAcKigw.png"></p>
<p>上面的解释只是对动词时态的基本描述。但是，你也可以通过ChatGPT提供的例子和更多语法规则的细节来理解所学的概念以及如何在不同的语境中使用它们。</p>
<p>另外ChatGPT可以帮助你纠正错误。</p>
<p>ChatGPT可以纠正你的语法和拼写错误，并为你提供一些额外的信息，解释为什么出错以及如何修改。这对于自学的人来说特别有用，因为没有人检查他们的写作。</p>
<p>下面是我要求ChatGPT纠正我用德语写的一封邮件。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kui474LjnsZS5sVhew4WwQ.png"></p>
<p>默认情况下，ChatGPT的修改更加正式。如果你明确指定这封信是给谁，它可以调整语气。我告诉ChatGPT这封信是给一个朋友的，以下是它的回答。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAV5sACcIAyeGFniknB-mQ.png"></p>
<p>你也可以明确地要求ChatGPT让内容更加正式。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqXuoOSQKCMOiOsnN8vE0w.png"></p>
<p>正式的语言应在学术背景下使用，以及与陌生人或者比我们年长的人交谈时使用，而非正式语言可以与朋友使用。</p>
<p>现在，我要求ChatGPT让内容不那么正式，以便我找到一些差异性来学习新词。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2X9gVncvJOPNWwCNrCHYw.png"></p>
<p>现在是尝试编写邮件和论文的时候了。</p>
<h2 id="3-Use-ChatGPT-to-improve-your-vocabulary-and-reading-skills"><a href="#3-Use-ChatGPT-to-improve-your-vocabulary-and-reading-skills" class="headerlink" title="3. Use ChatGPT to improve your vocabulary and reading skills"></a>3. Use ChatGPT to improve your vocabulary and reading skills</h2><p>通常情况下，当你根据教科书学习时，你的学习内容会被限制到所提供的一组文本和词汇中。这些教材通常由一个或两个关于特定主题的内容组成，有时就会很枯燥。</p>
<p>有时你会花费很多时间在网上搜索合适的文本，但有了ChatGPT，你可以在几秒内快速生成任何级别和主题的内容，来节省你的时间和精力。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*De2NMiGblHWpc5V_EoiOiQ.png"></p>
<p>Okay! 上面这个故事没有太多的悬念，情节也很直白，但是它仍然提供了阅读材料。</p>
<p>另外，其中的一些词汇和短语可能不是真正的”简单”，但你仍然可以用这个故事进行练习。现在，让我们用它创建一个具有挑战性的单词列表，并提供它们的英文翻译：</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ew9f5o55-OHKf4wAe96PfQ.png"></p>
<p>Awesome!</p>
<p>你也可以要求ChatGPT继续写故事，只需要说”continue”，也可以要求将整个文本翻译成英文，甚至要求它为这些故事生成简单的理解性问题。</p>
<h2 id="4-Use-ChatGPT-to-improve-your-pronunciation"><a href="#4-Use-ChatGPT-to-improve-your-pronunciation" class="headerlink" title="4. Use ChatGPT to improve your pronunciation"></a>4. Use ChatGPT to improve your pronunciation</h2><p>ChatGPT不能使用音频，单它可以提供任何你感兴趣的单词的音译。</p>
<p>这个过程很简单，你只需要使用下面的提示。</p>
<blockquote>
<p>Create a table with 2 columns: In the first column type the [language] words: [word1, word2, …]. In the second column, you should provide the phonetic transcription.</p>
</blockquote>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zokSmgDZZkbAMUIzIdHq6w.png"></p>
<p>这个音标是以 International Phonetic Alphabet (IPA) 的形式给出，很利于你的发音练习!</p>
<h2 id="5-Use-ChatGPT-to-understand-different-dialects"><a href="#5-Use-ChatGPT-to-understand-different-dialects" class="headerlink" title="5. Use ChatGPT to understand different dialects"></a>5. Use ChatGPT to understand different dialects</h2><p>正如你所知道的，一些英语单词会根据不同的国家而发生变化。</p>
<p>这种情况也发生在其他语言上，如德语。</p>
<p>我学的是”high German”，原汁原味，未受方言影响。然而，在奥地利、德国或瑞士的一些地区，方言和词汇是不同的。现在，我可以向ChatGPT询问一个新词和它在特定方言中的对应词。</p>
<p>下面有个例子。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cX0x0lpVJh0iRj72CvpMBg.png"></p>
<h2 id="So-can-you-learn-a-language-with-ChatGPT"><a href="#So-can-you-learn-a-language-with-ChatGPT" class="headerlink" title="So can you learn a language with ChatGPT?"></a>So can you learn a language with ChatGPT?</h2><p>在这篇文章中，我们已经看到ChatGPT可以成为学习语言的一个有用工具。</p>
<p>作为一个人工智能语言模型，ChatGPT具有在特定语言上生成文本的能力，可以帮助人们提升词汇、写作和口语技能。也可以用来检查你的语法和拼写错误。</p>
<p>最后，要记住，它不能代替人与人之间的沟通或正式的语言学习计划，最好是将其作为其他学习资源的补充。另外始终要与语言老师或母语人士核实ChatGPT生成的信息。</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>AI</tag>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Bias in AI is a mirror of our culture</title>
    <url>/2023/07/29/%E3%80%90%E7%BF%BB%E3%80%91Bias-in-AI-is-a-mirror-of-our-culture/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://uxdesign.cc/bias-in-ai-is-a-mirror-of-our-culture-3607bd795c57">Bias in AI is a mirror of our culture</a><br>原作者：<a href="https://medium.com/@arvindsanjeev">Arvind Sanjeev</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://miro.medium.com/v2/resize:fit:1400/1*ZQAjJr41_3iLqVKCfmyKGg.gif"></p>
<p>在今天的生活中，人类更多的是与 AI 模型互动，而非人类。无论是在 Youtube 和 Netflix 上进行娱乐活动，还是在 Instagram 和 TikTok 上寻找灵感，在 Tinder 和 Hinge 上寻找 朋友， AI 模型都会决定我们应该与哪些人类和内容互动。AI 模型已经在不知不觉地控制着我们的生活。</p>
<p>我们把决策权交给了算法，现在它们可以决定哪些人可以获得住房或医疗保险，谁会被雇佣或者被大学录取，我们的信用评分等等。人们希望通过公式将人类的看法剔除，使机器能够做出公平公正的决定，然而，训练这些模型的数据就是来自于一个从根本上存在偏见的社会；要完全消除这些偏见是不可能的。AI 只是将它们又反射给我们。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/59bMh59JQDo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<h2 id="Algorithmic-racism"><a href="#Algorithmic-racism" class="headerlink" title="Algorithmic racism"></a>Algorithmic racism</h2><p><strong>种族歧视算法正在把人们送进监狱。</strong></p>
<p><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*CbF68Ttsv7AItzxNs_S0LA.png"></p>
<p>在2015年，Media Lab 的 Joy Buolamwini 发现，当时所有的人脸识别算法(来自 IBM 、 Microsoft 等公司)都无法检测到她的脸，因为她是一个黑人女性。然而，当她<a href="https://artsandculture.google.com/story/BQWBaNKAVWQPJg?hl=en">带上白色面罩</a>时，这些算法又能看到她了。她注意到，在分析黑人女性和白人男性时，误差达到35%。我们过去还有许多其他的例子：</p>
<ul>
<li>在2015年，谷歌的图像标记算法把<a href="https://www.theverge.com/2015/7/1/8880363/google-apologizes-photos-app-tags-two-black-people-gorillas">一对黑人朋友标为“大猩猩”</a></li>
<li>Flicker 的系统也犯了<a href="https://petapixel.com/2015/05/20/flickr-fixing-racist-auto-tagging-feature-after-black-man-mislabeled-ape/">同样的错误</a>，用“动物”和“猿猴”标记了一个黑人。</li>
<li>Nikon 的相机可以检测一个人是否持续眨眼，但它却告诉一位亚洲用户<a href="https://content.time.com/time/business/article/0,8599,1954643,00.html">她的眼睛是闭着的</a></li>
<li>HP 的网络摄像头在2009年可以轻松追踪到白人的脸，但却<a href="https://gizmodo.com/hp-face-tracking-webcams-dont-recognize-black-people-5431190">看不到黑人的脸</a></li>
</ul>
<iframe width="560" height="315" src="https://www.youtube.com/embed/t4DT3tQqgRM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<blockquote>
<p>“We will not solve the problems of the present with the tools of the past. The past is a very racist place. And we only have data from the past to train Artificial Intelligence.”<br>— Trevor Paglen, artist and critical geographer</p>
</blockquote>
<p>有偏见的人脸识别算法甚至错误地将黑人男子逮捕并送进监狱。以下是美国执法人员使用种族歧视决策工具的两个例子：</p>
<ul>
<li><a href="https://www.propublica.org/article/how-we-analyzed-the-compas-recidivism-algorithm">COMPAS</a>：美国法官和假释官使用的一种累犯预测软件，用于确定刑事被告的风险程度，进而影响他们的量刑。该算法不公平地将黑人和西班牙裔人归类为比其他人更危险的人。</li>
</ul>
<p><img src="https://miro.medium.com/v2/format:webp/1*jLw2AcMjDVAJ52em6SD6Pg.png"></p>
<ul>
<li><a href="https://predpol.com/">PrePol</a>: Predictive Policing 是一种“少数民族报告”式的犯罪预测软件，由警方用来确定哪些社区应该比其他社区进行更多的巡逻。由于这种有偏见的算法，黑人社区总是受到更多的巡逻和骚扰。</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DMptJ7Eo9CG3XedP.png"></p>
<blockquote>
<p>Black men are six times more likely to be incarcerated by police than white men and 21 times more likely to be killed by them.<br>— Cathy O Neil, Weapons of Math Destruction</p>
</blockquote>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">This is a damn trap <a href="https://t.co/UssHF5MtNk">pic.twitter.com/UssHF5MtNk</a></p>&mdash; Saturday Night Live - SNL (@nbcsnl) <a href="https://twitter.com/nbcsnl/status/1502873834029989889?ref_src=twsrc%5Etfw">March 13, 2022</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="Gender-bias"><a href="#Gender-bias" class="headerlink" title="Gender bias"></a>Gender bias</h2><p><strong>Binary algorithms 加强了刻板印象</strong></p>
<p>Subspring 是有史以来第一个由 AI 创作的短片。Oscar Sharp用科幻电影脚本训练模型，创造出这部作品。2021年，当他尝试用动作电影剧本训练模型做类似的事情时却大吃一惊。因为他注意到，所有生成的故事都只有一个稳重的男性角色，而唯一的女性角色(恋爱对象)在整个故事中都只是被称为”女朋友”</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/sv6ew4EWRiQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p>OpenAI的研究员发现了在自己的软件上描述男性和女性时产生的十大有偏见的词汇。对于男性来说，”large”、”mostly”、”lazy”、”fantastic “和 “eccentric “是最多的词汇。而对于女性来说，则是 “optimistic”、”bubbly”、”naughty”、”easy-going “和 “petite”。研究员写道：“我们发现，女性更常用以外表为导向的词汇描述自己”</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Machine learning models learn the biases back in data and reflect them back to us<br><br>Hungarians have no gendered pronouns but apparently, Google Translate has learnt all the gender stereotypes! 😱😱 <a href="https://t.co/Hi0r62PMpF">pic.twitter.com/Hi0r62PMpF</a></p>&mdash; Bindu Reddy (@bindureddy) <a href="https://twitter.com/bindureddy/status/1450317088271126529?ref_src=twsrc%5Etfw">October 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<h2 id="Transphobic-algorithms"><a href="#Transphobic-algorithms" class="headerlink" title="Transphobic algorithms"></a>Transphobic algorithms</h2><p><strong>我们已经生活在一个性别歧视的世界里，但 AI 让情况变得更糟糕。</strong></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAQr-ApTrxwBugIpd-Wmgg.png"></p>
<p>Automatic Gender Recognition(AGR)是 transphobic algorithms 的最佳示例。AGR广泛用于机场、商场等公共场所。当算法无法标记 non-binary 人的性别时，就会给他们带来很多羞辱和不适，从而引起他们更多的警觉和关注。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*Sejw17f93q7ItFEd1zH07A.png"></p>
<blockquote>
<p>“Every trans person you talk to has a TSA horror story. The best you can hope for is just to be humiliated; at worst, you are going to be harassed, detained, subjected to very invasive screenings, etc. Trans people or gender non-conforming people who have a multi-racial or Middle Eastern descent are most probable to have a negative airport security incident.”<br>— Kelsey Campbell, Founder Gayta Science</p>
</blockquote>
<p>了解更多 transphobic algorithms:</p>
<ul>
<li><a href="https://edition.cnn.com/2019/11/21/tech/ai-gender-recognition-problem/index.html">AI software defines people as male or female. That’s a problem</a>。作者：Rachel Metz, CNN</li>
<li><a href="https://venturebeat.com/ai/a-transgender-ai-researchers-nightmare-scenarios-for-facial-recognition-software/">A transgender AI researcher’s nightmare scenarios for facial recognition software</a>，作者：Khari Johnson，VentureBeat</li>
<li><a href="https://reallifemag.com/counting-the-countless/">Counting the Countless</a>，作者：Os Keyes, Real life mag</li>
</ul>
<h2 id="Biased-hiring-algorithms"><a href="#Biased-hiring-algorithms" class="headerlink" title="Biased hiring algorithms"></a>Biased hiring algorithms</h2><p>如果你是一个叫 Jared 的白人，在高中打过曲棍球，你就能得到这份工作！</p>
<p>使用 AI-powered 简历筛选工具的灵感来自于<a href="https://en.wikipedia.org/wiki/Blind_audition">盲选</a>，即乐团在封闭帷幕后选择音乐家。这可以让他们忽略艺术家的性别、种族、声誉等因素。然而，大多数招聘算法不可避免地会<a href="https://hbr.org/2019/05/all-the-ways-hiring-algorithms-can-introduce-bias">产生偏见</a>。</p>
<p>Amazon就是一个例子；他们的招聘和解雇算法都臭名昭著。他们的<a href="https://qz.com/1427621/companies-are-on-the-hook-if-their-hiring-algorithms-are-biased">招聘算法偏爱白人男性</a>，而不是其他人群，而解雇算法则会在没有明确理由或者根本没有人为监督的情况下<a href="https://www.bloomberg.com/news/features/2021-06-28/fired-by-bot-amazon-turns-to-machine-managers-and-workers-are-losing-out">解雇工厂工人</a>。</p>
<blockquote>
<p>After the company trained the algorithm on 10 years of its own hiring data, the algorithm reportedly became biased against female applicants. The word “women,” like in women’s sports, would cause the algorithm to specifically rank applicants lower.<br>— Companies are on the hook if their hiring algorithms are biased, QZ</p>
</blockquote>
<h2 id="Who’s-fighting-back"><a href="#Who’s-fighting-back" class="headerlink" title="Who’s fighting back?"></a>Who’s fighting back?</h2><p>AI 审计是最广为接受的减少偏见的技术之一。这个框架被广泛用于确定AI模型是否存在偏见、歧视或其他没发现的偏见。像Meta和Microsoft这种公司已经拥有内部审计团队来分析这些模型，但外部机构如ORCAA、ProPublica、NIST等机构也在进行审计。AJL（Algorithmic Justice League）的论文《Who audits the auditors》详细描述了AI审计生态系统的情况。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/uaRKNGvQ4Pw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p>以下是一些减少AI偏见的其他例子：</p>
<ul>
<li><a href="https://nvlpubs.nist.gov/NISTpubs/SpecialPublications/NIST.SP.1270.pdf">Standards for Identifying and Managing Bias in Artificial Intelligence</a>：NIST制定的guideline，用于支持可信和负责性的AI发展</li>
<li><a href="https://arxiv.org/abs/1710.06921">Themis</a>：一款审计软件，用于设计出算法中的偏差，揭露出AI模型中隐藏的不平衡。</li>
<li><a href="https://huggingface.co/spaces/society-ethics/DiffusionBiasExplorer">Diffusion bias explorer</a>：来自HuggingFace的Sasha Luccioni的项目，揭示了Stable Diffusion中的隐藏偏见。</li>
<li>The <a href="https://webtap.princeton.edu/">Princeton web accountability and transparency</a> project：这是一个利用机器人在网络上伪装成黑人、亚洲人、穷人、女性或跨性别者，并尝试在未被代表的数据集中代表这些少数群体的项目。</li>
<li><a href="https://uxdesign.cc/bias-in-ai-is-a-mirror-of-our-culture-3607bd795c57">Feminist dataset</a>: 这个项目让社区参与创建数据集，以实现数据收集的透明方法。</li>
<li><a href="https://www.ellpha.com/">Ellpha</a>：这个项目旨在创建性别平衡的数据集，使其能够真实地代表现实世界。</li>
<li><a href="https://www.queerinai.com/">Queer in AI</a>：提高在 AI&#x2F;ML 领域同性恋问题的认识，培养同性恋研究人员和科学家群体。</li>
<li><a href="https://www.gaytascience.com/">Gayta science</a>：利用数据科学技术捕捉、结合和提取见解，为LGBTQ+群体的经历赋予表达声音的机会。</li>
<li>Q：这是第一款自称雌雄同体的人的声音训练的无性别语音助手。这些声音的频率范围在145赫兹到175赫兹之间，正好位于男性和女性的声音范围之间的甜蜜点。</li>
</ul>
<iframe width="560" height="315" src="https://www.youtube.com/embed/lvv6zYOQqm0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p>有偏见的算法被用作掩盖不公平做法和裁决少数群体的工具。通过以上的例子，希望你可以开始对 AI 所做的决策产生质疑。所以，下次当有人说这是一个由客观机器做出的公正决定时，就不会成为对话的终结者；相反，它会引起关于 AI 中偏见的全新讨论。</p>
<blockquote>
<p>High-tech tools have a built-in authority and patina of objectivity that often lead us to believe that their decisions are less discriminatory than those made by humans. But bias is introduced through programming choices, data selection, and performance metrics. It redefines social work as information processing, and then replaces social workers with computers. Humans that remain become extensions of algorithms.<br>— Virginia Eubanks, Automating Inequality</p>
</blockquote>
<p>有关此主题及其他主题的更多资源，请查阅本手册<a href="https://arvindsanjeev.notion.site/arvindsanjeev/The-Handbook-of-AI-s-Unintended-Consequences-720cda3d8cec49dc88807641157a0bba">《AI’s unintended consequences》</a>。本文是探讨 <a href="https://medium.com/@arvindsanjeev/ai-sociopaths-and-their-unintended-consequences-bf6f19012e4f">unintended consequences of AI 四部系列文章</a>中的第二章</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】I Used ChatGPT (Every Day) for 5 Months. Here Are Some Hidden Gems That Will Change Your Life</title>
    <url>/2023/06/23/%E3%80%90%E7%BF%BB%E3%80%91I-Used-ChatGPT-Every-Day-for-5-Months-Here-Are-Some-Hidden-Gems-That-Will-Change-Your-Life/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://artificialcorner.com/i-used-chatgpt-every-day-for-5-months-here-are-some-hidden-gems-that-will-change-your-life-a451e2093097">I Used ChatGPT (Every Day) for 5 Months. Here Are Some Hidden Gems That Will Change Your Life</a><br>原作者：<a href="https://dianatheathlete.medium.com/">Diana Dovgopol</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_DpPoH6_DMbQeAqTIL0Lw.png"></p>
<p>随着ChatGPT越来越受欢迎，许多人已经习惯了它的标准功能，并且以各种方式开始使用它。然而，许多人并没有意思到，这种AI除了输入文字之外还有很多高级的功能。</p>
<p>ChatGPT有许多功能都可以应用到你的工作和生活中</p>
<p>在这篇文章中，我会和你分享ChatGPT的一些鲜为人知和非标准的功能。通过探索这些隐藏的功能，你可以解锁这个AI的全部潜力，并为你带来好处。</p>
<p>废话不多说，让我们深入了解吧!</p>
<h2 id="1-Summarize-videos-articles-papers-and-posts"><a href="#1-Summarize-videos-articles-papers-and-posts" class="headerlink" title="1. Summarize videos, articles, papers and posts"></a>1. Summarize videos, articles, papers and posts</h2><p>ChatGPT最好的功能之一是为我节省了阅读在线内容的时间。</p>
<p>在过去，我为了找到某些信息，不得不阅读浏览大量无聊的科研文章，但现在ChatGPT可以在几秒内帮我做到这一点。此外，它甚至可以将内容在不到一分钟的时间内翻译成另一种语言。</p>
<p>下面是它的工作原理(注意，你需要启动这些<a href="https://artificialcorner.com/i-tried-84-chatgpt-plugins-these-are-the-best-3b3be6b1cb7b">ChatGPT插件</a>)</p>
<ol>
<li>查找视频&#x2F;文章&#x2F;paper&#x2F;帖子</li>
<li>复制链接</li>
<li>让ChatGPT给你总结</li>
</ol>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-EaO0tq2vum7kOY-zZ6Ew.png"></p>
<p>这个功能对我非常有帮助。我发现的唯一缺点就是不能阅读PDF格式的科研文章。也就是说，当需要总结网站的纯文本内容时，它可以做的很好。</p>
<p>注意：现在你可以用新的ChatGPT插件”Ask Your PDF”来总结PDF格式内容。需要了解更多，<a href="https://artificialcorner.com/i-tried-84-chatgpt-plugins-these-are-the-best-3b3be6b1cb7b">可以查看这篇文章</a></p>
<h2 id="2-Scan-and-Describe-Images-with-ChatGPT"><a href="#2-Scan-and-Describe-Images-with-ChatGPT" class="headerlink" title="2. Scan and Describe Images with ChatGPT"></a>2. Scan and Describe Images with ChatGPT</h2><p>我最近发现了一个对我非常有用的功能，我认为分享给你会很有帮助 – 通过ChatGPT扫描图像。</p>
<p>这让我想起了我的学生时代为了逻辑测试努力描述图像的场景。那时候，我还没有ChatGPT，但现在我可以用AI来简化这个对我有挑战性的任务。</p>
<p>下面是他的工作原理。</p>
<ol>
<li>在网上找到所需的图像。在下面的例子中，我将使用膝盖的解剖学图像。</li>
</ol>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4AktKGovcnBk9kvHasWsuw.png"></p>
<ol start="2">
<li>在一个单独的浏览器标签中打开图片，确保该标签中只有图片是可见的。然后在浏览器的地址栏中复制URL，如下图的截图所示。</li>
</ol>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4aseBnUcCKleu7G5Z8m0w.png"></p>
<ol start="3">
<li>请ChatGPT为你描述图像。</li>
</ol>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86A4gAjfLh_piWUVAOoZCQ.png"></p>
<p>然后就欣赏ChatGPT带来的详细描述!</p>
<p>ChatGPT也有为各种可视化图像提供描述的能力。下面是一张左上角有图例的地图。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYLG-ZHeF47BRqvHtu79qw.png"></p>
<p>下面是我从ChatGPT中得到的描述。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0ZqwbUi06tN3wpzElhsDQ.png"></p>
<p>但是这还不是全部！ChatGPT可以描述很多东西，从艺术品到科学图解。</p>
<p>注意：显然ChatGPT(GPT-3.5)并没有真正扫描图片，而是利用了链接中的关键词来描述图片。也就是说，你可以尝试使用ChatGPT插件 Link Reader，正如<a href="https://artificialcorner.com/i-tried-84-chatgpt-plugins-these-are-the-best-3b3be6b1cb7b">这篇文章</a>所解释的。</p>
<h2 id="3-Use-ChatGPT-as-your-private-teacher"><a href="#3-Use-ChatGPT-as-your-private-teacher" class="headerlink" title="3. Use ChatGPT as your private teacher"></a>3. Use ChatGPT as your private teacher</h2><p>我每天都在使用这个功能，他对我来说是一个真正的游戏规则改变者。他使我的生活变得轻松，并为我节省了大量的时间和金钱。</p>
<p>我把ChatGPT变成了我的语言私教。以下是ChatGPT<a href="https://artificialcorner.com/how-to-use-chatgpt-to-learn-a-language-and-practice-it-f7e7e38b1cee">如何帮助我学习外语的</a>。</p>
<ul>
<li>用ChatGPT检查我的语法</li>
<li>用ChatGPT把单词和短语翻译成不同的语言</li>
<li>用ChatGPT帮我练习写作和语言能力，并且我可以得到实时反馈</li>
</ul>
<p>但ChatGPT不是只能帮助你语言学习。它还帮助我学习其他科目，比如数学。</p>
<p>当我在学校的时候，我学习数学时很困难，发现它很难理解，同时不幸的是，我学校的老师并没有很好的帮我解释，因此我没有取得什么进展。</p>
<p>然而，多亏了ChatGPT，我现在可以在任何数学题上得到我想要的解释。我可以要求ChatGPT逐步的说明如何解决一个问题。它甚至可以提供多种解题方案。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JlrY_S5I_x6k2ppDWTTdzQ.png"></p>
<p>此外，我还可以让ChatGPT为我解释如何得到正确的答案。这很神奇，你不觉得吗？</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WuVx0ikJM0ZnfpSPUSSHFA.png"></p>
<p>你可以对任何感兴趣的学科进行提问，而且解释是易于理解的语言编写的，任何人都可以理解</p>
<h2 id="4-Ask-ChatGPT-for-advice"><a href="#4-Ask-ChatGPT-for-advice" class="headerlink" title="4. Ask ChatGPT for advice"></a>4. Ask ChatGPT for advice</h2><p>这个功能不会取代你的朋友或心理医生，但它可以帮助你找到问题的解决办法。</p>
<h3 id="Life-advice"><a href="#Life-advice" class="headerlink" title="Life advice"></a>Life advice</h3><p><a href="https://dianatheathlete.medium.com/the-athletes-15-minute-night-routine-to-maximize-performance-in-your-mornings-cc2cc60630fd">早上早起对我来说一直是一个挑战</a>，即使我睡得很早，所以我决定向ChatGPT询问一些这方面的技巧</p>
<p>以下是它的建议。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NXBMBAKdRSLXu9aK4M0VQ.png"></p>
<p>第4点和第6点对我很有帮助。</p>
<p>你可以对你生活的不同方面进行询问。比如你在工作中遇到一个态度傲慢无礼的同事。在这种情况下，以下是ChatGPT的建议。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNpBJ8-sI06MIHCHn7kO8A.png"></p>
<p>这类似于一个朋友对你的推荐。</p>
<p>当然，它不能取代全面的沟通、与情境相关的笑话或原创的建议，但当你需要迅速做出决策或想要考虑多个解决问题的选项时，它可以非常有用。</p>
<p>你提供的细节越多，得到的答案就更好。</p>
<h3 id="Health-Advice"><a href="#Health-Advice" class="headerlink" title="Health Advice"></a>Health Advice</h3><p>过去，我需要在互联网上搜索计算我的卡路里需求，或者完全依靠营养师制定具体的膳食计划；然而，现在ChatGPT可以帮我提供这些信息，来为我节省一些时间和金钱。</p>
<p>我可以要求ChatGPT根据我的体重、身高、性别、身体活动和期望的减肥目标来计算我的卡路里需求。</p>
<blockquote>
<p>Prompt: “Calculate my calorie requirement. I am a girl, 24 years old, my weight is 55kg and I am 166cm, I do workouts 3 times a week and would like to lose 3kg”.</p>
</blockquote>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbk0z6IoPJYe6NArzQNo6w.png"></p>
<p>这个答案相当棒，因为我在大学学习期间与教授讨论时也有类似的想法。如果要准确地计算出你每天所需的卡路里，需要考虑几个因素，如年龄、性别、体重、身高、活动水平和减肥目标。</p>
<p>当然，为了获得尽可能准确的答案，在输入所需的细节时，必须提供尽可能多的信息。</p>
<p>我还把ChatGPT变成了我的营养师。</p>
<blockquote>
<p>Prompt: “Can you write down a menu with a daily deficit of 500–1000 calories?”</p>
</blockquote>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PLaS4RAu9cQdDHMTDnUCNw.png"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1007-VbqdYig52kUgZlbWQ.png"></p>
<p>我得到了一份适合我日常饮食的食物清单。你甚至可以要求提供一整周或更长时间的菜单，告诉ChatGPT你喜欢或不喜欢吃什么。这超级简单!</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJ9Al1D6DOOVt4yfoAPzwQ.png"></p>
<p>*免责声明：你不能100%依赖ChatGPT的回复，而是要把它作为一个助手，不是作为健康建议的替代品。这篇文章仅供参考，不应视为健康建议。</p>
<h2 id="Artificial-Corner’s-Free-ChatGPT-Cheat-Sheet"><a href="#Artificial-Corner’s-Free-ChatGPT-Cheat-Sheet" class="headerlink" title="Artificial Corner’s Free ChatGPT Cheat Sheet"></a>Artificial Corner’s Free ChatGPT Cheat Sheet</h2><p>We’re offering a free cheat sheet to our readers. <a href="https://frankandrade.ck.page/08c94cf1c1">Join our newsletter with 20K+ people and get our free ChatGPT cheat sheet</a>.</p>
<p>Loved this story and want to support me as a writer? Consider signing up for Medium. If you <a href="https://dianatheathlete.medium.com/membership">sign up with my link</a>, I earn a small commission at no cost to you! And you’ll get full access to all stories on Medium.</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>AI</tag>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Indistinguishable AI content is crippling our perception</title>
    <url>/2023/07/21/%E3%80%90%E7%BF%BB%E3%80%91Indistinguishable-AI-content-is-crippling-our-perception/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://uxdesign.cc/indistinguishable-ai-content-is-crippling-our-perception-f2b24c7cd311">Indistinguishable AI content is crippling our perception</a><br>原作者：<a href="https://medium.com/@arvindsanjeev">Arvind Sanjeev</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://miro.medium.com/v2/resize:fit:1400/1*JzBgspzi8LOngxpNKCiX8Q.gif"></p>
<p>在2020年，一名大学生 Liam Porr 利用 <a href="https://www.technologyreview.com/2020/08/14/1006780/ai-gpt-3-fake-blog-reached-top-of-hacker-news/">GPT-3创建了一个假的博客</a>，并登上了 hacker news 的榜单第一。他通过使用假名 “adolos”, 生成 productivity 和 self-help 相关主题的内容，几乎不用编辑就进行发布。然后社区论坛中的读者不知道这是一个AI生成的博客，对其进行投票，Liam 后来承认，这是实验的一部分，目的是看看GPT-3是否能冒充人类作家。这并不是第一次用AI取代人类作家；《LA Times》从2014年起就开始<a href="https://www.bbc.com/news/technology-26614051">使用机器人编写新闻文章</a>。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCs1KwkiDFBbQf8ubKowJA.png"></p>
<ul>
<li>你能从这两张图片中分辨出AI生成的婴儿吗？(答案在页面底部)</li>
</ul>
<blockquote>
<p>到2025年或2030年，互联网上会有90%的内容都是自动生成的，自动生成的内容会大大增加可用内容的数量<br>— Nina Shick, Deep Fakes and the Infocalypse</p>
</blockquote>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gTJnlZtrPgMmNPieO1Q2Tw.png"></p>
<p>如今，DeepFaceLab 等工具可以让任何人制作政治候选人的视频并在网上传播，Disrupt 可以让你模仿任何人的声音，GPT 可以让你编写假新闻；这些工具加在一起就可以成为一个假新闻发布机器。现在，一个人只要掌握了这些机器就可以直接单独破环现实世界。 – 操纵选举，散播虚假宣传，伪造虚假色情视频，制造阴谋论等。</p>
<h2 id="Volatile-democracy"><a href="#Volatile-democracy" class="headerlink" title="Volatile democracy"></a>Volatile democracy</h2><p><strong>政客们害怕 Deepfake，因为它们可以很容易被用于操纵选举结果。</strong></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/X17yrEV5sl4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p>2022年3月，在Facebook 和 Youtube 上出现了一段<a href="https://www.wired.com/story/zelensky-deepfake-facebook-twitter-playbook/">伪造的 Volodymyr Zelensky 视频</a>，在这个视频中，他宣布对俄罗斯的入侵投降，并要求乌克兰军队放下武器。不过，这段视频并不令人相信。他的上半身一动不动，语气也有所不同。但对于没有经历过的人来说，这足以造成困惑和恐慌。这是 Deepfake 首次在武装冲突中被用作武器。</p>
<blockquote>
<p>“Democracies appear to be gravely threatened by the speed at which disinformation can be created and spread via social media, where the incentive to share the most sensationalist content outweighs the incentive to perform the tiresome work of verification.”<br>Source: <a href="https://www.theguardian.com/technology/ng-interactive/2019/jun/22/the-rise-of-the-deepfake-and-the-threat-to-democracy">Politicians fear this like fire</a>, The Guardian</p>
</blockquote>
<p>假新闻过去曾被用来影响<a href="https://news.stanford.edu/2017/01/18/stanford-study-examines-fake-news-2016-presidential-election/">美国大选</a>，而随着新的生成式AI工具出现，它变得更加容易。</p>
<h2 id="DeepFake-porn"><a href="#DeepFake-porn" class="headerlink" title="DeepFake porn"></a>DeepFake porn</h2><p><strong>色情报复已经被推向一个全新的层次。</strong></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*OhWBGf1BTwDzjyJz.gif"></p>
<p>在之前的<a href="https://medium.com/@arvindsanjeev/ai-sociopaths-and-their-unintended-consequences-bf6f19012e4f">介绍文章</a>中，我分享了 Rana 的故事，她是一个印度的调查记者，她的对手通过<a href="https://www.huffingtonpost.co.uk/entry/deepfake-porn_uk_5bf2c126e4b0f32bd58ba316"> deepfake 色情活动</a>对她进行了攻击。与她的故事类似，网上也有很多关于<a href="https://vimeo.com/492572852">女性的采访</a>，她们站出来分享了 deepfake 工具是如何针对她们并制作诽谤视频。色情报复已经上升到了另一个高度，如今任何人都可以使用你的一张照片去生成一些视频然后发到网上。据研究公司 Sensity AI 估计，90%到95%的在线 deepfake 视频都是未经同意的色情视频，其中90%以女性为主角。这些工具大多已被禁止，政府和执法机构仍在努力追赶和遏制这种使用行为。</p>
<p>MIT Technology Review 的 Karen Hao 对这个话题进行了有力的报道：</p>
<ul>
<li><a href="https://www.technologyreview.com/2021/09/13/1035449/ai-deepfake-app-face-swaps-women-into-porn/">A horrifying new AI app swaps women into porn videos with a click</a></li>
<li><a href="https://www.technologyreview.com/2019/06/28/134352/an-ai-app-that-undressed-women-shows-how-deepfakes-harm-the-most-vulnerable/">An AI app that “undressed” women shows how deepfakes harm the most vulnerable</a></li>
<li><a href="https://www.technologyreview.com/2020/10/20/1010789/ai-deepfake-bot-undresses-women-and-underage-girls/">A deepfake bot is being used to “undress” underage girls</a></li>
<li><a href="https://www.technologyreview.com/2021/02/12/1018222/deepfake-revenge-porn-coming-ban/">Deepfake porn is ruining women’s lives. Now the law may finally ban it</a></li>
</ul>
<h2 id="Bringing-the-dead-back-to-life"><a href="#Bringing-the-dead-back-to-life" class="headerlink" title="Bringing the dead back to life"></a>Bringing the dead back to life</h2><p><strong>Chatbots 和 deepfake 模仿你已故的亲人</strong></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*jMW-J7oZYG9HnVOvUwaqLQ.gif"></p>
<p>像 Microsoft 和 Amazon 等公司正在竞相将死者复活。就像《黑镜》中一样，公司会利用我们<a href="https://www.vice.com/en/article/bvmqbv/founder-youll-soon-be-able-to-talk-to-your-dead-mom-in-the-metaverse-thanks-to-chatgpt">已故亲人的数据去训练chatbots</a>。亚马逊的一段视频展示了Alexa如何表现出一个孩子已故祖母的声音，并给他讲故事：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/22cb24-sGhg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p>Somnium Space 是一家构建虚拟世界的VR 公司，它提供了一种<a href="https://www.vice.com/en/article/pkp47y/metaverse-company-to-offer-immortality-through-live-forever-mode">永生模式</a>。通过这种模式，即使你死了，人们也可以根据你之前收集的数据继续与你的化身互动。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ihEEjwRlghQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p>另一个例子是纪录片《Roadrunner》，该片讲述了去世的著名厨师 Anthony Bourdain 的生平。纪录片中的画外音是由根据 Anthony 的声音训练出来的AI model 完成的；然而，<a href="https://www.washingtonpost.com/arts-entertainment/2021/07/16/anthony-bourdain-documentary-ai-deepfake/">他的遗孀和家人并不满意</a>。这就引发了一场关于“谁能控制逝者数据”的大讨论。<a href="https://www.reuters.com/article/us-britain-dataprotection-privacy-analys-idUSKCN1Q304F">大多数国家的数字往生政策</a>允许亲属在提出申请后访问这些数据。但大数据公司是否可以继续使用这些数据来训练 AI ，目前还不清楚；如果无人认领，也没有法律规定谁拥有这些数据。</p>
<h2 id="Replacing-Celebrities"><a href="#Replacing-Celebrities" class="headerlink" title="Replacing Celebrities"></a>Replacing Celebrities</h2><p><strong>不再有人类演员</strong></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8GXIT5qvQH0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<p><a href="https://www.wired.com/story/bruce-willis-deepfake-rights-law/">谁拥有了 Bruce Willis </a>？这位演员最近制作了自己的数字模型，并分享给一家俄罗斯广告公司制作了上面的广告。Bruce Willis 被诊断为患有失语症，这是一种老年痴呆症，这让他不得不在去年退休；不过，通过 deepfakes，他可以继续演戏，准备好看《Die Hard 47》了吗？</p>
<p>讽刺的是，<a href="https://restofworld.org/2023/ai-voice-acting/">配音演员正在帮助训练即将取代他们的AI</a>。这也意味着，有了人工智能，<a href="https://www.wired.com/story/simpsons-voice-actors-ai-deepfakes/">《辛普森一家》可以无限期地播放下去</a>。但这也引出了一个更大的问题，一个名人签署了在媒体中使用其模型的权利，这是否预示着我们的未来不再需要人类演员？全球各地的演员工会都在竭力解决这个问题。</p>
<p>另一个例子是”<a href="https://losttapesofthe27club.com/">Lost Tapes of the 27 Club</a>“，这是一个利用AI生成新曲目的音乐项目，这些曲目来自与精神健康问题作斗争并在27岁去世的音乐家，其中包括Cobain，Jimi Hendrix，Jim Morrison和Amy Winehouse。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/muT6x7VXx5I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<h2 id="Who’s-fighting-back"><a href="#Who’s-fighting-back" class="headerlink" title="Who’s fighting back?"></a>Who’s fighting back?</h2><p>这是几个政策和实验的例子，试图减轻 deepfakes 造成的伤害</p>
<h3 id="Policies-and-frameworks"><a href="#Policies-and-frameworks" class="headerlink" title="Policies and frameworks"></a>Policies and frameworks</h3><ul>
<li><a href="https://www.congress.gov/bill/116th-congress/house-bill/3230">Deepfakes Accountability Act</a>: 在2019年，美国众议员 Yvette Clarke提出了这项法案，以打击 deepfake 色情内容</li>
<li><a href="https://leginfo.legislature.ca.gov/faces/billTextClient.xhtml?bill_id=201920200AB730">AB 730</a>, 美国州长 Gavin Newsom 签署了加州第 730 号法案，即“<a href="https://www.wired.com/story/opinion-californias-anti-deepfake-law-is-far-too-feeble/">Anti-Deepfake Bill</a>”，使其成为法律用来遏制2020年大选前的 deepfakes 传播</li>
<li><a href="https://nvlpubs.nist.gov/nistpubs/ai/NIST.AI.100-1.pdf">The Aritificial Intelligence Risk Management Framework</a>：NIST的这个框架为管理<a href="https://www.nist.gov/news-events/news/2023/01/nist-risk-management-framework-aims-improve-trustworthiness-artificial">AI的许多风险</a>提供了指导</li>
</ul>
<h3 id="New-Turing-tests"><a href="#New-Turing-tests" class="headerlink" title="New Turing tests"></a>New Turing tests</h3><p>检测AI编写的内容的最佳方法之一就是训练另一个AI来做这件事，以下是几个例子：</p>
<ul>
<li><a href="https://gptzero.me/">GPTZero</a></li>
<li><a href="https://techcrunch.com/2022/12/10/openais-attempts-to-watermark-ai-text-hit-limits/">给AI生成的内容加水印</a>，作者 Scott Aaronson， Open AI：</li>
</ul>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fc-cHk9yFpg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

<ul>
<li><a href="https://openai-openai-detector--mqlck.hf.space/">Jong Wook</a> 和 <a href="https://detectgpt.ericmitchell.ai/">Eric Mitchell</a> 的 GPT2 探测器</li>
</ul>
<p>各国政府也在竞相资助能够辨别AI生成内容的工具。例如，生成式AI公司DeepMedia就获得了一笔美国拨款，用于开发人工智能辅助技术，以剔除错误信息，满足 DoD 的国家安全需求。</p>
<hr>
<p>本文开头的人工智能生成图片问题的答案是左边的婴儿。来源：<a href="https://loremfaces.com/">Lorem Faces</a> 和 <a href="https://thispersonexists.net/">ThisPersonExists</a></p>
<p>在尝试这个练习的人中，有50%的人答案错误，而100%的人感到困惑。我们不再有能力分辨AI生成的内容，<a href="https://www.wsj.com/articles/chatgpt-creator-releases-tool-to-detect-ai-generated-text-calls-it-unreliable-11675204820">专家们也对我们是否有能力分辨AI生成的内容持怀疑态度</a>。然而，通过对AI生成工具进行道德设计，再加上广泛的认知，我们可以发展出一种新的能力：对我们所看到的内容提出质疑的能力。</p>
<blockquote>
<p>Something strange is afoot. In the hyper-connected, data-deluged present, schisms emerge in mass perception. We’re all looking at the same skies, but we’re seeing different things. Where I see covert deportations and secret surveillance planes — supported by flight logs and ADS-B data, newspaper reports and Freedom of Information requests — others see a global conspiracy to doctor the atmosphere, to control minds, to enslave populations, or to reengineer the climate for naive or nefarious purposes.<br>— James Bridle, New Dark Age</p>
</blockquote>
<p>有关此主题及其他主题的更多资源，请查阅本手册<a href="https://arvindsanjeev.notion.site/arvindsanjeev/The-Handbook-of-AI-s-Unintended-Consequences-720cda3d8cec49dc88807641157a0bba">《AI’s unintended consequences》</a>。本文是探讨 <a href="https://medium.com/@arvindsanjeev/ai-sociopaths-and-their-unintended-consequences-bf6f19012e4f">unintended consequences of AI 四部系列文章</a>中的第一章</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Mastering TypeScript: A Guide to Choosing Between ‘type’ and ‘interface’</title>
    <url>/2023/05/24/%E3%80%90%E7%BF%BB%E3%80%91Mastering-TypeScript-A-Guide-to-Choosing-Between-%E2%80%98type%E2%80%99-and-%E2%80%98interface%E2%80%99/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://levelup.gitconnected.com/mastering-typescript-a-guide-to-choosing-between-type-and-interface-c31d3527693b">Mastering TypeScript: A Guide to Choosing Between ‘type’ and ‘interface’</a><br>原作者：<a href="https://blog.ricofritzsche.de/">Rico Fritzsche</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>TypeScript现在已经成为捕捉错误和提高代码稳定性的可靠工具。然而，在使用TypeScript时，我经常想知道type和interface之间的区别，以及如何使用它们</p>
<p>在这篇博客中，我想分享我所知道的的关于type和interface之间的区别，以及何时使用它们，我会提供明确的例子和解释，帮助你更好地理解如何在TypeScript项目中使用这两个强大的工具。</p>
<p>在本篇文章结束时，你将对type和interface之间的区别有更好的理解，以及知道如何在TypeScript代码中更有效地使用它们。我希望这篇文章对希望提高TypeScript技能和希望编写更多可靠代码的web开发者有所帮助。</p>
<h3 id="Type-vs-Interface"><a href="#Type-vs-Interface" class="headerlink" title="Type vs Interface"></a>Type vs Interface</h3><p>在TypeScript中，type和interface都可以用来定义对象类型，但他们在语法和功能上有一些区别，首先interface是一个用来定义对象类型关键字，其语法是：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">IUser</span> &#123;
  <span class="attr">name</span>: <span class="built_in">string</span>;
  <span class="attr">age</span>: <span class="built_in">number</span>;
  ...
&#125;</code></pre>

<p>另一方面，type也是一个定义对象类型的关键字，其语法是：</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;
  <span class="attr">name</span>: <span class="built_in">string</span>;
  <span class="attr">age</span>: <span class="built_in">number</span>;
  ...
&#125;;</code></pre>

<p>语法差异不大，但在功能上还有其他差异。</p>
<p>interface可以扩展并创建继承父interface属性的新类型：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">IUser</span> &#123;
  <span class="attr">name</span>: <span class="built_in">string</span>;
&#125;

<span class="keyword">interface</span> <span class="title class_">IMember</span> <span class="keyword">extends</span> <span class="title class_">IUser</span> &#123;
  <span class="attr">department</span>: <span class="built_in">string</span>;
&#125;</code></pre>

<p>这允许你定义一套多个类型共享的基础属性，然后根据需要为更多的特定类型进行扩展。这可以帮助你避免代码重复，使你的代码更具有模块化和组织。</p>
<p>而type不能以同样的方式被扩展，但它可以用来定义联合、交叉和其他复杂类型：</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">Union</span> = <span class="title class_">Type1</span> | <span class="title class_">Type2</span>;

<span class="keyword">type</span> <span class="title class_">Intersection</span> = <span class="title class_">Type1</span> &amp; <span class="title class_">Type2</span>;</code></pre>

<p>这些type允许你定义类型更复杂的关系，并且可以帮助你更准确地建立数据模型。</p>
<h3 id="Example-—-Building-a-Messaging-App"><a href="#Example-—-Building-a-Messaging-App" class="headerlink" title="Example — Building a Messaging App"></a>Example — Building a Messaging App</h3><p>假如你正在构建一个消息app，你想为一条信息定义一个类型，它可以包含文本或图像，你可以使用一个联合类型来定义：</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">Message</span> = &#123;
  <span class="attr">type</span>: <span class="string">&#x27;text&#x27;</span> | <span class="string">&#x27;image&#x27;</span>;
  <span class="attr">content</span>: <span class="built_in">string</span> | <span class="title class_">File</span>;
&#125;</code></pre>

<p>在这个例子中，我们使用type来定义一个联合类型，它只能是两个字符串值中的一个：”text”或者”image”，我们还使用联合类型来定义content属性，他可以是一个字符串(text messages)或者是一个File对象(image messages)。</p>
<p>现在，假如你想在你的app中为一组拥有不同角色的用户定义一个类型，比如管理员、版主和普通用户。你可以使用一个交叉类型来定义：</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;
  <span class="attr">id</span>: <span class="built_in">number</span>;
  <span class="attr">name</span>: <span class="built_in">string</span>;
&#125;

<span class="keyword">type</span> <span class="title class_">Admin</span> = <span class="title class_">User</span> &amp; &#123;
  <span class="attr">role</span>: <span class="string">&#x27;admin&#x27;</span>;
  <span class="attr">permissions</span>: <span class="built_in">string</span>[];
&#125;

<span class="keyword">type</span> <span class="title class_">Moderator</span> = <span class="title class_">User</span> &amp; &#123;
  <span class="attr">role</span>: <span class="string">&#x27;moderator&#x27;</span>;
  <span class="attr">canDelete</span>: <span class="built_in">boolean</span>;
&#125;

<span class="keyword">type</span> <span class="title class_">RegularUser</span> = <span class="title class_">User</span> &amp; &#123;
  <span class="attr">role</span>: <span class="string">&#x27;user&#x27;</span>;
  <span class="attr">isPremium</span>: <span class="built_in">boolean</span>;
&#125;</code></pre>

<p>在这个例子中，我们定义了一个有两个属性的用户类型：id和name。然后我们定义了另外三个类型(Admin、Moderator和RegularUser)，它们使用一个交叉类型(&amp;)来扩展User类型。这些类型中每一个都有一个不同的role属性和针对其角色的额外属性。</p>
<p>使用联合类型和交叉类型可以帮助你在TypeScript代码中定义更复杂的类型，并使其更容易对现实世界的数据进行建模。</p>
<h3 id="Declaration-Merging"><a href="#Declaration-Merging" class="headerlink" title="Declaration Merging"></a>Declaration Merging</h3><p>interface还支持声明合并，它允许你定义多个同名的interface，并将它们的属性合并到一个interface中：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">MyObject</span> &#123;
  <span class="attr">property1</span>: <span class="title class_">Type1</span>;
&#125;

<span class="keyword">interface</span> <span class="title class_">MyObject</span> &#123;
  <span class="attr">property2</span>: <span class="title class_">Type2</span>;
&#125;

<span class="keyword">const</span> <span class="attr">myObject</span>: <span class="title class_">MyObject</span> = &#123;
  <span class="attr">property1</span>: <span class="string">&#x27;value1&#x27;</span>,
  <span class="attr">property2</span>: <span class="string">&#x27;value2&#x27;</span>
&#125;;</code></pre>

<p>当你与第三方库或系统一起工作时，这很有用，它们分别定义了它们的interface，然后在需要时把它们合并成一个interface。</p>
<h3 id="Example-—-Unleashing-the-Power-of-Declaration-Merging"><a href="#Example-—-Unleashing-the-Power-of-Declaration-Merging" class="headerlink" title="Example — Unleashing the Power of Declaration Merging"></a>Example — Unleashing the Power of Declaration Merging</h3><p>假如你正在构建一个需要用户登录的app，你想为认证API返回的用户对象定义一个interface。你可以像这样定义这个interface：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;
  <span class="attr">username</span>: <span class="built_in">string</span>;
  <span class="attr">email</span>: <span class="built_in">string</span>;
&#125;</code></pre>

<p>后来，你发现认证API也会为每个用户返回一个userId属性，但你不想修改原来的User interface。相反，你可以定义一个同名的新interface，它将自动将属性与原来的User interface合并：</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;
  <span class="attr">userId</span>: <span class="built_in">number</span>;
&#125;

<span class="comment">// Now the User interface has three properties: username, email, and userId</span>
<span class="keyword">const</span> <span class="attr">user</span>: <span class="title class_">User</span> = &#123;
  <span class="attr">username</span>: <span class="string">&#x27;john.doe&#x27;</span>,
  <span class="attr">email</span>: <span class="string">&#x27;john.doe@example.com&#x27;</span>,
  <span class="attr">userId</span>: <span class="number">123</span>
&#125;;</code></pre>

<p>在这个例子中，我们定义了User interface， 有两个属性：username和email，然后，我们定义了一个新的User interface，并带有userId属性。当我们使用User interface来定义我们的用户对象时，两个接口的属性会被合并在一起，创建一个具有三个属性的对象：username，email和userId。</p>
<p>声明合并是interface一个很有用的功能，它允许你在不修改原有定义的情况下扩展现有interface。</p>
<h3 id="Let’s-talk-about-the-Open-x2F-Closed-Principle"><a href="#Let’s-talk-about-the-Open-x2F-Closed-Principle" class="headerlink" title="Let’s talk about the Open&#x2F;Closed Principle"></a>Let’s talk about the Open&#x2F;Closed Principle</h3><p>开闭原则(OCP)，是面向对象编程设计SOLID原则之一。它就像软件开发的圣杯。每个人都在谈论它，但是你们真的了解它吗？还只是假装了解？</p>
<p>我希望你记住：SOLID是一个缩写，代表了Robert C.Martin（也被称为Bob叔叔）提出的面向对象编程设计的五个原则。这些原则使软件开发具有可伸缩、可维护、可扩展</p>
<p>之前的例子很好的说明了开闭原则，因为它展示了如何在不修改原有interface的情况下扩展它。通过定义一个带有userId属性的新interface，而不是修改原来的User interface，在保持原来的接口不被修改的同时还能扩展其功能。这种方式随着时间的推移，使你的代码更容易维护和扩展，而不会引入意想不到的问题和破坏式变化。</p>
<p>但是等等，还有更多！如果你使用TypeScript或其他具有声明合并功能的语言，你可以只用两个属性来定义user interface，然后用userId属性定义一个新的user interface，但你用User interface定义用户对象时，两个接口的属性会神奇地合并在一起，创建一个有三个属性的对象。这就像魔术一样，只不过没有兔子，更多的是TypeScript。</p>
<p>但是实际中，谁有时间去研究OCP这些废话？有时你只是需要完成一些功能，而修改现有代码是最快的办法。谁会关心OCP呢？它只是软件开发者喜欢抛出的一个花哨的原则，让自己听起来很聪明。</p>
<p>所以，如果你必须做的话，就去违反OCP吧。只要确保你有一个很好的理由这样做。如果有人问起，就告诉他们你是在遵循KCP(保持满足原则)。这是一个我们都支持的原则。</p>
<h3 id="React-Component-Props"><a href="#React-Component-Props" class="headerlink" title="React Component Props"></a>React Component Props</h3><p>所以你是想用type还是interface来定义React component props？让我告诉你，你来对地方了，我的意思是，当你可以将时间花在探讨TypeScript语法的细微差别时，谁还需要生活呢？你就像现代的苏格拉底，提着重要的问题，比如“我应该是用type还是interface？”而我们这些凡人则忙着在Tinder上左滑右滑。所以，请系好安全带，我的朋友，因为我们即将深入探索React Components 类型定义的精彩世界</p>
<p>在React组件上使用type还是interface来定义props在很大程度上是一个个人偏好的问题，因为这两个选项提供了相似的功能。然而，在选择它们的时候，有一些区别需要考虑。</p>
<p>首先interface是React组件中定义props的一种常用方式。因为interface允许你扩展和重用来定义props对象。例如，你可以创建一个基本props interface，然后在每个单独的组件中扩展它</p>
<pre><code class="highlight ts"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;
  className?: <span class="built_in">string</span>;
  onClick?: <span class="function">() =&gt;</span> <span class="built_in">void</span>;
&#125;

<span class="keyword">interface</span> <span class="title class_">ButtonProps</span> <span class="keyword">extends</span> <span class="title class_">Props</span> &#123;
  <span class="keyword">type</span>?: <span class="string">&#x27;button&#x27;</span> | <span class="string">&#x27;submit&#x27;</span> | <span class="string">&#x27;reset&#x27;</span>;
&#125;

<span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params">&#123; className, onClick, <span class="keyword">type</span> &#125;: ButtonProps</span>) &#123;
  <span class="comment">// render button with props</span>
&#125;</code></pre>

<p>在这个例子中，我们定义了一个包含className和onClick属性的interface。然后我们扩展这个interface，创建了一个ButtonProps interface，增加了一个可选的type prop。然后用这个interface来定义Button组件的props。</p>
<p>另一方面，当你需要定义更复杂的类型时，比如联合或者交叉类型时，type就很有用。比如，你可以使用type来定义一个size options，代表一个组件的不同size选项。</p>
<pre><code class="highlight ts"><span class="keyword">type</span> <span class="title class_">Size</span> = <span class="string">&#x27;small&#x27;</span> | <span class="string">&#x27;medium&#x27;</span> | <span class="string">&#x27;large&#x27;</span>;

<span class="keyword">interface</span> <span class="title class_">Props</span> &#123;
  <span class="attr">size</span>: <span class="title class_">Size</span>;
&#125;

<span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">&#123; size &#125;: Props</span>) &#123;
  <span class="comment">// render component with props</span>
&#125;</code></pre>

<p>在这个例子中，我们使用type定义了一个size类型，代表组件的不同尺寸。然后，我们用props interface来定义size prop，要求是必须的并且是尺寸类型中的一个。</p>
<p>通常，使用interface是定义简单props的好选择，可以扩展或重复使用，而使用type是定义复杂类型的好选择。</p>
<p>总之，type和interface都可以用来React组件中定义props，但它们在功能上有一些区别。interface可以扩展或重复使用，而type对于定义更复杂的类型很有用。最终，在type和interface之间选择是一个个人偏好和你项目具体需求的问题。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>一般来说，interface经常被用来定义对象的结构，并作为其他系统或库的interface。另一方面，type经常用来定义更复杂的类型，如联合、交叉或映射类型，或者定义不能用interface表达的类型，如函数类型或条件类型。</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Reactivity in Depth</title>
    <url>/2023/08/18/%E3%80%90%E7%BF%BB%E3%80%91Reactivity-in-Depth/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://vuejs.org/guide/extras/reactivity-in-depth.html">Reactivity in Depth</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Vue 最与众不同的功能之一就是其难以察觉的响应式系统。Vue的组件状态都是由javascript对象组成。当你修改它们时，视图就会更新。这就使状态管理变得简单直观，但如果能了解它是如何工作的也可以避免一些常见的问题。在本节中，我们会深入探讨Vue响应式系统的一些底层细节。</p>
<h2 id="What-is-Reactivity"><a href="#What-is-Reactivity" class="headerlink" title="What is Reactivity?"></a>What is Reactivity?</h2><p>近来，这个术语在编程的讨论中出现频率很高，但当人们说这个词时是什么意思呢？响应式本质上是一种编程范式，它允许我们以声明的方式处理变化。一个经常拿来展示的例子就是Excel表格</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这里的单元格A2是通过公式 A0 + A1 定义的(你可以点击A2查看或编辑公式)，所以得出结果为3。没有问题，但如果更新A0或者A1，你会发现A2也会自动更新。</p>
<p>当然javascript通常不是这样工作。如果我们用javascript写一个相似的逻辑：</p>
<pre><code class="highlight js"><span class="keyword">let</span> <span class="variable constant_">A0</span> = <span class="number">1</span>
<span class="keyword">let</span> <span class="variable constant_">A1</span> = <span class="number">2</span>
<span class="keyword">let</span> <span class="variable constant_">A2</span> = <span class="variable constant_">A0</span> + <span class="variable constant_">A1</span>

<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">A2</span>) <span class="comment">// 3</span>

<span class="variable constant_">A0</span> = <span class="number">2</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">A2</span>) <span class="comment">// Still 3</span></code></pre>

<p>当我们改变A0时，A2不会自动改变。</p>
<p>那么，该如何用javascript实现这一功能呢？首先，为了重新运行更新A2的代码，我们可以用一个函数来封装它：</p>
<pre><code class="highlight js"><span class="keyword">let</span> <span class="variable constant_">A2</span>

<span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;
  <span class="variable constant_">A2</span> = <span class="variable constant_">A0</span> + <span class="variable constant_">A1</span>
&#125;</code></pre>

<p>然后，我们需要定义几个术语：</p>
<ul>
<li>首先<code>update()</code>函数会产生副作用，简称“effect”，因为它会修改程序的状态。</li>
<li><code>A0</code>和<code>A1</code>是 effect 的依赖项，因为它们的值是用于执行effect。可以说，effect是其依赖项的订阅者</li>
</ul>
<p>我们需要一个魔法函数，可以在<code>A0</code>或<code>A1</code>发生变化时调用<code>update()</code></p>
<pre><code class="highlight js"><span class="title function_">whenDepsChange</span>(update)</code></pre>

<p>这个<code>whenDepsChange()</code>函数有以下任务：</p>
<ol>
<li>追踪变量何时被读取。比如，在计算表达式<code>A0 + A1</code>时，<code>A0</code>和<code>A1</code>都会被读取。</li>
<li>如果一个变量在当前运行的effect中被读取，则该effect就为该变量的订阅者。比如，由于<code>A0</code>和<code>A1</code>在<code>update()</code>执行时被读取，因此<code>update()</code>在第一次调用后就成为了<code>A0</code>和<code>A1</code>的订阅者</li>
<li>当变量发生变化时进行检测。比如，当<code>A0</code>被修改为一个新值时，通知其所有订阅了的effect重新执行。</li>
</ol>
<h2 id="How-Reactivity-Works-in-Vue"><a href="#How-Reactivity-Works-in-Vue" class="headerlink" title="How Reactivity Works in Vue"></a>How Reactivity Works in Vue</h2><p>我们无法像示例中那样追踪局部变量的读写。在原生的javascript中没有这样的机制。但我们可以做到追踪对象属性的读写。</p>
<p>在javascript中有两种拦截属性访问的方法：<code>getter</code>&#x2F;<code>setters</code>和<code>proxies</code>。由于浏览器支持的限制，Vue2中只能使用<code>getter</code>&#x2F;<code>setters</code>。在Vue3中，<code>proxy</code>用于响应式对象，<code>getter</code>&#x2F;<code>setter</code>用于<code>refs</code>。下面是一些说明它们如何工作的伪代码：</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;
    <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;
      <span class="title function_">track</span>(target, key)
      <span class="keyword">return</span> target[key]
    &#125;,
    <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;
      target[key] = value
      <span class="title function_">trigger</span>(target, key)
    &#125;
  &#125;)
&#125;

<span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value</span>) &#123;
  <span class="keyword">const</span> refObject = &#123;
    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;
      <span class="title function_">track</span>(refObject, <span class="string">&#x27;value&#x27;</span>)
      <span class="keyword">return</span> value
    &#125;,
    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;
      value = newValue
      <span class="title function_">trigger</span>(refObject, <span class="string">&#x27;value&#x27;</span>)
    &#125;
  &#125;
  <span class="keyword">return</span> refObject
&#125;</code></pre>

<blockquote>
<p>TIP: 这里和下面的代码片段是为了以最简单的形式解释核心概念，因此省略了许多细节，也忽略了边界情况。</p>
</blockquote>
<p>以上就解释了我在基础部分讨论过的响应式对象的一些局限性：</p>
<ul>
<li>当你将一个响应式对象的属性赋值或解构到一个本地变量时，该变量的访问和赋值就不是响应式的了，因为它不再触发源对象上的<code>get</code>&#x2F;<code>set</code>的代理。请注意，这种断开只影响变量绑定，如果变量指向一个非原始值，那么该对象的更改仍是响应式的。</li>
<li>使用<code>proxy</code>返回的响应式对象，虽然与原始对象无异，但如果我们使用 <code>===</code> 操作符将其对比式，还是能够比较出不同</li>
</ul>
<p>在<code>track()</code>中，我们会检查当前是否有正在运行的effect。如果有，我们会查找到一个存储所有追踪了该属性的订阅的Set，并将其添加到Set中：</p>
<pre><code class="highlight js"><span class="comment">// This will be set right before an effect is about</span>
<span class="comment">// to be run. We&#x27;ll deal with this later.</span>
<span class="keyword">let</span> activeEffect

<span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;
  <span class="keyword">if</span> (activeEffect) &#123;
    <span class="keyword">const</span> effects = <span class="title function_">getSubscribersForProperty</span>(target, key)
    effects.<span class="title function_">add</span>(activeEffect)
  &#125;
&#125;</code></pre>

<p>effect订阅会以这种数据结构<code>WeakMap&lt;target, Map&lt;key, Set&lt;effect&gt;&gt;</code>存储在全局。如果某个属性没有找到effect Set，说明是首次追踪，则会创建一个effect Set。简而言之，这就是<code>getSubscribersForProperty()</code>函数的作用。为简单起见，我们跳过其细节。</p>
<p>在<code>trigger()</code>中，我们再次查找该属性的effect订阅。但这次我们会执行它们：</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;
  <span class="keyword">const</span> effects = <span class="title function_">getSubscribersForProperty</span>(target, key)
  effects.<span class="title function_">forEach</span>(<span class="function">(<span class="params">effect</span>) =&gt;</span> <span class="title function_">effect</span>())
&#125;</code></pre>

<p>现在我们回到<code>whenDepsChange()</code>函数中：</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">whenDepsChange</span>(<span class="params">update</span>) &#123;
  <span class="keyword">const</span> <span class="title function_">effect</span> = (<span class="params"></span>) =&gt; &#123;
    activeEffect = effect
    <span class="title function_">update</span>()
    activeEffect = <span class="literal">null</span>
  &#125;
  <span class="title function_">effect</span>()
&#125;</code></pre>

<p>它把原始的<code>update</code>函数封装在一个effect中，然后该effect会在实际更新之前将自己设置为activeEffect。这样就能在更新过程中调用<code>track()</code>来定位当前的active effect。</p>
<p>在这里，我们已经创建了一个可以自动追踪其依赖关系的effect，并在依赖关系发生变化时重新运行。我们称之为响应式副作用。</p>
<p>Vue提供一个可以创建响应式副作用的API：<code>watchEffect()</code>。事实上，你可能已经注意到它的工作原理与示例中的<code>whenDepsChange()</code>非常相似。现在，我们可以使用实际的Vue API运行最初的示例：</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">const</span> <span class="variable constant_">A0</span> = <span class="title function_">ref</span>(<span class="number">0</span>)
<span class="keyword">const</span> <span class="variable constant_">A1</span> = <span class="title function_">ref</span>(<span class="number">1</span>)
<span class="keyword">const</span> <span class="variable constant_">A2</span> = <span class="title function_">ref</span>()

<span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;
  <span class="comment">// tracks A0 and A1</span>
  <span class="variable constant_">A2</span>.<span class="property">value</span> = <span class="variable constant_">A0</span>.<span class="property">value</span> + <span class="variable constant_">A1</span>.<span class="property">value</span>
&#125;)

<span class="comment">// triggers the effect</span>
<span class="variable constant_">A0</span>.<span class="property">value</span> = <span class="number">2</span></code></pre>

<p>使用响应式副作用来改变ref并不是最有趣的用例，事实上，使用计算属性会使它更具有声明性：</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">const</span> <span class="variable constant_">A0</span> = <span class="title function_">ref</span>(<span class="number">0</span>)
<span class="keyword">const</span> <span class="variable constant_">A1</span> = <span class="title function_">ref</span>(<span class="number">1</span>)
<span class="keyword">const</span> <span class="variable constant_">A2</span> = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="variable constant_">A0</span>.<span class="property">value</span> + <span class="variable constant_">A1</span>.<span class="property">value</span>)

<span class="variable constant_">A0</span>.<span class="property">value</span> = <span class="number">2</span></code></pre>

<p>在内部，computed会通过响应式副作用来管理失效和重新计算的过程。</p>
<p>所以，最有用且常见的响应式示例是什么呢？就是更新DOM！我们可以执行一个简单的响应式渲染例子：</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)

<span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;
  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`count is: <span class="subst">$&#123;count.value&#125;</span>`</span>
&#125;)

<span class="comment">// updates the DOM</span>
count.<span class="property">value</span>++</code></pre>

<p>事实上，这与Vue保持状态和DOM同步的方式非常接近，每个组件实例都会创建一个响应式副作用来渲染和更新DOM。当然Vue组件使用了比innerHTML更高效的方式来更新DOM。这会在渲染机制一节中讨论。</p>
<h2 id="Runtime-vs-Compile-time-Reactivity"><a href="#Runtime-vs-Compile-time-Reactivity" class="headerlink" title="Runtime vs. Compile-time Reactivity"></a>Runtime vs. Compile-time Reactivity</h2><p>Vue的响应式系统主要基于运行时：跟踪和触发都是代码直接在浏览器运行时进行的。运行时的优点是无需构建步骤即可运行，而且边界情况较少。另一方面，这也使它受到javascript语法的制约，导致需要 refs这样的值容器</p>
<p>像一些框架，如Svelte，选择在编译阶段实现响应式来克服这些限制，它通过分析和转换代码来模拟响应式。编译阶段允许框架改变javascript本身的语义，比如，隐式注入代码来执行依赖性分析，并在访问本地定义的变量时触发。这样做的缺点是，这种转换需要一个构建步骤，而改变javascript语义本质上就是创造一种看起来像javascript但编译成另一种语言的语言。</p>
<p>Vue团队曾通过了一项名为 <a href="https://vuejs.org/guide/extras/reactivity-transform.html">Reactivity Transform</a> 的实验性功能探索过这个方向，但我们最后还是因为<a href="https://github.com/vuejs/rfcs/discussions/369#discussioncomment-5059028">这个原因</a>，认为他不适合这个项目。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】On Styling Web Components</title>
    <url>/2023/06/17/%E3%80%90%E7%BF%BB%E3%80%91On%20Styling%20Web%20Components/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://blog.webf.zone/on-styling-web-components-b74b8c70c492">On Styling Web Components</a><br>原作者：<a href="https://medium.com/@mistyHarsh">Harshal Patil</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>以正确的方式进行 — 使用CSSOM</p>
<p><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*nrlNnE1jCyNVqNQllN1Qzw.png"></p>
<p>更好的封装性可能是你开始使用Web Components的主要原因。特别是，ShadowDOM是实现真正封装性的机制。多年来，Web社区发明了一些方案来修复和改善CSS和JS的全局特性，这些解决方案虽起作用了但并不完美。直到有了Shadow DOM，我们才真正实现了CSS的完美作用域。</p>
<p>在这篇文章中，我们会探索如何将样式应用到Web Components上，并尝试找到最合适的方法。此外，我们还将尝试将我们的解决方案和当前的构建工具相结合。</p>
<h2 id="The-naive-way-—-Plain-lt-style-gt-tag"><a href="#The-naive-way-—-Plain-lt-style-gt-tag" class="headerlink" title="The naive way — Plain &lt;style&gt; tag"></a>The naive way — Plain <code>&lt;style&gt;</code> tag</h2><p>在使用Shadow DOM时，为了使 style sheet 发挥作用，目前是要在每个shadow root中使用<code>&lt;style&gt;</code> 元素，在大多数文章中，都会很表面的说出这个方案</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">FancyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;

  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">super</span>();

    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);

    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">      &lt;!-- Styles are scoped --&gt;</span>
<span class="string">      &lt;style&gt;</span>
<span class="string">        p &#123; color: red; &#125;</span>
<span class="string">      &lt;/style&gt;</span>
<span class="string">      &lt;div&gt;</span>
<span class="string">        &lt;p&gt;Hello World&lt;/p&gt;</span>
<span class="string">      &lt;/div&gt;</span>
<span class="string">    `</span>;
  &#125;
&#125;

customElements.<span class="title function_">define</span>(<span class="string">&#x27;fancy-comp&#x27;</span>, <span class="title class_">FacyComponent</span>);</code></pre>

<p>这个解决办法简单直接，然而有一个问题：</p>
<blockquote>
<p>对于页面中添加的每个组件实例，浏览器都会解析它的样式表规则。</p>
</blockquote>
<p>这对性能会产生很大的影响，比如时间增加和内存增加。时间会增加是因为浏览器需要解析更多的原始字符串，内存成本增加是因为每个组件都会存储样式规则。浏览器没有办法知道同一个组件的两个实例是否共享相同的样式。</p>
<blockquote>
<p>原作者更新：Eric Bidelman在评论中指出，性能方面不一定会影响。浏览器可能在内部进行优化，这样它就不会在每次创建实例时解析样式标签。事实上，Blink（Chrome、Opera等）引擎已经对此进行了优化</p>
</blockquote>
<h2 id="Can-we-do-something-better"><a href="#Can-we-do-something-better" class="headerlink" title="Can we do something better?"></a>Can we do something better?</h2><p>其实，我们可以通过创建一个样式节点，然后在组件的每个实例中进行深度克隆，来防止样式规则的重新解析：</p>
<pre><code class="highlight js"><span class="comment">// Create style node outside of WebComponent</span>
<span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);

style.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">  p &#123; color: blue; &#125;</span>
<span class="string">`</span>;

<span class="keyword">class</span> <span class="title class_">FancyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;

  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">super</span>();

    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);

    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">      &lt;div&gt;</span>
<span class="string">        &lt;p&gt;Hello World&lt;/p&gt;</span>
<span class="string">      &lt;/div&gt;</span>
<span class="string">    `</span>;

    <span class="comment">// Let us try to optimize</span>
    <span class="comment">// Deep cloning of style node</span>
    <span class="keyword">const</span> clonedStyle = style.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);

    shadowRoot.<span class="title function_">appendChild</span>(clonedStyle);
  &#125;
&#125;</code></pre>

<p>不过，这种方法虽然很容易，但是仍然有问题。</p>
<ul>
<li>首先，它不能真正的帮助我们在组件实例间共享样式。新的样式节点仍然会创建</li>
<li>其次这个方法与 <strong>lit-html</strong> 和 <strong>hyperHTML</strong> 等声明式解决方案一起使用有点尴尬。</li>
</ul>
<h2 id="Enter-the-Constructible-Stylesheets"><a href="#Enter-the-Constructible-Stylesheets" class="headerlink" title="Enter the Constructible Stylesheets"></a>Enter the Constructible Stylesheets</h2><p>顾名思义，可构建的样式表允许在使用Shadow DOM时创建和共享样式。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5R11T84I-Fd0JBzOur2AQ.png"></p>
<pre><code class="highlight js"><span class="keyword">const</span> sheet = <span class="keyword">new</span> <span class="title class_">CSSStyleSheet</span>();

<span class="comment">// Replace all styles synchronously for this style sheet</span>
sheet.<span class="title function_">replaceSync</span>(<span class="string">&#x27;p &#123; color: green; &#125;&#x27;</span>);

<span class="keyword">class</span> <span class="title class_">FancyComponent1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;

  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">super</span>();

    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);

    <span class="comment">// Attaching the style sheet to the Shadow DOM of this component</span>
    shadowRoot.<span class="property">adoptedStyleSheets</span> = [sheet];

    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">      &lt;div&gt;</span>
<span class="string">        &lt;p&gt;Hello World&lt;/p&gt;</span>
<span class="string">      &lt;/div&gt;</span>
<span class="string">    `</span>;

  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">FancyComponent2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;

  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">super</span>();

    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);

    <span class="comment">// Same style sheet can also be used by another web component</span>
    shadowRoot.<span class="property">adoptedStyleSheets</span> = [sheet];

    <span class="comment">// You can even manipulate the style sheet with plain JS manipulations</span>
    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> shadowRoot.<span class="property">adoptedStyleSheets</span> = [], <span class="number">2000</span>);

    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span>
<span class="string">      &lt;div&gt;</span>
<span class="string">        &lt;p&gt;Hello World&lt;/p&gt;</span>
<span class="string">      &lt;/div&gt;</span>
<span class="string">    `</span>;

  &#125;
&#125;</code></pre>

<p>除了解决重复拷贝的问题，它还有一些特点：</p>
<ul>
<li>首先样式不仅仅被同一组件的实例共享，也会被多个不同组件所共享</li>
<li>它还支持处理异步样式。例如，在你的CSS代码中使用 <code>url</code> 和 <code>@import</code></li>
<li>最后，<code>adoptedStyleSheets</code> 是一个数组。这意味着你可以在我们以前不可能做到的方式来组成可复用的样式表。首先你可以把你的CSS规则分成小块，然后只应用需要的那部分。甚至你可以做下面这样的事情：</li>
</ul>
<pre><code class="highlight js">shadowRoot.<span class="property">adoptedStyleSheets</span> = [sheet];
<span class="comment">// Remove stylesheets after two seconds</span>
<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> shadowRoot.<span class="property">adoptedStyleSheets</span> = [], <span class="number">2000</span>);</code></pre>

<h2 id="Using-with-Webpack-and-SCSS"><a href="#Using-with-Webpack-and-SCSS" class="headerlink" title="Using with Webpack and SCSS"></a>Using with Webpack and SCSS</h2><p>SCSS作为一个CSS预处理器，Webpack作为一个模块打包和构建工具，都是非常常见的配置。其中<br> <code>CSSStyleSheet.replace()</code> 和 <code>CSSStyleSheet.replaceSync()</code> 预期接收一个原始字符串形式的CSS规则。我们可以使用一个简单的loader chain，包括sass-loader和raw-loader，如下：</p>
<pre><code class="highlight js"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;

  <span class="attr">entry</span>: &#123; <span class="comment">/* config */</span> &#125;,

  <span class="attr">output</span>: &#123; <span class="comment">/* config */</span> &#125;,

  <span class="attr">module</span>: &#123;
    <span class="attr">rules</span>: [
      <span class="comment">// Regular css files</span>
      &#123;
        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,
        <span class="attr">loader</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]
      &#125;,

      <span class="comment">// Transforming SCSS file into CSS string</span>
      &#123;
        <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,
        <span class="attr">use</span>: [
          <span class="string">&#x27;raw-loader&#x27;</span>,
          &#123;
            <span class="attr">loader</span>: <span class="string">&#x27;sass-loader&#x27;</span>,
            <span class="attr">options</span>: &#123;
              <span class="attr">includePaths</span>: [path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;node_modules&#x27;</span>)]
            &#125;
          &#125;
        ]
      &#125;,
    ]
  &#125;,
  <span class="attr">plugins</span>: [],
&#125;;</code></pre>

<p>在你的代码中可以导入SCSS文件：</p>
<pre><code class="highlight js"><span class="comment">// Read SCSS file as a raw CSS text</span>
<span class="keyword">import</span> styleText <span class="keyword">from</span> <span class="string">&#x27;./my-component.scss&#x27;</span>;

<span class="keyword">const</span> sheet = <span class="keyword">new</span> <span class="title class_">CSSStyleSheet</span>();
sheet.<span class="title function_">replaceSync</span>(styleText);</code></pre>

<p>在Rollup.js中也可以进行类似的设置。此外，来自Polymer团队的新库<strong>LitElement</strong>已经在使用这种方法，并具有回退机制</p>
<p>*注意：目前可构建的样式表是在Chromium系列的浏览器中实现。然而，通过合理的渐进式增强，为不支持的浏览器提供支持应该是容易的。</p>
<h2 id="Under-the-hood-—-CSSOM"><a href="#Under-the-hood-—-CSSOM" class="headerlink" title="Under the hood — CSSOM"></a>Under the hood — CSSOM</h2><p>*如果你对其中细节不感兴趣，可以跳过这一节。</p>
<p>如果HTML被转化为DOM，那么CSS则被转化为CSSOM。这些都是独立的数据结构。最终的渲染树是由这两个数据结构构建的。作为一个前端开发者，理解CSSOM的机制其实并不重要，因此它是一个不太知名的概念。</p>
<p>粗略地说，一个<code>&lt;link type=&#39;text/css&#39; href=&#39;&#39;/&gt;</code>标签对应一个CSS样式表。它在CSSOM中由CSSStyleSheet接口表示。一个CSSStyleSheet由多个规则组成。每个规则由CSSRule接口表示。</p>
<p>要访问document上的CSSStyleSheet对象，你可以使用 <code>document.styleSheets</code> 属性。实际上，如果你想创建一个CSSStyleSheet对象，你必须创建一个样式标签，然后将其添加到document中并使用sheet属性：</p>
<pre><code class="highlight js"><span class="keyword">const</span> styleNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);
<span class="comment">// It is important to add style node to the document</span>
<span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(styleNode);
<span class="keyword">const</span> sheet = styleNode.<span class="property">sheet</span>;</code></pre>

<p>然后，可构建的样式表启用了两个API — <code>CSSStyleSheet()</code>构造函数和<code>document.adoptedStyleSheets</code>。</p>
<blockquote>
<p>有了可构造的样式表，你可以使用CSSStyleSheet()构造函数来创建样式表</p>
</blockquote>
<p>在Shadow Roots和Documents上 <code>adoptedStyleSheets</code> 是可用的。它允许我们将一个CSSStyleSheet定义的样式应用到一个给定的DOM子树上。另需要注意，adoptedStyleSheets是一个不可变的数组，因此 <code>push</code> 或 <code>splice</code> 会不起作用。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*xQyzox2_i0wMUZh6wJm_DA.png"></p>
<p>就CSSRule而言，有许多CSSRule type都扩展了CSSRule interface。以下是MDN提供的一个所有规则的列表：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSRule">CSSRule MDN</a></li>
</ul>
<p>CSS Object MOdel是很庞大的，而且一直都在不停的发展，你可以在下面找到详细的信息：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSS Object Model (CSSOM)</a></li>
</ul>
<p>另外，不要忘记新的 CSS Typed Object Model正在积极开发中，它肯定会对如何用JS编写CSS产生影响，你可以在下面的文章中找到更多关于它的内容：</p>
<ul>
<li><a href="https://developer.chrome.com/blog/cssom/">Working with the new CSS Typed Object Model</a></li>
</ul>
<h2 id="Side-notes"><a href="#Side-notes" class="headerlink" title="Side notes"></a>Side notes</h2><p>不管你是在Shadow DOM中如何处理style，你都应该牢记以下几项：</p>
<ul>
<li>您可以通过使用<code>@import</code>语句来在 Shadow DOM 中使用外部样式</li>
<li>插槽可以通过全局CSS或容器组件的样式表进行设置</li>
<li>CSS自定义属性可以跨越Shadow DOM边界使用和修改</li>
</ul>
<p>因此，这些自定义属性是从外部处理 ShadowDOM 样式的首选</p>
<ul>
<li>除了自定义属性外，还可以使用新的CSS选择器，如 <code>:host</code>、<code>:part</code>、<code>:theme</code>，进一步提供来自外部的样式定制</li>
<li>在很大程度上，使用Shadow DOM进行样式封装是替代CSS-in-JS方法的很好选择</li>
<li>虚拟组件(没有元素的组件，如Vue的<code>&lt;router-view /&gt;</code>或React的<code>&lt;Route /&gt;</code>)是不可能使用Web Components</li>
<li>Web Components非常适合替代子组件，如输入框、面板、卡片、选择器等</li>
</ul>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>Web Component</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Render Functions &amp; JSX</title>
    <url>/2023/08/31/%E3%80%90%E7%BF%BB%E3%80%91Render-Functions-JSX/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://vuejs.org/guide/extras/render-function.html">Render Functions &amp; JSX</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Vue 推荐大多数情况下使用模板来构建应用。不过，在某些情况下，我们需要使用JavaScript的全部编程能力。这时，我们就需要使用渲染函数。</p>
<h2 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h2><h3 id="Creating-Vnodes"><a href="#Creating-Vnodes" class="headerlink" title="Creating Vnodes"></a>Creating Vnodes</h3><p>Vue提供了<code>h()</code>函数用于创建vnode</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">const</span> vnode = <span class="title function_">h</span>(
  <span class="string">&#x27;div&#x27;</span>, <span class="comment">// type</span>
  &#123; <span class="attr">id</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">class</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, <span class="comment">// props</span>
  [
    <span class="comment">/* children */</span>
  ]
)</code></pre>

<p><code>h()</code>是 <strong>hyperscript</strong> 的缩写，意思是”生成HTML（超文本标记语言）的JavaScript”。这个名字来自于许多虚拟DOM实现时的共同约定。一个描述性更强的名称可以为<code>createVnode()</code>，但当你需要在渲染函数中多次调用时，一个更简短的名称会有所帮助。</p>
<p>这个<code>h()</code>函数设计的非常灵活</p>
<pre><code class="highlight js"><span class="comment">// all arguments except the type are optional</span>
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>)
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;foo&#x27;</span> &#125;)

<span class="comment">// both attributes and properties can be used in props</span>
<span class="comment">// Vue automatically picks the right way to assign it</span>
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">innerHTML</span>: <span class="string">&#x27;hello&#x27;</span> &#125;)

<span class="comment">// props modifiers such as `.prop` and `.attr` can be added</span>
<span class="comment">// with `.` and `^` prefixes respectively</span>
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="string">&#x27;.name&#x27;</span>: <span class="string">&#x27;some-name&#x27;</span>, <span class="string">&#x27;^width&#x27;</span>: <span class="string">&#x27;100&#x27;</span> &#125;)

<span class="comment">// class and style have the same object / array</span>
<span class="comment">// value support that they have in templates</span>
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: [foo, &#123; bar &#125;], <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125; &#125;)

<span class="comment">// event listeners should be passed as onXxx</span>
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;&#125; &#125;)

<span class="comment">// children can be a string</span>
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, <span class="string">&#x27;hello&#x27;</span>)

<span class="comment">// props can be omitted when there are no props</span>
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [<span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)])

<span class="comment">// children array can contain mixed vnodes and strings</span>
<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [<span class="string">&#x27;hello&#x27;</span>, <span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)])</code></pre>

<p>生成的vnode结构如下：</p>
<pre><code class="highlight js"><span class="keyword">const</span> vnode = <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, [])

vnode.<span class="property">type</span> <span class="comment">// &#x27;div&#x27;</span>
vnode.<span class="property">props</span> <span class="comment">// &#123; id: &#x27;foo&#x27; &#125;</span>
vnode.<span class="property">children</span> <span class="comment">// []</span>
vnode.<span class="property">key</span> <span class="comment">// null</span></code></pre>

<blockquote>
<p>Note<br>完整的VNode结构还包含许多其他内部属性，当强烈建议避免依赖以上所列的以外其他属性。这样可以避免在内部属性发生变化时出现意外中断。</p>
</blockquote>
<h3 id="Declaring-Render-Functions"><a href="#Declaring-Render-Functions" class="headerlink" title="Declaring Render Functions"></a>Declaring Render Functions</h3><p>在通过 Composition API 使用模版时，<code>setup()</code>的返回值是用于向模版暴露数据。但在使用渲染函数时，我们可以直接返回渲染函数：</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; ref, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">export</span> <span class="keyword">default</span> &#123;
  <span class="attr">props</span>: &#123;
    <span class="comment">/* ... */</span>
  &#125;,
  <span class="title function_">setup</span>(<span class="params">props</span>) &#123;
    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">1</span>)

    <span class="comment">// return the render function</span>
    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, props.<span class="property">msg</span> + count.<span class="property">value</span>)
  &#125;
&#125;</code></pre>

<p>因为渲染函数是在<code>setup()</code>内部声明的，所以它自然可以访问其同一作用域下声明的props和任意的响应数据。</p>
<p>除了返回单个vnode外，还可以返回字符串或者数组：</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">default</span> &#123;
  <span class="title function_">setup</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="string">&#x27;hello world!&#x27;</span>
  &#125;
&#125;</code></pre>

<pre><code class="highlight js"><span class="keyword">import</span> &#123; h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">export</span> <span class="keyword">default</span> &#123;
  <span class="title function_">setup</span>(<span class="params"></span>) &#123;
    <span class="comment">// use an array to return multiple root nodes</span>
    <span class="keyword">return</span> <span class="function">() =&gt;</span> [
      <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>),
      <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>),
      <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>)
    ]
  &#125;
&#125;</code></pre>

<blockquote>
<p>TIP<br>确保返回的是一个函数，而不是直接返回值！因为每个组件的<code>setup()</code>只会调用一次，而返回的渲染函数会被调用多次。</p>
</blockquote>
<p>如果渲染函数不需要任何实例状态，你也可以直接声明一个函数：</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">Hello</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> <span class="string">&#x27;hello world!&#x27;</span>
&#125;</code></pre>

<p>没错，这是一个有效的Vue组件！有关此语法的更多详情，可以查看 <a href="https://vuejs.org/guide/extras/render-function.html#functional-components">Functional Components</a></p>
<h3 id="Vnodes-Must-Be-Unique"><a href="#Vnodes-Must-Be-Unique" class="headerlink" title="Vnodes Must Be Unique"></a>Vnodes Must Be Unique</h3><p>组件树中的所有vnode必须是唯一的。下面的渲染函数就意味着是无效的：</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> p = <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)
  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [
    <span class="comment">// Yikes - duplicate vnodes!</span>
    p,
    p
  ])
&#125;</code></pre>

<p>如果你真的想多次复制相同的元素&#x2F;组件，可以使用工厂函数来实现。比如，下面的渲染函数就是渲染了20个相同内容的有效方法：</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> <span class="title function_">h</span>(
    <span class="string">&#x27;div&#x27;</span>,
    <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">20</span> &#125;).<span class="title function_">map</span>(<span class="function">() =&gt;</span> &#123;
      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)
    &#125;)
  )
&#125;</code></pre>

<h2 id="JSX-x2F-TSX​"><a href="#JSX-x2F-TSX​" class="headerlink" title="JSX &#x2F; TSX​"></a>JSX &#x2F; TSX​</h2><p><a href="https://facebook.github.io/jsx/">JSX</a>是JavaScript的XML扩展，可以让我们写出以下代码：</p>
<pre><code class="highlight jsx"><span class="keyword">const</span> vnode = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></code></pre>

<p>在JSX表达式中，使用花括号嵌入动态值：</p>
<pre><code class="highlight jsx"><span class="keyword">const</span> vnode = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;dynamicId&#125;</span>&gt;</span>hello, &#123;userName&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></code></pre>

<p><strong>create-vue</strong>和Vue CLI都有在脚手架配置项中进行了JSX支持。如果你要手动配置JSX，请参阅<a href="https://github.com/vuejs/babel-plugin-jsx">@vue&#x2F;babel-plugin-jsx</a>文档了解详情。</p>
<p>虽然JSX最初是由React引入的，但它实际上并没有定义运行时语义，可以编译成各种不同的输出。如果你以前使用过JSX，需注意Vue的JSX转换和React的JSX转换是不同的，所以你不能在Vue应用中使用React的JSX转换，具体与React JSX的一些明显区别包括：</p>
<ul>
<li>你可以使用<code>class</code>和<code>for</code>等HTML属性作为props，无需使用<code>className</code>或者<code>htmlFor</code>。</li>
<li>将子元素传递给组件(即插槽)的工作方式有所不同。</li>
</ul>
<p>Vue的类型定义还为TSX的使用提供了类型推断。使用TSX时，确保在tsconfig.json中指定<code>&quot;jsx&quot;: &quot;preserve&quot;</code>，以便在TypeScript保留JSX语法，供Vue JSX转换处理。</p>
<h3 id="JSX-Type-Inference"><a href="#JSX-Type-Inference" class="headerlink" title="JSX Type Inference"></a>JSX Type Inference</h3><p>与transform一样，Vue的JSX也需要不同的类型定义。目前，Vue会自动全局注册Vue的JSX类型。这意味着，当Vue的类型可用时，TSX就能开箱即用。</p>
<p>Vue的全局JSX类型可能会与其他同样需要JSX类型推导的库发生冲突，特别是React。从3.3版本开始，Vue支持通过TypeScript的jsxImportSource选项指定JSX命名空间。我们计划在3.4版本中移除默认的全局JSX命名空间注册。</p>
<p>对于TSX用户，建议在升级到3.3之后在 tsconfig.json 中将 jsxImportSource 选项设置为 “vue”，或者在每个文件中使用 <code>/* @jsxImportSource vue */</code>。这样，你现在就可以选择加入新行为，并在 3.4 发布时无缝升级。</p>
<p>如果有代码依赖于全局JSX命名空间，你可以通过显式引用 vue&#x2F;jsx（它会注册全局 JSX 命名空间）来保留完全相同的 3.4 之前的全局行为</p>
<h2 id="Render-Function-Recipes"><a href="#Render-Function-Recipes" class="headerlink" title="Render Function Recipes"></a>Render Function Recipes</h2><p>下面我们会提供一些用等价的渲染函数&#x2F;JSX实现模版功能的常用方法。</p>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>template:</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span>&gt;</span>
  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span>
  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>no<span class="tag">&lt;/<span class="name">span</span>&gt;</span>
<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre>

<p>等价 渲染函数&#x2F;JSX:</p>
<pre><code class="highlight js"><span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [ok.<span class="property">value</span> ? <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;yes&#x27;</span>) : <span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;no&#x27;</span>)])</code></pre>

<pre><code class="highlight jsx">&lt;div&gt;&#123;ok.<span class="property">value</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>no<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;&lt;/div&gt;</code></pre>

<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>template:</p>
<pre><code class="highlight html"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>
  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;&#123; id, text &#125; in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span>
    &#123;&#123; text &#125;&#125;
  <span class="tag">&lt;/<span class="name">li</span>&gt;</span>
<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></code></pre>

<p>等价 渲染函数&#x2F;JSX:</p>
<pre><code class="highlight js"><span class="title function_">h</span>(
  <span class="string">&#x27;ul&#x27;</span>,
  <span class="comment">// assuming `items` is a ref with array value</span>
  items.<span class="property">value</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; id, text &#125;</span>) =&gt;</span> &#123;
    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">key</span>: id &#125;, text)
  &#125;)
)</code></pre>

<pre><code class="highlight jsx">&lt;ul&gt;
  &#123;items.<span class="property">value</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; id, text &#125;</span>) =&gt;</span> &#123;
    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;id&#125;</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>
  &#125;)&#125;
&lt;/ul&gt;</code></pre>

<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>props名称以<code>on</code>开头且后面跟大写字母的被视为事件监听器。比如，<code>onClick</code>相当于模版的<code>@click</code>。</p>
<pre><code class="highlight js"><span class="title function_">h</span>(
  <span class="string">&#x27;button&#x27;</span>,
  &#123;
    <span class="title function_">onClick</span>(<span class="params">event</span>) &#123;
      <span class="comment">/* ... */</span>
    &#125;
  &#125;,
  <span class="string">&#x27;click me&#x27;</span>
)</code></pre>

<pre><code class="highlight jsx">&lt;button
  onClick=&#123;<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;
    <span class="comment">/* ... */</span>
  &#125;&#125;
&gt;
  click me
&lt;/button&gt;</code></pre>

<h3 id="Event-Modifiers"><a href="#Event-Modifiers" class="headerlink" title="Event Modifiers"></a>Event Modifiers</h3><p>对于<code>.passive</code>，<code>.capture</code>和<code>.once</code>事件修饰符，可以驼峰写法在事件名称后面进行连接。</p>
<p>例如：</p>
<pre><code class="highlight js"><span class="title function_">h</span>(<span class="string">&#x27;input&#x27;</span>, &#123;
  <span class="title function_">onClickCapture</span>(<span class="params"></span>) &#123;
    <span class="comment">/* listener in capture mode */</span>
  &#125;,
  <span class="title function_">onKeyupOnce</span>(<span class="params"></span>) &#123;
    <span class="comment">/* triggers only once */</span>
  &#125;,
  <span class="title function_">onMouseoverOnceCapture</span>(<span class="params"></span>) &#123;
    <span class="comment">/* once + capture */</span>
  &#125;
&#125;)</code></pre>

<pre><code class="highlight jsx">&lt;input
  onClickCapture=&#123;<span class="function">() =&gt;</span> &#123;&#125;&#125;
  onKeyupOnce=&#123;<span class="function">() =&gt;</span> &#123;&#125;&#125;
  onMouseoverOnceCapture=&#123;<span class="function">() =&gt;</span> &#123;&#125;&#125;
/&gt;</code></pre>

<p>然后其余的事件和按键修饰符，可以使用<code>withModifiers</code>协助使用：</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; withModifiers &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123;
  <span class="attr">onClick</span>: <span class="title function_">withModifiers</span>(<span class="function">() =&gt;</span> &#123;&#125;, [<span class="string">&#x27;self&#x27;</span>])
&#125;)</code></pre>

<pre><code class="highlight jsx">&lt;div onClick=&#123;<span class="title function_">withModifiers</span>(<span class="function">() =&gt;</span> &#123;&#125;, [<span class="string">&#x27;self&#x27;</span>])&#125; /&gt;</code></pre>

<h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p>要为组件创建vnode，传递给<code>h()</code>的第一个参数应该是组件定义。这就意味着使用渲染函数时，无需注册组件，只是直接使用导入的组件即可：</p>
<pre><code class="highlight js"><span class="keyword">import</span> <span class="title class_">Foo</span> <span class="keyword">from</span> <span class="string">&#x27;./Foo.vue&#x27;</span>
<span class="keyword">import</span> <span class="title class_">Bar</span> <span class="keyword">from</span> <span class="string">&#x27;./Bar.jsx&#x27;</span>

<span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, [<span class="title function_">h</span>(<span class="title class_">Foo</span>), <span class="title function_">h</span>(<span class="title class_">Bar</span>)])
&#125;</code></pre>

<pre><code class="highlight jsx"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> (
    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span>
<span class="language-xml">      <span class="tag">&lt;<span class="name">Foo</span> /&gt;</span></span>
<span class="language-xml">      <span class="tag">&lt;<span class="name">Bar</span> /&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
  )
&#125;</code></pre>

<p>正如我们看到的，只要是有效的Vue组件，h函数就能处理任何文件格式导入的组件。</p>
<p>动态组件在渲染组件中可直接使用：</p>
<pre><code class="highlight js"><span class="keyword">import</span> <span class="title class_">Foo</span> <span class="keyword">from</span> <span class="string">&#x27;./Foo.vue&#x27;</span>
<span class="keyword">import</span> <span class="title class_">Bar</span> <span class="keyword">from</span> <span class="string">&#x27;./Bar.jsx&#x27;</span>

<span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> ok.<span class="property">value</span> ? <span class="title function_">h</span>(<span class="title class_">Foo</span>) : <span class="title function_">h</span>(<span class="title class_">Bar</span>)
&#125;</code></pre>

<pre><code class="highlight jsx"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> ok.<span class="property">value</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">Bar</span> /&gt;</span></span>
&#125;</code></pre>

<p>如果组件是用名称注册的，无法直接导入(例如，有库进行的全局注册)，这种情况可以使用<code>resolveComponent</code>来解析该组件。</p>
<h3 id="Rendering-Slots"><a href="#Rendering-Slots" class="headerlink" title="Rendering Slots"></a>Rendering Slots</h3><p>在渲染函数中，可以通过<code>setup()</code>的上下文访问slot。然后slots对象上的每一个slot都是一个函数，会返回一个vnodes数组：</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">default</span> &#123;
  <span class="attr">props</span>: [<span class="string">&#x27;message&#x27;</span>],
  <span class="title function_">setup</span>(<span class="params">props, &#123; slots &#125;</span>) &#123;
    <span class="keyword">return</span> <span class="function">() =&gt;</span> [
      <span class="comment">// default slot:</span>
      <span class="comment">// &lt;div&gt;&lt;slot /&gt;&lt;/div&gt;</span>
      <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, slots.<span class="title function_">default</span>()),

      <span class="comment">// named slot:</span>
      <span class="comment">// &lt;div&gt;&lt;slot name=&quot;footer&quot; :text=&quot;message&quot; /&gt;&lt;/div&gt;</span>
      <span class="title function_">h</span>(
        <span class="string">&#x27;div&#x27;</span>,
        slots.<span class="title function_">footer</span>(&#123;
          <span class="attr">text</span>: props.<span class="property">message</span>
        &#125;)
      )
    ]
  &#125;
&#125;</code></pre>

<p>JSX：</p>
<pre><code class="highlight js"><span class="comment">// default</span>
&lt;div&gt;&#123;slots.<span class="title function_">default</span>()&#125;&lt;/div&gt;

<span class="comment">// named</span>
<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;slots.footer(&#123; text: props.message &#125;)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></code></pre>

<h3 id="Passing-Slots"><a href="#Passing-Slots" class="headerlink" title="Passing Slots"></a>Passing Slots</h3><p>将子元素传递给组件和子元素传递给元素的方式有些不同。我们不需要传递数组，而是传递slot函数或者slot函数对象。slot函数可以返回与普通渲染函数的返回值一样的内容，并且在子组件访问时，这些内容将始终会转换为一个vnodes数组。</p>
<pre><code class="highlight js"><span class="comment">// 单个默认插槽</span>
<span class="title function_">h</span>(<span class="title class_">MyComponent</span>, <span class="function">() =&gt;</span> <span class="string">&#x27;hello&#x27;</span>)

<span class="comment">// 具名插槽</span>
<span class="comment">// 注意 `null` 是必需的</span>
<span class="comment">// 以避免 slot 对象被当成 prop 处理</span>
<span class="title function_">h</span>(<span class="title class_">MyComponent</span>, <span class="literal">null</span>, &#123;
    <span class="attr">default</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;default slot&#x27;</span>,
    <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>),
    <span class="attr">bar</span>: <span class="function">() =&gt;</span> [<span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;one&#x27;</span>), <span class="title function_">h</span>(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)]
&#125;)</code></pre>

<p>等价的JSX：</p>
<pre><code class="highlight jsx"><span class="comment">// default</span>
&lt;<span class="title class_">MyComponent</span>&gt;&#123;<span class="function">() =&gt;</span> <span class="string">&#x27;hello&#x27;</span>&#125;&lt;/<span class="title class_">MyComponent</span>&gt;

<span class="comment">// named</span>
<span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>&#123;&#123;</span>
<span class="language-xml">  default: () =&gt; &#x27;default slot&#x27;,</span>
<span class="language-xml">  foo: () =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span>
<span class="language-xml">  bar: () =&gt; [<span class="tag">&lt;<span class="name">span</span>&gt;</span>one<span class="tag">&lt;/<span class="name">span</span>&gt;</span>, <span class="tag">&lt;<span class="name">span</span>&gt;</span>two<span class="tag">&lt;/<span class="name">span</span>&gt;</span>]</span>
<span class="language-xml">&#125;&#125;<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></code></pre>

<p>将slot作为函数传递给子组件，可以让子组件懒散地调用slot。这样，子组件而不是父组件就能跟踪slot的依赖关系，从而实现更准确、更有效的更新。</p>
<h3 id="Built-in-Components"><a href="#Built-in-Components" class="headerlink" title="Built-in Components"></a>Built-in Components</h3><p>内置组件如<code>&lt;KeepAlive&gt;</code>, <code>&lt;Transition&gt;</code>, <code>&lt;TransitionGroup&gt;</code>, <code>&lt;Teleport&gt;</code> 和 <code>&lt;Suspense&gt;</code>必须导入才能在渲染函数中使用</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; h, <span class="title class_">KeepAlive</span>, <span class="title class_">Teleport</span>, <span class="title class_">Transition</span>, <span class="title class_">TransitionGroup</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">export</span> <span class="keyword">default</span> &#123;
  setup () &#123;
    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="title class_">Transition</span>, &#123; <span class="attr">mode</span>: <span class="string">&#x27;out-in&#x27;</span> &#125;, <span class="comment">/* ... */</span>)
  &#125;
&#125;</code></pre>

<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>在模版编译过程中，<code>v-model</code>指令会扩展为<code>modelValue</code>和<code>onUpdate:modelValue</code>两个props，在渲染函数中就必须自己提供这些props：</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">default</span> &#123;
  <span class="attr">props</span>: [<span class="string">&#x27;modelValue&#x27;</span>],
  <span class="attr">emits</span>: [<span class="string">&#x27;update:modelValue&#x27;</span>],
  <span class="title function_">setup</span>(<span class="params">props, &#123; emit &#125;</span>) &#123;
    <span class="keyword">return</span> <span class="function">() =&gt;</span>
      <span class="title function_">h</span>(<span class="title class_">SomeComponent</span>, &#123;
        <span class="attr">modelValue</span>: props.<span class="property">modelValue</span>,
        <span class="string">&#x27;onUpdate:modelValue&#x27;</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="title function_">emit</span>(<span class="string">&#x27;update:modelValue&#x27;</span>, value)
      &#125;)
  &#125;
&#125;</code></pre>

<h3 id="Custom-Directives"><a href="#Custom-Directives" class="headerlink" title="Custom Directives"></a>Custom Directives</h3><p>自定义指令可以通过<code>withDirectives</code>应用到vnode：</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; h, withDirectives &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="comment">// a custom directive</span>
<span class="keyword">const</span> pin = &#123;
  <span class="title function_">mounted</span>(<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;,
  <span class="title function_">updated</span>(<span class="params"></span>) &#123; <span class="comment">/* ... */</span> &#125;
&#125;

<span class="comment">// &lt;div v-pin:top.animate=&quot;200&quot;&gt;&lt;/div&gt;</span>
<span class="keyword">const</span> vnode = <span class="title function_">withDirectives</span>(<span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>), [
  [pin, <span class="number">200</span>, <span class="string">&#x27;top&#x27;</span>, &#123; <span class="attr">animate</span>: <span class="literal">true</span> &#125;]
])</code></pre>

<p>如果指令是通过名字注册的，是无法直接导入的，需要使用<code>resolveDirective</code>对其进行解析。</p>
<h3 id="Template-Refs"><a href="#Template-Refs" class="headerlink" title="Template Refs"></a>Template Refs</h3><p>在使用组合式API时，模版ref是通过<code>ref()</code>本身作为props传递给vnode创建的</p>
<pre><code class="highlight js"><span class="keyword">import</span> &#123; h, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">export</span> <span class="keyword">default</span> &#123;
  <span class="title function_">setup</span>(<span class="params"></span>) &#123;
    <span class="keyword">const</span> divEl = <span class="title function_">ref</span>()

    <span class="comment">// &lt;div ref=&quot;divEl&quot;&gt;</span>
    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">ref</span>: divEl &#125;)
  &#125;
&#125;</code></pre>

<h2 id="Functional-Components"><a href="#Functional-Components" class="headerlink" title="Functional Components"></a>Functional Components</h2><p>函数组件是组件的另一种形式，自身没有任何状态。执行的内容就像纯函数，props输入，vnode输出。在渲染时不创建组件实例(即没有<code>this</code>)，也没有一些组件声明周期钩子。</p>
<p>我们会通过一个普通函数来创建一个函数组件，而不是一个选项对象。该函数实际上就是组件的渲染函数。</p>
<p>函数组件的签名与<code>setup()</code>hook相同：</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props, &#123; slots, emit, attrs &#125;</span>) &#123;
  <span class="comment">// ...</span>
&#125;</code></pre>

<p>组件的大多数常规配置选项都不适用于函数组件。不过，可以通过添加属性来定义<code>props</code>和<code>emits</code>：</p>
<pre><code class="highlight js"><span class="title class_">MyComponent</span>.<span class="property">props</span> = [<span class="string">&#x27;value&#x27;</span>]
<span class="title class_">MyComponent</span>.<span class="property">emits</span> = [<span class="string">&#x27;click&#x27;</span>]</code></pre>

<p>如果未指定props选项，那么传递给函数的props对象将包含所有属性，与attrs相同。除非指定来props选项，否则props名称不会规范为驼峰。</p>
<p>对于没有明确props的函数组件，属性穿透的工作原理与普通组件大致相同。但是，对于没有明确指定props的函数组件，默认情况下将会从<code>attrs</code>继承<code>class</code>、<code>style</code>和<code>onXxx</code>事件侦听器。无论是哪种情况，都可以将<code>inheritAttrs</code>设为<code>false</code>以禁用属性继承：</p>
<pre><code class="highlight js"><span class="title class_">MyComponent</span>.<span class="property">inheritAttrs</span> = <span class="literal">false</span></code></pre>

<p>函数组件可以像普通组件一样注册和使用。如果将函数作为<code>h()</code>的第一个参数，它会被视为函数组件。</p>
<h3 id="Typing-Functional-Components"><a href="#Typing-Functional-Components" class="headerlink" title="Typing Functional Components"></a>Typing Functional Components</h3><p>函数组件可根据其命名或匿名类型来进行标注类型。在SFC模板中使用时，Volar还支持对其进行类型检查。</p>
<p>具名函数组件</p>
<pre><code class="highlight tsx"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">SetupContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>
<span class="keyword">type</span> <span class="title class_">FComponentProps</span> = &#123;
  <span class="attr">message</span>: <span class="built_in">string</span>
&#125;

<span class="keyword">type</span> <span class="title class_">Events</span> = &#123;
  <span class="title function_">sendMessage</span>(<span class="attr">message</span>: <span class="built_in">string</span>): <span class="built_in">void</span>
&#125;

<span class="keyword">function</span> <span class="title function_">FComponent</span>(<span class="params"></span>
<span class="params">  props: FComponentProps,</span>
<span class="params">  context: SetupContext&lt;Events&gt;</span>
<span class="params"></span>) &#123;
  <span class="keyword">return</span> (
    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> context.emit(&#x27;sendMessage&#x27;, props.message)&#125;&gt;</span>
<span class="language-xml">        &#123;props.message&#125; &#123;&#x27; &#x27;&#125;</span>
<span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>
  )
&#125;

<span class="title class_">FComponent</span>.<span class="property">props</span> = &#123;
  <span class="attr">message</span>: &#123;
    <span class="attr">type</span>: <span class="title class_">String</span>,
    <span class="attr">required</span>: <span class="literal">true</span>
  &#125;
&#125;

<span class="title class_">FComponent</span>.<span class="property">emits</span> = &#123;
  <span class="attr">sendMessage</span>: <span class="function">(<span class="params">value: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>
&#125;</code></pre>

<p>匿名函数组件</p>
<pre><code class="highlight tsx"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">FunctionalComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>

<span class="keyword">type</span> <span class="title class_">FComponentProps</span> = &#123;
  <span class="attr">message</span>: <span class="built_in">string</span>
&#125;

<span class="keyword">type</span> <span class="title class_">Events</span> = &#123;
  <span class="title function_">sendMessage</span>(<span class="attr">message</span>: <span class="built_in">string</span>): <span class="built_in">void</span>
&#125;

<span class="keyword">const</span> <span class="title class_">FComponent</span>: <span class="title class_">FunctionalComponent</span>&lt;<span class="title class_">FComponentProps</span>, <span class="title class_">Events</span>&gt; = <span class="function">(<span class="params"></span></span>
<span class="params"><span class="function">  props,</span></span>
<span class="params"><span class="function">  context</span></span>
<span class="params"><span class="function"></span>) =&gt;</span> &#123;
  <span class="keyword">return</span> (
    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> context.emit(&#x27;sendMessage&#x27;, props.message)&#125;&gt;</span>
<span class="language-xml">        &#123;props.message&#125; &#123;&#x27; &#x27;&#125;</span>
<span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>
  )
&#125;

<span class="title class_">FComponent</span>.<span class="property">props</span> = &#123;
  <span class="attr">message</span>: &#123;
    <span class="attr">type</span>: <span class="title class_">String</span>,
    <span class="attr">required</span>: <span class="literal">true</span>
  &#125;
&#125;

<span class="title class_">FComponent</span>.<span class="property">emits</span> = &#123;
  <span class="attr">sendMessage</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span>
&#125;</code></pre>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Rendering Mechanism</title>
    <url>/2023/08/13/%E3%80%90%E7%BF%BB%E3%80%91Rendering-Mechanism/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://vuejs.org/guide/extras/rendering-mechanism.html">Rendering Mechanism</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Vue 是如何将 template 转换为真实的DOM节点？又是如何高效地更新这些节点？接下来我们会通过研究Vue内部的渲染机制，来解释这些问题。</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>你也许听过”虚拟DOM”这个概念，Vue的渲染就是基于它实现的</p>
<p>虚拟DOM（VDOM）是一个编程概念，他将用户所需的界面通过虚拟节点(对象结构)保存在内存中，并与真实的DOM节点同步。这个概念是由 React 首创，并被Vue在内的许多其他框架以不同的实现方式采用</p>
<p>虚拟DOM更像是一种模式，而不是一种特定的技术，因此不存在某种标准的实现方式，我们可以通过一个简单的例子来说明：</p>
<pre><code class="highlight js"><span class="keyword">const</span> vnode = &#123;
  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,
  <span class="attr">props</span>: &#123;
    <span class="attr">id</span>: <span class="string">&#x27;hello&#x27;</span>
  &#125;,
  <span class="attr">children</span>: [
    <span class="comment">/* more vnodes */</span>
  ]
&#125;</code></pre>

<p>在上面这个例子中，vnode 是一个纯 JavaScript 对象，表示一个 <code>&lt;div&gt;</code>元素。它包含了我们创建真实DOM所需的所有信息。它还包含了更多的子节点，这就使它成为了虚拟DOM树的根节点。</p>
<p>然后一个运行时的渲染器(runtime renderer)遍历这个虚拟DOM树，并使其构建为一个真实的DOM树，这一过程称为挂载(mount)。</p>
<p>如果我们有两个虚拟DOM树，渲染器也可以对这个树进行遍历和对比，找出不同之处。然后将这些不同之处的更改应用到真实DOM上。这个过程称为 patch，也可以称为”diffing”或者”reconciliation”</p>
<p>虚拟DOM的主要优势在于，可以让开发人员以声明的方式，创建、检查和组合所需的用户界面结构，而真实DOM的操作就留给渲染器去实现</p>
<h2 id="Render-Pipeline"><a href="#Render-Pipeline" class="headerlink" title="Render Pipeline"></a>Render Pipeline</h2><p>从高层次来看，挂载Vue组件时会发生以下几件事：</p>
<ol>
<li><p><strong>Compile</strong>：Vue 模版会被编译成渲染函数：渲染函数会返回虚拟DOM树，这一步可以是在构建之前完成，也可以在运行时渲染器即时完成的。</p>
</li>
<li><p><strong>Mount</strong>：运行时渲染器会调用渲染函数，然后遍历返回的虚拟DOM树，并以此创建真实DOM节点。这一步是在响应式副作用中执行，因此它会跟踪所有使用过的响应式依赖项。</p>
</li>
<li><p><strong>Patch</strong>：当挂载期间使用过的依赖数据发生变化时，副作用会重新运行。这时，会创建一个新的并且经过更新的虚拟DOM树。然后运行时渲染器会遍历新的DOM树，并与旧的DOM树进行对比，并将必要的更新应用到真实DOM上。</p>
</li>
</ol>
<p><img src="https://cn.vuejs.org/assets/render-pipeline.03805016.png"></p>
<h2 id="Templates-vs-Render-Functions"><a href="#Templates-vs-Render-Functions" class="headerlink" title="Templates vs. Render Functions"></a>Templates vs. Render Functions</h2><p>Vue模版会被编译成虚拟DOM渲染函数。另外Vue也提供了一些API可以跳过模版编译阶段直接编写渲染函数。当你在处理高度动态的逻辑时，直接编写渲染函数比模版更加灵活，因为你可以使用javascript的全部功能来处理 vnodes</p>
<p>那为什么Vue默认推荐使用模版呢？有几个原因：</p>
<ol>
<li><p>模版更接近真实的HTML。这样就更容易的复用现有的HTML代码段，并有更好的可读性，更能方便地使用CSS样式，并且设计师更容易理解和修改。</p>
</li>
<li><p>模版的语法更加确定，因此更容易进行静态分析。这就可以让Vue的模版编译器在编译时有更多的优化，以提高虚拟DOM的性能(这个我们会在下面讨论)。</p>
</li>
</ol>
<p>在实践中，模版足以满足应用中的大多用例。渲染函数通常只需要处理高度动态渲染逻辑的可重用组件。如果想了解更多渲染函数的使用，可以去 <a href="https://vuejs.org/guide/extras/render-function.html"><strong>Render Functions &amp; JSX</strong></a> 中继续阅读</p>
<h2 id="Compiler-Informed-Virtual-DOM"><a href="#Compiler-Informed-Virtual-DOM" class="headerlink" title="Compiler-Informed Virtual DOM"></a>Compiler-Informed Virtual DOM</h2><p>React 中的虚拟DOM和大多数虚拟DOM实现都是单纯的运行时实现：reconciliation 算法无法预知传入的虚拟DOM树，所以它必须完全遍历，并对比每个vnode的props，以确保正确性。另外 ，即使DOM树的其中一部分从未改变，每次重新渲染时也会为它们创建新的vnode，从而造成不必要的内存压力。这也是虚拟DOM最为人诟病的地方之一：粗暴的更新过程牺牲了效率，却换来了代码的声明性和正确性</p>
<p>但其实不必如此。在Vue中，框架同时控制了编译器和运行时。这可以让我们实现许多编译时的优化，只有编译时和渲染时紧密耦合才能利用这些优化。编译器可以静态分析模版，并在生成的代码中留下提示，这样运行时就可能通过这些提示走捷径。同时，我们仍然保留了用户在某些边界情况想要使用底层渲染函数的能力。我们将这种混合实现称为带编译时信息的虚拟 DOM (Compiler-Informed Virtual DOM)</p>
<p>在下面，我们将讨论Vue编译器为提高虚拟DOM运行时性能而进行的几项主要优化。</p>
<h3 id="Static-Hoisting"><a href="#Static-Hoisting" class="headerlink" title="Static Hoisting"></a>Static Hoisting</h3><p>在模版中经常会出现不包含任何动态绑定的部分：</p>
<pre><code class="highlight js">&lt;div&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> &lt;!-- hoisted --&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> &lt;!-- hoisted --&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; dynamic &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
&lt;/div&gt;

<span class="comment">// ==&gt; after compile</span>

<span class="keyword">import</span> &#123; createElementVNode <span class="keyword">as</span> _createElementVNode, createCommentVNode <span class="keyword">as</span> _createCommentVNode, toDisplayString <span class="keyword">as</span> _toDisplayString, openBlock <span class="keyword">as</span> _openBlock, createElementBlock <span class="keyword">as</span> _createElementBlock &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>

<span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;foo&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)
<span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createElementVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;bar&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)

<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;
  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [
    _hoisted_1,
    <span class="title function_">_createCommentVNode</span>(<span class="string">&quot; hoisted &quot;</span>),
    _hoisted_2,
    <span class="title function_">_createCommentVNode</span>(<span class="string">&quot; hoisted &quot;</span>),
    <span class="title function_">_createElementVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">dynamic</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)
  ]))
&#125;</code></pre>

<p><code>foo</code> 和 <code>bar</code>的<code>div</code>元素是静态的，因此在每次重新渲染时重新创建vnode并进行diffing处理是没必要的。Vue编译器会自动将静态部分从渲染函数中移出到外面，并在每次渲染时重复使用相同的vnode。当渲染器发现旧的vnode和新的vnode是同一个时，它还可以完全跳过它们的diffing处理</p>
<p>此外，如果有足够多的连续静态元素，它们将组合成一个”静态vnode”，其中包含这些节点的纯HTML字符串。然后这些vnode可以直接通过<code>innerHTML</code>来加载。在初始挂载时，它们也会缓存相应的DOM节点，如果同一内容在应用的其他地方重复使用后，就会通过本地的<code>cloneNode()</code>创建新的DOM节点，这样做会非常高效。</p>
<h3 id="Patch-Flags"><a href="#Patch-Flags" class="headerlink" title="Patch Flags"></a>Patch Flags</h3><p>对于动态绑定的单个元素，我们也可以在编译时从中推断出很多信息：</p>
<pre><code class="highlight js">&lt;!-- <span class="keyword">class</span> <span class="title class_">binding</span> only --&gt;
<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; active &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>

&lt;!-- id and value bindings only --&gt;
<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:id</span>=<span class="string">&quot;id&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml"><span class="comment">&lt;!-- text children only --&gt;</span></span>
<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; dynamic &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml"></span>
<span class="language-xml">// ==&gt; after compile</span>
<span class="language-xml"></span>
<span class="language-xml">import &#123; normalizeClass as _normalizeClass, createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock &#125; from &quot;vue&quot;</span>
<span class="language-xml"></span>
<span class="language-xml">export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;</span>
<span class="language-xml">  return (_openBlock(), _createElementBlock(_Fragment, null, [</span>
<span class="language-xml">    _createElementVNode(&quot;div&quot;, &#123;</span>
<span class="language-xml">      class: _normalizeClass(&#123; active: _ctx.active &#125;)</span>
<span class="language-xml">    &#125;, null, 2 /* CLASS */),</span>
<span class="language-xml">    _createElementVNode(&quot;input&quot;, &#123;</span>
<span class="language-xml">      id: _ctx.id,</span>
<span class="language-xml">      value: _ctx.value</span>
<span class="language-xml">    &#125;, null, 8 /* PROPS */, [&quot;id&quot;, &quot;value&quot;]),</span>
<span class="language-xml">    _createElementVNode(&quot;div&quot;, null, _toDisplayString(_ctx.dynamic), 1 /* TEXT */)</span>
<span class="language-xml">  ], 64 /* STABLE_FRAGMENT */))</span>
<span class="language-xml">&#125;</span>
<span class="language-xml"></span></code></pre>

<p>在为这些元素生成渲染函数代码时，Vue会在vnode创建调用中直接编码每个元素所需的更新类型：</p>
<pre><code class="highlight js"><span class="title function_">createElementVNode</span>(<span class="string">&quot;div&quot;</span>, &#123;
  <span class="attr">class</span>: <span class="title function_">_normalizeClass</span>(&#123; <span class="attr">active</span>: _ctx.<span class="property">active</span> &#125;)
&#125;, <span class="literal">null</span>, <span class="number">2</span> <span class="comment">/* CLASS */</span>)</code></pre>

<p>最后一个参数2是patch flag。一个元素可以有多个flag，这些flag会合并成一个数字。然后，运行时渲染器可以通过位运算检查这些flag，用于确定是否需要执行某些更新操作：</p>
<pre><code class="highlight js"><span class="keyword">if</span> (vnode.<span class="property">patchFlag</span> &amp; <span class="title class_">PatchFlags</span>.<span class="property">CLASS</span> <span class="comment">/* 2 */</span>) &#123;
  <span class="comment">// update the element&#x27;s class</span>
&#125;</code></pre>

<p>位运算检查速度极快。有了patch flags，Vue就能通过最少的更新操作来更新具有动态绑定的元素</p>
<p>Vue还会给vnode的子节点类型进行编码。例如，具有多个根节点的模版被表示为一个片段。在大多数情况下，我们可以确定这些根节点的顺序永远不会改变，所以可以将这个信息通过标记提供给运行时</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(_Fragment, <span class="literal">null</span>, [
    <span class="comment">/* children */</span>
  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))
&#125;
</code></pre>

<p>所以，运行时可以完全跳过根片段的子序列顺序的协调过程</p>
<h3 id="Tree-Flattening"><a href="#Tree-Flattening" class="headerlink" title="Tree Flattening"></a>Tree Flattening</h3><p>再看一下上一个示例中生成的代码，你会发现返回的虚拟DOM树的根是通过一个特殊的 <code>createElementBlock()</code>调用创建的：</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;
  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(_Fragment, <span class="literal">null</span>, [
    <span class="comment">/* children */</span>
  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))
&#125;</code></pre>

<p>从概念上看，“block”是模版中具有稳定内部结构的一部分。在这个示例中，整个模版只有一个block，因为它不包含任何结构指令，如<code>v-if</code>和<code>v-for</code></p>
<p>每个block都会追踪任何有patch flags的后代节点(不只是直接子节点)。例如：</p>
<pre><code class="highlight js">&lt;div&gt; &lt;!-- root block --&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>         &lt;!-- not tracked --&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>   &lt;!-- tracked --&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>                  <span class="comment">&lt;!-- not tracked --&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; bar &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- tracked --&gt;</span></span>
<span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
&lt;/div&gt;</code></pre>

<p>这个结果是一个只包含动态子节点的扁平化数组：</p>
<pre><code class="highlight js">div (block root)
- div <span class="keyword">with</span> :id binding
- div <span class="keyword">with</span> &#123;&#123; bar &#125;&#125; binding</code></pre>

<p>当组件需要重新渲染时，它只需要遍历这个扁平化的树而不是整棵树。这就所谓的 Tree Flattening，它大大减少了虚拟DOM协调过程中需要遍历的节点数量。模版中的任何静态部分都会高效略过。</p>
<p><code>v-if</code>和<code>v-for</code>会创建新的block节点：</p>
<pre><code class="highlight js">&lt;div&gt; &lt;!-- root block --&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>&gt;</span> <span class="comment">&lt;!-- if block --&gt;</span></span>
<span class="language-xml">      ...</span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span>
<span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></code></pre>

<p>子block会在父block的动态后代数组中进行追踪。这就为父block保留了一个稳定的结构。</p>
<h2 id="Impact-on-SSR-Hydration"><a href="#Impact-on-SSR-Hydration" class="headerlink" title="Impact on SSR Hydration"></a>Impact on SSR Hydration</h2><p>patch flags 和 tree flattening 也会提高Vue的 <a href="https://vuejs.org/guide/scaling-up/ssr.html#client-hydration">SSR Hydration</a> 性能：</p>
<ul>
<li>单个元素的 hydration 可以根据 vnode 的 path flag 走更快的捷径。</li>
<li>只有block节点和其动态子节点在进行 hydration 时需要进行遍历，从而在模板级别实现部分 hydration。</li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Resource optimization in Node.js</title>
    <url>/2023/07/15/%E3%80%90%E7%BF%BB%E3%80%91Resource-optimization-in-Node-js/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://medium.com/pipedrive-engineering/resource-optimization-in-node-js-c90c731f9df4">Resource optimization in Node.js</a><br>原作者：<a href="https://medium.com/@nelson.gomes_64705">Nelson Gomes</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在这篇文章中，我们将探索Node.js最大优化的可能性，并了解资源共享的好处，反证每个请求都必须隔离的假设。加入我们，发掘Node.js的全部潜力，了解资源优化如何提高应用程序的性能和效率。</p>
<p>我们都知道Node.js速度快，单线程，无阻塞，但我们在开发中是否充分利用了呢？大多数情况下的答案是”没有”</p>
<p>因为它是单线程的，我们往往会忘记我们仍然有几个类似线程的执行方式！所以我们可以改进代码的执行方式，将线程获得的资源提供给其他线程使用，从而减少这些宝贵资源的负载。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Y7nbW1YwR2kEX-2hq16vA.png"></p>
<p>假设我们有一个端点调用一个API，并且该端点同时被许多客户端调用。因此，当第一个请求到达并需要调用该API时，第二个请求也到达并调用与第一个请求完全相同的API，为什么不共享它呢？</p>
<p>开发人员经常有个错误的假设，认为在Node.js服务器上工作时，每个请求都必须与其他请求完全隔离，每个请求都需要在与其他请求隔离的情况下进行调用和数据库请求。</p>
<p>事实并非如此。</p>
<p>如果满足某些情况，请求可以共享同一个资源：</p>
<ul>
<li>首先这个请求不是客户特定数据，或者没有使用 authentication token （我们绝不能混合这些请求，这意味着我们需要知道谁提出了请求）。</li>
<li>请求数据确保是完全相同。</li>
<li>我们要确保如果发生错误，不会将信息泄露给其他客户端(导致GDPR问题)，可以通过记录原始错误并向所有客户端发送一个通用错误来避免。</li>
<li>最后，它需要是一个频繁调用的请求，最好是需要一些时间来执行，这样资源共享对多个执行请求来说才有好处，否则好处几乎不会察觉</li>
</ul>
<p>关于请求流程，请查看下图，每一行代表一个请求，每个颜色条代表使用资源所花费的时间。因为每个请求都是完全独立的，我们并没有共享资源，而当应用程序进行数千个并发请求时这通常很重要，并且不容易解决。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyXUNpB0IYVS9pT780KbIw.png"></p>
<p>当我们拥有非常专门化的服务时，我们可能会有多个请求请求完全相同的资源，这是改进我们应用程序的机会。</p>
<p>请看，一些调用被Promise替代了。这是因为同样的资源已经被获取，所以我们决定共享它而不是再次调用，从而减轻资源的负载。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vCkIw3uTwjUSTsoAj6V5iA.png"></p>
<p>在Java等语言中，开发者使用同步方法来控制资源访问。而对于Node.js有个好处，由于Node.js的架构，不需要对 mutexes 或 semaphores 进行昂贵的系统调用，这使得Node.js的速度更快。</p>
<p>当然，在这个例子中，我说的是服务的单个实例。在多个服务实例上进行此操作稍微复杂一下。尽管概念是相似的（我正在研究更高级的分布式模式）</p>
<p>这个优化点的有趣之处不仅在于节省资源，实际上，它还能让你的应用程序变得更快。你可能会问。怎么可能？让我们假设一个操作耗时200ms，并且同一操作的任何后续请求都会重复使用该操作。这意味着，在这200ms内任何传入的请求都将重用该结果，即使它是在初始操作开始1ms后或200ms后开始的，因此重用操作平均耗时200ms&#x2F;2&#x3D;100ms。</p>
<p>通过重复这些操作，你将平均节省一半的时间，这是一个极大的优化。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uA-88yStVJNi_bhp9SKX0A.png"></p>
<p>除非你在类似 transaction 的操作范围内运行，或者在API调用时使用了特定的 用户token（在这种情况下，你不应该共享由此产生的数据），除此之外你可以毫无顾虑地共享大部分常见操作数据。</p>
<p>那我们如何实现这个目标，Promise 就是答案</p>
<p>当我们检测到对资源的调用已经开始时，我们不启动对它的另一个调用，而是返回一个Promise来表示其结果(or failure)。这样，就可以避免对API、数据库查询或任何需要调用的并发请求，从而降低资源负载。</p>
<p>我们来实现一个简单的调用，它需要一些时间并返回一个结果。为此，我们要将几个值乘以200ms的延迟，这将代表我们的API调用或数据库查询：</p>
<pre><code class="highlight ts"><span class="keyword">import</span> &#123; delay &#125; <span class="keyword">from</span> <span class="string">&#x27;ts-timeframe&#x27;</span>;

<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">simulatedCall</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;
  <span class="comment">// these 3 lines represent our call</span>
  <span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">200</span>);
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`calculated <span class="subst">$&#123;a&#125;</span> * <span class="subst">$&#123;b&#125;</span>`</span>);
  <span class="keyword">return</span> a * b;
&#125;

<span class="comment">// our data fetching function, could be an API call, db query, whatever slow promise is needed</span>
<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">costlyFunction</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; &#123;
  <span class="keyword">return</span> <span class="title function_">simulatedCall</span>(a, b);
&#125;

<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> values = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([
    <span class="title function_">costlyFunction</span>(<span class="number">4</span>, <span class="number">5</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">4</span>, <span class="number">5</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">4</span>, <span class="number">5</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">50</span>, <span class="number">2</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">50</span>, <span class="number">2</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">50</span>, <span class="number">2</span>),
  ]);

  <span class="variable language_">console</span>.<span class="title function_">log</span>(values);
&#125;

<span class="title function_">main</span>();</code></pre>

<p>当我们执行这段代码时，得到了预期的结果，没有任何意外。我们调用该函数6次，每次等待200ms</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0X2mg3xU-XhG-W6YmR26YQ.png"></p>
<p>现在，让我们改变这些代码，利用之前的模式来改进我们的应用程序。这次我们将使用 <code>OperationRegistry</code> 来管理我们的调用，更重要的是，我们将创建一个唯一的key来标识我们在注册表中的操作。</p>
<p>完成后，我们会调用 <code>isExecuting</code> 函数查看它是否返回一个Promise。如果是，这意味着另一个执行正在进行中，我们只需返回等待结果的Promise。否则，我们执行调用，将结果传播给所有待执行的Promise，并返回我们的值，根据操作是否成功，可以通过 <code>triggerAwaitingResolves</code> 或 <code>triggerAwaitingRejects</code> 将结果传递给特定 Promise</p>
<pre><code class="highlight ts"><span class="keyword">import</span> &#123; delay &#125; <span class="keyword">from</span> <span class="string">&#x27;ts-timeframe&#x27;</span>;
<span class="keyword">import</span> &#123; <span class="title class_">OperationRegistry</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;reliable-caching&#x27;</span>;

<span class="keyword">const</span> operationRegistry = <span class="keyword">new</span> <span class="title class_">OperationRegistry</span>(<span class="string">&#x27;costlyFunction&#x27;</span>);

<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">simulatedCall</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;
  <span class="comment">// these 3 lines represent our call</span>
  <span class="keyword">await</span> <span class="title function_">delay</span>(<span class="number">200</span>);
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`calculated <span class="subst">$&#123;a&#125;</span> * <span class="subst">$&#123;b&#125;</span>`</span>);
  <span class="keyword">return</span> a * b;
&#125;

<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">costlyFunction</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; &#123;
  <span class="keyword">const</span> uniqueOperationKey = <span class="string">`<span class="subst">$&#123;a&#125;</span>:<span class="subst">$&#123;b&#125;</span>`</span>;
  <span class="keyword">const</span> promiseForResult = operationRegistry.<span class="property">isExecuting</span>&lt;<span class="built_in">number</span>&gt;(uniqueOperationKey);

  <span class="comment">// a promise means execution for the same key is ongoing, we just need to await for it</span>
  <span class="keyword">if</span> (promiseForResult) &#123;
    <span class="keyword">return</span> promiseForResult;
  &#125;

  <span class="keyword">try</span> &#123;
    <span class="comment">// otherwise we call it</span>
    <span class="keyword">const</span> value = <span class="keyword">await</span> <span class="title function_">simulatedCall</span>(a, b);

    <span class="comment">// pass value to awaiting promises (in next event loop, to avoid delaying current execution)</span>
    operationRegistry.<span class="title function_">triggerAwaitingResolves</span>(uniqueOperationKey, value);

    <span class="comment">// return value to current execution</span>
    <span class="keyword">return</span> value;
  &#125; <span class="keyword">catch</span> (e) &#123;
    <span class="comment">// pass error to awaiting rejects (in next event loop, to avoid delaying current execution)</span>
    operationRegistry.<span class="title function_">triggerAwaitingRejects</span>(uniqueOperationKey, e);

    <span class="comment">// throw exception to current execution</span>
    <span class="keyword">throw</span> e;
  &#125;
&#125;

<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> values = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([
    <span class="title function_">costlyFunction</span>(<span class="number">4</span>, <span class="number">5</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">4</span>, <span class="number">5</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">4</span>, <span class="number">5</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">50</span>, <span class="number">2</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">50</span>, <span class="number">2</span>),
    <span class="title function_">costlyFunction</span>(<span class="number">50</span>, <span class="number">2</span>),
  ]);

  <span class="variable language_">console</span>.<span class="title function_">log</span>(values);
&#125;

<span class="title function_">main</span>();</code></pre>

<p>让我们看看当第二次执行这段代码时会发生什么：</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRX9-tGj6Gwaciiudtj13Q.png"></p>
<p>结果完全相同，但我们的函数只调用了2次，而不是之前的6次，每个key被调用一次。当然，只有当你多次执行相同的操作，或者因为操作耗时过长，或者因为操作频繁发生时，这种模式才是有益的。</p>
<p>但是有一个问题：错误和结果是所有执行共享的，所以要非常注意不要污染共享的结果，否则可能会出现意想不到的错误。如果需要更改对象，不要忘记克隆它。</p>
<p>Conclusions:</p>
<ul>
<li>虽然这并非易事，但对于并发应用程序来说，它能带来很大的好处，因为资源非常稀缺。此外，正如我们在本文中所解释的，这不仅可以释放这些资源，还可以提高应用程序的运行时间。</li>
<li>这个改变会对频繁调用的操作产生巨大影响，更重要的是，它可以节省资源并提高系统稳定性。即使是微不足道的收益，也能帮助我们缩短P99的响应时间，这一点非常重要。</li>
<li>如果在此基础上添加缓冲，效果更好！想象一下，如果不只是在单个实例上节省资源，而是在服务的所有实例之间节省这些资源，会有什么好处，因为这样就更有可能在多个实例中共享常用资源。</li>
<li>这些小细节是区分优秀的微服务架构和一般的微服务架构的关键所在，因为CPU功率和内存并不能解决所有问题，而拥有优化的服务才是区分胜者和败者的关键所在。</li>
</ul>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】SOLID Principles in JavaScript</title>
    <url>/2023/06/02/%E3%80%90%E7%BF%BB%E3%80%91SOLID-Principles-in-JavaScript/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://medium.com/@akashjha9041/solid-principles-in-javascript-ab69197e4cf7">SOLID Principles in JavaScript</a><br>原作者：<a href="https://medium.com/@akashjha9041">roniee</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>SOLID原则是由Robert C. Martin提出的一套软件设计原则。这些原则指导开发人员构建出健壮的、可维护的应用程序，同时将维护的成本降到最低。在这篇文章中，我们将讨论如何在JavaScript中使用这些原则，并会展示一些代码示例</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*b8uhCfoR8YgDFc58"></p>
<p>SOLID原则是由Robert C. Martin. “Bob叔叔” 提出的一套软件设计原则。这些原则指导开发人员构建出健壮的、可维护的应用程序，同时将维护的成本降到最低。</p>
<p>尽管SOLID原则经常被用于面向对象的编程，但我们可以将其用于其他语言，比如JavaScript。在这篇文章中，我们将讨论如何在JavaScript中使用这些原则，并会展示一些代码示例</p>
<h2 id="What-are-the-SOLID-principles"><a href="#What-are-the-SOLID-principles" class="headerlink" title="What are the SOLID principles?"></a>What are the SOLID principles?</h2><ul>
<li>Single responsibility principle（单一职责原则）</li>
<li>Open-closed principle（开闭原则）</li>
<li>Liskov substitution principle（里式替换原则）</li>
<li>Interface segregation principle（接口分离原则）</li>
<li>Dependency inversion principle（依赖倒置原则）</li>
</ul>
<h2 id="Single-responsibility-principle"><a href="#Single-responsibility-principle" class="headerlink" title="Single responsibility principle"></a>Single responsibility principle</h2><p>一个class，一个module或者一个function应该只负责一个角色。所以它应该只有一个改变原因。</p>
<p>单一职责原则是SOLID最简单的原则之一。然而，开发者经常误解它。认为一个模块应该只做一件事。</p>
<p>让我们用一个简单的例子来理解这个原则。下面的JavaScript代码片段有一个名为 ManageEmployee 的 class 和几个管理雇员的 function</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">ManageEmployee</span> &#123;

  <span class="title function_">constructor</span>(<span class="params">private http: HttpClient</span>)
  <span class="variable constant_">SERVER_URL</span> = <span class="string">&#x27;http://localhost:5000/employee&#x27;</span>;

  getEmployee (empId)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
  &#125;

  updateEmployee (employee)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">put</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;employee.id&#125;</span>`</span>,employee);
  &#125;

  deleteEmployee (empId)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
  &#125;

  calculateEmployeeSalary (empId, workingHours)&#123;
    <span class="keyword">var</span> employee = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
    <span class="keyword">return</span> employee.<span class="property">rate</span> * workingHours;
  &#125;

&#125;</code></pre>

<p>前面的代码看上去完全没有问题，并且很多开发者都会按照相同的方法来做并不会有任何问题。然而，由于它是对两个角色负责，这样他就有违单一职责原则。<code>getEmployee()</code>、<code>updateEmployee()</code>和<code>deleteEmployee()</code>函数直接与 HR 管理有关，而<code>calculateEmployeeSalary()</code>则与财务管理有关。</p>
<p>将来，如果你需要为HR或财务更新一个功能时，你就必须改变 <code>ManageEmployee class</code> 来影响两个角色，因此， <code>ManageEmployee class</code> 违反了单一职责原则。你需要把HR和财务有关的功能分开，使代码符合单一职责原则。下面的代码示例证明了这一点。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">ManageEmployee</span> &#123;

  <span class="title function_">constructor</span>(<span class="params">private http: HttpClient</span>)
  <span class="variable constant_">SERVER_URL</span> = <span class="string">&#x27;http://localhost:5000/employee&#x27;</span>;

  getEmployee (empId)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
  &#125;

  updateEmployee (employee)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">put</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;employee.id&#125;</span>`</span>,employee);
  &#125;

  deleteEmployee (empId)&#123;
     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">delete</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
  &#125;

&#125;

<span class="keyword">class</span> <span class="title class_">ManageSalaries</span> &#123;

  <span class="title function_">constructor</span>(<span class="params">private http: HttpClient</span>)
  <span class="variable constant_">SERVER_URL</span> = <span class="string">&#x27;http://localhost:5000/employee&#x27;</span>;

  calculateEmployeeSalary (empId, workingHours)&#123;
    <span class="keyword">var</span> employee = <span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="variable language_">this</span>.<span class="property">SERVER_URL</span> + <span class="string">`/<span class="subst">$&#123;empId&#125;</span>`</span>);
    <span class="keyword">return</span> employee.<span class="property">rate</span> * workingHours;
  &#125;

&#125;</code></pre>

<h2 id="Open-closed-principle"><a href="#Open-closed-principle" class="headerlink" title="Open-closed principle"></a>Open-closed principle</h2><p>Functions, modules, 和 classes 应该是可扩展的，但不是可修改的。</p>
<p>这是实现大型应用时需要遵循的一个重要原则。根据这一原则，我们应该能够很容易地为应用添加新的功能，但同时我们不应该对现有的代码引入破坏式修改。</p>
<p>举个例子，假设我们实现一个 <code>calculateSalaries()</code> 的函数，该函数使用一个带有工作角色和时薪的数组来计算工资。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">ManageSalaries</span> &#123;
  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">this</span>.<span class="property">salaryRates</span> = [
      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">role</span>: <span class="string">&#x27;developer&#x27;</span>, <span class="attr">rate</span>: <span class="number">100</span> &#125;,
      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">role</span>: <span class="string">&#x27;architect&#x27;</span>, <span class="attr">rate</span>: <span class="number">200</span> &#125;,
      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">role</span>: <span class="string">&#x27;manager&#x27;</span>, <span class="attr">rate</span>: <span class="number">300</span> &#125;,
    ];
  &#125;

  <span class="title function_">calculateSalaries</span>(<span class="params">empId, hoursWorked</span>) &#123;
    <span class="keyword">let</span> salaryObject = <span class="variable language_">this</span>.<span class="property">salaryRates</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> o.<span class="property">id</span> === empId);
    <span class="keyword">return</span> hoursWorked * salaryObject.<span class="property">rate</span>;
  &#125;
&#125;

<span class="keyword">const</span> mgtSalary = <span class="keyword">new</span> <span class="title class_">ManageSalaries</span>();
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Salary : &quot;</span>, mgtSalary.<span class="title function_">calculateSalaries</span>(<span class="number">1</span>, <span class="number">100</span>));</code></pre>

<p>直接修改 salaryRates 数组会违反开闭原则。例如，你需要为一个新角色进行工资计算。在这种情况下，你需要创建一个单独的方法，将工资添加到 salaryRates 数组中，而不是对原代码进行修改。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">ManageSalaries</span> &#123;
  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;
    <span class="variable language_">this</span>.<span class="property">salaryRates</span> = [
      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">role</span>: <span class="string">&#x27;developer&#x27;</span>, <span class="attr">rate</span>: <span class="number">100</span> &#125;,
      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">role</span>: <span class="string">&#x27;architect&#x27;</span>, <span class="attr">rate</span>: <span class="number">200</span> &#125;,
      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">role</span>: <span class="string">&#x27;manager&#x27;</span>, <span class="attr">rate</span>: <span class="number">300</span> &#125;,
    ];
  &#125;

  <span class="title function_">calculateSalaries</span>(<span class="params">empId, hoursWorked</span>) &#123;
    <span class="keyword">let</span> salaryObject = <span class="variable language_">this</span>.<span class="property">salaryRates</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> o.<span class="property">id</span> === empId);
    <span class="keyword">return</span> hoursWorked * salaryObject.<span class="property">rate</span>;
  &#125;

  <span class="title function_">addSalaryRate</span>(<span class="params">id, role, rate</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">salaryRates</span>.<span class="title function_">push</span>(&#123; <span class="attr">id</span>: id, <span class="attr">role</span>: role, <span class="attr">rate</span>: rate &#125;);
  &#125;
&#125;

<span class="keyword">const</span> mgtSalary = <span class="keyword">new</span> <span class="title class_">ManageSalaries</span>();
mgtSalary.<span class="title function_">addSalaryRate</span>(<span class="number">4</span>, <span class="string">&#x27;developer&#x27;</span>, <span class="number">250</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Salary : &#x27;</span>, mgtSalary.<span class="title function_">calculateSalaries</span>(<span class="number">4</span>, <span class="number">100</span>));</code></pre>

<h2 id="Liskov-substitution-principle"><a href="#Liskov-substitution-principle" class="headerlink" title="Liskov substitution principle"></a>Liskov substitution principle</h2><p>假设P(y)是类型A的对象y的一个可证明属性，那么对于类型B的对象x，其中B是A的子类型，P(x)应该为真</p>
<p>你能在网上找到关于里式替换原则的不同定义，但它们都有相同的含义。简单的说，里式替换原则指出，如果父类的子类在应用中产生意外行为，我们就不应该用子类替换父类。</p>
<p>例如，有一个名为 Animal 的类，它包括一个名为 <code>eat()</code> 的函数。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;
  <span class="title function_">eat</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Animal Eats&quot;</span>)
  &#125;
&#125;</code></pre>

<p>现在，我将把 Animal 类扩展成一个名为Bird的新类，其函数名为 <code>fly()</code> 。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;
  <span class="title function_">fly</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Bird Flies&quot;</span>)
  &#125;
&#125;

<span class="keyword">var</span> parrot = <span class="keyword">new</span> <span class="title class_">Bird</span>();
parrot.<span class="title function_">eat</span>();
parrot.<span class="title function_">fly</span>();</code></pre>

<p>在之前的例子中，我根据 Bird 类创建了一个名为 parrot 的对象，并同时拥有 eat 和 fly 方法。由于鹦鹉能够完成这两个动作，因此将 Animal 类扩展到 Bird 类并不违反里式替换原则</p>
<p>现在我们进一步扩展 Bird ，创建了一个名为 Ostrich 的新类</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Bird</span>&#123;
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Ostriches Do Not Fly&quot;</span>)
&#125;

<span class="keyword">var</span> ostrich = <span class="keyword">new</span> <span class="title class_">Ostrich</span>();
ostrich.<span class="title function_">eat</span>();
ostrich.<span class="title function_">fly</span>();</code></pre>

<p>这个对 Bird 类的扩展就违反了里式替换原则，因为鸵鸟不会飞行，这可能会在应用中引发意外行为。解决这个情况的最佳方法是从 Animal 类扩展 Ostrich 类。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">Ostrich</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;

  <span class="title function_">walk</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Ostrich Walks&quot;</span>)
  &#125;

&#125;</code></pre>

<h2 id="Interface-segregation-principle"><a href="#Interface-segregation-principle" class="headerlink" title="Interface segregation principle"></a>Interface segregation principle</h2><p>客户端不应该添加他们永远不会使用的依赖接口。</p>
<p>这个原则和接口有关，主要是将大接口分为小接口。举个例子，假如你要去驾校学习如何驾驶汽车，他们给你一大套关于驾驶汽车、卡车、火车的说明。由于你只需要学习驾驶汽车，你不需要其他的信息。驾校就应该把说明分开，只给你专门针对汽车的说明。</p>
<p>由于 JavaScript 不支持 interface ，所以在基于 JavaScript 的应用中很难采用这一原则。然而，我们可以使用 JavaScript 组合来实现这一点。组合允许开发人员在不继承整个类的情况下添加功能。假设有一个名为 DrivingTest 的类，然后有两个名为 startCarTest 和 startTruckTest 的函数。然后我们有 CarDrivingTest 和 TruckDrivingTest 扩展 DrivingTest 类，然后我们必须强制这两个类实现 startCarTest 和 startTruckTest s函数。</p>
<pre><code class="highlight js"><span class="title class_">Class</span> <span class="title class_">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">userType</span> = userType;
  &#125;

  <span class="title function_">startCarTest</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(“<span class="title class_">This</span> is <span class="keyword">for</span> <span class="title class_">Car</span> <span class="title class_">Drivers</span>”’);
  &#125;

  <span class="title function_">startTruckTest</span>(<span class="params"></span>) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(“<span class="title class_">This</span> is <span class="keyword">for</span> <span class="title class_">Truck</span> <span class="title class_">Drivers</span>”);
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">CarDrivingTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">super</span>(userType);
  &#125;

  <span class="title function_">startCarTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> “<span class="title class_">Car</span> <span class="title class_">Test</span> <span class="title class_">Started</span>”;
  &#125;

  <span class="title function_">startTruckTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> <span class="literal">null</span>;
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">TruckDrivingTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">super</span>(userType);
  &#125;

  <span class="title function_">startCarTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> <span class="literal">null</span>;
  &#125;

  <span class="title function_">startTruckTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> “<span class="title class_">Truck</span> <span class="title class_">Test</span> <span class="title class_">Started</span>”;
  &#125;
&#125;

<span class="keyword">const</span> carTest = <span class="keyword">new</span> <span class="title class_">CarDrivingTest</span>(carDriver );
<span class="variable language_">console</span>.<span class="title function_">log</span>(carTest.<span class="title function_">startCarTest</span>());
<span class="variable language_">console</span>.<span class="title function_">log</span>(carTest.<span class="title function_">startTruckTest</span>());

<span class="keyword">const</span> truckTest = <span class="keyword">new</span> <span class="title class_">TruckDrivingTest</span>( ruckdriver );
<span class="variable language_">console</span>.<span class="title function_">log</span>(truckTest.<span class="title function_">startCarTest</span>());
<span class="variable language_">console</span>.<span class="title function_">log</span>(truckTest.<span class="title function_">startTruckTest</span>());</code></pre>

<p>然而，这种实现方法违反了接口分离原则，因为我们强迫那两个扩展类实现这两种功能。我们可以通过组合来为所需的类添加功能来解决这个问题，如下面的例子中所示。</p>
<pre><code class="highlight js"><span class="title class_">Class</span> <span class="title class_">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">userType</span> = userType;
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">CarDrivingTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">super</span>(userType);
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">TruckDrivingTest</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DrivingTest</span> &#123;
  <span class="title function_">constructor</span>(<span class="params">userType</span>) &#123;
    <span class="variable language_">super</span>(userType);
  &#125;
&#125;

<span class="keyword">const</span> carUserTests = &#123;
  <span class="title function_">startCarTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> ‘<span class="title class_">Car</span> <span class="title class_">Test</span> <span class="title class_">Started</span>’;
  &#125;,
&#125;;

<span class="keyword">const</span> truckUserTests = &#123;
  <span class="title function_">startTruckTest</span>(<span class="params"></span>) &#123;
    <span class="keyword">return</span> ‘<span class="title class_">Truck</span> <span class="title class_">Test</span> <span class="title class_">Started</span>’;
  &#125;,
&#125;;

<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">CarDrivingTest</span>.<span class="property"><span class="keyword">prototype</span></span>, carUserTests);
<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">TruckDrivingTest</span>.<span class="property"><span class="keyword">prototype</span></span>, truckUserTests);

<span class="keyword">const</span> carTest = <span class="keyword">new</span> <span class="title class_">CarDrivingTest</span>(carDriver );
<span class="variable language_">console</span>.<span class="title function_">log</span>(carTest.<span class="title function_">startCarTest</span>());
<span class="variable language_">console</span>.<span class="title function_">log</span>(carTest.<span class="title function_">startTruckTest</span>()); <span class="comment">// Will throw an exception</span>

<span class="keyword">const</span> truckTest = <span class="keyword">new</span> <span class="title class_">TruckDrivingTest</span>( ruckdriver );
<span class="variable language_">console</span>.<span class="title function_">log</span>(truckTest.<span class="title function_">startTruckTest</span>());
<span class="variable language_">console</span>.<span class="title function_">log</span>(truckTest.<span class="title function_">startCarTest</span>()); <span class="comment">// Will throw an exception</span></code></pre>

<p>现在， <code>carTest.startTruckTest()</code> 将抛出一个异常，因为 <code>startTruckTest()</code> 函数没有分配给 CarDrivingTest 类。</p>
<h2 id="Dependency-inversion-principle"><a href="#Dependency-inversion-principle" class="headerlink" title="Dependency inversion principle"></a>Dependency inversion principle</h2><p>高层模块应该使用抽象化。并且，他们不应该依赖于低层模块。</p>
<p>依赖倒置是关于解耦代码的。遵循这个原则将使你能够灵活地在最高级别上扩展和改变你的应用而不出现任何问题。</p>
<p>关于JavaScript，我们不需要考虑抽象的问题，因为JavaScript是一种动态语言。然而，我们需要确保高层模块不依赖于低层模块。</p>
<p>我们来用一个简单的例子来解释依赖倒置是如何工作的。假设你在你的应用中需要使用 Yahoo 的 email API ，现在你需要把它改为 Gmail 的 API 。如果你像下面的例子一样实现了没有依赖倒置的控制器，你需要对每个控制器都进行修改。这是因为多个控制器使用了 Yahoo API ，你需要找到每个实例并更新它。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">EmailController</span> &#123; 
  <span class="title function_">sendEmail</span>(<span class="params">emailDetails</span>) &#123; 
    <span class="comment">// Need to change this line in every controller that uses YahooAPI.const response = YahooAPI.sendEmail(emailDetails); </span>
    <span class="keyword">if</span> (response.<span class="property">status</span> == <span class="number">200</span>) &#123; 
       <span class="keyword">return</span> <span class="literal">true</span>;
    &#125; <span class="keyword">else</span> &#123;
       <span class="keyword">return</span> <span class="literal">false</span>;
    &#125;
  &#125;
&#125;</code></pre>

<p>依赖倒置原则可以帮助开发者避免这种高昂的错误，在这个原则下，将 email API 处理部分转移到一个单独的控制器。然后你只需要在 email API 发生改变时改变该控制器即可。</p>
<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">EmailController</span> &#123; 
  <span class="title function_">sendEmail</span>(<span class="params">emailDetails</span>) &#123; 
    <span class="keyword">const</span> response = <span class="title class_">EmailApiController</span>.<span class="title function_">sendEmail</span>(emailDetails);   
    <span class="keyword">if</span> (response.<span class="property">status</span> == <span class="number">200</span>) &#123; 
       <span class="keyword">return</span> <span class="literal">true</span>;
    &#125; <span class="keyword">else</span> &#123;
       <span class="keyword">return</span> <span class="literal">false</span>;
    &#125;
  &#125;
&#125;

<span class="keyword">class</span> <span class="title class_">EmailApiController</span> &#123;
  <span class="title function_">sendEmail</span>(<span class="params">emailDetails</span>) &#123;
    <span class="comment">// Only need to change this controller. return YahooAPI.sendEmail(emailDetails);</span>
  &#125;
&#125;</code></pre>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在这篇文章中，我们讨论了在软件设计中SOLID原则的重要性，以及我们如何在JavaScript应用中采用这些概念。作为开发人员，理解并在我们的应用中使用这些核心概念是很重要的。有时，在处理一些小的应用时，这些原则的好处可能并不明显，但一旦你开始在一个大规模的项目上工作时，你一定会知道它们的不同。</p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Why Japanese Websites Look So Different</title>
    <url>/2023/06/10/%E3%80%90%E7%BF%BB%E3%80%91Why-Japanese-Websites-Look-So-Different/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://medium.com/@mirijam.missbichler/why-japanese-websites-look-so-different-2c7273e8be1e">Why Japanese Websites Look So Different</a><br>原作者：<a href="https://medium.com/@mirijam.missbichler">Mirijam Missbichler</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>多年以来，我多次接触过日本网站，无论是研究签证、计划旅行，还是简单的在网上购物。我花了很长时间才习惯下面这样的文字布局，使用大量鲜艳的颜色和十多种不同的字体</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfpAOTRBmUP6k80b2GNGlg.png"></p>
<p>对于习惯使用西方网站的人，有许多网站设计的简约且易于浏览，但是为什么这种更加复杂的风格在日本却很流行。</p>
<p>澄清一下，这些不是过去的网站，是现在正在维护的网站，比如下面这个网站最后一次更新是在2023年。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52jHrlyvsqRw2l7hwfMS5A.png"></p>
<p>我们可以从几个不同角度来分析这种设计：</p>
<ul>
<li>字体和网站开发的限制</li>
<li>技术发展停滞</li>
<li>机构缺乏数字素养</li>
<li>文化的影响</li>
</ul>
<p>就像大多数话题一样，可能没有一个正确的答案。这种网站设计是各种因素长期互相作用的结果</p>
<h2 id="Fonts-amp-Front-End-Website-Development-Constraints"><a href="#Fonts-amp-Front-End-Website-Development-Constraints" class="headerlink" title="Fonts &amp; Front-End Website Development Constraints"></a>Fonts &amp; Front-End Website Development Constraints</h2><p>为罗马语言创建新的字体是一个很好的挑战，每个人只要对字体设计有基本的了解，并且用适当的程序和一些时间就可以承受，但是为日语创建字体是一个很难的事情</p>
<p>首先如果从头创建一个英语字体，你会看到大约230个字形，一个字形是一个字母的单独展示(A a a 算3个字形)，如果你想覆盖所有基于拉丁字母的语言，就需要840个字形。但是对于日语，由于三种不同的书写系统和无数的汉字，你就会看到7000 - 16000个字形甚至更多。因此，创建一个新的日语字体需要一个有组织的团队花费比拉丁语字体相当多的时间才可能</p>
<p>毫不奇怪，对于中文和(汉字)韩文字体来说，类似的工作量也是必然的，这导致这些语言通常被所谓的CJK字体所覆盖</p>
<p>随着越来越少的设计师接受这一特殊挑战，在建立一个网站时可供选择的字体也就越来越少。再加上缺乏大写字体和日文字体，需要引入较大体积的库，会导致加载时间过长，最终你就需要使用不同的方法，来创建视觉层次。</p>
<p>我们可以拿美国和日本的星巴克主页为例：</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfaaGd_Bl2fTN9uqAT-bKA.png"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-TiKrBADjkMrnHjBAQ4bQ.png"></p>
<p>就这样，我们可以解释为什么对于许多日本网站倾向于用文字密集的图像来表示内容类别。有时候你甚至可以看到每个瓷砖都使用自己特定的字体，特别是限时优惠时。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Imrz53GsvI3Jmibv4Lltxw.png"></p>
<h2 id="Technological-Development-x2F-Stagnation-amp-Institutional-Digital-Literacy"><a href="#Technological-Development-x2F-Stagnation-amp-Institutional-Digital-Literacy" class="headerlink" title="Technological Development&#x2F;Stagnation &amp; Institutional Digital Literacy"></a>Technological Development&#x2F;Stagnation &amp; Institutional Digital Literacy</h2><p>虽然关于 “失去的十年” 和日本技术进步的关系有无数的讨论，但我最喜欢这个总结：</p>
<blockquote>
<p>Japan, living in the year 2000 since 1985. (<a href="https://www.reddit.com/r/japan/comments/10herkr/comment/j59m31c/?context=3">thanks Reddit</a>)</p>
</blockquote>
<p>如果你对日本感兴趣，你可能会熟悉先进技术和过时技术的这种对比，这种对比在许多地方都存在。作为世界机器人领域的领先者之一，将一座<a href="https://www.unicorn-gundam-statue.jp/en/">真人大小的高达雕像</a>放在御台场人工岛上的国家，却仍然依赖软驱和传真机，并在2022年时面对<a href="https://www.bloomberg.com/news/articles/2022-06-15/end-of-internet-explorer-era-spells-trouble-for-japan-businesses?leadSource=uverify%20wall#xj4y7vzkg">windows ie关闭</a>陷入恐慌</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDYVc3z22_A-ELz8Q1KHIw.png"></p>
<p>在德国，前总理安格拉-默克尔在2013年称互联网为 “未知领域”（德文原话：”Das Internet ist für uns alle Neuland”）后，被全国取笑。然而，这一情况被前网络安全部长樱田义孝在2018年超越。据报道，他声称从未使用过计算机，并且当在议会被问及USB驱动器的概念时，他“困惑不解”(<a href="https://www.theguardian.com/world/2018/nov/15/japan-cyber-security-ministernever-used-computer-yoshitaka-sakurada">来源</a>)。</p>
<p>对于那些没有机会看到幕后的人来说，这样的状况可能听起来很奇怪。因为日本在技术素养方面，一直严重滞后。因此，推断这些问题对日本网站设计发展也起到了一点阻碍的作用。而且，日本的网站设计也面临着这种困境。只需在谷歌或Pinterest上搜索日本海报设计，就能见证一种截然不同且现代化的平面设计水平。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4nu6H_pheQBXEiAIZz6jA.png"></p>
<h2 id="Cultural-Influence"><a href="#Cultural-Influence" class="headerlink" title="Cultural Influence"></a>Cultural Influence</h2><p>在分析任何类型的设计选择时，文化习俗、倾向、偏见和偏好都不应被低估。然而，“这是文化”的观点存在过于简化主题的风险，并可能被用作为各种差异辩护的借口。而要摆脱个人的观点偏见是困难的，甚至不可能完全做到。</p>
<p>所以，从我们的角度来看，很容易看待这个网站…</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Tgk9_5Ci-B4DoITuGqQTw.png"></p>
<p>…感觉难以接受，并且认为它的设计很糟糕，然后宣布结束。因为谁会使用这个混乱无序的网站呢？</p>
<p>正是因为这种无知，这些有趣的见解就被忽视了。现在，我不能确切的告诉你日本文化如何影响了这种设计。然而，我很幸运地能够从与日本本土人的对话中获得启示，也有在日本工作和生活的经验可以借鉴。</p>
<p>我曾经参与过一次与这个分析相关但与网站无关的对话，是关于YouTube的缩略图，因为这同样让人难以接受</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lwaEIIIUc5peoMMo6fM_Q.png"></p>
<p>对于一个习惯了许多西方频道使用的极简和光滑设计的人来说，以一个标题，反复出现的调色板和有限的字体为特色，上面的缩略图让人难以接受，我曾问一个日本人为什么许多非常受欢迎的频道的缩略图都是这样设计的，然而，他非常惊讶这种视为混乱的想法。他认为日本人的视频看起来更有吸引力，提供了一些能让人抓住的信息，让人们更容易决定视频是否有趣。我给他看英文视频缩略图做对比时，他认为非常模糊且无聊。</p>
<p>而正是这种寻求信息的态度，可能是我们的观念出现如此大分歧的根本原因。在日本，规避风险、反复检查和对做决定时的犹豫不决的程度明显高于西方国家。这与更多的集体主义社会心态密切相关，比如，将一份文件发送给商业伙伴之前，进行双重（或三重）检查可能会花费更多时间，但却大大降低错误溜走的风险，从而防止相关人员丢脸。</p>
<p>回到网站设计，这个文化角度更能助于解释为什么网上购物、新闻和政府网站从外部来看往往是”最糟糕的犯罪者”。毕竟，在这些情况下，大量的细节直接对应着好的的购买决策、高效地保持最新信息或确保你拥有某个流程的所有必要信息。</p>
<p>有趣的是，关于美国人和中国&#x2F;日本人对信息的感知方式，有着大量研究。一些研究的结果似乎表明，日本人对信息的感知更加全面，而美国人则倾向于选择一个焦点来引导他们的注意力(<a href="https://www.wired.com/2008/03/japanese-more-s/">来源</a>)。这就给我们提供了一个解释，为什么西方人即使在日语水平很高的情况下也很难使用这类网站</p>
<p>最后，需要指出，网站不是单独存在的。从杂志到地铁里的广告等各种媒体也尽可能在小的空间里塞进尽可能多的信息，人们可能只是习惯了这种无处不在的展示导致没有人想要质疑它。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6KRgu_BarZlRVPehgytsA.png"></p>
<p>长话短说，这既不是为了找到标题的绝对答案，也不是为了加强日本人独特性的概念。相反，特别是看到一些专注于将某种解释视为“真正答案”的讨论后，我想要说明科技、历史和文化影响的范围导致最终形成的这种差异。</p>
<h2 id="Sources-amp-further-reading"><a href="#Sources-amp-further-reading" class="headerlink" title="Sources &amp; further reading"></a>Sources &amp; further reading</h2><h3 id="Fonts-amp-Typography"><a href="#Fonts-amp-Typography" class="headerlink" title="Fonts &amp; Typography"></a>Fonts &amp; Typography</h3><p>Interview with Font Designer Akira Kobayashi: <a href="https://www.smashingmagazine.com/2015/04/interview-with-akira-kobayashi/">https://www.smashingmagazine.com/2015/04/interview-with-akira-kobayashi/</a></p>
<p>A detailed breakdown of the creation process behind a Chinese font: <a href="https://qz.com/522079/the-long-incredibly-tortuous-and-fascinating-process-of-creating-a-chinese-font">https://qz.com/522079/the-long-incredibly-tortuous-and-fascinating-process-of-creating-a-chinese-font</a></p>
<p>An example of a Japanese font including glyph count from Adobe Fonts: <a href="https://fonts.adobe.com/fonts/source-han-sans-japanese#fonts-section">https://fonts.adobe.com/fonts/source-han-sans-japanese#fonts-section</a></p>
<p>CJK Fonts: <a href="https://en.wikipedia.org/wiki/List_of_CJK_fonts">https://en.wikipedia.org/wiki/List_of_CJK_fonts</a></p>
<h3 id="Japan-amp-Technology"><a href="#Japan-amp-Technology" class="headerlink" title="Japan &amp; Technology"></a>Japan &amp; Technology</h3><p>An article on Japan’s fading hi-tech image and where it came from: <a href="https://thenextweb.com/news/japan-loves-fax-machine-techno-orientalism">https://thenextweb.com/news/japan-loves-fax-machine-techno-orientalism</a></p>
<p>Bloomberg on the effects of the Internet Explorer shutdown in Japan: <a href="https://www.bloomberg.com/news/articles/2022-06-15/end-of-internet-explorer-era-spells-trouble-for-japan-businesses#xj4y7vzkg?leadSource=uverify%20wall">https://www.bloomberg.com/news/articles/2022-06-15/end-of-internet-explorer-era-spells-trouble-for-japan-businesses#xj4y7vzkg?leadSource=uverify%20wall</a></p>
<p>The Guardian on the 2018 statement made by Japan’s former Cybersecurity Minister: <a href="https://www.theguardian.com/world/2018/nov/15/japan-cyber-security-ministernever-used-computer-yoshitaka-sakurada">https://www.theguardian.com/world/2018/nov/15/japan-cyber-security-ministernever-used-computer-yoshitaka-sakurada</a></p>
<p>Reading up on the Lost Decades: <a href="https://en.wikipedia.org/wiki/Lost_Decades">https://en.wikipedia.org/wiki/Lost_Decades</a></p>
<h3 id="Cultural-Influences"><a href="#Cultural-Influences" class="headerlink" title="Cultural Influences"></a>Cultural Influences</h3><p>Wired on several studies about perception differences: <a href="https://www.wired.com/2008/03/japanese-more-s/">https://www.wired.com/2008/03/japanese-more-s/</a></p>
<p>A study on the same topic: <a href="https://www.researchgate.net/publication/11645680_Attending_holistically_vs_analytically_Comparing_the_context_sensitivity_of_Japanese_and_Americans_Journal_of_Personality_and_Social_Psychology_81_922-934">https://www.researchgate.net/publication/11645680_Attending_holistically_vs_analytically_Comparing_the_context_sensitivity_of_Japanese_and_Americans_Journal_of_Personality_and_Social_Psychology_81_922-934</a></p>
]]></content>
      <tags>
        <tag>Translate</tag>
        <tag>Web Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】Stop using &amp;&amp; in React Conditional Rendering</title>
    <url>/2023/05/20/%E3%80%90%E7%BF%BB%E3%80%91Stop-using-in-React-Conditional-Rendering/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://www.crocoder.dev/blog/react-conditional-rendering/">Stop using &amp;&amp; in React Conditional Rendering</a><br>原作者：<a href="https://twitter.com/devabram">David Abram</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>条件渲染是React中的一项技术，它允许你根据某些条件来展示或隐藏用户界面的一部分。这意味着你可以根据你应用程序在任何时间发生的情况来显示不同的内容和组件</p>
<p>比如，你正在构建一个网站，用户可以登录并查看他们的个人资料信息。当用户没有登录时，你可能想展示一个登录表单。但当用户登录后，你可能想展示他们的资料信息。</p>
<p>让我们看看React中条件渲染的一个例子。</p>
<h3 id="The-CrocDemo-component"><a href="#The-CrocDemo-component" class="headerlink" title="The CrocDemo component"></a>The CrocDemo component</h3><pre><code class="highlight js"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;

<span class="keyword">const</span> <span class="title class_">CrocDemo</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;
  <span class="keyword">const</span> crocodiles = [<span class="string">&#x27;Lyle&#x27;</span>, <span class="string">&#x27;Snappy&#x27;</span>, <span class="string">&#x27;Mr. Vile&#x27;</span>];

  <span class="keyword">const</span> dodos = [];

  <span class="keyword">return</span> (
    <span class="language-xml"><span class="tag">&lt;&gt;</span></span>
<span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;crocodiles.length &amp;&amp; `crocodiles: $&#123;crocodiles.map(() =&gt; &#x27;🐊&#x27;).join(&#x27; &#x27;)&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;dodos.length &amp;&amp; `dodos: $&#123;dodos.map(() =&gt; &#x27;🦤&#x27;).join(&#x27; &#x27;)&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span>
<span class="language-xml">    <span class="tag">&lt;/&gt;</span></span>
  );
&#125;;</code></pre>

<p>这段代码定义了一个名为<code>CrocDemo</code>的React组件</p>
<p>在这个组件中，定义了两个数组：<code>crocodiles</code>和<code>dodos</code>。crocodiles数组包含三条鳄鱼的名字。而dodos数组是空的。这是当然的，因为渡渡鸟已经灭绝了</p>
<p>然后该组件返回了一些JSX代码，包括两个div元素，第一个div元素显示鳄鱼的名字，第二个div元素显示渡渡鸟的名字。</p>
<p>这段代码中有意思的一部分是如何展示这些名字。div元素使用一种叫做条件渲染的技术来决定是否显示名字。</p>
<p>第一个div元素检查crocodies数组的长度是否大于0。如果是，这个div元素就会显示crocodiles文本，然后是一系列的鳄鱼表情。这些表情是用map函数创建，它根据原数组中的鳄鱼数量生成一个新的表情数组，然后用join函数将这些表情连接成一个字符串，显示在div元素内。</p>
<p>第二个div元素按照相同的模式，当它检查dodos数组的长度是否大于0。由于dodos数组是空的，所以这个div元素不会显示任何东西。</p>
<p>所以，最终的结果是，如果鳄鱼数组中有任何鳄鱼，CrocDemo组件就会显示鳄鱼的名字(表情符号)，而对dodos数组则不显示。</p>
<p>至少没有展示关于dodos数组的内容。</p>
<pre><code class="highlight text">crocodiles: 🐊 🐊 🐊
0</code></pre>

<p>嗯… 看起来是有一个随机的0，我们期望的是什么都不展示，这是为什么呢？</p>
<p>让我们试着用具有不同<code>false value</code>的<code>&amp;&amp;</code>运算符来了解发生了什么</p>
<pre><code class="highlight js"><span class="comment">/* This won&#x27;t render anything ✅ */</span>
&lt;&gt;&#123;<span class="literal">false</span> &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&lt;/&gt;

<span class="comment">/* This will render 0 😡 */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;0 &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;&quot;&quot;  &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;null &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;undefined &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This will render NaN 😡 */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;NaN &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span></code></pre>

<p>在JavaScript中，<code>&amp;&amp;</code>运算符会检查左右操作对象是否都是true，如果左边的操作对象是false，那么右边的操作对象就不会被检查，并且<code>&amp;&amp;</code>运算符会返回左边的操作对象</p>
<p>在表达式<code>&#123;0 &amp;&amp; &lt;div&gt;👋&lt;/div&gt;&#125;</code>中，左边的操作对象是0，这在javascript中是一个<code>false value</code>，因为左边的操作对象是false，所以右边的操作对象不会被检查。并且返回左边的操作对象，也就是0</p>
<p>当React试图渲染该组件时，它将0解释为一个字符串，并将其渲染到页面上。😡😡😡</p>
<p>NaN的情况是一样的。</p>
<pre><code class="highlight js"><span class="comment">/* This will render NaN 😡 */</span>
&lt;&gt;&#123;<span class="title class_">NaN</span> &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&lt;/&gt;</code></pre>

<p>那么，我们怎么解决这个问题呢？</p>
<h3 id="Use-the-ternary-operator"><a href="#Use-the-ternary-operator" class="headerlink" title="Use the ternary operator"></a>Use the ternary operator</h3><p>有几种方法可以解决这个问题。第一个(也是最好的)方法是使用三元运算符。三元运算符是一个条件运算符，它检查一个条件是否为true。如果条件为true，它返回第一个操作对象，如果条件为false，这返回第二个操作对象。</p>
<pre><code class="highlight js"><span class="comment">/* This won&#x27;t render anything ✅ */</span>
&lt;&gt;&#123;<span class="number">0</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>&#125;&lt;/&gt;

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;NaN ? <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span> : null&#125;<span class="tag">&lt;/&gt;</span></span></code></pre>

<h3 id="Convert-falsy-values-to-Boolean"><a href="#Convert-falsy-values-to-Boolean" class="headerlink" title="Convert falsy values to Boolean"></a>Convert falsy values to Boolean</h3><p>另外，我们可以把所有的false转为boolean，或者使用<code>!!</code>运算符，<code>!!</code>运算符是将一个值转为布尔值的，它本质上是将一个true value或者false value转换为true或false的一个速记方法。</p>
<pre><code class="highlight js"><span class="comment">/* This won&#x27;t render anything ✅ */</span>
&lt;&gt;&#123;<span class="title class_">Boolean</span>(<span class="number">0</span>) &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&lt;/&gt;

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;Boolean(NaN) &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;!!0 &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span>

<span class="comment">/* This won&#x27;t render anything ✅ */</span>
<span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;!!NaN &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>👋<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/&gt;</span></span></code></pre>

<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>条件渲染是React中的一项技术，它允许你根据某些条件来展示或者隐藏用户界面的某些部分。当你想根据应用程序中发生的事情来显示不同的内容或组件时，这很有用。</p>
<p>然而，在使用<code>&amp;&amp;</code>运算符时，有一个问题，如0和NaN这样的false value，会意外地导致意外的渲染。</p>
<p>为了解决这个问题，我们可以使用三元运算符或将false value转换为boolean。这些技术将有助于确保你的React组件完全呈现出你所期望的效果。</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻】“return null” vs “return false” in React</title>
    <url>/2023/05/13/%E3%80%90%E7%BF%BB%E3%80%91%E2%80%9Creturn-null%E2%80%9D-vs-%E2%80%9Creturn-false%E2%80%9D-in-React/</url>
    <content><![CDATA[<blockquote>
<p>为了提高英语水平和保持技术成长，开始按计划翻译一些短篇和博客，有问题欢迎讨论👻<br>原文：<a href="https://caglayanyanikoglu.medium.com/return-null-vs-return-false-in-react-826d8abcc429">“return null” vs “return false” in React</a><br>原作者：<a href="https://caglayanyanikoglu.medium.com/">Çağlayan Yanıkoğlu</a></p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>大家好，在本周的#SundayTechMusings，我将尝试解释在React中”return null”和”return false”之间的区别。</p>
<p>这实际上与性能有关，在写之前，你可以看看我的文章<a href="https://tech.jotform.com/react-performance-improvements-356f81b1904f">Performance Optimization Techniques</a></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*yaIvvEwXKIvFQ_8g"></p>
<p>我知道很多人认为”return null”和”return false”是一样的，实际上是非常相似的，但是也有一些区别，这和React的工作方式有关。</p>
<p>在使用React开发时，通常会使用条件渲染根据不同的条件显示不同的组件。在一些条件下，你可能想明确指出一个组件不应该渲染任何东西。这就是null和false的来历，虽然这两个值都会阻止一个组件的渲染，但是它们之间有着重要的区别。</p>
<h3 id="Returning-null"><a href="#Returning-null" class="headerlink" title="Returning null"></a>Returning null</h3><p>当一个组件返回null，它会告诉React不要在DOM中为该组件渲染任何东西。当你想要根据某种状态有条件地渲染一个组件时，但不希望在不符合该状态时显示任何东西时，返回null就很有用，比如说：</p>
<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">Greeting</span> = (<span class="params">props</span>) =&gt; &#123;
  <span class="keyword">if</span> (!props.<span class="property">name</span>) &#123;
    <span class="keyword">return</span> <span class="literal">null</span>;
  &#125;

  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;
&#125;;</code></pre>

<p>在上面的例子中，如果没有提供 <code>name</code> prop，组件会返回null，这样就不会渲染<code>&lt;h1&gt;</code>元素。如果提供了 <code>name</code> prop，该组件就会渲染带有实际内容的<code>&lt;h1&gt;</code>元素，这实际上是每个人的经典做法。</p>
<h3 id="Returning-false"><a href="#Returning-false" class="headerlink" title="Returning false"></a>Returning false</h3><p>当一个组件返回false时，它告诉会React不要再DOM中为该组件渲染任何东西，就像null一样。然而，有一个重要的区别：返回false也会阻止该组件在未来的更新。这是因为React将false解释为“卸载”组件的信号，这意味着从DOM中完全删除它。</p>
<p>下面是一个返回false的组件的例子：</p>
<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">props</span>) =&gt; &#123;
  <span class="keyword">if</span> (!props.<span class="property">onClick</span>) &#123;
    <span class="keyword">return</span> <span class="literal">false</span>;
  &#125;

  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;
&#125;;</code></pre>

<p>在这个例子中，如果没有提供 <code>onClick</code> prop，组件就会返回false，从而阻止 <code>&lt;button&gt;</code>元素渲染。如果提供了 <code>onClick</code> prop，组件会用指定的点击处理来渲染 <code>&lt;button&gt;</code> 元素</p>
<p>值得注意的是，返回false可能会有意想不到的后果，比如在应该更新的时候阻止组件的更新。出于这个原因，当你想在不影响未来更新的情况下阻止渲染，使用null通常更安全</p>
<p>从一个组件的渲染方法中返回false，只有在该组件没有任何副作用时才有用，比如更新状态或者触发API请求。如果一个组件有副作用并返回false时，这些副作用仍然会发生，可能会导致意外的行为。</p>
<p><a href="https://github.com/facebook/react/blob/main/packages/react/src/ReactElementValidator.js#L347-L385">react&#x2F;ReactElementValidator.js at main</a></p>
<p>如果你在React库中检查上面这段代码时，你会看到一个”null”检查，为了更好的理解React的工作，你可以看看这段代码。</p>
<h3 id="To-sum-up"><a href="#To-sum-up" class="headerlink" title="To sum up"></a>To sum up</h3><p>总而言之，返回null和返回false都会阻止一个组件在DOM中渲染任何东西，但它们之间有重要的区别。null是一个简单的方法来有条件的渲染一个组件，并且不影响未来的更新，而false则是向React发出卸载组件的信号，并可能导致意想不到的后果。为你特定的用例选择正确的选项是很重要的</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>前端的Docker学习记录</title>
    <url>/2022/10/30/%E5%89%8D%E7%AB%AF%E7%9A%84Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><ul>
<li>Docker 是一个应用<strong>打包</strong>、<strong>分发</strong>、<strong>部署</strong>的工具，可以使应用部署更加轻量，可移植，可扩展，可以理解为一个轻量的虚拟机<ul>
<li>打包：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</li>
<li>分发：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装</li>
<li>部署：拿着“安装包”就可以一个命令运行起来应用，自动模拟出一模一样的运行环境，不管是在Windows&#x2F;Mac&#x2F;Linux</li>
</ul>
</li>
<li>docker架构图<br><img src="https://s1.ax1x.com/2022/10/30/xI2lGR.png"></li>
</ul>
<ul>
<li><strong>docker client</strong>: 即docker命令行工具</li>
<li><strong>docker host</strong>: 宿主机，docker daemon的运行环境服务器</li>
<li><strong>docker daemon</strong>: docker的守护进程，docker client通过命令行与docker daemon交互</li>
<li><strong>image</strong>: 镜像，可以理解为安装包，可以方便的进行传播和安装</li>
<li><strong>container</strong>: 容器，镜像的运行实例，每个软件运行环境都是独立的，隔离的</li>
<li><strong>registry</strong>: 镜像仓库，可以从镜像仓库拉取和推送镜像</li>
</ul>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>docker底层使用了一些linux内核的特性，<code>namespace</code>，<code>cgroups</code>，<code>unionFS</code></p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><ul>
<li>namespace，也叫命名空间，名称空间，它表示一个标识符的可见范围。一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的。这样，在一个新的名字空间中可定义任何标识符，它不会与任何已有的标识符发生冲突，因为已有的定义都处于其他命名空间中</li>
<li>docker使用linux namespace构建隔离的环境，它由以下namespace组成<ul>
<li>pid：隔离进程</li>
<li>net：隔离网络</li>
<li>ipc：隔离IPC</li>
<li>mnt：隔离文件系统挂载</li>
<li>uts：隔离hostname</li>
<li>user：隔离uid&#x2F;gid</li>
</ul>
</li>
</ul>
<h3 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h3><ul>
<li>cgroups，是控制组群(control groups)的简写，是用来限制、控制与分离一个进程组的资源(如CPU、内存、磁盘输入输出等)</li>
<li>cgroups功能：<ul>
<li>资源限制：设置内存限制，包括虚拟内存</li>
<li>优先级：一些资源可以得到大量的CPU或磁盘IO吞吐量</li>
<li>结算：用来度量系统实际用了多少资源</li>
<li>控制：冻结组或检查点和重启动</li>
</ul>
</li>
</ul>
<h3 id="unionFS"><a href="#unionFS" class="headerlink" title="unionFS"></a>unionFS</h3><ul>
<li>unionFS(Union file systems)是一种分层、轻量级并且高性能的文件性能，支持对文件系统的修改作为一次提交来一层层的叠加。docker的镜像与容器就是分层存储，可用的存储引擎呦aufs，overlay等</li>
</ul>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ul>
<li>镜像是一份用来创造容器的配置文件，而容器可以视作最小型的一个操作系统</li>
<li>docker的镜像和容器都使用了unionFS做分层存储，镜像作为只读层是共享的，而容器在镜像之上附加了一层可写层，最大程度地减少了空间的浪费</li>
<li>镜像的相关命令<ul>
<li>镜像拉取：<code>docker pull node:alpine</code></li>
<li>查看镜像信息：<code>docker inspect node:alpine</code></li>
<li>列出所有镜像：<code>docker images</code></li>
<li>镜像打包：<code>docker build -t docker-app:v1.0.0</code><ul>
<li><code>-t</code>：设置镜像名字和版本号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul>
<li>Dockerfile是docker构建镜像的配置文件，比如一个简单的Dockerfile如下<pre><code class="highlight dockerfile"><span class="keyword">FROM</span> node:<span class="number">16</span>
<span class="keyword">MAINTAINER</span> songlh

<span class="keyword">ADD</span><span class="language-bash"> . /app</span>
<span class="keyword">WORKDIR</span><span class="language-bash"> /app</span>

<span class="keyword">RUN</span><span class="language-bash"> npm install pnpm -g</span>
<span class="keyword">RUN</span><span class="language-bash"> pnpm install</span>

<span class="keyword">CMD</span><span class="language-bash"> pnpm run dev</span></code></pre></li>
<li>常用指令</li>
<li><code>FROM</code>：表示基于一个已有的基础镜像，<code>FROM &lt;image&gt; [AS &lt;name&gt;]</code></li>
<li><code>MAINTAINER</code>：声明dockerfile镜像构建的作者</li>
<li><code>ADD</code>：表示把宿主机的文件或目录加入到镜像的文件系统，<code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li>
<li><code>RUN</code>: 在镜像中执行命令，由于ufs的文件系统，它会在当前镜像的顶层新增一层，<code>RUN &lt;command&gt;</code></li>
<li><code>CMD</code>: 指定容器如何启动，一个Dockerfile中只允许有一个CMD</li>
<li><code>WORKDIR</code>：设置工作目录</li>
<li><code>ENV</code>：设置环境变量</li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul>
<li><code>docker run</code>：创建容器<ul>
<li><code>docker run -p 8080:8080 --name docker-hello docker-app:v1.0.0</code>表示基于docker-app镜像的v1.0.0版本创建一个容器并在本地的8080端口运行，容器名字叫<code>docker-hellp</code></li>
<li><code>-p host-port:container-port</code>：宿主机与容器端口映射，方便容器对外提供服务</li>
<li><code>--name</code>：为容器指定名称</li>
<li><code>-d</code>：后台运行</li>
<li><code>--rm</code>：当停止容器时自动清除容器</li>
</ul>
</li>
<li><code>docker stop</code>：停止容器</li>
<li><code>docker rm</code>：删除容器</li>
<li><code>docker exec -it container-name</code>：进入容器环境</li>
<li><code>docker ps</code>：列出所有容器</li>
<li><code>docker port</code>：查看容器端口映射</li>
<li><code>docker stats</code>：查看容器资源占用</li>
</ul>
<h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h2><ul>
<li>按照目前已有知识，如果改了项目代码不会立刻生效，需要重新build和run，很麻烦，而且容器产生的数据，如果容器删除了就会没有，目录挂载就是为了解决这些问题</li>
<li>目前的挂载方式<ul>
<li><code>bind mount</code>：直接把宿主机目录映射到容器内，适合挂载代码目录和配置文件，可挂载到多个容器上</li>
<li><code>volume</code>：由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux文件系统，适合存储数据库数据。可挂载到多个容器上</li>
<li><code>tmpfs mount</code>：适合存储临时文件，存储在宿主机内存中。不可多容器共享</li>
<li><img src="https://s1.ax1x.com/2022/10/30/xI2Qi9.png"></li>
</ul>
</li>
</ul>
<h3 id="bind-mount"><a href="#bind-mount" class="headerlink" title="bind mount"></a>bind mount</h3><ul>
<li><code>bind mount</code>是通过<code>-v</code>参数来绑定宿主机目录，比如将外部的html文档挂载到Nginx容器的根目录下<ul>
<li><code>docker run -v ~/html:/usr/share/nginx/html -p 81:80 -d --name nginx_bind nginx:latest</code></li>
</ul>
</li>
<li>这种方式的缺点就是被挂载的宿主机目录(或文件)不受保护，任何容器都可以随意修改</li>
</ul>
<h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><ul>
<li>volume也是一个文件，但是这个文件是在docker的管控范围内，docker可以通过挂载的设定来控制容器对volume的读写权限</li>
<li>通过<code>docker volume create volume-name</code>创建一个Volume，实际上是在docker的<code>/var/lib/docker/volumes/</code>文件夹内创建一个相同名字的文件夹来保存数据</li>
<li>比如设置一个只能读取volume<ul>
<li><code>docker run --mount type=volume,source=nginx-volume,destination=/usr/share/nginx/html,readonly -p 82:80 -d --name nginx_volume nginx:latest</code></li>
</ul>
</li>
</ul>
<h3 id="tmpfs-mount"><a href="#tmpfs-mount" class="headerlink" title="tmpfs mount"></a>tmpfs mount</h3><ul>
<li>tmpfs挂载是临时的，仅保留在主机内存中。当容器停止时，tmpfs挂载被移除，写入的文件不会被持久化</li>
<li><code>docker run --mount type=tmpfs,destination=/usr/share/nginx/html -p 83:80 -d --name nginx-tempfs nginx:latest</code></li>
<li>tmpfs因为不是持久化，一般不使用</li>
</ul>
<h2 id="容器通信"><a href="#容器通信" class="headerlink" title="容器通信"></a>容器通信</h2><ul>
<li>容器间的通信根据媒介可以分为：volume共享通信、网络通信</li>
<li>根据通信范围可以分为：同主机通信、跨主机通信</li>
</ul>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul>
<li>Docker的网络通信模型分为以下几种，在安装Docker以后，会默认创建三种网络，可以通过<code>docker network ls</code>查看<ul>
<li><strong>bridge</strong>：为每一个容器分配、设置IP等，并将容器连接到一个<code>docker0</code>虚拟网桥，默认为该模式</li>
<li><strong>host</strong>：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</li>
<li><strong>none</strong>：容器有独立的<code>network namespace</code>，但并没有对其进行任何网络设置，如分配<code>veth pair</code>和网桥连接，IP等</li>
<li><strong>overlay</strong>：可以连接多个docker守护进程或者满足集群服务之间的通信，适用于不同宿主机上的docker容器之间的通信</li>
<li><strong>macvlan</strong>: 可以为docker容器分配MAC地址，使其像真实的物理及一样运行</li>
</ul>
</li>
<li>Docker内置的<code>bridge network</code>，也就是docker0接口所属的network，所有未指定network的容器，默认连接到此network中，其网段未<code>172.17.0.1/16</code>，所以两个未进行任何连接操作的容器是可以通过IP地址互相通信的，因为他们同在一个network下，但通信只能通过IP地址进行，不可以通过容器名通信<ul>
<li><img src="https://s1.ax1x.com/2022/10/30/xI21R1.png"></li>
</ul>
</li>
<li>创建自定义网络：<code>docker network create custom_network</code></li>
<li>查看网络模式：<code>docker network ls</code></li>
<li>通过自定义网络创建容器：<code>docker run -di --name docker-app --net custom_network docker-app:v1.0.0</code></li>
<li>查看容器的网络信息：<code>docker inspect 容器名称|ID</code>，然后在<code>NetworkSettings</code>节点中可以看到</li>
<li>为容器连接新的网络：<code>docker network connect 网络名称 容器名称</code></li>
<li>断开网络：<code>docker network disconnect 网络名称 容器名称</code></li>
</ul>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><ul>
<li>docker-compose是用于定义和运行多容器Docker应用程序的工具。通过compose，您可以使用YML文件来配置应用程序需要的所有服务，然后使用一个命令就可以从YML文件配置中创建并启动所有服务</li>
<li>使用分三步<ul>
<li><ol>
<li>使用Dockerfile定义应用程序的环境</li>
</ol>
</li>
<li><ol start="2">
<li>使用docker-compose.yml定义构成应用程序的服务，这样它们可以在隔离环境中一起运行</li>
</ol>
</li>
<li><ol start="3">
<li>最后，执行docker-compose up命令启动并运行整个应用程序</li>
</ol>
</li>
</ul>
</li>
<li>比如运行一个web项目和redis，可以编写一个如下的<code>docker-compose.yml</code>文件<pre><code class="highlight yml"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span>

<span class="attr">services:</span>
  <span class="attr">app:</span>
    <span class="attr">build:</span> <span class="string">./</span>
    <span class="attr">ports:</span>
      <span class="bullet">-</span> <span class="number">80</span><span class="string">:8080</span>
    <span class="attr">volumes:</span>
      <span class="bullet">-</span> <span class="string">./:/app</span>
  <span class="attr">redis:</span>
    <span class="attr">image:</span> <span class="string">redis:5.0.13</span>
    <span class="attr">volumes:</span>
      <span class="bullet">-</span> <span class="string">redis:/data</span>
<span class="attr">volumes:</span>
  <span class="attr">redis:</span></code></pre></li>
<li>version：指定本yml依从的compose哪个版本指定的</li>
<li>build: 指定构建镜像上下文路径</li>
<li>image：指定启动容器的镜像</li>
<li>volumes：卷挂载路径设置，如果跨多个服务并重用挂载卷，可以在volumes关键字中命名挂载卷</li>
<li>ports：暴露端口信息</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/Mr_YanMingXin/article/details/123016807">浅谈Docker底层原理</a></li>
<li><a href="https://docker.easydoc.net/">Docker快速入门</a></li>
<li><a href="https://q.shanyue.tech/deploy/docker.html#%E6%9C%AF%E8%AF%AD">Docker使用指南</a></li>
<li><a href="https://juejin.cn/post/6993979788020940830">Docker与数据：三种挂载方式</a></li>
<li><a href="https://www.cnblogs.com/mrhelloworld/p/docker11.html">Docker 网络模式详解及容器间网络通信</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>基于canvas实现的多功能画板</title>
    <url>/2022/09/21/%E5%9F%BA%E4%BA%8Ecanvas%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E5%8A%9F%E8%83%BD%E7%94%BB%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近空闲时间比较多，就想做点小工具玩玩，方案选了好几个，最终决定做一个基于canvas的画板，目前已经完成了第一版，有以下主要功能</p>
<ol>
<li>画笔（动态宽度设置，颜色设置）</li>
<li>橡皮擦</li>
<li>撤回，反撤回，清除画板，保存</li>
<li>画板拖拽</li>
<li>多图层</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>目前实现效果如下<br><img src="https://img-blog.csdnimg.cn/img_convert/6ee0b9163552f4c61abfde6af199b3ed.png"><br>预览地址：<a href="https://lhrun.github.io/paint-board/">https://lhrun.github.io/paint-board/</a><br>repo：<a href="https://github.com/LHRUN/paint-board">https://github.com/LHRUN/paint-board</a></p>
<h2 id="画板设计"><a href="#画板设计" class="headerlink" title="画板设计"></a>画板设计</h2><ol>
<li>首先是建立一个canvas画板类，所有canvas上的操作和数据全都在此处理，例如初始化，渲染，拖拽画板等等<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;
  <span class="attr">canvas</span>: <span class="title class_">HTMLCanvasElement</span>
  <span class="attr">context</span>: <span class="title class_">CanvasRenderingContext2D</span>
  ...
  <span class="title function_">constructor</span>(<span class="params">canvas: HTMLCanvasElement</span>) &#123;&#125;
  <span class="comment">// 初始化canvas</span>
  <span class="title function_">initCanvas</span>(<span class="params"></span>) &#123;&#125;
  <span class="comment">// 渲染</span>
  <span class="title function_">render</span>(<span class="params"></span>) &#123;&#125;
  <span class="comment">// 拖拽</span>
  <span class="title function_">drag</span>(<span class="params"></span>) &#123;&#125;
  ...
&#125;</code></pre></li>
<li>然后基于canvas类，根据当前的操作，建立对应的canvas元素，比如画笔，橡皮擦，基本类型如下<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">CanvasElement</span> &#123;
  <span class="attr">type</span>: string <span class="comment">// 元素类型</span>
  <span class="attr">layer</span>: number <span class="comment">// 图层</span>
  <span class="comment">// ...</span>
  <span class="title function_">constructor</span>(<span class="params">type: string, layer: number</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">type</span> = type
    <span class="variable language_">this</span>.<span class="property">layer</span> = layer
    <span class="comment">// ...</span>
  &#125;
  <span class="comment">// ...</span>
&#125;</code></pre></li>
<li>最后根据渲染逻辑，还会封装一些通用的逻辑来改变canvas上最终的展示，比如撤回，反撤回，图层操作等等</li>
</ol>
<h2 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h2><ul>
<li>实现画笔效果首先要在鼠标按下时建立一个画笔元素，然后在构造函数中接受基础宽度，颜色，初始化鼠标移动记录和线宽记录，然后在鼠标移动时记录鼠标移动的坐标</li>
<li>为了体现鼠标移动快，线宽就变窄，移动慢，线宽就恢复正常这个效果，我会计算当前移动的速度，然后根据速度计算线宽<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">FreeLine</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CanvasElement</span> &#123;
  ...
  <span class="title function_">constructor</span>(<span class="params">color: string, width: number, layer: number</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">positions</span> = [] <span class="comment">// 鼠标移动位置记录</span>
    <span class="variable language_">this</span>.<span class="property">lineWidths</span> = [<span class="number">0</span>] <span class="comment">// 线宽记录</span>
    <span class="variable language_">this</span>.<span class="property">color</span> = color <span class="comment">// 当前绘线颜色</span>
    <span class="variable language_">this</span>.<span class="property">maxWidth</span> = width <span class="comment">// 最大线宽</span>
    <span class="variable language_">this</span>.<span class="property">minWidth</span> = width / <span class="number">2</span> <span class="comment">// 最小线宽</span>
    <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> = width <span class="comment">// 最后绘线宽度</span>
  &#125;
&#125;</code></pre></li>
<li>记录鼠标位置和当前线宽<pre><code class="highlight js">interface <span class="title class_">MousePosition</span> &#123;
  <span class="attr">x</span>: number
  <span class="attr">y</span>: number
&#125;

<span class="title function_">addPosition</span>(<span class="params">position: MousePosition</span>) &#123;
  <span class="variable language_">this</span>.<span class="property">positions</span>.<span class="title function_">push</span>(position)
  <span class="comment">// 处理当前线宽</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;
    <span class="keyword">const</span> mouseSpeed = <span class="variable language_">this</span>.<span class="title function_">_computedSpeed</span>(
      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">2</span>],
      <span class="variable language_">this</span>.<span class="property">positions</span>[<span class="variable language_">this</span>.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">1</span>]
    )
    <span class="keyword">const</span> lineWidth = <span class="variable language_">this</span>.<span class="title function_">_computedLineWidth</span>(mouseSpeed)
    <span class="variable language_">this</span>.<span class="property">lineWidths</span>.<span class="title function_">push</span>(lineWidth)
  &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 计算移动速度</span>
<span class="comment"> * <span class="doctag">@param</span> start 起点</span>
<span class="comment"> * <span class="doctag">@param</span> end 终点</span>
<span class="comment"> */</span>
<span class="title function_">_computedSpeed</span>(<span class="params">start: MousePosition, end: MousePosition</span>) &#123;
  <span class="comment">// 获取距离</span>
  <span class="keyword">const</span> moveDistance = <span class="title function_">getDistance</span>(start, end)

  <span class="keyword">const</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()
  <span class="comment">// 获取移动间隔时间   lastMoveTime：最后鼠标移动时间</span>
  <span class="keyword">const</span> moveTime = curTime - <span class="variable language_">this</span>.<span class="property">lastMoveTime</span>
  <span class="comment">// 计算速度</span>
  <span class="keyword">const</span> mouseSpeed = moveDistance / moveTime
  <span class="comment">// 更新最后移动时间</span>
  <span class="variable language_">this</span>.<span class="property">lastMoveTime</span> = curTime
  <span class="keyword">return</span> mouseSpeed
&#125;

<span class="comment">/**</span>
<span class="comment"> * 计算画笔宽度</span>
<span class="comment"> * <span class="doctag">@param</span> speed 鼠标移动速度</span>
<span class="comment"> */</span>
<span class="title function_">_computedLineWidth</span>(<span class="params">speed: number</span>) &#123;
  <span class="keyword">let</span> lineWidth = <span class="number">0</span>
  <span class="keyword">const</span> minWidth = <span class="variable language_">this</span>.<span class="property">minWidth</span>
  <span class="keyword">const</span> maxWidth = <span class="variable language_">this</span>.<span class="property">maxWidth</span>
  <span class="keyword">if</span> (speed &gt;= <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) &#123;
    lineWidth = minWidth
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (speed &lt;= <span class="variable language_">this</span>.<span class="property">minSpeed</span>) &#123;
    lineWidth = maxWidth
  &#125; <span class="keyword">else</span> &#123;
    lineWidth = maxWidth - (speed / <span class="variable language_">this</span>.<span class="property">maxSpeed</span>) * maxWidth
  &#125;

  lineWidth = lineWidth * (<span class="number">1</span> / <span class="number">3</span>) + <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> * (<span class="number">2</span> / <span class="number">3</span>)
  <span class="variable language_">this</span>.<span class="property">lastLineWidth</span> = lineWidth
  <span class="keyword">return</span> lineWidth
&#125;</code></pre></li>
<li>保存坐标后，渲染就是遍历所有坐标<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">freeLineRender</span>(<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  instance: FreeLine</span>
<span class="params"></span>) &#123;
  context.<span class="title function_">save</span>()
  context.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>
  context.<span class="property">strokeStyle</span> = instance.<span class="property">color</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span>; i++) &#123;
    <span class="title function_">_drawLine</span>(instance, i, context)
  &#125;
  context.<span class="title function_">restore</span>()
&#125;

<span class="comment">/**</span>
<span class="comment"> * 画笔轨迹是借鉴了网上的一些方案，分两种情况</span>
<span class="comment"> * 1. 如果是前两个坐标，就通过lineTo连接即可</span>
<span class="comment"> * 2. 如果是前两个坐标之后的坐标，就采用贝塞尔曲线进行连接，</span>
<span class="comment"> *    比如现在有a, b, c 三个点，到c点时，把ab坐标的中间点作为起点</span>
<span class="comment"> *     bc坐标的中间点作为终点，b点作为控制点进行连接</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">_drawLine</span>(<span class="params"></span>
<span class="params">  instance: FreeLine,</span>
<span class="params">  i: number,</span>
<span class="params">  context: CanvasRenderingContext2D</span>
<span class="params"></span>) &#123;
  <span class="keyword">const</span> &#123; positions, lineWidths &#125; = instance
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: centerX, <span class="attr">y</span>: centerY &#125; = positions[i - <span class="number">1</span>]
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: endX, <span class="attr">y</span>: endY &#125; = positions[i]
  context.<span class="title function_">beginPath</span>()
  <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;
    context.<span class="title function_">moveTo</span>(centerX, centerY)
    context.<span class="title function_">lineTo</span>(endX, endY)
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">const</span> &#123; <span class="attr">x</span>: startX, <span class="attr">y</span>: startY &#125; = positions[i - <span class="number">2</span>]
    <span class="keyword">const</span> lastX = (startX + centerX) / <span class="number">2</span>
    <span class="keyword">const</span> lastY = (startY + centerY) / <span class="number">2</span>
    <span class="keyword">const</span> x = (centerX + endX) / <span class="number">2</span>
    <span class="keyword">const</span> y = (centerY + endY) / <span class="number">2</span>
    context.<span class="title function_">moveTo</span>(lastX, lastY)
    context.<span class="title function_">quadraticCurveTo</span>(centerX, centerY, x, y)
  &#125;

  context.<span class="property">lineWidth</span> = lineWidths[i]
  context.<span class="title function_">stroke</span>()
&#125;</code></pre></li>
</ul>
<h2 id="橡皮擦"><a href="#橡皮擦" class="headerlink" title="橡皮擦"></a>橡皮擦</h2><ul>
<li>橡皮擦是一个线状擦除，我采用的方案是通过计算每个点的圆弧轨迹和两个点之间的矩形区域，然后通过clip剪切后清除<br><img src="https://img-blog.csdnimg.cn/img_convert/8ae8229d79cd8b69d175d5fbb68e3c43.png"><pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 橡皮擦渲染</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> cleanCanvas 清除画板</span>
<span class="comment"> * <span class="doctag">@param</span> instance CleanLine</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">cleanLineRender</span>(<span class="params"></span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  cleanCanvas: () =&gt; <span class="keyword">void</span>,</span>
<span class="params">  instance: CleanLine</span>
<span class="params"></span>) &#123;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; instance.<span class="property">positions</span>.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;
    <span class="title function_">_cleanLine</span>(
      instance.<span class="property">positions</span>[i],
      instance.<span class="property">positions</span>[i + <span class="number">1</span>],
      context,
      cleanCanvas,
      instance.<span class="property">cleanWidth</span>
    )
  &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 线状清除</span>
<span class="comment"> * <span class="doctag">@param</span> start 起点</span>
<span class="comment"> * <span class="doctag">@param</span> end 终点</span>
<span class="comment"> * <span class="doctag">@param</span> context canvas二维渲染上下文</span>
<span class="comment"> * <span class="doctag">@param</span> cleanCanvas 清除画板</span>
<span class="comment"> * <span class="doctag">@param</span> cleanWidth 清楚宽度</span>
<span class="comment"> */</span>
<span class="keyword">function</span> <span class="title function_">_cleanLine</span>(<span class="params"></span>
<span class="params">  start: MousePosition,</span>
<span class="params">  end: MousePosition,</span>
<span class="params">  context: CanvasRenderingContext2D,</span>
<span class="params">  cleanCanvas: () =&gt; <span class="keyword">void</span>,</span>
<span class="params">  cleanWidth: number</span>
<span class="params"></span>)&#123;
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: x1, <span class="attr">y</span>: y1 &#125; = start
  <span class="keyword">const</span> &#123; <span class="attr">x</span>: x2, <span class="attr">y</span>: y2 &#125; = end

  <span class="comment">// 获取鼠标起点和终点之间的矩形区域端点</span>
  <span class="keyword">const</span> asin = cleanWidth * <span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="title class_">Math</span>.<span class="title function_">atan</span>((y2 - y1) / (x2 - x1)))
  <span class="keyword">const</span> acos = cleanWidth * <span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="title class_">Math</span>.<span class="title function_">atan</span>((y2 - y1) / (x2 - x1)))
  <span class="keyword">const</span> x3 = x1 + asin
  <span class="keyword">const</span> y3 = y1 - acos
  <span class="keyword">const</span> x4 = x1 - asin
  <span class="keyword">const</span> y4 = y1 + acos
  <span class="keyword">const</span> x5 = x2 + asin
  <span class="keyword">const</span> y5 = y2 - acos
  <span class="keyword">const</span> x6 = x2 - asin
  <span class="keyword">const</span> y6 = y2 + acos

  <span class="comment">// 清除末端圆弧</span>
  context.<span class="title function_">save</span>()
  context.<span class="title function_">beginPath</span>()
  context.<span class="title function_">arc</span>(x2, y2, cleanWidth, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>)
  context.<span class="title function_">clip</span>()
  <span class="title function_">cleanCanvas</span>()
  context.<span class="title function_">restore</span>()

  <span class="comment">// 清除矩形区域</span>
  context.<span class="title function_">save</span>()
  context.<span class="title function_">beginPath</span>()
  context.<span class="title function_">moveTo</span>(x3, y3)
  context.<span class="title function_">lineTo</span>(x5, y5)
  context.<span class="title function_">lineTo</span>(x6, y6)
  context.<span class="title function_">lineTo</span>(x4, y4)
  context.<span class="title function_">closePath</span>()
  context.<span class="title function_">clip</span>()
  <span class="title function_">cleanCanvas</span>()
  context.<span class="title function_">restore</span>()
&#125;</code></pre></li>
</ul>
<h2 id="撤回、反撤回"><a href="#撤回、反撤回" class="headerlink" title="撤回、反撤回"></a>撤回、反撤回</h2><ul>
<li>实现撤回，反撤回就要把canvas上的每个元素的渲染数据进行存储，通过改变控制变量，限制渲染元素的遍历，这样就可以达到撤回的效果</li>
<li>首先画板初始化时建立一个history类，然后建立缓存和step数据，撤回和反撤回时，只需要修改step即可<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">History</span>&lt;T&gt; &#123;
  <span class="attr">cacheQueue</span>: T[]
  <span class="attr">step</span>: number
  <span class="title function_">constructor</span>(<span class="params">cacheQueue: T[]</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">cacheQueue</span> = cacheQueue
    <span class="variable language_">this</span>.<span class="property">step</span> = cacheQueue.<span class="property">length</span> - <span class="number">1</span>
  &#125;
  <span class="comment">// 添加数据</span>
  <span class="title function_">add</span>(<span class="params">data: T</span>) &#123;
    <span class="comment">// 如果在回退时添加数据就删除暂存数据</span>
    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> !== <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;
      <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> = <span class="variable language_">this</span>.<span class="property">step</span> + <span class="number">1</span>
    &#125;
    <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="title function_">push</span>(data)
    <span class="variable language_">this</span>.<span class="property">step</span> = <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span>
  &#125;

  <span class="comment">// 遍历cacheQueue</span>
  <span class="title function_">each</span>(<span class="params">cb?: (ele: T, i: number) =&gt; <span class="keyword">void</span></span>) &#123;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="variable language_">this</span>.<span class="property">step</span>; i++) &#123;
      cb?.(<span class="variable language_">this</span>.<span class="property">cacheQueue</span>[i], i)
    &#125;
  &#125;

  <span class="comment">// 后退</span>
  <span class="title function_">undo</span>(<span class="params"></span>) &#123;
    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> &gt;= <span class="number">0</span>) &#123;
      <span class="variable language_">this</span>.<span class="property">step</span>--
      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheQueue</span>[<span class="variable language_">this</span>.<span class="property">step</span>]
    &#125;
  &#125;

  <span class="comment">// 前进</span>
  <span class="title function_">redo</span>(<span class="params"></span>) &#123;
    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">step</span> &lt; <span class="variable language_">this</span>.<span class="property">cacheQueue</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;
      <span class="variable language_">this</span>.<span class="property">step</span>++
      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheQueue</span>[<span class="variable language_">this</span>.<span class="property">step</span>]
    &#125;
  &#125;
&#125;</code></pre></li>
<li>针对画板，通过监听鼠标按下操作，在history中添加一个元素，然后对渲染函数的遍历限制到step就达到了撤回的效果<pre><code class="highlight js"><span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;
  ...
  <span class="comment">/**</span>
<span class="comment">   * 记录当前元素，并加入history</span>
<span class="comment">   */</span>
  <span class="title function_">recordCurrent</span>(<span class="params">type: string</span>) &#123;
    <span class="keyword">let</span> <span class="attr">ele</span>: <span class="variable constant_">ELEMENT_INSTANCE</span> | <span class="literal">null</span> = <span class="literal">null</span>
    <span class="keyword">switch</span> (type) &#123;
      <span class="keyword">case</span> <span class="variable constant_">CANVAS_ELE_TYPE</span>.<span class="property">FREE_LINE</span>:
        ele = <span class="keyword">new</span> <span class="title class_">FreeLine</span>(
          <span class="variable language_">this</span>.<span class="property">currentLineColor</span>,
          <span class="variable language_">this</span>.<span class="property">currentLineWidth</span>,
          <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">current</span>
        )
        <span class="keyword">break</span>
      <span class="keyword">case</span> <span class="variable constant_">CANVAS_ELE_TYPE</span>.<span class="property">CLEAN_LINE</span>:
        ele = <span class="keyword">new</span> <span class="title class_">CleanLine</span>(<span class="variable language_">this</span>.<span class="property">cleanWidth</span>, <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">current</span>)
        <span class="keyword">break</span>
      <span class="attr">default</span>:
        <span class="keyword">break</span>
    &#125;
    <span class="keyword">if</span> (ele) &#123;
      <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">add</span>(ele)
      <span class="variable language_">this</span>.<span class="property">currentEle</span> = ele
    &#125;
  &#125;

  <span class="comment">/**</span>
<span class="comment">   * 遍历history渲染数据</span>
<span class="comment">   */</span>
  <span class="title function_">render</span>(<span class="params"></span>) &#123;
    <span class="comment">// 清除画布</span>
    <span class="variable language_">this</span>.<span class="title function_">cleanCanvas</span>()
    <span class="comment">// 遍历history</span>
    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">each</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;
      <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">save</span>()
      <span class="comment">// render....</span>
      <span class="variable language_">this</span>.<span class="property">context</span>,<span class="title function_">resore</span>()
    &#125;)
    <span class="comment">// 缓存数据</span>
    <span class="variable language_">this</span>.<span class="title function_">cache</span>()
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="拖拽画布"><a href="#拖拽画布" class="headerlink" title="拖拽画布"></a>拖拽画布</h2><ul>
<li>拖拽画布的实现是通过计算鼠标移动距离，根据距离改变画布的原点位置，达到拖拽的效果</li>
</ul>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">drag</span>(<span class="params">position: MousePosition</span>) &#123;
  <span class="keyword">const</span> mousePosition = &#123;
    <span class="attr">x</span>: position.<span class="property">x</span> - <span class="variable language_">this</span>.<span class="property">canvasRect</span>.<span class="property">left</span>,
    <span class="attr">y</span>: position.<span class="property">y</span> - <span class="variable language_">this</span>.<span class="property">canvasRect</span>.<span class="property">top</span>
  &#125;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">x</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">y</span>) &#123;
    <span class="keyword">const</span> translteX = mousePosition.<span class="property">x</span> - <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">x</span>
    <span class="keyword">const</span> translteY = mousePosition.<span class="property">y</span> - <span class="variable language_">this</span>.<span class="property">originPosition</span>.<span class="property">y</span>
    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">translate</span>(translteX, translteY)
    <span class="variable language_">this</span>.<span class="property">originTranslate</span> = &#123;
      <span class="attr">x</span>: translteX + <span class="variable language_">this</span>.<span class="property">originTranslate</span>.<span class="property">x</span>,
      <span class="attr">y</span>: translteY + <span class="variable language_">this</span>.<span class="property">originTranslate</span>.<span class="property">y</span>
    &#125;
    <span class="variable language_">this</span>.<span class="title function_">render</span>()
  &#125;
  <span class="variable language_">this</span>.<span class="property">originPosition</span> = mousePosition
&#125;</code></pre>

<h2 id="多图层"><a href="#多图层" class="headerlink" title="多图层"></a>多图层</h2><p>实现多图层需要对以下几个地方进行处理</p>
<ol>
<li>画板初始化时建立图层类，所有的图层数据和图层逻辑全在此处</li>
<li>然后对canvas上的元素加layer属性，用于判断归属于哪个图层</li>
<li>画板的渲染函数改为按照图层顺序进行渲染</li>
<li>拖拽或者隐藏图层都需要重新渲染，删除图层把对应的缓存图层元素进行删除</li>
</ol>
<pre><code class="highlight js">interface <span class="title class_">ILayer</span> &#123;
  <span class="attr">id</span>: number <span class="comment">// 图层id</span>
  <span class="attr">title</span>: string <span class="comment">// 图层名称</span>
  <span class="attr">show</span>: boolean <span class="comment">// 图层展示状态</span>
&#125;

<span class="comment">/**</span>
<span class="comment"> * 图层</span>
<span class="comment"> */</span>
<span class="keyword">class</span> <span class="title class_">Layer</span> &#123;
  <span class="attr">stack</span>: <span class="title class_">ILayer</span>[] <span class="comment">// 图层数据</span>
  <span class="attr">current</span>: number <span class="comment">// 当前图层</span>
  <span class="attr">render</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span> <span class="comment">// 画板渲染事件</span>

  <span class="title function_">constructor</span>(<span class="params">render: () =&gt; <span class="keyword">void</span>, initData?: Layer</span>) &#123;
    <span class="keyword">const</span> &#123;
      stack = [
        &#123;
          <span class="attr">id</span>: <span class="number">1</span>,
          <span class="attr">title</span>: <span class="string">&#x27;item1&#x27;</span>,
          <span class="attr">show</span>: <span class="literal">true</span>
        &#125;
      ],
      id = <span class="number">1</span>,
      current = <span class="number">1</span>
    &#125; = initData || &#123;&#125;
    <span class="variable language_">this</span>.<span class="property">stack</span> = stack
    <span class="variable language_">this</span>.<span class="property">id</span> = id
    <span class="variable language_">this</span>.<span class="property">current</span> = current
    <span class="variable language_">this</span>.<span class="property">render</span> = render
  &#125;
  ...
&#125;

<span class="keyword">class</span> <span class="title class_">PaintBoard</span> &#123;
  <span class="comment">// 通过图层进行排序</span>
   <span class="title function_">sortOnLayer</span>(<span class="params"></span>) &#123;
     <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;
       <span class="keyword">return</span> (
         <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> id === b?.<span class="property">layer</span>) -
         <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">&#123; id &#125;</span>) =&gt;</span> id === a?.<span class="property">layer</span>)
       )
     &#125;)
   &#125;

   <span class="comment">// 渲染函数只渲染图层展示状态的元素</span>
   <span class="title function_">render</span>(<span class="params"></span>) &#123;
     <span class="keyword">const</span> showLayerIds = <span class="keyword">new</span> <span class="title class_">Set</span>(
       <span class="variable language_">this</span>.<span class="property">layer</span>.<span class="property">stack</span>.<span class="property">reduce</span>&lt;number[]&gt;(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;
         <span class="keyword">return</span> cur.<span class="property">show</span> ? [...acc, cur.<span class="property">id</span>] : acc
       &#125;, [])
     )
     <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">each</span>(<span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;
       <span class="keyword">if</span> (ele?.<span class="property">layer</span> &amp;&amp; showLayerIds.<span class="title function_">has</span>(ele.<span class="property">layer</span>)) &#123;
         ...
       &#125;
     &#125; 
   &#125;
&#125;</code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>我本篇主要是分享一些主要逻辑，还有一些兼容问题和一些UI交互就不叙述了</li>
<li>这个画板写下来大概用了一个星期，有好多功能还没写上，如果过段时间有空的话就继续写下去，并进一步优化，现在还是有点优化问题没有写好，比如画笔宽度显示的还是有点问题，原点位置和一些初始化设计的不太好，不过写完这个画板还是挺有成就感的</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/axes/p/3850309.html">HTML5 实现橡皮擦的擦除效果</a></li>
<li><a href="https://juejin.cn/post/7091276963146530847">我做了一个在线白板！</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>基于markdown-it打造的markdown编辑器</title>
    <url>/2022/10/12/%E5%9F%BA%E4%BA%8Emarkdown-it%E6%89%93%E9%80%A0%E7%9A%84markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>markdown-it是一个用来解析markdown的库，它可以将markdown编译为html，然后解析时markdown-it会根据规则生成tokens，如果需要自定义，就通过rules函数对token进行处理<br>我现在基于markdown-it已完成第一版编辑器，现有以下功能：</p>
<ol>
<li>快捷编辑按钮</li>
<li>代码块主题切换</li>
<li>同步滚动</li>
<li>目录列表生成</li>
<li>内容状态缓存</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>目前实现效果如下<br><img src="https://s1.ax1x.com/2022/10/12/xaMejs.jpg"></p>
<p>预览地址：<a href="https://lhrun.github.io/md-editor/">https://lhrun.github.io/md-editor/</a><br>repo：<a href="https://github.com/LHRUN/md-editor">https://github.com/LHRUN/md-editor</a> 欢迎star⭐️</p>
<h2 id="编辑器设计"><a href="#编辑器设计" class="headerlink" title="编辑器设计"></a>编辑器设计</h2><ol>
<li>页面布局分四部分，顶部是快捷工具栏，然后主体内容分三部分，编辑区域(textarea)、html展示区域、目录列表(可展示隐藏)，因为我是用react开发的，所以html字符串我是通过<a href="https://zh-hans.reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml">dangerouslySetInnerHTML</a>设置</li>
<li>markdown-it初始化<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">MD</span> = <span class="keyword">new</span> <span class="title class_">MarkdownIt</span>(&#123;
  <span class="attr">html</span>: <span class="literal">true</span>, <span class="comment">// 在源码中启用HTML标签</span>
  <span class="attr">linkify</span>: <span class="literal">true</span>, <span class="comment">// 将类似URL的文本自动转换为链接</span>
  <span class="attr">breaks</span>: <span class="literal">true</span>, <span class="comment">// 转换段落里的 &#x27;\n&#x27; 到 &lt;br&gt;</span>
  <span class="attr">highlight</span>: <span class="keyword">function</span> (<span class="params">str, lang</span>) &#123;
    <span class="keyword">return</span> <span class="title function_">highlightFormatCode</span>(str, lang)
  &#125;
&#125;)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItSub</span>)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItSup</span>)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItMark</span>)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItDeflist</span>)
  .<span class="title function_">use</span>(<span class="title class_">MarkdownItTaskLists</span>)
  .<span class="title function_">use</span>(markdownItAbbr)
  .<span class="title function_">use</span>(markdownItFootnote)
  <span class="comment">// 其余的markdownIt插件...</span>

<span class="keyword">const</span> highlightFormatCode = (<span class="attr">str</span>: string, <span class="attr">lang</span>: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;
  <span class="keyword">if</span> (lang &amp;&amp; hljs.<span class="title function_">getLanguage</span>(lang)) &#123;
    <span class="keyword">try</span> &#123;
      <span class="keyword">return</span> <span class="title function_">codeBlockStyle</span>(hljs.<span class="title function_">highlight</span>(lang, str, <span class="literal">true</span>).<span class="property">value</span>)
    &#125; <span class="keyword">catch</span> (e) &#123;
      <span class="variable language_">console</span>.<span class="title function_">error</span>(e)
    &#125;
  &#125;

  <span class="keyword">return</span> <span class="title function_">codeBlockStyle</span>(<span class="variable constant_">MD</span>.<span class="property">utils</span>.escapeHtml(str))
&#125;

<span class="keyword">const</span> codeBlockStyle = (<span class="attr">val</span>: string): <span class="function"><span class="params">string</span> =&gt;</span> &#123;
  <span class="keyword">return</span> <span class="string">`&lt;pre class=&quot;hljs&quot; style=&quot;padding: 10px;border-radius: 10px;&quot;&gt;&lt;code&gt;<span class="subst">$&#123;val&#125;</span>&lt;/code&gt;&lt;/pre&gt;`</span>
&#125;</code></pre></li>
</ol>
<h2 id="快捷编辑按钮"><a href="#快捷编辑按钮" class="headerlink" title="快捷编辑按钮"></a>快捷编辑按钮</h2><p>快捷便捷按钮主要是通过判断textarea的光标位置，然后通过光标位置改变编辑器文本内容，比如添加图片</p>
<pre><code class="highlight js"><span class="comment">// 获取光标位置</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getCursorPosition</span> = (<span class="params">editor: HTMLTextAreaElement</span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; selectionStart, selectionEnd &#125; = editor
  <span class="keyword">return</span> [selectionStart, selectionEnd]
&#125;

<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addImage</span> = (<span class="params"></span>
<span class="params">  editor: HTMLTextAreaElement,</span>
<span class="params">  source: string,</span>
<span class="params">  setSource: (v: string) =&gt; <span class="keyword">void</span></span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> [start, end] = <span class="title function_">getCursorPosition</span>(editor)
  <span class="keyword">let</span> val = source
  <span class="keyword">if</span> (start === end) &#123;
    val = <span class="string">`<span class="subst">$&#123;source.slice(<span class="number">0</span>, start)&#125;</span>\n![图片描述](url)\n<span class="subst">$&#123;source.slice(end)&#125;</span>`</span>
  &#125; <span class="keyword">else</span> &#123;
    val = <span class="string">`<span class="subst">$&#123;source.slice(<span class="number">0</span>, start)&#125;</span>\n![<span class="subst">$&#123;source.slice(</span></span>
<span class="subst"><span class="string">      start,</span></span>
<span class="subst"><span class="string">      end</span></span>
<span class="subst"><span class="string">    )&#125;</span>](url)\n<span class="subst">$&#123;source.slice(end)&#125;</span>`</span>
  &#125;
  <span class="title function_">setSource</span>(val)
&#125;</code></pre>

<h2 id="代码块主题切换"><a href="#代码块主题切换" class="headerlink" title="代码块主题切换"></a>代码块主题切换</h2><ul>
<li>代码块高亮我是采用了<strong>highlight.js</strong>，因为这个库提供了很多主题样式，所以主题切换，我只需要改变css link即可<pre><code class="highlight js"><span class="comment">// codeTheme就是已选的主题名字</span>
<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;
  <span class="keyword">if</span> (codeTheme) &#123;
    <span class="title function_">switchLink</span>(
      <span class="string">&#x27;code-style&#x27;</span>,
      <span class="string">`https://cdn.bootcdn.net/ajax/libs/highlight.js/11.6.0/styles/<span class="subst">$&#123;codeTheme&#125;</span>.min.css`</span>
    )
  &#125;
&#125;, [codeTheme])

<span class="comment">/**</span>
<span class="comment"> * 切换html css link</span>
<span class="comment"> * <span class="doctag">@param</span> key link key 指定唯一标识，用于切换link</span>
<span class="comment"> * <span class="doctag">@param</span> href link href</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">switchLink</span> = (<span class="params">key: string, href: string</span>) =&gt; &#123;
  <span class="keyword">const</span> head = <span class="variable language_">document</span>.<span class="property">head</span>
  <span class="keyword">const</span> oldLink = head.<span class="title function_">getElementsByClassName</span>(key)
  <span class="keyword">if</span> (oldLink.<span class="property">length</span>) head.<span class="title function_">removeChild</span>(oldLink[<span class="number">0</span>])

  <span class="keyword">const</span> newLink = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>)
  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>)
  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>)
  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, key)
  newLink.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, href)
  newLink.<span class="property">onerror</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;
    <span class="variable language_">console</span>.<span class="title function_">error</span>(e)
    message.<span class="title function_">error</span>(<span class="string">&#x27;获取css link失败&#x27;</span>)
  &#125;
  head.<span class="title function_">appendChild</span>(newLink)
&#125;</code></pre></li>
</ul>
<h2 id="同步滚动"><a href="#同步滚动" class="headerlink" title="同步滚动"></a>同步滚动</h2><p>同步滚动是我认为最难搞的一个功能，因为我不想仅仅通过百分比来计算滚动距离，因为这样的话如果编辑区域添加了一堆图片，预览就会有非常大的高度差。我在网上找了许多方案，最后发现markdown-it的官方实现是我能找到并能实现的最佳方案，大致实现思路是如下</p>
<ol>
<li><p>首先在编译时对标题元素和段落元素添加行号</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 注入行号</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="attr">injectLineNumbers</span>: <span class="title class_">Renderer</span>.<span class="property">RenderRule</span> = <span class="function">(<span class="params"></span></span>
<span class="params"><span class="function">  tokens,</span></span>
<span class="params"><span class="function">  idx,</span></span>
<span class="params"><span class="function">  options,</span></span>
<span class="params"><span class="function">  _env,</span></span>
<span class="params"><span class="function">  slf</span></span>
<span class="params"><span class="function"></span>) =&gt;</span> &#123;
  <span class="keyword">let</span> line
  <span class="keyword">if</span> (tokens[idx].<span class="property">map</span> &amp;&amp; tokens[idx].<span class="property">level</span> === <span class="number">0</span>) &#123;
    line = (tokens[idx].<span class="property">map</span> <span class="keyword">as</span> [number, number])[<span class="number">0</span>]
    tokens[idx].<span class="title function_">attrJoin</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;line&#x27;</span>)
    tokens[idx].<span class="title function_">attrSet</span>(<span class="string">&#x27;data-line&#x27;</span>, <span class="title class_">String</span>(line))
  &#125;
  <span class="keyword">return</span> slf.<span class="title function_">renderToken</span>(tokens, idx, options)
&#125;

<span class="variable constant_">MD</span>.<span class="property">renderer</span>.<span class="property">rules</span>.<span class="property">heading_open</span> = <span class="variable constant_">MD</span>.<span class="property">renderer</span>.<span class="property">rules</span>.<span class="property">paragraph_open</span> = injectLineNumbers</code></pre>
</li>
<li><p>滚动前计算出当前编辑区域每行对应的预览偏移距离，有标记行号的元素直接计算offset，未标记行号的元素就等比计算</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 获取编辑区域每行对应的预览偏移距离</span>
<span class="comment"> * <span class="doctag">@param</span> editor 编辑元素</span>
<span class="comment"> * <span class="doctag">@param</span> review 预览元素</span>
<span class="comment"> * <span class="doctag">@returns</span> number[]</span>
<span class="comment"> */</span>
<span class="keyword">const</span> <span class="title function_">buildScrollMap</span> = (<span class="params"></span>
<span class="params">  editor: HTMLTextAreaElement,</span>
<span class="params">  review: HTMLDivElement</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> <span class="attr">lineHeightMap</span>: number[] = []
  <span class="keyword">let</span> linesCount = <span class="number">0</span> <span class="comment">// 编辑区总行数</span>

  <span class="comment">/**</span>
<span class="comment">   * 临时创建元素获取每次换行之间的总行数</span>
<span class="comment">   */</span>
  <span class="keyword">const</span> sourceLine = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)
  sourceLine.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>
  sourceLine.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;hidden&#x27;</span>
  sourceLine.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;auto&#x27;</span>
  sourceLine.<span class="property">style</span>.<span class="property">width</span> = <span class="string">`<span class="subst">$&#123;editor.clientWidth&#125;</span>px`</span>
  sourceLine.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;15px&#x27;</span>
  sourceLine.<span class="property">style</span>.<span class="property">lineHeight</span> = <span class="string">`<span class="subst">$&#123;LINE_HEIGHT&#125;</span>px`</span>
  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(sourceLine)
  <span class="keyword">let</span> acc = <span class="number">0</span>
  editor.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">str</span>) =&gt;</span> &#123;
    lineHeightMap.<span class="title function_">push</span>(acc)
    <span class="keyword">if</span> (str.<span class="property">length</span> === <span class="number">0</span>) &#123;
      acc++
      <span class="keyword">return</span>
    &#125;
    sourceLine.<span class="property">textContent</span> = str
    <span class="keyword">const</span> h = sourceLine.<span class="property">offsetHeight</span>
    acc += <span class="title class_">Math</span>.<span class="title function_">round</span>(h / <span class="variable constant_">LINE_HEIGHT</span>)
  &#125;)
  sourceLine.<span class="title function_">remove</span>()
  lineHeightMap.<span class="title function_">push</span>(acc)
  linesCount = acc

  <span class="comment">// 最终输出的偏移map</span>
  <span class="keyword">const</span> <span class="attr">_scrollMap</span>: number[] = <span class="keyword">new</span> <span class="title class_">Array</span>(linesCount).<span class="title function_">fill</span>(-<span class="number">1</span>)

  <span class="comment">/**</span>
<span class="comment">   * 获取标记行号的offset距离</span>
<span class="comment">   */</span>
  <span class="keyword">const</span> nonEmptyList = []
  nonEmptyList.<span class="title function_">push</span>(<span class="number">0</span>)
  _scrollMap[<span class="number">0</span>] = <span class="number">0</span>
  <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.line&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;
    <span class="keyword">let</span> <span class="attr">t</span>: string | number = el.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-line&#x27;</span>) <span class="keyword">as</span> string
    <span class="keyword">if</span> (t === <span class="string">&#x27;&#x27;</span>) &#123;
      <span class="keyword">return</span>
    &#125;
    t = lineHeightMap[<span class="title class_">Number</span>(t)]
    <span class="keyword">if</span> (t !== <span class="number">0</span>) &#123;
      nonEmptyList.<span class="title function_">push</span>(t)
    &#125;
    _scrollMap[t] = <span class="title class_">Math</span>.<span class="title function_">round</span>((el <span class="keyword">as</span> <span class="title class_">HTMLElement</span>).<span class="property">offsetTop</span> - review.<span class="property">offsetTop</span>)
  &#125;)

  nonEmptyList.<span class="title function_">push</span>(linesCount)
  _scrollMap[linesCount] = review.<span class="property">scrollHeight</span>

  <span class="comment">/**</span>
<span class="comment">   * 未标记行号的元素等比计算</span>
<span class="comment">   */</span>
  <span class="keyword">let</span> pos = <span class="number">0</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; linesCount; i++) &#123;
    <span class="keyword">if</span> (_scrollMap[i] !== -<span class="number">1</span>) &#123;
      pos++
      <span class="keyword">continue</span>
    &#125;
    <span class="keyword">const</span> a = nonEmptyList[pos]
    <span class="keyword">const</span> b = nonEmptyList[pos + <span class="number">1</span>]
    _scrollMap[i] = <span class="title class_">Math</span>.<span class="title function_">round</span>(
      (_scrollMap[b] * (i - a) + _scrollMap[a] * (b - i)) / (b - a)
    )
  &#125;

  <span class="keyword">return</span> _scrollMap
&#125;</code></pre>
</li>
<li><p>编辑区域滚动根据具体行获取需滚动高度</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">editorScroll</span> = (<span class="params"></span>
<span class="params">  editor: HTMLTextAreaElement,</span>
<span class="params">  preview: HTMLDivElement</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">if</span> (!scrollMap) &#123;
    scrollMap = <span class="title function_">buildScrollMap</span>(editor, preview)
  &#125;

  <span class="keyword">const</span> lineNo = <span class="title class_">Math</span>.<span class="title function_">floor</span>(editor.<span class="property">scrollTop</span> / <span class="variable constant_">LINE_HEIGHT</span>)
  <span class="keyword">const</span> posTo = scrollMap[lineNo]
  preview.<span class="title function_">scrollTo</span>(&#123; <span class="attr">top</span>: posTo &#125;)
&#125;</code></pre></li>
<li><p>预览区域滚动根据当前的滚动高度查对应编辑区域的行，然后根据计算滚动高度</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">previewScroll</span> = (<span class="params"></span>
<span class="params">  editor: HTMLTextAreaElement,</span>
<span class="params">  preview: HTMLDivElement</span>
<span class="params"></span>) =&gt; &#123;
  <span class="keyword">if</span> (!scrollMap) &#123;
    scrollMap = <span class="title function_">buildScrollMap</span>(editor, preview)
  &#125;

  <span class="keyword">const</span> lines = <span class="title class_">Object</span>.<span class="title function_">keys</span>(scrollMap)
  <span class="keyword">if</span> (lines.<span class="property">length</span> &lt; <span class="number">1</span>) &#123;
    <span class="keyword">return</span>
  &#125;
  <span class="keyword">let</span> line = lines[<span class="number">0</span>]
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; lines.<span class="property">length</span>; i++) &#123;
    <span class="keyword">if</span> (scrollMap[<span class="title class_">Number</span>(lines[i])] &lt; preview.<span class="property">scrollTop</span>) &#123;
      line = lines[i]
      <span class="keyword">continue</span>
    &#125;
    <span class="keyword">break</span>
  &#125;
  editor.<span class="title function_">scrollTo</span>(&#123; <span class="attr">top</span>: <span class="variable constant_">LINE_HEIGHT</span> * <span class="title class_">Number</span>(line) &#125;)
&#125;</code></pre></li>
</ol>
<h3 id="同步滚动注意点"><a href="#同步滚动注意点" class="headerlink" title="同步滚动注意点"></a>同步滚动注意点</h3><ol>
<li>在改变编辑内容和窗口大小时需清空计算结果，因为这两个一改变，每行的偏移距离就会发生变化，在滚动时需要重新计算</li>
<li>同步滚动时会有一个无限触发的问题，因为编辑区域滚动，会触发预览区域的<code>scrollTo()</code>，然后预览区域的滚动监听方法就会被触发，然后这样就会无限触发下去，所以需要一个变量记住当前的手动滚动的区域，进行限制</li>
</ol>
<h2 id="目录列表生成"><a href="#目录列表生成" class="headerlink" title="目录列表生成"></a>目录列表生成</h2><p>目录列表通过rules的<code>heading_open</code>方法，获取当前标题的token，然后通过token得出标题的具体内容进行拼接，最后根据level计算字体大小</p>
<ul>
<li>获取标题内容<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">getTitle</span> = (<span class="params">tokens: Token[], idx: number</span>) =&gt; &#123;
  <span class="keyword">const</span> &#123; children &#125; = tokens[idx + <span class="number">1</span>]
  <span class="keyword">const</span> &#123; markup &#125; = tokens[idx]
  <span class="keyword">const</span> val = children?.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;acc&#125;</span><span class="subst">$&#123;cur.content&#125;</span>`</span>, <span class="string">&#x27;&#x27;</span>) || <span class="string">&#x27;&#x27;</span>
  toc.<span class="title function_">push</span>(&#123;
    val,
    <span class="attr">level</span>: markup.<span class="property">length</span>
  &#125;)
&#125;</code></pre></li>
<li>html展示<pre><code class="highlight js">&#123;showToc &amp;&amp; (
  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.toc&#125;</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.tocTitle&#125;</span>&gt;</span>目录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span>
<span class="language-xml">      &#123;tocList.map((&#123; val, level &#125;, index) =&gt; &#123;</span>
<span class="language-xml">        const fontSize = ((7 - level) / 10) * 40</span>
<span class="language-xml"></span>
<span class="language-xml">        return (</span>
<span class="language-xml">          <span class="tag">&lt;<span class="name">div</span></span></span>
<span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span>
<span class="tag"><span class="language-xml">              <span class="attr">marginLeft:</span> `$&#123;<span class="attr">level</span> * <span class="attr">10</span>&#125;<span class="attr">px</span>`,</span></span>
<span class="tag"><span class="language-xml">              <span class="attr">fontSize:</span> `$&#123;<span class="attr">fontSize</span> &gt;</span> 12 ? fontSize : 12&#125;px`</span>
<span class="language-xml">            &#125;&#125;</span>
<span class="language-xml">            key=&#123;index&#125;</span>
<span class="language-xml">          &gt;</span>
<span class="language-xml">            &#123;val&#125;</span>
<span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml">        )</span>
<span class="language-xml">      &#125;)&#125;</span>
<span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
<span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>
)&#125;</code></pre></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能完成的有点粗糙，以后有时间继续完善细节，有问题欢迎讨论👻</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/m0_67393295/article/details/123220722">手把手带你10分钟手撸一个简易的Markdown编辑器</a></li>
<li><a href="https://github.com/markdown-it/markdown-it/blob/master/support/demo_template/index.js">markdown-it.github.io</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>markdown-it</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序滚动日历组件</title>
    <url>/2021/04/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%BB%9A%E5%8A%A8%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="小程序滚动日历组件"><a href="#小程序滚动日历组件" class="headerlink" title="小程序滚动日历组件"></a>小程序滚动日历组件</h2><p>前段时间产品提出这个需求，要求做一个日历容器，并要求是滚动，不能是那种每个月切换的容器，所以我就在网上大概查找了一下类似组件，滚动的容器较少，于是我就自己写了这个组件，以下是大概的js思路，wxml和css就不附上了，每个UI都有不同的想法</p>
<ol>
<li><p>在ready中初始化组件数据</p>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * <span class="doctag">@description</span>: 初始化</span>
<span class="comment"> */</span>
<span class="title function_">ready</span>(<span class="params"></span>) &#123;
  <span class="comment">// 这两个数据是从页面中传过来的，起始时间和结束时间</span>
  <span class="comment">// 数组类型 [year, month, day]</span>
  <span class="keyword">const</span> &#123; endDate, startDate &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">let</span> monthList = [] <span class="comment">// 这个用于wxml中遍历，以每月为item</span>

  <span class="comment">// 未跨年</span>
  <span class="keyword">if</span> ( endDate[<span class="number">0</span>] === startDate[<span class="number">0</span>]) &#123;
    <span class="keyword">let</span> rangeMonth = endDate[<span class="number">1</span>] - startDate[<span class="number">1</span>]
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= rangeMonth; i++) &#123;
      <span class="keyword">let</span> date = [startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i + <span class="number">1</span>]
      <span class="comment">// monthInitData()初始化每月数据</span>
      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i)
      monthList.<span class="title function_">push</span>(&#123;
        date,
        days,
      &#125;)
    &#125;
  &#125; <span class="keyword">else</span> &#123;
    <span class="comment">// 跨年前月份</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, lng = <span class="number">12</span> - startDate[<span class="number">1</span>]; i &lt; lng; i++) &#123;
      <span class="keyword">let</span> date = [startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i + <span class="number">1</span>]
      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>] + i)
      monthList.<span class="title function_">push</span>(&#123;
        date,
        days,
      &#125;)
    &#125;

    <span class="comment">// 跨年后月份</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= endDate[<span class="number">1</span>]; i++) &#123;
      <span class="keyword">let</span> date = [endDate[<span class="number">0</span>], i + <span class="number">1</span>]
      <span class="keyword">let</span> days = <span class="variable language_">this</span>.<span class="title function_">monthInitData</span>(endDate[<span class="number">0</span>], i)
      monthList.<span class="title function_">push</span>(&#123;
        date,
        days,
      &#125;)
    &#125;
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    monthList,
  &#125;)
&#125;</code></pre>
</li>
<li><p>初始化每月数据: </p>
<blockquote>
<p>逻辑是获取每个月第一天的星期数和每个月的最大天数，然后在之前和之后的空数据填充item占位<br>然后遍历，根据不同的需求，在遍历中处理，最后在html中flex布局即可</p>
</blockquote>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * <span class="doctag">@description</span>: 初始化每月数据</span>
<span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; year 年</span>
<span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; month 月</span>
<span class="comment"> */</span>
<span class="title function_">monthInitData</span>(<span class="params">year, month</span>) &#123;
  <span class="keyword">let</span> &#123; calendarValue, startDate, endDate &#125;= <span class="variable language_">this</span>.<span class="property">data</span>, <span class="comment">// 当前点击时间，起始时间，结束时间</span>
    firstWeek = <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, <span class="number">1</span>).<span class="title function_">getDay</span>(), <span class="comment">// 本月的第一天的星期数</span>
    days = [], <span class="comment">// 日期数组</span>
    max = <span class="variable language_">this</span>.<span class="title function_">getMonthMax</span>(year, month + <span class="number">1</span>), <span class="comment">// 每月最大天数</span>
    lastWeek = <span class="keyword">new</span> <span class="title class_">Date</span>(year, (month + <span class="number">1</span>), <span class="number">0</span>).<span class="title function_">getDay</span>() <span class="comment">// 本月的最后一天的星期数</span>

  <span class="comment">// 填充每月一号之前的空数据</span>
  <span class="keyword">if</span> (firstWeek &gt; <span class="number">0</span>) &#123;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; firstWeek; i++) &#123;
      days.<span class="title function_">push</span>(&#123;
        <span class="attr">day</span>: <span class="number">0</span>
      &#125;)
    &#125;
  &#125;

  <span class="keyword">let</span> currentTime = <span class="number">0</span>, 
      startTime = <span class="number">0</span>,
      endTime = <span class="number">0</span>

  <span class="keyword">if</span> (calendarValue[<span class="number">0</span>]) &#123;
    currentTime = <span class="keyword">new</span> <span class="title class_">Date</span>(calendarValue[<span class="number">0</span>], calendarValue[<span class="number">1</span>], calendarValue[<span class="number">2</span>]).<span class="title function_">getTime</span>()
  &#125;
  <span class="keyword">if</span> (startDate[<span class="number">0</span>]) &#123;
    startTime = <span class="keyword">new</span> <span class="title class_">Date</span>(startDate[<span class="number">0</span>], startDate[<span class="number">1</span>], startDate[<span class="number">2</span>]).<span class="title function_">getTime</span>()
  &#125;
  <span class="keyword">if</span> (endDate[<span class="number">0</span>]) &#123;
    endTime = <span class="keyword">new</span> <span class="title class_">Date</span>(endDate[<span class="number">0</span>], endDate[<span class="number">1</span>], endDate[<span class="number">2</span>]).<span class="title function_">getTime</span>()
  &#125;

  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;
    <span class="comment">// 以下状态是需要在html中判断处理，根据自己需求改变</span>
    <span class="keyword">let</span> current = <span class="literal">false</span>, <span class="comment">// 当前点击状态</span>
      disabled = <span class="literal">false</span>, <span class="comment">// 禁止状态</span>
      now = <span class="literal">false</span>, <span class="comment">// 今天显示文案</span>
      time = <span class="keyword">new</span> <span class="title class_">Date</span>(year, month, i).<span class="title function_">getTime</span>(),
      nowTime = [<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>(), <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getMonth</span>(), <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDate</span>()]
    <span class="keyword">if</span> (currentTime &amp;&amp; currentTime == time) current = <span class="literal">true</span>
    <span class="keyword">if</span> (startTime &amp;&amp; startTime &gt; time) disabled = <span class="literal">true</span>
    <span class="keyword">if</span> (endTime &amp;&amp; endTime &lt; time) disabled = <span class="literal">true</span>
    <span class="keyword">if</span> (year === nowTime[<span class="number">0</span>] &amp;&amp; month === nowTime[<span class="number">1</span>] &amp;&amp; i === nowTime[<span class="number">2</span>]) now = <span class="literal">true</span>

    days.<span class="title function_">push</span>(&#123;
      <span class="attr">day</span>: i,
      current,
      disabled,
      now,
    &#125;)
  &#125;

  <span class="comment">// 填充每月最后一天之后的空数据</span>
  <span class="keyword">if</span> (lastWeek != <span class="number">6</span>) &#123;
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = (<span class="number">6</span> - lastWeek); i &lt; l; i++) &#123;
      days.<span class="title function_">push</span>(&#123;
        <span class="attr">day</span>: <span class="number">0</span>
      &#125;)
    &#125;
  &#125;
  <span class="keyword">return</span> days
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 获取一个月最大天数</span>
<span class="comment"> * <span class="doctag">@method</span> <span class="variable">getMonthMax</span></span>
<span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; year 年份</span>
<span class="comment"> * <span class="doctag">@param</span>: &#123; number &#125; month 月份</span>
<span class="comment"> */</span>
<span class="title function_">getMonthMax</span>(<span class="params">year, month</span>) &#123;
  <span class="keyword">let</span> max = <span class="number">31</span>
  <span class="keyword">if</span> (month == <span class="number">4</span> || month == <span class="number">6</span> || month == <span class="number">9</span> || month == <span class="number">11</span>) &#123;
    max = <span class="number">30</span>
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (month == <span class="number">2</span>) &#123;
    <span class="keyword">if</span> (((year % <span class="number">4</span>) == <span class="number">0</span> &amp;&amp; (year % <span class="number">100</span>) &gt; <span class="number">0</span>) || (year % <span class="number">400</span>) == <span class="number">0</span>) &#123;
      max = <span class="number">29</span>
    &#125; <span class="keyword">else</span> &#123;
      max = <span class="number">28</span>
    &#125; 
  &#125;

  <span class="keyword">return</span> max
&#125;,
</code></pre></li>
</ol>
<ul>
<li>以上就是核心逻辑，像一些弹窗事件和一些点击事件就不附上来了</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序前端登录模块设计</title>
    <url>/2022/09/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信小程序登录基本上是每个小程序都必备的功能，但是随着业务的逐渐复杂，需要考虑的情况会越来越多，所以登录功能的健壮和高效是值得重点关注的，我会按照以往经验实现一个较优雅的登录方案</p>
<h2 id="基本登录流程"><a href="#基本登录流程" class="headerlink" title="基本登录流程"></a>基本登录流程</h2><ol>
<li>获取微信登录凭证，通过<code>wx.login</code>获取，这个api会返回一个带有时效性的code</li>
<li>发送code给服务端，这一步就是通过你和后端定义的接口发送</li>
<li>服务端根据前端发送的code获取用户身份信息，当然这一步就不是前端的逻辑了</li>
<li>服务端处理完后，会把用户信息和sessinId发送给前端，然后前端把需要的信息进行存储，接下来的请求就可以带着sessinId来表示身份</li>
<li>下面是微信官方的流程图<br><img src="https://img-blog.csdnimg.cn/3b0b114c140247ebbc666b027dfbda66.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<h2 id="逻辑封装"><a href="#逻辑封装" class="headerlink" title="逻辑封装"></a>逻辑封装</h2><p>针对以上登录流程，我会封装以下几个方法供业务层调用</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>getLoginCode</code></td>
<td>获取微信登录凭证</td>
</tr>
<tr>
<td><code>staticLogin</code></td>
<td>静默登录</td>
</tr>
<tr>
<td><code>singleLogin</code></td>
<td>登录请求封装</td>
</tr>
<tr>
<td><code>checkLogin</code></td>
<td>判断是否登录</td>
</tr>
<tr>
<td><code>getPhoneNum</code></td>
<td>获取微信授权手机号</td>
</tr>
</tbody></table>
<ul>
<li><p>我习惯在promise请求中使用await-to方法，这是一个针对异步比较优雅的方案</p>
<ul>
<li><a href="https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/">How to write async await without try-catch blocks in Javascript</a></li>
</ul>
</li>
<li><p>getLoginCode，一个简单的promise封装获取code</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getLoginCode</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;
      wx.<span class="title function_">login</span>(&#123;
        success (res) &#123;
          <span class="keyword">if</span> (res.<span class="property">code</span>) &#123;
            <span class="title function_">resolve</span>(res.<span class="property">code</span>)
          &#125; <span class="keyword">else</span> &#123;
            <span class="title function_">reject</span>(res)
          &#125;
        &#125;,
        <span class="title function_">fail</span>(<span class="params">err</span>) &#123;
          <span class="title function_">reject</span>(err)
        &#125;
      &#125;)
  &#125;)
&#125;</code></pre>
</li>
<li><p>静默登录封装，获取用户信息，并进行存储</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">staticLogin</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;
  <span class="comment">// 如果已经登录，直接返回登录信息</span>
  <span class="keyword">if</span> (<span class="title function_">checkLogin</span>()) &#123;
    <span class="keyword">return</span> <span class="title function_">getLoginInfo</span>()
  &#125;
  <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">singleLogin</span>());
  <span class="keyword">if</span> (loginErr) &#123;
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(loginErr);
  &#125;
  <span class="comment">// 存储用户信息，这个就根据自己的情况了，我这随便定个方法</span>
  <span class="title function_">setLoginInfo</span>(&#123;
    ...loginRes,
  &#125;)
  <span class="keyword">return</span> loginRes;
&#125;</code></pre>
</li>
<li><p>登录请求封装，这里我是用单例模式并返回了一个promise，这样做是为了，你多次调用singleLogin时，比如快速切换页面，快速点击多个需登录区域，在数据没有返回的时候，都会等待，而不是触发多次请求</p>
<pre><code class="highlight js"><span class="keyword">let</span> loginInstance = <span class="literal">null</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">singleLogin</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">if</span> (loginInstance) &#123;
    <span class="keyword">return</span> loginInstance
  &#125;
  <span class="comment">// loginReq：封装请求，包括请求后端和getLoginCode</span>
  loginInstance = <span class="title function_">loginReq</span>()
  loginInstance.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;
    loginInstance = <span class="literal">null</span>;
    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);
  &#125;)
  <span class="keyword">return</span> loginInstance
&#125;</code></pre>
</li>
<li><p>checkLogin，检查是否登录，这个就看你存储在那个地方了，视情况而定</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">checkLogin</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">return</span> <span class="title class_">Boolean</span>(loginInfo?.<span class="property">sid</span>)
&#125;</code></pre>
</li>
<li><p>getPhoneNum</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getPhoneNum</span> = <span class="keyword">async</span> (<span class="params">iv, encryptedData</span>) =&gt; &#123;
  <span class="keyword">const</span> [codeErr, codeRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">getLoginCode</span>())
  <span class="keyword">if</span> (codeErr) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(codeErr);
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(codeErr);
  &#125;
  <span class="comment">// decrypt：请求后端</span>
  <span class="keyword">const</span> [phoneErr, phoneRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">decrypt</span>(&#123;
    iv,
    encryptedData,
    <span class="attr">code</span>: codeRes.<span class="property">code</span>
  &#125;))
  <span class="keyword">if</span> (phoneErr) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(phoneErr);
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(phoneErr);
  &#125;
  <span class="keyword">const</span> phoneNumber = phoneRes.<span class="property">result</span>.<span class="property">phoneNumber</span>
  <span class="title function_">setLoginInfo</span>(&#123;
    phoneNumber,
  &#125;)
  <span class="keyword">return</span> phoneNumber
&#125;</code></pre></li>
</ul>
<h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p>业务层我会在以下几个地方调用</p>
<ol>
<li><p>请求前根据options判断是否需登录，并进行处理</p>
<pre><code class="highlight js"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">REQUEST</span> = <span class="keyword">async</span> (<span class="params">requestObj</span>) =&gt; &#123;
  <span class="comment">// isLogin 当前接口请求是否需要登录</span>
  <span class="keyword">if</span> (requestObj.<span class="property">isLogin</span> &amp;&amp; !<span class="title function_">checkLogin</span>()) &#123;
    <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">staticLogin</span>());
    <span class="keyword">if</span> (loginErr) &#123;
      <span class="title class_">Toast</span>(<span class="string">&#x27;登录失败&#x27;</span>)
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(loginErr);
    &#125;
  &#125;
  ...
&#125;</code></pre>
</li>
<li><p>登录按钮，这个主要用于登录失败兜底的情况，让用户主动点击，用于登录弹窗等组件，只需调用<code>staticLogin</code>即可</p>
</li>
<li><p>获取用户授权手机号按钮</p>
<pre><code class="highlight js"><span class="comment">// index.html</span>
<span class="comment">// 用户主动触发进行授权手机号</span>
&lt;button open-type=<span class="string">&quot;getPhoneNumber&quot;</span> bindgetphonenumber=<span class="string">&quot;bindPhoneNumber&quot;</span>&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span>
&lt;/button&gt;

<span class="comment">// index.js</span>
<span class="keyword">async</span> <span class="title function_">bindPhoneNumber</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> iv = e.<span class="property">detail</span>.<span class="property">iv</span>;
  <span class="keyword">const</span> encryptedData = e.<span class="property">detail</span>.<span class="property">encryptedData</span>;
  <span class="keyword">const</span> [phoneErr, phoneRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">getPhoneNum</span>(iv, encryptedData));
  <span class="keyword">if</span> (phoneErr) &#123;
    <span class="title class_">Toast</span>(<span class="string">&#x27;获取手机号失败&#x27;</span>);
    <span class="keyword">return</span>;
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;getPhoneNumber&#x27;</span>, phoneRes);
&#125;</code></pre>
</li>
<li><p>页面组件，在小程序中一般都有一个页面组件，用于封装一些页面必需的功能，比如loading，导航栏，无效页面等等，登录也是必需的，所以我把登录逻辑封装到页面组件上，如果成功会通过triggerEvent触发给页面，如果失败就弹出登录弹窗，当然这种处理不太细，根据业务的不同改变相关的逻辑<br><img src="https://img-blog.csdnimg.cn/f6cd710acc4d45a1a7d88042623ad4bc.png#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<pre><code class="highlight js"><span class="comment">// index.html</span>
&lt;view&gt;
  ...
  &lt;login-modal show=&#123;loginShow&#125; &#123;...props&#125; /&gt;
&lt;/view&gt;

<span class="comment">// index.js</span>
<span class="keyword">async</span> <span class="title function_">created</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> [loginErr, loginRes] = <span class="keyword">await</span> <span class="title function_">_to</span>(<span class="title function_">staticLogin</span>());
  <span class="keyword">if</span> (loginErr) &#123;
    <span class="title class_">Toast</span>(<span class="string">&#x27;登录失败&#x27;</span>);
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">loginShow</span>: <span class="literal">true</span>,
    &#125;);
    <span class="keyword">return</span>;
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;login&#x27;</span>, loginRes);
&#125;</code></pre>
<ol start="5">
<li>还有一些不是太通用的业务组件就不叙述了…</li>
</ol>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序单指拖拽和双指缩放旋转</title>
    <url>/2021/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%95%E6%8C%87%E6%8B%96%E6%8B%BD%E5%92%8C%E5%8F%8C%E6%8C%87%E7%BC%A9%E6%94%BE%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>小程序单指拖拽和双指操作是一个比较常用的功能，效果如下图<br><img src="https://img-blog.csdnimg.cn/babbbc7162d241e9b0fb01e0b18531eb.gif#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>实现这三个功能，主要用三个触摸事件<code>touchstart</code>、<code>touchmove</code>、<code>touchend</code><pre><code class="highlight html"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;height: 100vh; width: 100vw&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">image</span></span>
<span class="tag">    <span class="attr">src</span>=<span class="string">&quot;...&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;translateX&#125;&#125;px, &#123;&#123;translateY&#125;&#125;px) scale(&#123;&#123;scale&#125;&#125;) rotate(&#123;&#123;rotate&#125;&#125;deg);&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchstart</span>=<span class="string">&quot;touchStart&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span>
<span class="tag">  /&gt;</span>
<span class="tag">&lt;/<span class="name">view</span>&gt;</span></code></pre></li>
<li>用了以下变量<pre><code class="highlight ts"><span class="title class_">Page</span>(&#123;
  <span class="attr">data</span>: &#123;
    <span class="attr">translateX</span>: <span class="number">0</span>, <span class="comment">// 位移x坐标 单位px</span>
    <span class="attr">translateY</span>: <span class="number">0</span>, <span class="comment">// 位移y坐标 单位px</span>
    <span class="attr">distance</span>: <span class="number">0</span>, <span class="comment">// 双指接触点距离</span>
    <span class="attr">scale</span>: <span class="number">1</span>, <span class="comment">// 缩放倍数</span>
    <span class="attr">rotate</span>: <span class="number">0</span>, <span class="comment">// 旋转角度</span>
    <span class="attr">oldRotate</span>: <span class="number">0</span>, <span class="comment">// 上一次旋转停止后的角度</span>
    <span class="attr">startMove</span>: &#123; <span class="comment">// 起始位移距离</span>
      <span class="attr">x</span>: <span class="number">0</span>,
      <span class="attr">y</span>: <span class="number">0</span>,
    &#125;,
    <span class="attr">startTouches</span>: [] <span class="comment">// 起始点touch数组</span>
  &#125;,
&#125;)</code></pre></li>
</ul>
<h2 id="单指拖拽"><a href="#单指拖拽" class="headerlink" title="单指拖拽"></a>单指拖拽</h2><ul>
<li>实现单指拖拽比较简单，只需要记录移动的点坐标，然后减去起始点坐标，就可以求出相对页面的移动距离</li>
<li><code>touchstart</code><pre><code class="highlight ts"><span class="title function_">touchStart</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> touches = e.<span class="property">touches</span>
  <span class="keyword">const</span> &#123; translateX, translateY &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = touches[<span class="number">0</span>]
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">startMove</span> = &#123;
    <span class="attr">x</span>: pageX - translateX,
    <span class="attr">y</span>: pageY - translateY
  &#125;
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">startTouches</span> = touches
&#125;,</code></pre></li>
<li><code>touchmove</code><pre><code class="highlight ts"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> touches = e.<span class="property">touches</span>
  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; startMove &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,
    <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span>
  &#125;)
&#125;</code></pre></li>
</ul>
<h2 id="双指缩放"><a href="#双指缩放" class="headerlink" title="双指缩放"></a>双指缩放</h2><ul>
<li>双指缩放的原理是根据两点坐标求出距离(勾股定理)，然后在用移动坐标的距离比就可以求出缩放倍数</li>
<li><code>touchmove</code><pre><code class="highlight js"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> touches = e.<span class="property">touches</span>
  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; startMove, scale, <span class="attr">distance</span>: oldDistance, startTouches &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">if</span> (touches.<span class="property">length</span> === <span class="number">2</span> &amp;&amp; startTouches.<span class="property">length</span> === <span class="number">2</span>) &#123;
    <span class="comment">// 双指缩放</span>
    <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: twoPageX, <span class="attr">pageY</span>: twoPageY &#125; = touches[<span class="number">1</span>]
    <span class="comment">// 求出当前双指距离</span>
    <span class="keyword">const</span> distance = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((twoPageX - onePageX) ** <span class="number">2</span> + (twoPageY - onePageY) ** <span class="number">2</span>)
    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">distance</span> = distance
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">scale</span>: scale * (distance / (oldDistance || distance))
    &#125;)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startTouches.<span class="property">length</span> !== <span class="number">2</span>) &#123;
    <span class="comment">// 单指拖拽</span>
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,
      <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span>
    &#125;)
  &#125;
&#125;</code></pre></li>
<li><code>startTouches.length !== 2</code>这个判断的原因是防止图片跳动，因为如果你两个手指触摸，然后离开一个手指，我是禁止拖拽的，只有双指都离开后再次触摸才能单指拖拽</li>
</ul>
<h2 id="双指旋转"><a href="#双指旋转" class="headerlink" title="双指旋转"></a>双指旋转</h2><ul>
<li>双指旋转的原理是根据三角函数求出起始点的角度，然后再求出移动坐标的角度，相减然后加上上一次旋转的角度就等于你当前所需的选择角度</li>
<li><code>touchmove</code></li>
</ul>
<pre><code class="highlight ts"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> touches = e.<span class="property">touches</span>
  <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: onePageX, <span class="attr">pageY</span>: onePageY &#125; = touches[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; startMove, scale, <span class="attr">distance</span>: oldDistance, startTouches, oldRotate &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">if</span> (touches.<span class="property">length</span> === <span class="number">2</span> &amp;&amp; startTouches.<span class="property">length</span> === <span class="number">2</span>) &#123;
    <span class="keyword">const</span> &#123; <span class="attr">pageX</span>: twoPageX, <span class="attr">pageY</span>: twoPageY &#125; = touches[<span class="number">1</span>]
    <span class="keyword">const</span> distance = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>((twoPageX - onePageX) ** <span class="number">2</span> + (twoPageY - onePageY) ** <span class="number">2</span>)
+   <span class="keyword">let</span> rotate = <span class="variable language_">this</span>.<span class="title function_">getAngle</span>(touches[<span class="number">0</span>], touches[<span class="number">1</span>]) - <span class="variable language_">this</span>.<span class="title function_">getAngle</span>(startTouches[<span class="number">0</span>], startTouches[<span class="number">1</span>]) + oldRotate
  <span class="comment">// 如果大于360度，就减去360</span>
+   rotate = rotate &gt; <span class="number">360</span> ? rotate - <span class="number">360</span> : rotate
    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">distance</span> = distance
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">scale</span>: scale * (distance / (oldDistance || distance)),
+     rotate
    &#125;)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startTouches.<span class="property">length</span> !== <span class="number">2</span>) &#123;
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">translateX</span>: onePageX - startMove.<span class="property">x</span>,
      <span class="attr">translateY</span>: onePageY - startMove.<span class="property">y</span>
    &#125;)
  &#125;
&#125;,</code></pre>
<ul>
<li><code>getAngle</code><pre><code class="highlight ts"><span class="title function_">getAngle</span>(<span class="params">p1, p2</span>) &#123;
  <span class="keyword">const</span> x = p1.<span class="property">pageX</span> - p2.<span class="property">pageX</span>
  <span class="keyword">const</span> y = p1.<span class="property">pageY</span>- p2.<span class="property">pageY</span>
  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">atan2</span>(y, x) * <span class="number">180</span> / <span class="title class_">Math</span>.<span class="property">PI</span>
&#125;</code></pre></li>
<li><code>touchend</code><pre><code class="highlight ts"><span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;
  <span class="comment">// 保存当前旋转角度</span>
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">oldRotate</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">rotate</span>
&#125;,</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/0nS1tImU7Rs5</code></li>
<li>H5原理一致，只需改一下语法即可</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序图片上传&amp;九宫格拖拽组件</title>
    <url>/2021/09/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="微信小程序图片上传-amp-九宫格拖拽组件"><a href="#微信小程序图片上传-amp-九宫格拖拽组件" class="headerlink" title="微信小程序图片上传&amp;九宫格拖拽组件"></a>微信小程序图片上传&amp;九宫格拖拽组件</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>图片上传加九宫格拖拽是一个比较常用的组件，常用于发帖或者评论等内容上传模块，我这篇九宫格拖拽的思路是借鉴了<a href="https://www.cnblogs.com/haha1212/p/11562944.html"><strong>一款优雅的小程序拖拽排序组件实现</strong></a>这篇文章</p>
</li>
<li><p>实现效果如下图<br><img src="https://img-blog.csdnimg.cn/cc8c84d6bc3049349e94b95f540916c7.gif" alt="请添加图片描述"></p>
</li>
<li><p>实现原理：新增图片时，为每一个图片增加一个key属性，和tranX、tranY属性，用于transform位移，然后这个九宫格的拖拽新增删除都是以key为标记来修改tranX和tranY，从而达到拖拽效果</p>
</li>
<li><p>使用了以下变量</p>
<pre><code class="highlight js"><span class="attr">data</span>: &#123;
  <span class="attr">ITEM_SIZE</span>: <span class="number">100</span>, <span class="comment">// 图片大小 单位px</span>
  <span class="attr">dragImgList</span>: [], <span class="comment">// 图片列表 &#123; src: string, key: number, tranX: number, tranY: number &#125;[]</span>
  <span class="attr">containerRes</span>: &#123;&#125;, <span class="comment">// 拖拽容器属性</span>
  <span class="attr">currentKey</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的key</span>
  <span class="attr">currentIndex</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的index</span>
  <span class="attr">tranX</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的x距离</span>
  <span class="attr">tranY</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的y距离</span>
  <span class="attr">uploadPosition</span>: &#123; <span class="comment">// upload上传图标位移距离</span>
    <span class="attr">tranX</span>: <span class="number">0</span>,
    <span class="attr">tranY</span>: <span class="number">0</span>,
  &#125;
&#125;,</code></pre></li>
</ul>
<h3 id="WXML-amp-WXSS"><a href="#WXML-amp-WXSS" class="headerlink" title="WXML &amp; WXSS"></a>WXML &amp; WXSS</h3><pre><code class="highlight html"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-container&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">view</span></span>
<span class="tag">    <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;dragImgList&#125;&#125;&quot;</span> </span>
<span class="tag">    <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;index === currentIndex ? tranX : item.tranX&#125;&#125;px, &#123;&#123;index === currentIndex ? tranY : item.tranY&#125;&#125;px); z-index: &#123;&#123;index === currentIndex ? 10 : 1&#125;&#125;;&quot;</span></span>
<span class="tag">    <span class="attr">class</span>=<span class="string">&quot;darg-item item-transition&quot;</span></span>
<span class="tag">    <span class="attr">mark:index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">catch:longpress</span>=<span class="string">&quot;longPress&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span>
<span class="tag">  &gt;</span>
    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;darg-item-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.src&#125;&#125;&quot;</span>/&gt;</span>
    <span class="tag">&lt;<span class="name">text</span> <span class="attr">catch:tap</span>=<span class="string">&quot;deleteImg&quot;</span> <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete&quot;</span>&gt;</span>×<span class="tag">&lt;/<span class="name">text</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
  <span class="tag">&lt;<span class="name">view</span></span>
<span class="tag">    <span class="attr">bindtap</span>=<span class="string">&quot;uploadImage&quot;</span></span>
<span class="tag">    <span class="attr">class</span>=<span class="string">&quot;darg-item drag-item-upload&quot;</span></span>
<span class="tag">    <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123;dragImgList.length &gt;= 9&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;uploadPosition.tranX&#125;&#125;px, &#123;&#123;uploadPosition.tranY&#125;&#125;px);&quot;</span></span>
<span class="tag">  &gt;</span>+<span class="tag">&lt;/<span class="name">view</span>&gt;</span>
<span class="tag">&lt;/<span class="name">view</span>&gt;</span></code></pre>
<pre><code class="highlight css"><span class="selector-class">.drag-container</span>&#123;
  <span class="attribute">position</span>: relative;
  <span class="attribute">width</span>: <span class="number">300px</span>;
  <span class="attribute">height</span>: <span class="number">300px</span>;
&#125;
<span class="selector-class">.item-transition</span> &#123;
  <span class="attribute">transition</span>: transform <span class="number">0.1s</span>
&#125;
<span class="selector-class">.darg-item</span>&#123;
  <span class="attribute">position</span>: absolute;
  <span class="attribute">top</span>: <span class="number">0</span>;
  <span class="attribute">left</span>: <span class="number">0</span>;
  <span class="attribute">width</span>: <span class="number">100px</span>;
  <span class="attribute">height</span>: <span class="number">100px</span>;
&#125;
<span class="selector-class">.darg-item-img</span>&#123;
  <span class="attribute">width</span>: <span class="number">100%</span>;
  <span class="attribute">height</span>: <span class="number">100%</span>;
&#125;
<span class="selector-class">.drag-item-delete</span>&#123;
  <span class="attribute">position</span>: absolute;
  <span class="attribute">top</span>: <span class="number">0</span>;
  <span class="attribute">right</span>: <span class="number">0</span>;
  <span class="attribute">width</span>: <span class="number">58</span>rpx;
  <span class="attribute">height</span>: <span class="number">33</span>rpx;
  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.7</span>);
  <span class="attribute">font-size</span>: <span class="number">47</span>rpx;
  <span class="attribute">line-height</span>: <span class="number">25</span>rpx;
  <span class="attribute">text-align</span>: center;
  <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">64</span>rpx;
  <span class="attribute">color</span>: <span class="number">#fff</span>;
&#125;
<span class="selector-class">.drag-item-upload</span>&#123;
  <span class="attribute">background-color</span>: burlywood;
  <span class="attribute">font-size</span>: <span class="number">200</span>rpx;
  <span class="attribute">text-align</span>: center;
  <span class="attribute">color</span>: white;
  <span class="attribute">line-height</span>: <span class="number">200</span>rpx;
&#125;</code></pre>

<h3 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h3><ul>
<li>图片上传很简单，就是初始化上传的图片，然后拼接图片列表，最后修改上传图标位置即可<pre><code class="highlight js"><span class="title function_">uploadImage</span>(<span class="params"></span>) &#123;
  <span class="keyword">let</span> &#123; dragImgList, <span class="variable constant_">ITEM_SIZE</span> &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  wx.<span class="title function_">chooseImage</span>(&#123;
    <span class="attr">count</span>: <span class="number">9</span> - dragImgList.<span class="property">length</span>,
    <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;
      <span class="keyword">const</span> imgList = res.<span class="property">tempFilePaths</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (&#123;
        <span class="attr">tranX</span>: <span class="variable constant_">ITEM_SIZE</span> * ((dragImgList.<span class="property">length</span> + index) % <span class="number">3</span>),
        <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>((dragImgList.<span class="property">length</span> + index) / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>,
        <span class="attr">src</span>: item,
        <span class="attr">key</span>: dragImgList.<span class="property">length</span> + index
      &#125;))
      dragImgList = dragImgList.<span class="title function_">concat</span>(imgList)
      <span class="comment">// 修改上传图标位置</span>
      <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(dragImgList.<span class="property">length</span>)
      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
        dragImgList,
      &#125;)
    &#125;
  &#125;)
&#125;,</code></pre>
<pre><code class="highlight js"><span class="title function_">setUploaPosition</span>(<span class="params">listLength</span>) &#123;
  <span class="keyword">const</span> <span class="variable constant_">ITEM_SIZE</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">ITEM_SIZE</span>
  <span class="keyword">const</span> uploadPosition = &#123;
    <span class="attr">tranX</span>: listLength % <span class="number">3</span> * <span class="variable constant_">ITEM_SIZE</span>,
    <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(listLength / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>,
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    uploadPosition,
  &#125;)
&#125;,</code></pre></li>
</ul>
<h3 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h3><ul>
<li>首先从图片列表中删除所需图片，然后修改列表，把大于所选图片key的key全部减一，最后修改剩余图片位置和上传图标位置<pre><code class="highlight js"><span class="title function_">deleteImg</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> key = e.<span class="property">mark</span>.<span class="property">key</span>
  <span class="comment">// 删除图片</span>
  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> !== key)
  <span class="comment">// 修改key值</span>
  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> &gt; key &amp;&amp; item.<span class="property">key</span>--)
  <span class="comment">// 修改剩余图片位置</span>
  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(list)
  <span class="comment">// 修改上传图标位置</span>
  <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(list.<span class="property">length</span>)
&#125;</code></pre>
<pre><code class="highlight js"><span class="title function_">getListPosition</span>(<span class="params">list</span>) &#123;
  <span class="keyword">const</span> <span class="variable constant_">ITEM_SIZE</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">ITEM_SIZE</span>
  <span class="keyword">const</span> dragImgList = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    item.<span class="property">tranX</span> = <span class="variable constant_">ITEM_SIZE</span> * (item.<span class="property">key</span> % <span class="number">3</span>);
    item.<span class="property">tranY</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(item.<span class="property">key</span> / <span class="number">3</span>) * <span class="variable constant_">ITEM_SIZE</span>;
    <span class="keyword">return</span> item
  &#125;)
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    dragImgList,
  &#125;)

  <span class="comment">// 向页面传递最新图片列表</span>
  <span class="keyword">const</span> urlList = [...dragImgList].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">key</span> - b.<span class="property">key</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">src</span>)
  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;updateImage&#x27;</span>, &#123;
    <span class="attr">list</span>: urlList
  &#125;)
&#125;,</code></pre></li>
</ul>
<h3 id="九宫格拖拽"><a href="#九宫格拖拽" class="headerlink" title="九宫格拖拽"></a>九宫格拖拽</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>初始化只需获取容器的位置信息即可，因为拖拽组件不一定是在页面的左上角，所以需要知道容器的位置信息<pre><code class="highlight js"><span class="attr">lifetimes</span>: &#123;
  <span class="title function_">ready</span>(<span class="params"></span>) &#123;
    <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>()
      .<span class="title function_">select</span>(<span class="string">&quot;.drag-container&quot;</span>)
      .<span class="title function_">boundingClientRect</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;
        <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span> = res
      &#125;).<span class="title function_">exec</span>();
  &#125;
&#125;,</code></pre></li>
</ul>
<h4 id="longPress"><a href="#longPress" class="headerlink" title="longPress"></a>longPress</h4><ul>
<li>这里采用longPress，而不是touchStart的原因，一是为了优化体验，二是touchStart与删除按钮冲突<pre><code class="highlight js"><span class="title function_">longPress</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> index = e.<span class="property">mark</span>.<span class="property">index</span>
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; top, left &#125; = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span>
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">currentIndex</span>: index,
    <span class="attr">tranX</span>: pageX - <span class="number">50</span> - left,
    <span class="attr">tranY</span>: pageY - <span class="number">50</span> - top
  &#125;)
&#125;,</code></pre></li>
</ul>
<h4 id="touchMove"><a href="#touchMove" class="headerlink" title="touchMove"></a>touchMove</h4><ul>
<li>touchMove首先计算出位移距离，然后根据位移距离求出停放位置的key，如果不一样就修改位置<pre><code class="highlight js"><span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="comment">// 如果currentIndex &lt; 0，说明并没有触发longPress</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentIndex</span> &lt; <span class="number">0</span>) <span class="keyword">return</span>
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>]
  <span class="keyword">const</span> &#123; top, left &#125; = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">containerRes</span>
  <span class="keyword">const</span> tranX = pageX - <span class="number">50</span> - left
  <span class="keyword">const</span> tranY = pageY - <span class="number">50</span> - top
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    tranX,
    tranY
  &#125;)
  <span class="comment">// 对比当前移动的key和停放位置的key，如果不一样就修改位置</span>
  <span class="keyword">const</span> currentKey = e.<span class="property">mark</span>.<span class="property">key</span>
  <span class="keyword">const</span> moveKey = <span class="variable language_">this</span>.<span class="title function_">getMoveKey</span>(tranX, tranY)
  <span class="keyword">if</span> (currentKey === moveKey || <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> === currentKey) <span class="keyword">return</span>
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = currentKey
  <span class="variable language_">this</span>.<span class="title function_">insert</span>(currentKey, moveKey)
&#125;,</code></pre>
<pre><code class="highlight js"><span class="title function_">getMoveKey</span>(<span class="params">tranX, tranY</span>) &#123;
  <span class="keyword">const</span> &#123; <span class="attr">dragImgList</span>: list, <span class="variable constant_">ITEM_SIZE</span> &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">const</span> <span class="title function_">_getPositionNumber</span> = (<span class="params">position</span>) =&gt; &#123;
    <span class="keyword">const</span> positionNumber = <span class="title class_">Math</span>.<span class="title function_">round</span>(position/ <span class="variable constant_">ITEM_SIZE</span>)
    <span class="keyword">return</span> positionNumber &gt; <span class="number">2</span> ? <span class="number">2</span> : positionNumber &lt; <span class="number">0</span> ? <span class="number">0</span> : positionNumber
  &#125;
  <span class="keyword">const</span> endKey = <span class="number">3</span> * <span class="title function_">_getPositionNumber</span>(tranY) + <span class="title function_">_getPositionNumber</span>(tranX)
  <span class="keyword">return</span> endKey &gt;= list.<span class="property">length</span> ? list.<span class="property">length</span> - <span class="number">1</span> : endKey
&#125;,</code></pre>
<pre><code class="highlight js"><span class="title function_">insert</span>(<span class="params">origin, end</span>) &#123;
  <span class="keyword">const</span> dragImgList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>
  dragImgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (origin &lt; end) &#123;
      <span class="comment">// 如果起始key小于结束key，就把区间内的key全部减一</span>
      <span class="keyword">if</span> (item.<span class="property">key</span> &gt; origin &amp;&amp; item.<span class="property">key</span> &lt;= end) item.<span class="property">key</span>--
      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === origin) item.<span class="property">key</span> = end
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (origin &gt; end) &#123;
      <span class="comment">// 如果起始key大于结束key，就把区间内的key全部加一</span>
      <span class="keyword">if</span> (item.<span class="property">key</span> &gt;= end &amp;&amp; item.<span class="property">key</span> &lt; origin) item.<span class="property">key</span>++
      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === origin) item.<span class="property">key</span> = end
    &#125;
  &#125;)
  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(dragImgList)
&#125;,</code></pre></li>
</ul>
<h4 id="touchEnd"><a href="#touchEnd" class="headerlink" title="touchEnd"></a>touchEnd</h4><ul>
<li>touchEnd用于重置数据<pre><code class="highlight js"><span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">tranX</span>: <span class="number">0</span>,
    <span class="attr">tranY</span>: <span class="number">0</span>,
    <span class="attr">currentIndex</span>: -<span class="number">1</span>,
  &#125;)
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = -<span class="number">1</span>
&#125;,</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段<code>https://developers.weixin.qq.com/s/2rFIJamX7xty</code></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序图片拖拽排序组件</title>
    <url>/2022/09/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%9B%BE%E7%89%87%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>图片拖拽排序是一个比较常用的组件，常用于发帖或者评论等内容上传模块，我借鉴了<a href="https://www.cnblogs.com/haha1212/p/11562944.html">《一款优雅的小程序拖拽排序组件实现》</a>这篇文章的拖拽思路，并封装成<a href="https://github.com/LHRUN/wx-drag-img">wx-drag-img</a>发布到npm</li>
<li>实现原理：每个图片初始化我都会封装成一个拖拽的数据结构，然后触发touch事件时，通过改变图片的key来计算transform位置，从而达到拖拽效果</li>
<li>功能包括图片上传拖拽删除，源码和npm地址我会贴在结尾，如果感觉好的话，欢迎star</li>
<li>我会在下面逐步分析这个组件的实现思路</li>
<li>使用了以下变量<pre><code class="highlight ts"><span class="comment">// 拖拽数据结构</span>
<span class="keyword">interface</span> <span class="title class_">IDragImg</span> &#123;
  <span class="attr">src</span>: <span class="built_in">string</span>; <span class="comment">// 图片路径</span>
  <span class="attr">key</span>: <span class="built_in">number</span>; <span class="comment">// </span>
  <span class="attr">id</span>: <span class="built_in">number</span>; <span class="comment">// for循环遍历使用, 不会改变, 创建时自增id</span>
  <span class="attr">tranX</span>: <span class="built_in">number</span>; <span class="comment">// x轴位移距离</span>
  <span class="attr">tranY</span>: <span class="built_in">number</span>; <span class="comment">// y轴位移距离</span>
&#125;

<span class="comment">// props</span>
&#123;
  previewSize <span class="comment">// 图片大小</span>
  defaultImgList <span class="comment">// 初始化图片数组</span>
  maxCount <span class="comment">// 图片上传数量限制</span>
  columns <span class="comment">// 列数</span>
  gap <span class="comment">// 图片间隔</span>
  deleteStyle <span class="comment">// 删除样式</span>
&#125;

<span class="attr">data</span>: &#123;
  <span class="attr">dragImgList</span>: <span class="title class_">IDragImg</span>[],
  <span class="attr">containerRes</span>: &#123;
    <span class="attr">top</span>: <span class="number">0</span>, <span class="comment">// 容器距离页面顶部距离 px</span>
    <span class="attr">left</span>: <span class="number">0</span>, <span class="comment">// 容器距离页面左边距离 px</span>
    <span class="attr">width</span>: <span class="number">0</span>, <span class="comment">// 容器宽度 px</span>
    <span class="attr">height</span>: <span class="number">0</span>, <span class="comment">// 容器高度 px</span>
  &#125;, <span class="comment">// 拖拽容器属性</span>
  <span class="attr">currentKey</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的key</span>
  <span class="attr">currentIndex</span>: -<span class="number">1</span>, <span class="comment">// 正在拖拽图片的index</span>
  <span class="attr">tranX</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的x距离</span>
  <span class="attr">tranY</span>: <span class="number">0</span>, <span class="comment">// 正在拖拽图片移动的y距离</span>
  <span class="attr">uploadPosition</span>: &#123; <span class="comment">// upload上传图标位移距离</span>
    <span class="attr">tranX</span>: <span class="number">0</span>,
    <span class="attr">tranY</span>: <span class="number">0</span>,
  &#125;
&#125;,</code></pre></li>
</ul>
<h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><pre><code class="highlight html"><span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;width: &#123;&#123;containerRes.width&#125;&#125;px; height: &#123;&#123;containerRes.height&#125;&#125;px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-container&quot;</span>&gt;</span>
  <span class="tag">&lt;<span class="name">view</span></span>
<span class="tag">    <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;dragImgList&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;index === currentIndex ? tranX : item.tranX&#125;&#125;px, &#123;&#123;index === currentIndex ? tranY : item.tranY&#125;&#125;px); z-index: &#123;&#123;index === currentIndex ? 10 : 1&#125;&#125;; width: &#123;&#123;previewSize&#125;&#125;px; height: &#123;&#123;previewSize&#125;&#125;px;&quot;</span></span>
<span class="tag">    <span class="attr">class</span>=<span class="string">&quot;drag-item drag-item-transition&quot;</span></span>
<span class="tag">    <span class="attr">mark:index</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">catch:longpress</span>=<span class="string">&quot;longPress&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchmove</span>=<span class="string">&quot;touchMove&quot;</span></span>
<span class="tag">    <span class="attr">catch:touchend</span>=<span class="string">&quot;touchEnd&quot;</span></span>
<span class="tag">  &gt;</span>
    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;item.src&#125;&#125;&quot;</span>/&gt;</span>
    <span class="comment">&lt;!-- 删除图标 --&gt;</span>
    <span class="tag">&lt;<span class="name">view</span> <span class="attr">catch:tap</span>=<span class="string">&quot;deleteImg&quot;</span> <span class="attr">mark:key</span>=<span class="string">&quot;&#123;&#123;item.key&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete&quot;</span>&gt;</span>
      <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-item-delete_default&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&#123;&#123;deleteStyle&#125;&#125;&quot;</span>&gt;</span>x<span class="tag">&lt;/<span class="name">view</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">view</span>&gt;</span>

  <span class="comment">&lt;!-- 上传图片 --&gt;</span>
  <span class="tag">&lt;<span class="name">view</span></span>
<span class="tag">    <span class="attr">bindtap</span>=<span class="string">&quot;uploadImage&quot;</span></span>
<span class="tag">    <span class="attr">class</span>=<span class="string">&quot;drag-item drag-upload&quot;</span></span>
<span class="tag">    <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123;dragImgList.length &gt;= maxCount&#125;&#125;&quot;</span></span>
<span class="tag">    <span class="attr">style</span>=<span class="string">&quot;transform: translate(&#123;&#123;uploadPosition.tranX&#125;&#125;px, &#123;&#123;uploadPosition.tranY&#125;&#125;px); width: &#123;&#123;previewSize&#125;&#125;px; height: &#123;&#123;previewSize&#125;&#125;px;&quot;</span></span>
<span class="tag">  &gt;</span>
    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-upload_solt&quot;</span>&gt;</span>
      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;drag-upload_default&quot;</span>&gt;</span>
      <span class="tag">&lt;<span class="name">text</span>&gt;</span>+<span class="tag">&lt;/<span class="name">text</span>&gt;</span>
    <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">view</span>&gt;</span>
<span class="tag">&lt;/<span class="name">view</span>&gt;</span></code></pre>

<h2 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h2><ul>
<li>图片上传很简单，就是初始化上传的图片，然后拼接到现有图片，最后修改上传图标位置即可</li>
<li>点击上传区域回调函数<code>uploadImage</code><pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 上传图片</span>
<span class="comment"> */</span>
<span class="keyword">async</span> <span class="title function_">uploadImage</span>(<span class="params"></span>) &#123;
  <span class="keyword">let</span> &#123; dragImgList, maxCount &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">try</span> &#123;
    <span class="keyword">const</span> res = <span class="keyword">await</span> wx.<span class="title function_">chooseMedia</span>(&#123;
      <span class="attr">count</span>: maxCount - dragImgList.<span class="property">length</span>,
      <span class="attr">mediaType</span>: [<span class="string">&#x27;image&#x27;</span>],
    &#125;);
    <span class="comment">// 获取上传图片数据后需要初始化图片拽结构</span>
    <span class="keyword">const</span> imgList = <span class="variable language_">this</span>.<span class="title function_">getDragImgList</span>(res?.<span class="property">tempFiles</span>?.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; tempFilePath &#125;</span>) =&gt;</span> tempFilePath) || [], <span class="literal">false</span>);
    dragImgList = dragImgList.<span class="title function_">concat</span>(imgList);
    <span class="comment">// 修改上传区域位置</span>
    <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(dragImgList.<span class="property">length</span>);
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      dragImgList,
    &#125;);
    <span class="variable language_">this</span>.<span class="title function_">updateEvent</span>(dragImgList);
  &#125; <span class="keyword">catch</span> (error) &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);
  &#125;
&#125;,</code></pre></li>
<li>上传后需要初始化拖拽的数据结构<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 根据图片列表生成拖拽列表数据结构</span>
<span class="comment"> * <span class="doctag">@param</span> list 图片src列表</span>
<span class="comment"> * <span class="doctag">@param</span> init 是否是初始化</span>
<span class="comment"> */</span>
 <span class="title function_">getDragImgList</span>(<span class="params">list, init = <span class="literal">true</span></span>) &#123;
  <span class="keyword">let</span> &#123; dragImgList, previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">return</span> list.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;
    <span class="keyword">const</span> i = (init ? <span class="number">0</span> : dragImgList.<span class="property">length</span>) + index;
    <span class="keyword">return</span> &#123;
      <span class="attr">tranX</span>: (previewSize + gap) * (i % columns),
      <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(i / columns) * (previewSize + gap),
      <span class="attr">src</span>: item,
      <span class="attr">id</span>: i,
      <span class="attr">key</span>: i,
    &#125;;
  &#125;);
&#125;,</code></pre></li>
<li>修改上传区域位置<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 修改上传区域位置</span>
<span class="comment"> * <span class="doctag">@param</span> listLength 数组长度</span>
<span class="comment"> */</span>
<span class="title function_">setUploaPosition</span>(<span class="params">listLength</span>) &#123;
  <span class="keyword">const</span> &#123; previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> uploadPosition = &#123;
    <span class="attr">tranX</span>: listLength % columns * (previewSize + gap),
    <span class="attr">tranY</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(listLength / columns) * (previewSize + gap),
  &#125;;
  <span class="keyword">const</span> &#123; width, height &#125; = <span class="variable language_">this</span>.<span class="title function_">getContainerRect</span>(listLength);
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    uploadPosition,
    [<span class="string">&#x27;containerRes.width&#x27;</span>]: width,
    [<span class="string">&#x27;containerRes.height&#x27;</span>]: height,
  &#125;);
&#125;,</code></pre></li>
<li>图片数量改变后就要重新获取容器宽高了<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 改变图片数量后获取容器宽高</span>
<span class="comment"> * <span class="doctag">@parma</span> listLength 数组长度</span>
<span class="comment"> */</span>
<span class="title function_">getContainerRect</span>(<span class="params">listLength</span>) &#123;
  <span class="keyword">const</span> &#123; columns, previewSize, maxCount, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> number = listLength === maxCount ? listLength : listLength + <span class="number">1</span>;
  <span class="keyword">const</span> row = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(number / columns)
  <span class="keyword">return</span> &#123;
    <span class="attr">width</span>: columns * previewSize + (columns - <span class="number">1</span>) * gap,
    <span class="attr">height</span>: row * previewSize + gap * (row - <span class="number">1</span>),
  &#125;;
&#125;,</code></pre></li>
<li>updateEvent<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * updateEvent</span>
<span class="comment"> * <span class="doctag">@describe</span> 上传删除拖拽后触发事件把列表数据发给页面</span>
<span class="comment"> */</span>
<span class="title function_">updateEvent</span>(<span class="params">dragImgList</span>) &#123;
  <span class="keyword">const</span> list = [...dragImgList].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">key</span> - b.<span class="property">key</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">src</span>);
    <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;updateImageList&#x27;</span>, &#123;
      list,
  &#125;);
&#125;,</code></pre></li>
</ul>
<h3 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h3><ul>
<li>首先从图片列表中删除所需图片，然后修改列表，把大于所选图片key的key全部减一，最后计算剩余图片位置和上传图标位置<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 删除图片</span>
<span class="comment"> */</span>
<span class="title function_">deleteImg</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> key = e.<span class="property">mark</span>.<span class="property">key</span>;
  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">key</span> !== key);
  <span class="comment">// 大于删除图片key的key全部减1</span>
  list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    item.<span class="property">key</span> &gt; key &amp;&amp; item.<span class="property">key</span>--;
  &#125;);
  <span class="comment">// 获取</span>
  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(list);
  <span class="variable language_">this</span>.<span class="title function_">setUploaPosition</span>(list.<span class="property">length</span>);
&#125;,</code></pre>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 计算数组的位移位置</span>
<span class="comment"> * <span class="doctag">@param</span> list 拖拽图片数组</span>
<span class="comment"> */</span>
<span class="title function_">getListPosition</span>(<span class="params">list</span>) &#123;
  <span class="keyword">const</span> &#123; previewSize, columns, gap &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> dragImgList = list.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    item.<span class="property">tranX</span> = (previewSize + gap) * (item.<span class="property">key</span> % columns);
    item.<span class="property">tranY</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(item.<span class="property">key</span> / columns) * (previewSize + gap);
    <span class="keyword">return</span> item;
  &#125;)
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    dragImgList,
  &#125;);
  <span class="variable language_">this</span>.<span class="title function_">updateEvent</span>(dragImgList);
&#125;,</code></pre></li>
</ul>
<h2 id="图片拖拽"><a href="#图片拖拽" class="headerlink" title="图片拖拽"></a>图片拖拽</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化只需获取容器的位置信息即可，因为拖拽组件不一定是在页面的左上角，所以需要知道容器的位置信息<pre><code class="highlight js"><span class="attr">lifetimes</span>: &#123;
  <span class="title function_">ready</span>(<span class="params"></span>) &#123;
    <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>()
      .<span class="title function_">select</span>(<span class="string">&quot;.drag-container&quot;</span>)
      .<span class="title function_">boundingClientRect</span>(<span class="function">(<span class="params">&#123; top, left &#125;</span>) =&gt;</span> &#123;
        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
          [<span class="string">&#x27;containerRes.top&#x27;</span>]: top,
          [<span class="string">&#x27;containerRes.left&#x27;</span>]: left,
        &#125;);
      &#125;).<span class="title function_">exec</span>();
  &#125;
&#125;,</code></pre></li>
</ul>
<h3 id="longPress"><a href="#longPress" class="headerlink" title="longPress"></a>longPress</h3><ul>
<li>这里采用longPress，而不是touchStart的原因，一是为了优化体验，二是touchStart与删除按钮冲突<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 长按图片</span>
<span class="comment"> */</span>
<span class="title function_">longPress</span>(<span class="params">e</span>) &#123;
  <span class="keyword">const</span> index = e.<span class="property">mark</span>.<span class="property">index</span>;
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>];
  <span class="keyword">const</span> &#123; previewSize, <span class="attr">containerRes</span>: &#123; top, left &#125; &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">currentIndex</span>: index,
    <span class="attr">tranX</span>: pageX - previewSize / <span class="number">2</span> - left,
    <span class="attr">tranY</span>: pageY - previewSize / <span class="number">2</span> - top,
  &#125;);
&#125;,</code></pre></li>
</ul>
<h3 id="touchMove"><a href="#touchMove" class="headerlink" title="touchMove"></a>touchMove</h3><ul>
<li>touchMove首先计算出位移距离，然后根据位移距离求出停放位置的key，如果不一样就修改位置</li>
<li>touchMove<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * touchMove</span>
<span class="comment"> */</span>
<span class="title function_">touchMove</span>(<span class="params">e</span>) &#123;
  <span class="comment">// 如果currentIndex &lt; 0，说明并没有触发longPress</span>
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentIndex</span> &lt; <span class="number">0</span>) &#123;
    <span class="keyword">return</span>;
  &#125;
  <span class="keyword">const</span> &#123; pageX, pageY &#125; = e.<span class="property">touches</span>[<span class="number">0</span>];
  <span class="keyword">const</span> &#123; previewSize, <span class="attr">containerRes</span>: &#123; top, left &#125; &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> tranX = pageX - previewSize / <span class="number">2</span> - left;
  <span class="keyword">const</span> tranY = pageY - previewSize / <span class="number">2</span> - top;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    tranX,
    tranY
  &#125;);
  <span class="comment">// 对比当前移动的key和停放位置的key，如果不一样就修改位置</span>
  <span class="keyword">const</span> currentKey = e.<span class="property">mark</span>.<span class="property">key</span>;
  <span class="keyword">const</span> moveKey = <span class="variable language_">this</span>.<span class="title function_">getMoveKey</span>(tranX, tranY);

  <span class="comment">// 当移动的key和正在停放位置的key相等，就无须处理</span>
  <span class="keyword">if</span> (currentKey === moveKey || <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> === currentKey) &#123;
    <span class="keyword">return</span>;
  &#125;
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = currentKey;
  <span class="variable language_">this</span>.<span class="title function_">replace</span>(currentKey, moveKey);
&#125;,</code></pre></li>
<li>getMoveKey<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 计算移动中的key</span>
<span class="comment"> * <span class="doctag">@param</span> tranX 正在拖拽图片的tranX</span>
<span class="comment"> * <span class="doctag">@param</span> tranY 正在拖拽图片的tranY</span>
<span class="comment"> */</span>
<span class="title function_">getMoveKey</span>(<span class="params">tranX, tranY</span>) &#123;
  <span class="keyword">const</span> &#123; <span class="attr">dragImgList</span>: list, previewSize, columns &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> <span class="title function_">_getPositionNumber</span> = (<span class="params">drag, limit</span>) =&gt; &#123;
    <span class="keyword">const</span> positionNumber = <span class="title class_">Math</span>.<span class="title function_">round</span>(drag / previewSize);
    <span class="keyword">return</span> positionNumber &gt;= limit ? limit - <span class="number">1</span> : positionNumber &lt; <span class="number">0</span> ? <span class="number">0</span> : positionNumber;
  &#125;
  <span class="keyword">const</span> endKey = columns * <span class="title function_">_getPositionNumber</span>(tranY, <span class="title class_">Math</span>.<span class="title function_">ceil</span>(list.<span class="property">length</span> / columns)) + <span class="title function_">_getPositionNumber</span>(tranX, columns);
  <span class="keyword">return</span> endKey &gt;= list.<span class="property">length</span> ? list.<span class="property">length</span> - <span class="number">1</span> : endKey;
&#125;,</code></pre></li>
<li>replace<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 生成拖拽后的新数组</span>
<span class="comment"> * <span class="doctag">@param</span> start 拖拽起始的key</span>
<span class="comment"> * <span class="doctag">@param</span> end 拖拽结束的key</span>
<span class="comment"> */</span>
<span class="title function_">replace</span>(<span class="params">start, end</span>) &#123;
  <span class="keyword">const</span> dragImgList = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">dragImgList</span>;
  dragImgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (start &lt; end) &#123;
      <span class="keyword">if</span> (item.<span class="property">key</span> &gt; start &amp;&amp; item.<span class="property">key</span> &lt;= end) item.<span class="property">key</span>--;
      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === start) item.<span class="property">key</span> = end;
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; end) &#123;
      <span class="keyword">if</span> (item.<span class="property">key</span> &gt;= end &amp;&amp; item.<span class="property">key</span> &lt; start) item.<span class="property">key</span>++;
      <span class="keyword">else</span> <span class="keyword">if</span> (item.<span class="property">key</span> === start) item.<span class="property">key</span> = end;
    &#125;
  &#125;);
  <span class="variable language_">this</span>.<span class="title function_">getListPosition</span>(dragImgList);
&#125;,</code></pre></li>
</ul>
<h3 id="touchEnd"><a href="#touchEnd" class="headerlink" title="touchEnd"></a>touchEnd</h3><ul>
<li>touchEnd用于重置数据<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * touchEnd</span>
<span class="comment"> */</span>
<span class="title function_">touchEnd</span>(<span class="params"></span>) &#123;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    <span class="attr">tranX</span>: <span class="number">0</span>,
    <span class="attr">tranY</span>: <span class="number">0</span>,
    <span class="attr">currentIndex</span>: -<span class="number">1</span>,
  &#125;);
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentKey</span> = -<span class="number">1</span>;
&#125;,</code></pre></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><a href="https://github.com/LHRUN/wx-drag-img">repo</a></li>
<li><a href="https://www.npmjs.com/package/wx-drag-img">npm</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/haha1212/p/11562944.html">一款优雅的小程序拖拽排序组件实现</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序瀑布流和虚拟列表</title>
    <url>/2022/08/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%80%91%E5%B8%83%E6%B5%81%E5%92%8C%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="微信小程序瀑布流和虚拟列表"><a href="#微信小程序瀑布流和虚拟列表" class="headerlink" title="微信小程序瀑布流和虚拟列表"></a>微信小程序瀑布流和虚拟列表</h2><p>首先声明虽然本篇是写的微信小程序的案例，但是也可用于H5，思路是想通的，只是有些api的差异，最后会贴代码片段<br><img src="https://img-blog.csdnimg.cn/40f9275783f14ed4a2a020ec733b3043.gif#pic_center" alt="example"></p>
<h3 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h3><ul>
<li>一般在做长列表优化时，特别是面试时，虚拟列表就是个高频词。这个名词听起来很高级，其实原理很简单</li>
<li>虚拟列表就是将需要渲染的数组数据改造成二维数组，然后通过监听DOM在合适的地方切换为占位元素，达到长列表无限滚动时减少DOM的优化</li>
<li>JS <pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 处理占位元素，就是在获取新的数据后</span>
<span class="comment"> * 通过SelectQuery获取当前数据的实际高度，然后把这个高度设置到占位元素上</span>
<span class="comment"> */</span>
<span class="title function_">getCurrentItemHeight</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> query = <span class="variable language_">this</span>.<span class="title function_">createSelectorQuery</span>();
  <span class="keyword">const</span> &#123; virtualId &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  query.<span class="title function_">select</span>(<span class="string">`#<span class="subst">$&#123;virtualId&#125;</span>`</span>).<span class="title function_">boundingClientRect</span>()
  query.<span class="title function_">exec</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">height</span>: res[<span class="number">0</span>].<span class="property">height</span>
    &#125;, <span class="variable language_">this</span>.<span class="title function_">observePage</span>())
  &#125;)
&#125;

<span class="comment">/**</span>
<span class="comment"> * 监听元素与页面的相交</span>
<span class="comment"> * 可以选择指定元素为参照区域，也可以选择页面为参照元素，只是API不同</span>
<span class="comment"> * <span class="doctag">@doc</span> https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html</span>
<span class="comment"> */</span>
<span class="title function_">observePage</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> &#123; virtualId, observeDistance, wrapId &#125; = <span class="variable language_">this</span>.<span class="property">data</span>
  <span class="keyword">let</span> <span class="title class_">IntersectionObserver</span> = wx.<span class="title function_">createIntersectionObserver</span>(<span class="variable language_">this</span>);
  (wrapId ? <span class="title class_">IntersectionObserver</span>.<span class="title function_">relativeTo</span>(<span class="string">`#<span class="subst">$&#123;wrapId&#125;</span>`</span>) : <span class="title class_">IntersectionObserver</span>.<span class="title function_">relativeToViewport</span>(&#123; <span class="attr">top</span>: observeDistance, <span class="attr">bottom</span>: observeDistance &#125;))
  .<span class="title function_">observe</span>(<span class="string">`#<span class="subst">$&#123;virtualId&#125;</span>`</span>, <span class="function">(<span class="params">&#123; intersectionRatio &#125;</span>) =&gt;</span> &#123;
    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
      <span class="attr">isShow</span>: intersectionRatio &gt; <span class="number">0</span>,
    &#125;)
  &#125;)
&#125;</code></pre></li>
<li>html<pre><code class="highlight js">&lt;view id=<span class="string">&quot;&#123;&#123;virtualId&#125;&#125;&quot;</span>&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;isShow&#125;&#125;&quot;</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span>
<span class="language-xml">  <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span>
  <span class="language-xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span> <span class="attr">style</span>=<span class="string">&quot;height: &#123;&#123; height &#125;&#125;px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span>
&lt;/view&gt;</code></pre></li>
</ul>
<h3 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h3><ul>
<li>瀑布流，又称瀑布流式布局。视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部</li>
<li>瀑布流有多种写法，有通过纯CSS完成的，也有借助JS完成的，方法很多，但是我为了接下来能与虚拟列表相结合，就采用JS的写法，就是通过列数把每一列分为一个单独的子元素，然后会记录每一列的高度，通过判断哪一列高度最小，然后将数据push到高度最小的那一列<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment"> * 获取列表数据</span>
<span class="comment"> * <span class="doctag">@describe</span> 瀑布流处理，哪列高度小，就往哪列push新数据</span>
<span class="comment"> */</span>
<span class="title function_">getList</span>(<span class="params"></span>) &#123;
  <span class="keyword">let</span> &#123; <span class="attr">listQuery</span>: &#123; pageIndex, pageSize &#125;, columns, columnsHeight &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pageSize; i++) &#123;
    <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>)
    <span class="keyword">const</span> item = height &lt; <span class="number">50</span> ? height + <span class="number">50</span> : height
    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">computePosition</span>(columnsHeight)
    columns[position].<span class="title function_">push</span>(item)
    columnsHeight += item
  &#125;
  <span class="comment">// 在html中双重遍历columns，然后通过flex：1均匀分布</span>
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    columns,
  &#125;)
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">columnsHeight</span> = columnsHeight
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取高度最小列下标</span>
<span class="comment"> */</span>
<span class="title function_">computePosition</span>(<span class="params">heights</span>) &#123;
  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...heights);
  <span class="keyword">return</span> heights.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item === min)
&#125;</code></pre></li>
</ul>
<h3 id="瀑布流结合虚拟列表"><a href="#瀑布流结合虚拟列表" class="headerlink" title="瀑布流结合虚拟列表"></a>瀑布流结合虚拟列表</h3><ul>
<li>让瀑布流有虚拟滚动的能力，思路很简单，就是计算每列的偏移量，因为瀑布流被我们分成了二维数组，所以每块子元素之间就会因为列高度的不一致产生空白区域，所以需要计算这个空白区域的大小，然后通过<code>margin-top</code>移动列元素达到视觉上的瀑布流衔接效果<br><img src="https://img-blog.csdnimg.cn/070e8c72d982470ca8808ad8121e6110.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<pre><code class="highlight js"><span class="title function_">getList</span>(<span class="params"></span>) &#123;
  <span class="keyword">let</span> &#123; <span class="attr">listQuery</span>: &#123; pageIndex &#125;, column, columnsHeights &#125; = <span class="variable language_">this</span>.<span class="property">data</span>;
  <span class="keyword">const</span> columns = [];
  <span class="comment">// 上一组的高度数据，用于计算偏移值</span>
  <span class="keyword">const</span> lastHeights = [...columnsHeights];
  <span class="comment">// 获取数据</span>
  <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="title function_">getListData</span>();
  <span class="comment">// 初始化当前屏数据</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; column; i++ ) &#123;
    columns.<span class="title function_">push</span>([]);
  &#125;
  <span class="comment">// 遍历新数据，分配至各列</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.<span class="property">length</span>; i++) &#123;
    <span class="keyword">const</span> position = <span class="variable language_">this</span>.<span class="title function_">computePosition</span>(columnsHeights);
    columns[position].<span class="title function_">push</span>(list[i]);
    columnsHeights[position] += <span class="title class_">Number</span>(list[i].<span class="property">height</span>);
  &#125;
  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;
    [<span class="string">`listData[<span class="subst">$&#123;pageIndex&#125;</span>]`</span>]: &#123;
      columns,
      <span class="attr">columnOffset</span>: <span class="variable language_">this</span>.<span class="title function_">computeOffset</span>(lastHeights),
    &#125;
  &#125;);
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">listQuery</span>.<span class="property">pageIndex</span> = pageIndex + <span class="number">1</span>;
  <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">columnsHeights</span> = columnsHeights;
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 获取列表数据</span>
<span class="comment"> */</span>
<span class="title function_">getListData</span>(<span class="params"></span>) &#123;
  <span class="keyword">const</span> result = []
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">listQuery</span>.<span class="property">pageSize</span>; i++) &#123;
    <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">300</span>);
    <span class="keyword">const</span> item = &#123;
      <span class="attr">height</span>: height &lt; <span class="number">150</span> ? height + <span class="number">150</span> : height,
      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="title function_">randomRgbColor</span>(),
    &#125;;
    result.<span class="title function_">push</span>(item);
  &#125;
  <span class="keyword">return</span> result;
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 随机生成RGB颜色</span>
<span class="comment"> */</span>
<span class="title function_">randomRgbColor</span>(<span class="params"></span>) &#123;
  <span class="keyword">var</span> r = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内r值</span>
  <span class="keyword">var</span> g = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内g值</span>
  <span class="keyword">var</span> b = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">256</span>); <span class="comment">//随机生成256以内b值</span>
  <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>)`</span>; <span class="comment">//返回rgb(r,g,b)格式颜色</span>
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 获取最小高度列下标</span>
<span class="comment"> */</span>
<span class="title function_">computePosition</span>(<span class="params">heights</span>) &#123;
  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...heights);
  <span class="keyword">return</span> heights.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item === min);
&#125;,

<span class="comment">/**</span>
<span class="comment"> * 计算偏移量</span>
<span class="comment"> */</span>
<span class="title function_">computeOffset</span>(<span class="params">heights</span>) &#123;
  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...heights);
  <span class="keyword">return</span> heights.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> max - item);
&#125;,

<span class="title function_">onScrollLower</span>(<span class="params"></span>) &#123;
  <span class="variable language_">this</span>.<span class="title function_">getList</span>();
&#125;</code></pre>
<ul>
<li>WXML<pre><code class="highlight js">&lt;view&gt;
  <span class="language-xml"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">class</span>=<span class="string">&quot;virtualScrollView&quot;</span> <span class="attr">eventhandle</span> <span class="attr">scroll-y</span> <span class="attr">bindscrolltolower</span>=<span class="string">&quot;onScrollLower&quot;</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; listData &#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;screenIndex&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;screenIndex&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;screenItem&quot;</span>&gt;</span></span>
<span class="language-xml">      <span class="tag">&lt;<span class="name">VirtualItem</span> <span class="attr">virtualId</span>=<span class="string">&quot;virtual_&#123;&#123;pageIndex&#125;&#125;&quot;</span>&gt;</span></span>
<span class="language-xml">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;fall&quot;</span>&gt;</span></span>
<span class="language-xml">          <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; screenItem.columns &#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;columnIndex&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;columnIndex&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;column&quot;</span> &gt;</span></span>
<span class="language-xml">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: -&#123;&#123;screenItem.columnOffset[columnIndex]&#125;&#125;px;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fallCol&quot;</span>&gt;</span></span>
<span class="language-xml">              <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;column&#125;&#125;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: &#123;&#123; item.height &#125;&#125;px; background-color: &#123;&#123; item.color &#125;&#125;;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span>
<span class="language-xml">                screen: &#123;&#123; screenIndex &#125;&#125;, column: &#123;&#123; columnIndex &#125;&#125;</span>
<span class="language-xml">              <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span>
<span class="language-xml">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span>
<span class="language-xml">          <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span>
<span class="language-xml">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span>
<span class="language-xml">      <span class="tag">&lt;/<span class="name">VirtualItem</span>&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span>
<span class="language-xml">  <span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span>
&lt;/view&gt;</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>代码片段：<a href="https://developers.weixin.qq.com/s/5P3DpGmI7PBc">https://developers.weixin.qq.com/s/5P3DpGmI7PBc</a></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>瀑布流</tag>
        <tag>虚拟列表</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序蓝牙控制开门</title>
    <url>/2020/01/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%93%9D%E7%89%99%E6%8E%A7%E5%88%B6%E5%BC%80%E9%97%A8/</url>
    <content><![CDATA[<h2 id="小程序低功耗蓝牙控制开门"><a href="#小程序低功耗蓝牙控制开门" class="headerlink" title="小程序低功耗蓝牙控制开门"></a>小程序低功耗蓝牙控制开门</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><blockquote>
<ol>
<li>初始化蓝牙模块<code>openBluetoothAdapter</code></li>
<li>获取本机蓝牙适配器状态<code>getBluetoothAdapterState</code></li>
<li>搜索外围蓝牙设备<code>startBluetoothDevicesDiscovery</code></li>
<li>监听寻找到新设备<code>onBluetoothDeviceFound</code></li>
<li>连接蓝牙<code>createBLEConnection</code></li>
<li>获取蓝牙设备的服务<code>getBLEDeviceServices</code></li>
<li>获取服务中的特征值<code>getBLEDeviceCharacteristics</code></li>
<li>启用特征值变化时的notify功能<code>notifyBLECharacteristicValueChange</code></li>
<li>向蓝牙设备写入数据<code>writeBLECharacteristicValue</code></li>
<li>关闭蓝牙模块<code>closeBluetoothAdapter</code></li>
</ol>
</blockquote>
<h3 id="1-初始化蓝牙模块"><a href="#1-初始化蓝牙模块" class="headerlink" title="1. 初始化蓝牙模块"></a>1. 初始化蓝牙模块</h3><ul>
<li>初始化蓝牙模块使用的是：<code>wx.openBluetoothAdapter</code>，初始化之前对蓝牙功能做一个判断，看手机微信版本是否支持此功能</li>
<li>初始化之前需要关闭蓝牙模块：<code>wx.closeBluetoothAdapter</code>，否则容易搜索失败<pre><code class="highlight js"><span class="keyword">var</span> _this = <span class="variable language_">this</span>
<span class="keyword">if</span> (!wx.<span class="property">openBluetoothAdapter</span>) &#123;
  wx.<span class="title function_">showModal</span>(&#123;
    <span class="attr">title</span>: <span class="string">&#x27;提示&#x27;</span>,
    <span class="attr">showCancel</span>: <span class="literal">false</span>,
    <span class="attr">content</span>: <span class="string">&#x27;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试&#x27;</span>,
  &#125;)
&#125; <span class="keyword">else</span> &#123;
  wx.<span class="title function_">closeBluetoothAdapter</span>(&#123;
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      wx.<span class="title function_">openBluetoothAdapter</span>(&#123; <span class="comment">// 初始化蓝牙模块</span>
        <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始化蓝牙成功&#x27;</span>)
          _this.<span class="title function_">getBluetoothAdapterState</span>()
        &#125;,
        <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
          <span class="variable language_">console</span>.<span class="title function_">log</span>(err)
        &#125;
      &#125;)
    &#125;,
  &#125;)
&#125;</code></pre></li>
</ul>
<h3 id="2-获取本机蓝牙适配器状态"><a href="#2-获取本机蓝牙适配器状态" class="headerlink" title="2. 获取本机蓝牙适配器状态"></a>2. 获取本机蓝牙适配器状态</h3><ul>
<li>获取本机蓝牙适配器状态使用的是<code>wx.getBluetoothAdapterState</code>，调用成功后，会返回两个参数<ul>
<li><code>discovering</code>判断是否正在搜索设备</li>
<li><code>available</code>判断蓝牙适配器是否可用<pre><code class="highlight js"><span class="attr">getBluetoothAdapterState</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">getBluetoothAdapterState</span>(&#123;
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      <span class="keyword">if</span> (res.<span class="property">available</span> == <span class="literal">false</span>) &#123;
        wx.<span class="title function_">showToast</span>(&#123;
          <span class="attr">title</span>: <span class="string">&#x27;设备无法开启蓝牙连接&#x27;</span>,
          <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span>,
          <span class="attr">duration</span>: <span class="number">2000</span>
        &#125;)
        wx.<span class="title function_">closeBluetoothAdapter</span>()
      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">discovering</span> == <span class="literal">false</span>) &#123;
        _this.<span class="title function_">startBluetoothDevicesDiscovery</span>() <span class="comment">// 开启搜索外围设备</span>
      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">available</span>)&#123;
        _this.<span class="title function_">startBluetoothDevicesDiscovery</span>() <span class="comment">// 蓝牙适配器正常，去执行搜索外围设备</span>
      &#125;
    &#125;
  &#125;)
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h3 id="3-搜索外围蓝牙设备"><a href="#3-搜索外围蓝牙设备" class="headerlink" title="3. 搜索外围蓝牙设备"></a>3. 搜索外围蓝牙设备</h3><ul>
<li>搜索外围蓝牙设备使用的是<code>wx.startBluetoothDevicesDiscovery</code>，连接设备后一定要使用<code>wx.stopBluetoothDevicesDiscovery</code>停止搜索<pre><code class="highlight js"><span class="attr">startBluetoothDevicesDiscovery</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;
    <span class="keyword">var</span> _this = <span class="variable language_">this</span>
    wx.<span class="title function_">startBluetoothDevicesDiscovery</span>(&#123;
      <span class="attr">allowDuplicatesKey</span>: <span class="literal">false</span>,
      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
        <span class="keyword">if</span>(!res.<span class="property">isDiscovering</span>)&#123; <span class="comment">// 是否在搜索设备</span>
          _this.<span class="title function_">getBluetoothAdapterState</span>()
        &#125;<span class="keyword">else</span>&#123;
          _this.<span class="title function_">onBluetoothDeviceFound</span>() <span class="comment">// 搜索成功后，执行监听设备的api</span>
        &#125;
      &#125;,
      <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;蓝牙搜寻失败&quot;</span>)
        wx.<span class="title function_">stopBluetoothDevicesDiscovery</span>() <span class="comment">// 没有搜索到设备</span>
        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
      &#125;
    &#125;)
&#125;</code></pre></li>
</ul>
<h3 id="4-监听寻找到新设备"><a href="#4-监听寻找到新设备" class="headerlink" title="4. 监听寻找到新设备"></a>4. 监听寻找到新设备</h3><ul>
<li>监听寻找到新设备使用的是<code>wx.onBluetoothDeviceFound</code>，每搜到一个新设备就会触发一次，然后返回一个搜索到的设备列表，包含了设备名称和mac地址，一般都是使用设备名称和mac地址来匹配设备的<ul>
<li>安卓和IOS返回的deviceId不一样，安卓返回的是mac地址，IOS返回的是UUID，如果想通过mac地址来匹配设备，可以让mac地址存储在<code>advertisData</code>数据段中，然后解析这个数据段得到mac地址</li>
<li>我使用的是通过设备名称来进行匹配<pre><code class="highlight js"><span class="attr">onBluetoothDeviceFound</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">onBluetoothDeviceFound</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;
    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">devices</span>.<span class="property">length</span>; i++)&#123;
      <span class="keyword">if</span>(res.<span class="property">devices</span>[i].<span class="property">name</span> == <span class="string">&quot;设备名称&quot;</span> || res.<span class="property">devices</span>[i].<span class="property">localName</span> == <span class="string">&quot;设备名称&quot;</span>)&#123;
        _this.<span class="title function_">setData</span>(&#123;
          <span class="attr">deviceId</span>: res.<span class="property">devices</span>[i].<span class="property">deviceId</span> <span class="comment">// 把匹配设备的deviceId存到data中</span>
        &#125;)
        wx.<span class="title function_">stopBluetoothDevicesDiscovery</span>() <span class="comment">// 匹配到设备后关闭搜索</span>
        _this.<span class="title function_">createBLEConnection</span>() <span class="comment">// 连接蓝牙</span>
      &#125;
    &#125;
  &#125;)
&#125;</code></pre></li>
</ul>
</li>
</ul>
<h3 id="5-连接蓝牙"><a href="#5-连接蓝牙" class="headerlink" title="5. 连接蓝牙"></a>5. 连接蓝牙</h3><ul>
<li>连接蓝牙使用的是<code>wx.createBLEConnection</code>，连接蓝牙是通过<code>deviceId</code>连接，<code>deviceId</code>是通过<code>wx.onBluetoothDeviceFound</code>获取的</li>
<li>连接蓝牙容易失败，所以可以定一个变量<code>count</code>用来计算连接的次数，如果超出特定的次数就判断为连接失败，关闭蓝牙模块<pre><code class="highlight js"><span class="attr">createBLEConnection</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 连接低功耗蓝牙</span>
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">createBLEConnection</span>(&#123;
    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      _this.<span class="title function_">getBLEDeviceServices</span>()
    &#125;,
    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接失败&quot;</span>)
      <span class="keyword">if</span>( count &lt; <span class="number">6</span> )&#123;
        count++
        _this.<span class="title function_">createBLEConnection</span>()
      &#125;<span class="keyword">else</span>&#123;
        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 连接失败关闭蓝牙模块</span>
      &#125;
    &#125;
  &#125;)
&#125;</code></pre></li>
</ul>
<h3 id="6-获取蓝牙设备的服务"><a href="#6-获取蓝牙设备的服务" class="headerlink" title="6. 获取蓝牙设备的服务"></a>6. 获取蓝牙设备的服务</h3><ul>
<li>获取蓝牙设备的服务列表使用的是<code>wx.getBLEDeviceServices</code><pre><code class="highlight js"><span class="attr">getBLEDeviceServices</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">getBLEDeviceServices</span>(&#123;
    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">services</span>.<span class="property">length</span>; i++)&#123;
        <span class="comment">// 如果提前得知可以直接判断，如果不知道可以用蓝牙工具看一下服务所需的功能</span>
        <span class="keyword">if</span>(res.<span class="property">services</span>[i].<span class="property">uuid</span> == _this.<span class="property">data</span>.<span class="property">service</span>)&#123;
          _this.<span class="title function_">setData</span>(&#123;
            <span class="attr">serviceId</span>: res.<span class="property">services</span>[i].<span class="property">uuid</span>
          &#125;)
          _this.<span class="title function_">getBLEDeviceCharacteristics</span>()
        &#125;   
      &#125;
    &#125;,
    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取服务失败&quot;</span>)
      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
    &#125;
  &#125;)
&#125;,</code></pre></li>
</ul>
<h3 id="7-获取服务中的特征值"><a href="#7-获取服务中的特征值" class="headerlink" title="7. 获取服务中的特征值"></a>7. 获取服务中的特征值</h3><ul>
<li>获取服务中的特征值使用的是<code>wx.getBLEDeviceCharacteristics</code><pre><code class="highlight js"><span class="attr">getBLEDeviceCharacteristics</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 获取服务中的特征值</span>
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">getBLEDeviceCharacteristics</span>(&#123;
    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
    <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;res.<span class="property">characteristics</span>.<span class="property">length</span>; i++)&#123;
        <span class="keyword">let</span> model = res.<span class="property">characteristics</span>[i]
        <span class="keyword">if</span> ((model.<span class="property">properties</span>.<span class="property">notify</span> || model.<span class="property">properties</span>.<span class="property">indicate</span>) &amp;&amp; (model.<span class="property">properties</span>.<span class="property">read</span> &amp;&amp; model.<span class="property">properties</span>.<span class="property">write</span>))&#123;
          _this.<span class="title function_">setData</span>(&#123;
            <span class="attr">characteristicId</span>: model.<span class="property">uuid</span>
          &#125;)
          _this.<span class="title function_">notifyBLECharacteristicValueChange</span>()
        &#125;
      &#125;
    &#125;,
    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取服务中的特征值失败&quot;</span>)
      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
    &#125;
  &#125;)
&#125;,</code></pre></li>
</ul>
<h3 id="8-启用特征值变化时的notify功能"><a href="#8-启用特征值变化时的notify功能" class="headerlink" title="8. 启用特征值变化时的notify功能"></a>8. 启用特征值变化时的notify功能</h3><ul>
<li>启用特征值变化时的notify功能使用的是<code>wx.notifyBLECharacteristicValueChange</code><pre><code class="highlight js"><span class="attr">notifyBLECharacteristicValueChange</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 启用蓝牙特征值变化时的notify功能</span>
    <span class="keyword">var</span> _this = <span class="variable language_">this</span>
    wx.<span class="title function_">notifyBLECharacteristicValueChange</span>(&#123;
      <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
      <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,
      <span class="attr">characteristicId</span>: _thisa.<span class="property">characteristicId</span>,
      <span class="attr">state</span>: <span class="literal">true</span>,
      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
        wx.<span class="title function_">onBLECharacteristicValueChange</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;
            <span class="variable language_">console</span>.<span class="title function_">log</span>(如果要打印需要从arraybuffer格式转为字符串或<span class="number">16</span>进制)
        &#125;)
        _this.<span class="title function_">writeBLECharacteristicValue</span>() <span class="comment">// 向蓝牙设备写入数据</span>
      &#125;,
      <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;启用BLE蓝牙特征值变化时的notify功能错误&quot;</span>)
        wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
      &#125;
    &#125;)</code></pre></li>
</ul>
<h3 id="9-向蓝牙设备写入数据"><a href="#9-向蓝牙设备写入数据" class="headerlink" title="9. 向蓝牙设备写入数据"></a>9. 向蓝牙设备写入数据</h3><ul>
<li>向蓝牙设备写入数据<code>wx.writeBLECharacteristicValue</code>，这时候就是输入提前设定好的指令<pre><code class="highlight js"><span class="attr">writeBLECharacteristicValue</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 向蓝牙设备写入数据</span>
  <span class="keyword">var</span> _this = <span class="variable language_">this</span>
  wx.<span class="title function_">writeBLECharacteristicValue</span>(&#123;
    <span class="attr">deviceId</span>: _this.<span class="property">data</span>.<span class="property">deviceId</span>,
    <span class="attr">serviceId</span>: _this.<span class="property">data</span>.<span class="property">serviceId</span>,
    <span class="attr">characteristicId</span>: _this.<span class="property">data</span>.<span class="property">characteristicId</span>,
    <span class="attr">value</span>: buffer, <span class="comment">// 这个输入的指令，需要转换成ArrayBuffer</span>
    <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功&quot;</span>)
      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
    &#125;,
    <span class="attr">fail</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;输入指令失败&quot;</span>)
      wx.<span class="title function_">closeBluetoothAdapter</span>() <span class="comment">// 关闭蓝牙模块</span>
    &#125;
  &#125;)
&#125;</code></pre></li>
</ul>
<h3 id="转换格式"><a href="#转换格式" class="headerlink" title="转换格式"></a>转换格式</h3><ul>
<li><p>字符串转为arraybuffer</p>
<pre><code class="highlight js"><span class="attr">string2buffer</span>: <span class="keyword">function</span> (<span class="params">str</span>) &#123;
    <span class="comment">// 首先将字符串转为16进制</span>
    <span class="keyword">let</span> val = <span class="string">&quot;&quot;</span>
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;
      <span class="keyword">if</span> (val === <span class="string">&#x27;&#x27;</span>) &#123;
        val = str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">16</span>)
      &#125; <span class="keyword">else</span> &#123;
        val += <span class="string">&#x27;,&#x27;</span> + str.<span class="title function_">charCodeAt</span>(i).<span class="title function_">toString</span>(<span class="number">16</span>)
      &#125;
    &#125;
    <span class="comment">// 将16进制转化为ArrayBuffer</span>
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(val.<span class="title function_">match</span>(<span class="regexp">/[\da-f]&#123;2&#125;/gi</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">h</span>) &#123;
      <span class="keyword">return</span> <span class="built_in">parseInt</span>(h, <span class="number">16</span>)
    &#125;)).<span class="property">buffer</span>
&#125;</code></pre>
</li>
<li><p>arraybuffer转为字符串</p>
<pre><code class="highlight js"><span class="keyword">function</span> <span class="title function_">ab2str</span>(<span class="params">u,f</span>) &#123;
   <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Blob</span>([u]);
   <span class="keyword">var</span> r = <span class="keyword">new</span> <span class="title class_">FileReader</span>();
    r.<span class="title function_">readAsText</span>(b, <span class="string">&#x27;utf-8&#x27;</span>);
    r.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;<span class="keyword">if</span>(f)f.<span class="title function_">call</span>(<span class="literal">null</span>,r.<span class="property">result</span>)&#125;
&#125;</code></pre></li>
</ul>
<h3 id="蓝牙遇见的坑"><a href="#蓝牙遇见的坑" class="headerlink" title="蓝牙遇见的坑"></a>蓝牙遇见的坑</h3><ul>
<li>1.苹果手机有时候输入指令会显示发送成功，但是设备并没有反应<ul>
<li><pre><code>解决方法：把需要输入的指令改成每10毫秒输入一个字节
</code></pre>
</li>
<li>如果改成每10毫秒输入一个字节，安卓手机就会频繁出现10008错误</li>
<li>针对这个问题我用了一个不太好的方法，我判断了一下手机的类型，如果是ios的就分10毫秒输入，如果是安卓的就一次性输入</li>
</ul>
</li>
<li>2.在调用<code>wx.onBluetoothDeviceFound</code>这个api时ios会监听两次，然后就会导致最后设备会有两次指令输入<ul>
<li>解决方法：我在搜索蓝牙设备之前做了一个定时器，然后用<code>getBluetoothDevices</code>来查看所有已搜索到的蓝牙，在这个里面做判断来连接蓝牙设备</li>
</ul>
</li>
<li>我上面的步骤没有把这些坑的解决步骤加上，如果碰见此类问题，可以自己在合适的位置修改一下</li>
</ul>
<h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>我自己做了一个小程序的蓝牙调试器，下面是小程序码，欢迎大家体验<br><img src="https://img-blog.csdnimg.cn/20200123154720532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>解决react状态管理---React Query</title>
    <url>/2021/06/12/%E8%A7%A3%E5%86%B3react%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-ReactQuery/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210612171112847.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="React Query"></p>
<h3 id="什么是React-Query"><a href="#什么是React-Query" class="headerlink" title="什么是React Query"></a>什么是React Query</h3><ul>
<li><code>react-query</code>是一个适用于react hooks的请求库，它可以为任何类型的异步数据提供React状态管理功能，使React中的获取、缓存、同步和更新服务器数据变得轻而易举</li>
<li><code>react-query</code>与一些传统的状态管理库如redux,mobx不同，它是负责管理服务器与客户端之间的状态，一些用户交互的中间状态，如loading状态，错误信息等都是通过hooks直接返回</li>
<li><a href="https://react-query-v2.tanstack.com/">React Query官网</a></li>
</ul>
<h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><ol>
<li><code>yarn add react-query</code> or <code>npm i react-query</code>安装react-query</li>
<li>使用<code>QueryClientProvider</code>组件连接并提供一个<code>QueryClient</code>到你的应用程序<pre><code class="highlight js"><span class="keyword">import</span> &#123; <span class="title class_">QueryClient</span>, <span class="title class_">QueryClientProvider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query&#x27;</span>

&lt;<span class="title class_">QueryClientProvider</span> client=&#123;<span class="keyword">new</span> <span class="title class_">QueryClient</span>()&#125;&gt;
  &#123; ... &#125;
&lt;/<span class="title class_">QueryClientProvider</span>&gt;</code></pre></li>
</ol>
<h4 id="Devtools"><a href="#Devtools" class="headerlink" title="Devtools"></a>Devtools</h4><ul>
<li><code>yarn add react-query-devtools</code> or <code>npm i --save react-query-devtools</code>安装Devtools</li>
<li><code>react-query-devtools</code>是与<code>react-query</code>相匹配的开发工具</li>
<li>可在开发中实时查看缓存，手动获取和删除查询等等<pre><code class="highlight js"><span class="keyword">import</span> &#123; <span class="title class_">ReactQueryDevtools</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-query-devtools&#x27;</span>

<span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">return</span> (
    <span class="language-xml"><span class="tag">&lt;&gt;</span>    </span>
<span class="language-xml">      &#123; ... &#125;</span>
<span class="language-xml">      <span class="tag">&lt;<span class="name">ReactQueryDevtools</span> <span class="attr">initialIsOpen</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span>
<span class="language-xml">    <span class="tag">&lt;/&gt;</span></span>
  );
&#125;;</code></pre></li>
</ul>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><ul>
<li>react-query最常用的两个hook，查询(<code>useQuery</code>)、增删改(<code>useMutation</code>)</li>
</ul>
<h4 id="useQuery"><a href="#useQuery" class="headerlink" title="useQuery"></a>useQuery</h4><ul>
<li><code>useQuery</code>：在<code>React Query</code>中，查询是对某些异步数据源的声明性依赖。查询可以与任何基于Promise的方法(GET)一起使用，从服务器获取数据<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">useTodos</span> = (<span class="params">param</span>) =&gt; &#123;
  <span class="keyword">const</span> request = <span class="title function_">useHttp</span>()

  <span class="comment">/**</span>
<span class="comment">   * 第一个参数是QueryKey，是查询的关键，是一个独一无二的key，并在之后的增删改中需要，</span>
<span class="comment">   *   如果需要动态的QueryKey，可以使用数组的方式，如[&#x27;todos&#x27;, params]</span>
<span class="comment">   * 第二个参数是用于获取数据的异步函数</span>
<span class="comment">   * useQuery的响应返回就是获取到的数据和一些中间状态，如isLoading，error，isIdle...</span>
<span class="comment">   */</span>
  <span class="keyword">return</span> <span class="title function_">useQuery</span>(<span class="string">&#x27;todos&#x27;</span>, <span class="function">() =&gt;</span>
    <span class="title function_">request</span>(<span class="string">&#x27;todos&#x27;</span>, &#123; <span class="attr">data</span>: param &#125;)
  )
&#125;

<span class="comment">// 在UI组件调用</span>
<span class="keyword">const</span> &#123; isLoading, error, <span class="attr">data</span>: todos &#125; = <span class="title function_">useTodos</span>()</code></pre></li>
</ul>
<h4 id="useMutation"><a href="#useMutation" class="headerlink" title="useMutation"></a>useMutation</h4><ul>
<li><code>useMutation</code>：常用于创建&#x2F;更新&#x2F;删除数据或执行服务器副作用<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">useAddTodo</span> = (<span class="params"></span>) =&gt; &#123;
  <span class="keyword">const</span> request = <span class="title function_">useHttp</span>()

  <span class="comment">/**</span>
<span class="comment">   * 第一个参数是执行操作的异步函数，在返回的mutate中触发</span>
<span class="comment">   * 第二个参数是执行成功或者失败的一些配置函数，可用于一些处理缓存的操作，例如乐观更新</span>
<span class="comment">   */</span>
  <span class="keyword">return</span> <span class="title function_">useMutation</span>(
    <span class="function">(<span class="params">data</span>) =&gt;</span>
      <span class="title function_">request</span>(<span class="string">`todos`</span>, &#123;
        data,
        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,
      &#125;),
    &#123;
      <span class="title function_">onSuccess</span>(<span class="params"></span>)&#123;&#125;
      <span class="title function_">onError</span>(<span class="params"></span>)&#123;&#125;
      <span class="title function_">onSettled</span>(<span class="params"></span>)&#123;&#125;
      ...
    &#125;
  )
&#125;

<span class="comment">// 操作组件调用</span>
<span class="keyword">const</span> <span class="title function_">TodosAddBtn</span> = (<span class="params"></span>) =&gt; &#123;
  ...
  <span class="keyword">const</span> &#123; mutateAsync, isLoading, error &#125; = <span class="title function_">useAddTodo</span>()
  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> mutateAsync(todoData)&#125;&gt;add<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>
&#125;</code></pre></li>
</ul>
<h5 id="例：用第二个参数配置乐观更新"><a href="#例：用第二个参数配置乐观更新" class="headerlink" title="例：用第二个参数配置乐观更新"></a>例：用第二个参数配置乐观更新</h5><ul>
<li>乐观更新就是在一些请求或者数据处理没有结束的时候，提前给用户显示理想的结果，如果失败就回滚更新<pre><code class="highlight js"><span class="keyword">const</span> <span class="title function_">useAddConfig</span> = (<span class="params">queryKey</span>) =&gt; &#123;
  <span class="comment">// 获取当前QueryClient的实例</span>
  <span class="keyword">const</span> queryClient = <span class="title function_">useQueryClient</span>()
  
  <span class="keyword">return</span> &#123;
    <span class="comment">// 当mutate被调用时触发</span>
    <span class="keyword">async</span> <span class="title function_">onMutate</span>(<span class="params">target</span>) &#123;
      <span class="comment">// 获取当前数据快照，用于错误时回滚更新</span>
      <span class="keyword">const</span> previousItems = queryClient.<span class="title function_">getQueryData</span>(queryKey)
      <span class="comment">// 乐观更新为新值</span>
      queryClient.<span class="title function_">setQueryData</span>(queryKey, <span class="function">(<span class="params">old</span>) =&gt;</span> &#123;
        <span class="keyword">return</span> <span class="function">(<span class="params">target, old</span>) =&gt;</span> (old ? [...old, target] : [])
      &#125;)

      <span class="comment">// 这个返回值会作为最后一个参数传递给onError和onSettled</span>
      <span class="keyword">return</span> &#123; previousItems &#125;
    &#125;,
    <span class="comment">// 成功回调 清除缓存</span>
    <span class="attr">onSuccess</span>: <span class="function">() =&gt;</span> queryClient.<span class="title function_">invalidateQueries</span>(queryKey),
    <span class="comment">// 失败回调</span>
    <span class="title function_">onError</span>(<span class="params">error, newItem, context</span>) &#123;
      <span class="comment">// 当前queryKey的数据回滚</span>
      queryClient.<span class="title function_">setQueryData</span>(
        queryKey,
        context.<span class="property">previousItems</span>
      )
    &#125;,
    <span class="comment">// 无论错误或者成功都会触发，此例子没有使用</span>
    <span class="title function_">onSettled</span>(<span class="params"></span>) &#123;&#125;
  &#125;
&#125;</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>本地&#x2F;客户端中间状态<ul>
<li>redux与react-query都可，没有较大的优缺点</li>
</ul>
</li>
<li>服务端中间状态<ul>
<li>推荐react-query，将服务器状态从全局状态中解放出来，用更少的代码实现复杂的需求，让你的状态管理更优雅</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>ReactQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3响应式分析</title>
    <url>/2021/08/01/%E8%A7%A3%E6%9E%90reactive-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="vue3响应式分析"><a href="#vue3响应式分析" class="headerlink" title="vue3响应式分析"></a>vue3响应式分析</h2><ol>
<li>首先对vue3响应式分析之前，需要对前置知识<code>Proxy</code>和<code>Reflect</code>有所了解，，关于这两个知识我推荐看阮一峰老师的<a href="https://es6.ruanyifeng.com/#README">ES6入门教程</a></li>
<li>vue3的响应式我是以reactive为入口进行梳理，流程如下图<br><img src="https://img-blog.csdnimg.cn/83a41b1d8a3044d6b8135850ea972ed1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxOTI1OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>源码位置：<code>reactivity/src/...</code>，分四部分解析</li>
</ol>
<ul>
<li>reactive文件：目标对象转化为proxy实例</li>
<li>baseHandler文件：基本类型处理器</li>
<li>collectionHandlers文件：Map、Set处理器</li>
<li>effect文件：收集触发依赖</li>
</ul>
<ol start="4">
<li>如果不想看源码解析，可以直接看总结🐶</li>
</ol>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul>
<li><code>reactive</code>：将一个JS对象转为具有响应式的proxy实例<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) &#123;
    <span class="comment">// 如果是只读数据，就直接返回</span>
    <span class="keyword">if</span> (target &amp;&amp; (target <span class="keyword">as</span> <span class="title class_">Target</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>]) &#123;
      <span class="keyword">return</span> target
    &#125;
    <span class="keyword">return</span> <span class="title function_">createReactiveObject</span>(
      target,
      <span class="literal">false</span>,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    )
&#125;</code></pre></li>
<li><code>createReactiveObject</code><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">createReactiveObject</span>(<span class="params"></span>
<span class="params">    target: Target, <span class="comment">// 源对象</span></span>
<span class="params">    isReadonly: <span class="built_in">boolean</span>, <span class="comment">// 是否只读</span></span>
<span class="params">    baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;, <span class="comment">// 基本类型的handlers</span></span>
<span class="params">    collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;, <span class="comment">// 主要针对(set、map、weakSet、weakMap)的handlers</span></span>
<span class="params">    proxyMap: <span class="built_in">WeakMap</span>&lt;Target, <span class="built_in">any</span>&gt;</span>
<span class="params"></span>) &#123;
  <span class="comment">// 如果不是一个对象，直接返回，并且在开发环境发出警告</span>
    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;
      <span class="keyword">if</span> (__DEV__) &#123;
        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)
      &#125;
      <span class="keyword">return</span> target
    &#125;
    <span class="comment">// 如果已经是响应式，直接返回</span>
    <span class="keyword">if</span> (
      target[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>] &amp;&amp;
      !(isReadonly &amp;&amp; target[<span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>])
    ) &#123;
      <span class="keyword">return</span> target
    &#125;

    <span class="comment">// 如果目标对象已经存在代理，直接返回</span>
    <span class="keyword">const</span> existingProxy = proxyMap.<span class="title function_">get</span>(target)
    <span class="keyword">if</span> (existingProxy) &#123;
      <span class="keyword">return</span> existingProxy
    &#125;

    <span class="comment">// 如果类型值不是Object、Array、Map、Set、WeakMap、WeakSet的，直接返回</span>
    <span class="keyword">const</span> targetType = <span class="title function_">getTargetType</span>(target)
    <span class="keyword">if</span> (targetType === <span class="title class_">TargetType</span>.<span class="property">INVALID</span>) &#123;
      <span class="keyword">return</span> target
    &#125;

    <span class="comment">// 根据不同的类型值赋予不同的handlers，就是我之前图上画的分开处理</span>
    <span class="comment">/* </span>
<span class="comment">      把set、Map这种数据与基础数据分开处理，是因为Map、Set中存储的数据必须通过this进行访问</span>
<span class="comment">      但是被proxy劫持后，this就变成了proxy，</span>
<span class="comment">      所以需要特殊处理，把劫持方法进行重写</span>
<span class="comment">     */</span>
    <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(
      target,
      targetType === <span class="title class_">TargetType</span>.<span class="property">COLLECTION</span> ? collectionHandlers : baseHandlers
    )
    proxyMap.<span class="title function_">set</span>(target, proxy)
    <span class="keyword">return</span> proxy
  &#125;</code></pre></li>
</ul>
<h3 id="baseHandler"><a href="#baseHandler" class="headerlink" title="baseHandler"></a>baseHandler</h3><p><code>baseHandler</code>主要分析reactive的处理器对象<code>mutableHandlers</code></p>
<pre><code class="highlight ts"><span class="comment">// 对get set delete has onwKeys做了拦截处理</span>
<span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">mutableHandlers</span>: <span class="title class_">ProxyHandler</span>&lt;<span class="built_in">object</span>&gt; = &#123;
  get,
  set,
  deleteProperty,
  has,
  ownKeys
&#125;</code></pre>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) &#123;
  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | <span class="built_in">symbol</span>, receiver: <span class="built_in">object</span></span>) &#123;
    <span class="comment">// 访问标志位时的逻辑处理</span>
    <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_REACTIVE</span>) &#123;
      <span class="keyword">return</span> !isReadonly
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="title class_">ReactiveFlags</span>.<span class="property">IS_READONLY</span>) &#123;
      <span class="keyword">return</span> isReadonly
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (
      key === <span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span> &amp;&amp;
      receiver ===
        (isReadonly
          ? shallow
            ? shallowReadonlyMap
            : readonlyMap
          : shallow
            ? shallowReactiveMap
            : reactiveMap
        ).<span class="title function_">get</span>(target)
    ) &#123;
      <span class="keyword">return</span> target
    &#125;

    <span class="keyword">const</span> targetIsArray = <span class="title function_">isArray</span>(target)

    <span class="comment">// 如果target是数组并且key属于一些数组的原始方法，即触发拦截</span>
    <span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; <span class="title function_">hasOwn</span>(arrayInstrumentations, key)) &#123;
      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)
    &#125;

    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)

    <span class="comment">// 如果key是symbol的内置方法，或者是原型对象，直接返回</span>
    <span class="keyword">if</span> (<span class="title function_">isSymbol</span>(key) ? builtInSymbols.<span class="title function_">has</span>(key) : <span class="title function_">isNonTrackableKeys</span>(key)) &#123;
      <span class="keyword">return</span> res
    &#125;

    <span class="comment">// 只读对象不收集依赖，因为不会触发依赖更新</span>
    <span class="keyword">if</span> (!isReadonly) &#123;
      <span class="title function_">track</span>(target, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)
    &#125;

    <span class="comment">// 浅层响应立即返回，不递归转化</span>
    <span class="keyword">if</span> (shallow) &#123;
      <span class="keyword">return</span> res
    &#125;

    <span class="comment">// 如果是ref对象(数组除外)，返回真正的值，</span>
    <span class="keyword">if</span> (<span class="title function_">isRef</span>(res)) &#123;
      <span class="keyword">const</span> shouldUnwrap = !targetIsArray || !<span class="title function_">isIntegerKey</span>(key)
      <span class="keyword">return</span> shouldUnwrap ? res.<span class="property">value</span> : res
    &#125;

    <span class="keyword">if</span> (<span class="title function_">isObject</span>(res)) &#123;
      <span class="comment">// 由于proxy只能代理一层，所以target[key]的值如果是对象，就继续对其进行代理</span>
      <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)
    &#125;
    <span class="keyword">return</span> res
  &#125;
&#125;</code></pre>
<p>数组方法拦截: 对数组的两种原生方法进行了拦截</p>
<ul>
<li>遍历查找的方法：includes、indexOf、lastIndexOf</li>
<li>改变数组长度的方法：push、pop、shift、unshift、splice<pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">createArrayInstrumentations</span>(<span class="params"></span>) &#123;
    <span class="keyword">const</span> <span class="attr">instrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;&#125;
    ;([<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;
      <span class="keyword">const</span> method = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[key] <span class="keyword">as</span> <span class="built_in">any</span>
      instrumentations[key] = <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;
        <span class="comment">// 这一步是为了取原始实例，因为当前的this是receiver</span>
        <span class="keyword">const</span> arr = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)
        <span class="comment">// 搜集依赖</span>
        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="variable language_">this</span>.<span class="property">length</span>; i &lt; l; i++) &#123;
          <span class="title function_">track</span>(arr, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, i + <span class="string">&#x27;&#x27;</span>)
        &#125;
        <span class="comment">// 触发方法，如果没有找到对应的值，就取原始值再遍历</span>
        <span class="keyword">const</span> res = method.<span class="title function_">apply</span>(arr, args)
        <span class="keyword">if</span> (res === -<span class="number">1</span> || res === <span class="literal">false</span>) &#123;
          <span class="keyword">return</span> method.<span class="title function_">apply</span>(arr, args.<span class="title function_">map</span>(toRaw))
        &#125; <span class="keyword">else</span> &#123;
          <span class="keyword">return</span> res
        &#125;
      &#125;
    &#125;)
    <span class="comment">/* </span>
<span class="comment">      因为改变数组长度的方法，执行期间会触发length的get和set</span>
<span class="comment">      就回导致无限循环track和trigger</span>
<span class="comment">      所以就用pauseTracking()禁用依赖收集，触发方法后，</span>
<span class="comment">      再用resetTracking()恢复track</span>
<span class="comment">     */</span>
    ;([<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;
      <span class="keyword">const</span> method = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[key] <span class="keyword">as</span> <span class="built_in">any</span>
      instrumentations[key] = <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>[], ...args: <span class="built_in">unknown</span>[]</span>) &#123;
        <span class="title function_">pauseTracking</span>()
        <span class="keyword">const</span> res = method.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)
        <span class="title function_">resetTracking</span>()
        <span class="keyword">return</span> res
      &#125;
    &#125;)
    <span class="keyword">return</span> instrumentations
&#125;</code></pre></li>
</ul>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) &#123;
  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span>
<span class="params">    target: <span class="built_in">object</span>,</span>
<span class="params">    key: <span class="built_in">string</span> | <span class="built_in">symbol</span>,</span>
<span class="params">    value: <span class="built_in">unknown</span>,</span>
<span class="params">    receiver: <span class="built_in">object</span></span>
<span class="params">  </span>): <span class="built_in">boolean</span> &#123;
    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> <span class="built_in">any</span>)[key]
    <span class="keyword">if</span> (!shallow) &#123;
      value = <span class="title function_">toRaw</span>(value)
      oldValue = <span class="title function_">toRaw</span>(oldValue)
      <span class="comment">// 如果原来的值是ref，但新的值不是，则将新的值赋给oldValue.value</span>
      <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isRef</span>(oldValue) &amp;&amp; !<span class="title function_">isRef</span>(value)) &#123;
        oldValue.<span class="property">value</span> = value
        <span class="keyword">return</span> <span class="literal">true</span>
      &#125;
    &#125; <span class="keyword">else</span> &#123;
      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span>
    &#125;

    <span class="keyword">const</span> hadKey =
      <span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isIntegerKey</span>(key)
        ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span>
        : <span class="title function_">hasOwn</span>(target, key)
    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)
    
    <span class="comment">// 判断receiver是当前对象的proxy实例，防止原型链上的proxy触发更新</span>
    <span class="keyword">if</span> (target === <span class="title function_">toRaw</span>(receiver)) &#123;
      <span class="comment">// 判断新增属性还是修改属性</span>
      <span class="keyword">if</span> (!hadKey) &#123;
        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)
      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;
        <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)
      &#125;
    &#125;
    <span class="keyword">return</span> result
  &#125;
&#125;</code></pre>
<h4 id="deleteProperty、has…"><a href="#deleteProperty、has…" class="headerlink" title="deleteProperty、has…"></a>deleteProperty、has…</h4><ul>
<li>deleteProperty、has、ownKeys的源码就不贴了，都是判断key的属性，然后选择触发或者收集依赖</li>
</ul>
<h3 id="collectionHandlers"><a href="#collectionHandlers" class="headerlink" title="collectionHandlers"></a>collectionHandlers</h3><ul>
<li>collection主要分析reactive的重写方法对象mutableInstrumentations<pre><code class="highlight ts"><span class="comment">// 主要对以下原生api进行了改写</span>
<span class="keyword">const</span> <span class="attr">mutableInstrumentations</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Function</span>&gt; = &#123;
    <span class="title function_">get</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span></span>) &#123;
      <span class="keyword">return</span> <span class="title function_">get</span>(<span class="variable language_">this</span>, key)
    &#125;,
    <span class="keyword">get</span> <span class="title function_">size</span>() &#123;
      <span class="keyword">return</span> <span class="title function_">size</span>((<span class="variable language_">this</span> <span class="keyword">as</span> <span class="built_in">unknown</span>) <span class="keyword">as</span> <span class="title class_">IterableCollections</span>)
    &#125;,
    has,
    add,
    set,
    <span class="attr">delete</span>: deleteEntry,
    clear,
    <span class="attr">forEach</span>: <span class="title function_">createForEach</span>(<span class="literal">false</span>, <span class="literal">false</span>)
&#125;</code></pre></li>
</ul>
<h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>
<span class="params">    target: MapTypes,</span>
<span class="params">    key: <span class="built_in">unknown</span>,</span>
<span class="params">    isReadonly = <span class="literal">false</span>,</span>
<span class="params">    isShallow = <span class="literal">false</span></span>
<span class="params"></span>) &#123;
    <span class="comment">// 获取原始值重新赋值给target</span>
    target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]

    <span class="comment">// 对target源对象和key进一步获取原始值</span>
    <span class="keyword">const</span> rawTarget = <span class="title function_">toRaw</span>(target)
    <span class="keyword">const</span> rawKey = <span class="title function_">toRaw</span>(key)

    <span class="comment">// 当前key和原始key均进行依赖收集(track)</span>
    <span class="keyword">if</span> (key !== rawKey) &#123;
      !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, key)
    &#125;
    !isReadonly &amp;&amp; <span class="title function_">track</span>(rawTarget, <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>, rawKey)
    <span class="keyword">const</span> &#123; has &#125; = <span class="title function_">getProto</span>(rawTarget)

    <span class="comment">// 获取对应的转换函数</span>
    <span class="keyword">const</span> wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive
    <span class="comment">/* </span>
<span class="comment">      如果源对象有key对应的属性，就通过原生get方法取到值，</span>
<span class="comment">      并对该值进行响应式转换，返回转换后的响应式对象，</span>
<span class="comment">      如果没有，就去key原始值中去查找</span>
<span class="comment">    */</span>
    <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, key)) &#123;
      <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(key))
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has.<span class="title function_">call</span>(rawTarget, rawKey)) &#123;
      <span class="keyword">return</span> <span class="title function_">wrap</span>(target.<span class="title function_">get</span>(rawKey))
    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target !== rawTarget) &#123;
      target.<span class="title function_">get</span>(key)
    &#125;
&#125;</code></pre>

<h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><pre><code class="highlight ts"><span class="comment">// 对size属性做get拦截</span>
<span class="keyword">function</span> <span class="title function_">size</span>(<span class="params">target: IterableCollections, isReadonly = <span class="literal">false</span></span>) &#123;
  target = (target <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="title class_">ReactiveFlags</span>.<span class="property">RAW</span>]
  <span class="comment">// 获取size和获取数组的length类似，都用专门的key做依赖收集</span>
  !isReadonly &amp;&amp; <span class="title function_">track</span>(<span class="title function_">toRaw</span>(target), <span class="title class_">TrackOpTypes</span>.<span class="property">ITERATE</span>, <span class="variable constant_">ITERATE_KEY</span>)
  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, <span class="string">&#x27;size&#x27;</span>, target)
&#125;</code></pre>

<h4 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h4><pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"><span class="variable language_">this</span>: MapTypes, key: <span class="built_in">unknown</span>, value: <span class="built_in">unknown</span></span>) &#123;
  <span class="comment">// 获取value和this上下文的原始值</span>
  value = <span class="title function_">toRaw</span>(value)
  <span class="keyword">const</span> target = <span class="title function_">toRaw</span>(<span class="variable language_">this</span>)
  <span class="keyword">const</span> &#123; has, get &#125; = <span class="title function_">getProto</span>(target)

  <span class="comment">/* </span>
<span class="comment">    判断源对象是否已经存在对应的key</span>
<span class="comment">    1. 首先查找源对象是否已有key对应的属性</span>
<span class="comment">    2. 如果没有，再查找key对应的原始值在源对象的属性是否存在</span>
<span class="comment">  */</span>
  <span class="keyword">let</span> hadKey = has.<span class="title function_">call</span>(target, key)
  <span class="keyword">if</span> (!hadKey) &#123;
    key = <span class="title function_">toRaw</span>(key)
    hadKey = has.<span class="title function_">call</span>(target, key)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;
    <span class="title function_">checkIdentityKeys</span>(target, has, key)
  &#125;

  <span class="keyword">const</span> oldValue = get.<span class="title function_">call</span>(target, key)
  target.<span class="title function_">set</span>(key, value)

  <span class="comment">// 触发依赖，新增属性和修改属性分开进行trigger</span>
  <span class="keyword">if</span> (!hadKey) &#123;
    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>, key, value)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(value, oldValue)) &#123;
    <span class="title function_">trigger</span>(target, <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>, key, value, oldValue)
  &#125;
  <span class="keyword">return</span> <span class="variable language_">this</span>
&#125;</code></pre>
<h4 id="has、clear…"><a href="#has、clear…" class="headerlink" title="has、clear…"></a>has、clear…</h4><ul>
<li>其余重写方法我就不上代码了，不同点是单个属性触发单个的依赖，如果是遍历所有属性的方法就触发所有依赖</li>
</ul>
<h3 id="effect"><a href="#effect" class="headerlink" title="effect"></a>effect</h3><ul>
<li>effect文件作为响应式的核心，主要负责收集依赖，触发依赖</li>
</ul>
<h4 id="effect-1"><a href="#effect-1" class="headerlink" title="effect"></a>effect</h4><ul>
<li>effect函数主要是生成收集依赖所需的依赖函数<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">function</span> effect&lt;T = <span class="built_in">any</span>&gt;(
    <span class="attr">fn</span>: <span class="function">() =&gt;</span> T,
    <span class="attr">options</span>: <span class="title class_">ReactiveEffectOptions</span> = <span class="variable constant_">EMPTY_OBJ</span>
): <span class="title class_">ReactiveEffect</span>&lt;T&gt; &#123;
    <span class="comment">// 如果已经是effect函数，取得原来的fn</span>
    <span class="keyword">if</span> (<span class="title function_">isEffect</span>(fn)) &#123;
      fn = fn.<span class="property">raw</span>
    &#125;
    <span class="keyword">const</span> effect = <span class="title function_">createReactiveEffect</span>(fn, options)

    <span class="comment">// 如果lazy为false，立即执行一次</span>
    <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;
      <span class="title function_">effect</span>()
    &#125;
    <span class="keyword">return</span> effect
&#125;</code></pre></li>
<li><code>createReactiveEffect</code>：生成effect对象<pre><code class="highlight ts"><span class="keyword">function</span> createReactiveEffect&lt;T = <span class="built_in">any</span>&gt;(
    <span class="attr">fn</span>: <span class="function">() =&gt;</span> T,
    <span class="attr">options</span>: <span class="title class_">ReactiveEffectOptions</span>
): <span class="title class_">ReactiveEffect</span>&lt;T&gt; &#123;
    <span class="keyword">const</span> effect = <span class="keyword">function</span> <span class="title function_">reactiveEffect</span>(<span class="params"></span>): <span class="built_in">unknown</span> &#123;
      <span class="comment">// 没有激活，已经调用stop函数停止监听</span>
      <span class="keyword">if</span> (!effect.<span class="property">active</span>) &#123;
        <span class="keyword">return</span> <span class="title function_">fn</span>()
      &#125;
      <span class="comment">/**</span>
<span class="comment">       * effectStack是一个全局的effect栈结构</span>
<span class="comment">       * 设计为栈结构是因为如果effect是嵌套时，为了防止内层副作用函数覆盖外层副作用函数，在收集时只收集栈顶的，这样就不会收集到错误的副作用函数</span>
<span class="comment">       */</span>
      <span class="keyword">if</span> (!effectStack.<span class="title function_">includes</span>(effect)) &#123;
        <span class="comment">/**</span>
<span class="comment">         * 为了保证当前effect的dep是最新，因为在一些判断处理中，可能会导致一些无效的副作用函数</span>
<span class="comment">         * 所以为了取消这些不必要的更新，就要清除effect依赖</span>
<span class="comment">         */</span>
        <span class="title function_">cleanup</span>(effect)
        <span class="keyword">try</span> &#123;
          <span class="title function_">enableTracking</span>() <span class="comment">// 重新收集依赖</span>
          effectStack.<span class="title function_">push</span>(effect)
          activeEffect = effect
          <span class="keyword">return</span> <span class="title function_">fn</span>()
        &#125; <span class="keyword">finally</span> &#123;
          <span class="comment">/* </span>
<span class="comment">            track将依赖函数activeEffect添加到对应的dep中，</span>
<span class="comment">            然后将activeEffect重置为上一个effect的值</span>
<span class="comment">          */</span>
          effectStack.<span class="title function_">pop</span>()
          <span class="title function_">resetTracking</span>()
          activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]
        &#125;
      &#125;
    &#125; <span class="keyword">as</span> <span class="title class_">ReactiveEffect</span>
    effect.<span class="property">id</span> = uid++ <span class="comment">// 自增ID</span>
    effect.<span class="property">allowRecurse</span> = !!options.<span class="property">allowRecurse</span> <span class="comment">// 递归状态</span>
    effect.<span class="property">_isEffect</span> = <span class="literal">true</span> <span class="comment">// 用于标识方法是不是effect</span>
    effect.<span class="property">active</span> = <span class="literal">true</span> <span class="comment">// 用于判断当前effect是否激活，有一个stop()来将它设为false</span>
    effect.<span class="property">raw</span> = fn <span class="comment">// effect的执行函数</span>
    effect.<span class="property">deps</span> = [] <span class="comment">// 用于收集依赖</span>
    effect.<span class="property">options</span> = options <span class="comment">// 创建effect传入的options</span>
    <span class="keyword">return</span> effect
&#125;</code></pre></li>
<li>activeEffect就是标记track所需的依赖函数</li>
</ul>
<h4 id="track"><a href="#track" class="headerlink" title="track"></a>track</h4><ul>
<li>track就是baseHandler和collectionHandlers文件中频繁使用的收集依赖函数</li>
<li>首先需要看一个关键变量targetMap<pre><code class="highlight ts"><span class="comment">// targetMap是依赖管理中心，收集依赖和触发依赖都依托于这个Map数据</span>
<span class="comment">// 下面是targetMap的定义(target -&gt; key -&gt; dep)</span>
<span class="comment">// target: 监听的对象源</span>
<span class="comment">// key: 监听的键值</span>
<span class="comment">// dep：依赖函数</span>
<span class="keyword">type</span> <span class="title class_">Dep</span> = <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;
<span class="keyword">type</span> <span class="title class_">KeyToDepMap</span> = <span class="title class_">Map</span>&lt;<span class="built_in">any</span>, <span class="title class_">Dep</span>&gt;
<span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>&lt;<span class="built_in">any</span>, <span class="title class_">KeyToDepMap</span>&gt;()
<span class="comment">// 格式大致为</span>
targetMap = &#123;
  <span class="attr">target</span>: &#123;
    <span class="attr">key1</span>: &#123; fn1, fn2 &#125;
    <span class="attr">key2</span>: &#123; fn1, fn2 &#125;
  &#125;
&#125;</code></pre>
<pre><code class="highlight ts"><span class="comment">/**</span>
<span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">target</span>&#125; 目标对象</span>
<span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">type</span>&#125; 收集类型</span>
<span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">key</span>&#125; 需要收集依赖的key</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: <span class="built_in">unknown</span></span>) &#123;
    <span class="comment">// activeEffect为空，就表示当前没有依赖，就没必要做依赖收集了</span>
    <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;
      <span class="keyword">return</span>
    &#125;
    <span class="comment">// 获取当前依赖数据</span>
    <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)

    <span class="keyword">if</span> (!depsMap) &#123;
      targetMap.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))
    &#125;

    <span class="comment">// 如果当前数据中没有所属的依赖key，就重新设置一个</span>
    <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)
    <span class="keyword">if</span> (!dep) &#123;
      depsMap.<span class="title function_">set</span>(key, (dep = <span class="keyword">new</span> <span class="title class_">Set</span>()))
    &#125;
    <span class="comment">// 添加依赖函数</span>
    <span class="keyword">if</span> (!dep.<span class="title function_">has</span>(activeEffect)) &#123;
      dep.<span class="title function_">add</span>(activeEffect)
      activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(dep)
      <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.<span class="property">options</span>.<span class="property">onTrack</span>) &#123;
        activeEffect.<span class="property">options</span>.<span class="title function_">onTrack</span>(&#123;
          <span class="attr">effect</span>: activeEffect,
          target,
          <span class="keyword">type</span>,
          key
        &#125;)
      &#125;
    &#125;
&#125;</code></pre></li>
</ul>
<h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h4><pre><code class="highlight ts"><span class="comment">// 触发依赖</span>
<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params"></span>
<span class="params">  target: <span class="built_in">object</span>,</span>
<span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span>
<span class="params">  key?: <span class="built_in">unknown</span>,</span>
<span class="params">  newValue?: <span class="built_in">unknown</span>,</span>
<span class="params">  oldValue?: <span class="built_in">unknown</span>,</span>
<span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;<span class="built_in">unknown</span>, <span class="built_in">unknown</span>&gt; | <span class="built_in">Set</span>&lt;<span class="built_in">unknown</span>&gt;</span>
<span class="params"></span>) &#123;
  <span class="keyword">const</span> depsMap = targetMap.<span class="title function_">get</span>(target)
  <span class="comment">// 如果没有收集过依赖，直接返回</span>
  <span class="keyword">if</span> (!depsMap) &#123;
    <span class="keyword">return</span>
  &#125;

  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="title class_">ReactiveEffect</span>&gt;()
  <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">effectsToAdd: <span class="built_in">Set</span>&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt; &#123;
    <span class="keyword">if</span> (effectsToAdd) &#123;
      effectsToAdd.<span class="title function_">forEach</span>(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;
        <span class="comment">// 避免循环触发依赖 类似`effect(() =&gt; obj.foo++)`</span>
        <span class="keyword">if</span> (effect !== activeEffect || effect.<span class="property">allowRecurse</span>) &#123;
          effects.<span class="title function_">add</span>(effect)
        &#125;
      &#125;)
    &#125;
  &#125;

  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="title class_">TriggerOpTypes</span>.<span class="property">CLEAR</span>) &#123;
    <span class="comment">// 在清空前，将对应的依赖全部添加到局部Set</span>
    depsMap.<span class="title function_">forEach</span>(add)
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; <span class="title function_">isArray</span>(target)) &#123;
    <span class="comment">// 当数组的length属性变化时触发</span>
    depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;
      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;
        <span class="title function_">add</span>(dep)
      &#125;
    &#125;)
  &#125; <span class="keyword">else</span> &#123;
    <span class="comment">// schedule runs for SET | ADD | DELETE</span>
    <span class="comment">// 往相应队列添加依赖</span>
    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;
      <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(key))
    &#125;

    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span>
    <span class="comment">// 通过不同的TriggerOpTypes将depsMap的数据取出，添加到effects</span>
    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;
      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">ADD</span>:
        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;
          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))
          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;
            <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>))
          &#125;
        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isIntegerKey</span>(key)) &#123;
          <span class="comment">// new index added to array -&gt; length changes</span>
          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="string">&#x27;length&#x27;</span>))
        &#125;
        <span class="keyword">break</span>
      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">DELETE</span>:
        <span class="keyword">if</span> (!<span class="title function_">isArray</span>(target)) &#123;
          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))
          <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;
            <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>))
          &#125;
        &#125;
        <span class="keyword">break</span>
      <span class="keyword">case</span> <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>:
        <span class="keyword">if</span> (<span class="title function_">isMap</span>(target)) &#123;
          <span class="title function_">add</span>(depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>))
        &#125;
        <span class="keyword">break</span>
    &#125;
  &#125;

  <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">effect: ReactiveEffect</span>) =&gt; &#123;
    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.<span class="property">options</span>.<span class="property">onTrigger</span>) &#123;
      effect.<span class="property">options</span>.<span class="title function_">onTrigger</span>(&#123;
        effect,
        target,
        key,
        <span class="keyword">type</span>,
        newValue,
        oldValue,
        oldTarget
      &#125;)
    &#125;
    <span class="keyword">if</span> (effect.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;
      <span class="comment">// 如果有调度属性，就通过scheduler处理执行</span>
      effect.<span class="property">options</span>.<span class="title function_">scheduler</span>(effect)
    &#125; <span class="keyword">else</span> &#123;
      <span class="title function_">effect</span>()
    &#125;
  &#125;

  effects.<span class="title function_">forEach</span>(run)
&#125;</code></pre>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>vue3响应式是通过数据劫持和发布订阅的模式进行处理，首先vue3中的数据是通过<code>proxy</code>做了一层代理，然后处理<code>proxy</code>的<code>handler</code>，基本类型的<code>handler</code>是通过<code>baseHandlers</code>，特殊类型(map，set)的<code>handler</code>是通过<code>collectHandlers</code>。</li>
<li><code>handler</code>中获取属性的操作通过<code>track</code>进行依赖收集，修改属性的操作通过<code>trigger</code>进行依赖触发，依赖的收集与触发是通过依赖管理中心<code>targetMap</code>保存的</li>
<li><code>track</code>进行收集时，他收集的是<code>activeEffect</code>，这个变量存储的就是正在触发的副作用函数，<code>activeEffect</code>通过<code>effect()</code>方法进行收集</li>
<li><code>effect()</code>常用的三个地方<ul>
<li>组件副作用函数</li>
<li><code>watch</code></li>
<li><code>computed</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>解析nextTick---vue3任务调度</title>
    <url>/2021/07/17/%E8%A7%A3%E6%9E%90nextTick-vue3%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><ul>
<li>定义：将回调推迟到下一个 DOM 更新周期之后执行，在更改了一些数据以等待 DOM 更新后立即使用它</li>
<li>在实际中使用这个方法一般是用于组件更新，你需要获取更新后的数据，所以使用nextTick等待DOM更新<pre><code class="highlight js"><span class="keyword">import</span> &#123; createApp, nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>
<span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;
    <span class="title function_">setup</span>(<span class="params"></span>) &#123;
      <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello!&#x27;</span>)
      <span class="keyword">const</span> <span class="title function_">changeMessage</span> = <span class="keyword">async</span> newMessage =&gt; &#123;
        message.<span class="property">value</span> = newMessage
        <span class="comment">// 这里的value是旧值</span>
        <span class="keyword">await</span> <span class="title function_">nextTick</span>()
        <span class="comment">// nextTick后获取的就是DOM更新后的value</span>
        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Now DOM is updated&#x27;</span>)
      &#125;
    &#125;
&#125;)</code></pre></li>
<li>这个api使用时相当简单，而且相当容易理解，但是为了知其意，还是要翻一下源码了解它的执行机制<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params"></span>
<span class="params">  <span class="variable language_">this</span>: ComponentPublicInstance | <span class="built_in">void</span>,</span>
<span class="params">  fn?: () =&gt; <span class="built_in">void</span></span>
<span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;
  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise
  <span class="keyword">return</span> fn ? p.<span class="title function_">then</span>(<span class="variable language_">this</span> ? fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>) : fn) : p
&#125;</code></pre></li>
<li>上面是vue源码中nextTick的实现，为了搞清楚实现逻辑，就必须搞懂<code>currentFlushPromise</code>这个变量的含义，所以要从任务的调度机制开始分析</li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>首先这个调度机制的功能在<code>runtime-core</code>的<code>scheduler</code>文件</p>
<ul>
<li><p>API</p>
<pre><code class="highlight ts"><span class="comment">// 这个文件会抛出以下几个API函数</span>
<span class="title function_">nextTick</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 将函数在任务队列清空后执行</span>
<span class="title function_">queueJob</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加任务并开始执行任务队列</span>
<span class="title function_">invalidateJob</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 删除任务</span>
<span class="title function_">queuePreFlushCb</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加前置回调函数并开始执行任务队列</span>
<span class="title function_">queuePostFlushCb</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 添加后置回调函数并开始执行任务队列</span>
<span class="title function_">flushPreFlushCbs</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 执行前置回调函数</span>
<span class="title function_">flushPostFlushCbs</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 执行后置回调函数</span></code></pre></li>
<li><p>我们首先要知道几个关键变量</p>
<pre><code class="highlight ts"><span class="keyword">let</span> isFlushing = <span class="literal">false</span> <span class="comment">// 是否正在清空任务队列</span>
<span class="keyword">let</span> isFlushPending = <span class="literal">false</span> <span class="comment">// 清队任务已创建，等待清空状态</span>
<span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">SchedulerJob</span>[] = [] <span class="comment">// 任务队列</span>
<span class="keyword">let</span> flushIndex = <span class="number">0</span> <span class="comment">// 当前正在执行的任务在任务队列中的索引</span></code></pre></li>
<li><p>然后我们从<code>queueJob</code>这个函数开始</p>
<pre><code class="highlight ts"><span class="comment">/* </span>
<span class="comment">  这个函数主要是将一个任务进行入队操作</span>
<span class="comment">  然后在满足条件的情况下启动queueFlush</span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueJob</span>(<span class="params">job: SchedulerJob</span>) &#123;
    <span class="comment">/**</span>
<span class="comment">     * 任务可入队逻辑</span>
<span class="comment">     * 1. 任务队列为空</span>
<span class="comment">     * 2. 待入队任务不能存在于任务队列中(按情况分析)</span>
<span class="comment">     */</span>
    <span class="keyword">if</span> (
      (!queue.<span class="property">length</span> ||
        !queue.<span class="title function_">includes</span>(
          job,
          <span class="comment">/* </span>
<span class="comment">            在正在清空队列且当前待入队任务是可以递归时，</span>
<span class="comment">            说明当前任务一定和当前正在执行任务是同一任务，所以+1，</span>
<span class="comment">            就是为了保证待入队任务和正在执行任务相同，但不能和后面待执行任务相同</span>
<span class="comment">           */</span>
          isFlushing &amp;&amp; job.<span class="property">allowRecurse</span> ? flushIndex + <span class="number">1</span> : flushIndex
        )) &amp;&amp;
      job !== currentPreFlushParentJob
    ) &#123;
      <span class="comment">// 二分查找任务在队列中的位置</span>
      <span class="keyword">const</span> pos = <span class="title function_">findInsertionIndex</span>(job)
      <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;
        queue.<span class="title function_">splice</span>(pos, <span class="number">0</span>, job)
      &#125; <span class="keyword">else</span> &#123;
        queue.<span class="title function_">push</span>(job)
      &#125;
      <span class="title function_">queueFlush</span>()
    &#125;
&#125;</code></pre>
</li>
<li><p><code>queueFlush</code></p>
<pre><code class="highlight ts"><span class="keyword">function</span> <span class="title function_">queueFlush</span>(<span class="params"></span>) &#123;
    <span class="comment">/**</span>
<span class="comment">      清队任务创建后禁止再次创建更多的清队任务</span>
<span class="comment">      因为在入队操作完成后，flushJobs会在一次递归中将任务队列全部清空，所以只需要一次清队任务即可</span>
<span class="comment">     */</span>
    <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;
      isFlushPending = <span class="literal">true</span>
      <span class="comment">/* </span>
<span class="comment">        清队任务创建成功，并记录下当前清队任务，这个标记可以用于nextTick创建自定义函数，</span>
<span class="comment">        说明nextTick的执行时机是在清队任务后的，其实从这个地方就可以理解nextTick的执行原理了</span>
<span class="comment">      */</span>
      currentFlushPromise = resolvedPromise.<span class="title function_">then</span>(flushJobs)
    &#125;
&#125;</code></pre>
</li>
<li><p><code>flushJobs</code></p>
<pre><code class="highlight ts"><span class="comment">// 清空任务队列</span>
<span class="keyword">function</span> <span class="title function_">flushJobs</span>(<span class="params">seen?: CountMap</span>) &#123;
    isFlushPending = <span class="literal">false</span> <span class="comment">// 关闭清队任务等待状态</span>
    isFlushing = <span class="literal">true</span> <span class="comment">// 开启正在清空队列状态</span>
    <span class="keyword">if</span> (__DEV__) &#123;
      seen = seen || <span class="keyword">new</span> <span class="title class_">Map</span>()
    &#125;

    <span class="comment">// 清空前置回调任务队列</span>
    <span class="title function_">flushPreFlushCbs</span>(seen)

    <span class="comment">/* </span>
<span class="comment">      任务队列中的任务根据ID进行排序的原因</span>
<span class="comment">        1. 因为组件更新是从父组件到子组件的，而任务更新是在数据源更新时触发的，所以为了更新任务的顺序就需要进行排序</span>
<span class="comment">        2. 如果在父组件更新期间已经卸载了组件，那么子组件的更新任务就可以跳过</span>
<span class="comment">    */</span>
    queue.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">getId</span>(a) - <span class="title function_">getId</span>(b))

    <span class="keyword">try</span> &#123;
      <span class="comment">// 遍历任务队列</span>
      <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.<span class="property">length</span>; flushIndex++) &#123;
        <span class="keyword">const</span> job = queue[flushIndex]
        <span class="keyword">if</span> (job &amp;&amp; job.<span class="property">active</span> !== <span class="literal">false</span>) &#123;
          <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="title function_">checkRecursiveUpdates</span>(seen!, job)) &#123;
            <span class="keyword">continue</span>
          &#125;
          <span class="comment">// 执行当前任务</span>
          <span class="title function_">callWithErrorHandling</span>(job, <span class="literal">null</span>, <span class="title class_">ErrorCodes</span>.<span class="property">SCHEDULER</span>)
        &#125;
      &#125;
    &#125; <span class="keyword">finally</span> &#123;
      <span class="comment">// 重置当前任务索引</span>
      flushIndex = <span class="number">0</span>
      <span class="comment">// 清空任务队列</span>
      queue.<span class="property">length</span> = <span class="number">0</span>

      <span class="comment">// 执行后置回调任务队列</span>
      <span class="title function_">flushPostFlushCbs</span>(seen)
        <span class="comment">// 重置清队任务的状态</span>
      isFlushing = <span class="literal">false</span>
      currentFlushPromise = <span class="literal">null</span>
      <span class="comment">/* </span>
<span class="comment">        因为清队任务执行期间也会有任务入队，所以为了清队执行完成</span>
<span class="comment">        就需要判断各任务队列的长度，然后递归执行</span>
<span class="comment">      */</span>
      <span class="keyword">if</span> (
        queue.<span class="property">length</span> ||
        pendingPreFlushCbs.<span class="property">length</span> ||
        pendingPostFlushCbs.<span class="property">length</span>
      ) &#123;
        <span class="title function_">flushJobs</span>(seen)
      &#125;
    &#125;
&#125;</code></pre></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>nextTick的执行时机是在任务队列(前置、主任务、后置)清除后的，<code>currentFlushPromise</code>是清队任务的promise标记</li>
<li>任务队列执行顺序：执行前置回调任务队列 -&gt; 执行主任务队列 -&gt; 执行后置回调任务队列</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>解析Vue3patch核心算法patchKeyedChildren</title>
    <url>/2022/08/25/%E8%A7%A3%E6%9E%90Vue3patch%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95patchKeyedChildren/</url>
    <content><![CDATA[<h3 id="解析Vue3patch核心算法patchKeyedChildren"><a href="#解析Vue3patch核心算法patchKeyedChildren" class="headerlink" title="解析Vue3patch核心算法patchKeyedChildren"></a>解析Vue3patch核心算法patchKeyedChildren</h3><ul>
<li>locate：<code>runtime-core &gt; renderer &gt; baseCreateRenderer &gt; patchKeyedChildren</code></li>
<li>patchKeyedChildren是patch算法中较为复杂的一段，更是vue技术栈面试的高频点，最初我是在vue3.0 beta版本时大概看过源码，后来在《vue设计与分析》中看了霍春阳大佬的解析，本篇就简要分析一下做个记录</li>
<li>首先patchKeyedChildren是在子列表对比并且有key的情况会进入，并且逻辑大致分为5步，这个看源码官方注释就可以看出</li>
</ul>
<h4 id="第一步，从前向后遍历"><a href="#第一步，从前向后遍历" class="headerlink" title="第一步，从前向后遍历"></a>第一步，从前向后遍历</h4><p>这一步是从节点组头部向尾部遍历，如果遍历过程中遇到相似节点，就进行patch对比，否则就退出遍历，并记录当前遍历的最新下标</p>
<pre><code class="highlight js"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
  <span class="keyword">const</span> n1 = c1[i]
  <span class="keyword">const</span> n2 = (c2[i] = optimized
    ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)
    : <span class="title function_">normalizeVNode</span>(c2[i]))
  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;
    <span class="title function_">patch</span>(
      n1,
      n2,
      container,
      <span class="literal">null</span>,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">break</span>
  &#125;
  i++
&#125;</code></pre>

<h4 id="第二步，从后向前遍历"><a href="#第二步，从后向前遍历" class="headerlink" title="第二步，从后向前遍历"></a>第二步，从后向前遍历</h4><p>从后向前遍历，如果遇到第一步记录的下标就停止，然后遍历过程中，如果遇到相似节点也是直接进行patch对比，如果不相同就是直接退出遍历，并且记录旧节点组和新节点组的尾指针</p>
<pre><code class="highlight js"><span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;
  <span class="keyword">const</span> n1 = c1[e1]
  <span class="keyword">const</span> n2 = (c2[e2] = optimized
    ? <span class="title function_">cloneIfMounted</span>(c2[e2] <span class="keyword">as</span> <span class="title class_">VNode</span>)
    : <span class="title function_">normalizeVNode</span>(c2[e2]))
  <span class="keyword">if</span> (<span class="title function_">isSameVNodeType</span>(n1, n2)) &#123;
    <span class="title function_">patch</span>(
      n1,
      n2,
      container,
      <span class="literal">null</span>,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">break</span>
  &#125;
  e1--
  e2--
&#125;</code></pre>

<h4 id="第三步，检查旧节点组"><a href="#第三步，检查旧节点组" class="headerlink" title="第三步，检查旧节点组"></a>第三步，检查旧节点组</h4><p>这一步就是检查旧节点组在上两步的遍历后是否遍历完，如果遍历完，那么新节点组没有遍历完的就都是新的dom，可以全部当作新增节点进行挂载处理</p>
<pre><code class="highlight js"><span class="keyword">if</span> (i &gt; e1) &#123;
  <span class="keyword">if</span> (i &lt;= e2) &#123;
    <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span>
    <span class="keyword">const</span> anchor = nextPos &lt; l2 ? (c2[nextPos] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor
    <span class="keyword">while</span> (i &lt;= e2) &#123;
      <span class="comment">// patch第一个参数为null，就是代表没有旧节点，直接将新节点插入</span>
      <span class="title function_">patch</span>(
        <span class="literal">null</span>,
        (c2[i] = optimized
          ? <span class="title function_">cloneIfMounted</span>(c2[i] <span class="keyword">as</span> <span class="title class_">VNode</span>)
          : <span class="title function_">normalizeVNode</span>(c2[i])),
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      )
      i++
    &#125;
  &#125;
&#125;</code></pre>

<h4 id="第四步，检查新节点组"><a href="#第四步，检查新节点组" class="headerlink" title="第四步，检查新节点组"></a>第四步，检查新节点组</h4><p>如果上一步检查旧节点未遍历完，那么就检查新节点组是否遍历完，如果遍历完，那么旧的节点组剩余的节点说明都是要卸载的，因为都不需要了</p>
<pre><code class="highlight js"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;
  <span class="comment">// 旧子节点未被遍历完</span>
  <span class="keyword">while</span> (i &lt;= e1) &#123;
    <span class="title function_">unmount</span>(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>)
    i++
  &#125;
&#125;</code></pre>

<h4 id="第五步，未知序列"><a href="#第五步，未知序列" class="headerlink" title="第五步，未知序列"></a>第五步，未知序列</h4><ul>
<li>如果新旧节点组都未遍历完，说明存在未知序列，可能存在位移等情况，就需要进一步处理</li>
<li>首先创建一个数组，用于记录新旧节点的对应关系<pre><code class="highlight js"><span class="comment">// toBePatched是新序列的节点数量 e2 - s2 + 1</span>
<span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="title class_">Array</span>(toBePatched)
<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = <span class="number">0</span></code></pre></li>
<li>然后会遍历旧节点组，这里会用两个变量记录<ul>
<li><code>let moved = false</code>：位移标识，用于判断是否需要位移</li>
<li><code>let patched = 0</code>：记录已执行patch的新节点数量，用于处理如果在更新时更新过的数量大于需要更新的节点数量，就卸载对应旧节点<pre><code class="highlight js"><span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;
  <span class="keyword">const</span> prevChild = c1[i]
  <span class="comment">// 如果已更新数量大于新节点数量，就卸载节点</span>
  <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;
    <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)
    <span class="keyword">continue</span>
  &#125;
  <span class="keyword">let</span> newIndex <span class="comment">//新旧节点key相同的新节点index</span>
  <span class="keyword">if</span> (prevChild.<span class="property">key</span> != <span class="literal">null</span>) &#123;
    newIndex = keyToNewIndexMap.<span class="title function_">get</span>(prevChild.<span class="property">key</span>)
  &#125; <span class="keyword">else</span> &#123;
    <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;
      <span class="keyword">if</span> (
        newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp;
        <span class="title function_">isSameVNodeType</span>(prevChild, c2[j] <span class="keyword">as</span> <span class="title class_">VNode</span>)
      ) &#123;
        newIndex = j
        <span class="keyword">break</span>
      &#125;
    &#125;
  &#125;
  <span class="comment">// 如果newIndex为空，则说明未找到与旧节点对应的新节点，直接卸载</span>
  <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;
    <span class="title function_">unmount</span>(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)
  &#125; <span class="keyword">else</span> &#123;
    <span class="comment">// 更新新旧节点关系表</span>
    newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span>
    <span class="comment">/**</span>
<span class="comment">     * 这里的maxNexIndexSoFar是记录每次patch最大index</span>
<span class="comment">     * 也是用于判断是否产生了位移，因为如果新节点index比最大index小，就说明发生了位移</span>
<span class="comment">     * 例如：</span>
<span class="comment">     *  (a b) c</span>
<span class="comment">     *  (a c  b)</span>
<span class="comment">     * 在新旧序列对比b，c时，由于c最新的newIndex已经小于b对应的newIndex，因此会记录需要位移</span>
<span class="comment">     */</span>
    <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;
      maxNewIndexSoFar = newIndex
    &#125; <span class="keyword">else</span> &#123;
      moved = <span class="literal">true</span>
    &#125;
    <span class="title function_">patch</span>(
      prevChild,
      c2[newIndex] <span class="keyword">as</span> <span class="title class_">VNode</span>,
      container,
      <span class="literal">null</span>,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
    patched++
  &#125;
&#125;</code></pre></li>
</ul>
</li>
<li>遍历完旧序列后，就需要确定如何位移</li>
<li>首先是根据新旧节点关系表生成最长递增子序列(这个算法就不陈述了，较复杂，可以看<a href="https://juejin.cn/post/6952674285311754276#comment">精读《DOM diff 最长上升子序列》</a>)，然后倒序遍历新子节点<pre><code class="highlight js"><span class="comment">// 最长递增子序列</span>
<span class="keyword">const</span> increasingNewIndexSequence = moved
  ? <span class="title function_">getSequence</span>(newIndexToOldIndexMap)
  : <span class="variable constant_">EMPTY_ARR</span>
j = increasingNewIndexSequence.<span class="property">length</span> - <span class="number">1</span>
<span class="comment">// 从新序列尾部向前遍历，目的是为了使用上一个遍历的节点做锚点</span>
<span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;
  <span class="keyword">const</span> nextIndex = s2 + i
  <span class="keyword">const</span> nextChild = c2[nextIndex] <span class="keyword">as</span> <span class="title class_">VNode</span>
  <span class="comment">// 如果是序列的最后一个节点，anchor就是父节点对应的anchor，否则就是上一个子节点</span>
  <span class="keyword">const</span> anchor =
    nextIndex + <span class="number">1</span> &lt; l2 ? (c2[nextIndex + <span class="number">1</span>] <span class="keyword">as</span> <span class="title class_">VNode</span>).<span class="property">el</span> : parentAnchor
  <span class="comment">// 如果newIndexToOldIndexMap[i]还是0，那么说明新节点没有对应的旧节点，说明是新节点，直接挂载</span>
  <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;
    <span class="title function_">patch</span>(
      <span class="literal">null</span>,
      nextChild,
      container,
      anchor,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;
    <span class="comment">// 然后在moved为true的情况下，如果最长子序列为空或者最长子序列和当前访问的新节点index不同，说明就需要进行位移</span>
    <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;
      <span class="title function_">move</span>(nextChild, container, anchor, <span class="title class_">MoveType</span>.<span class="property">REORDER</span>)
    &#125; <span class="keyword">else</span> &#123;
      j--
    &#125;
  &#125;
&#125;</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>颜色选择器的纯JS实现</title>
    <url>/2022/11/05/%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E7%BA%AFJS%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在逛论坛的时候发现了一个新API：<code>EyeDropper</code>，仅需创建一个实例，然后调用open方法，就可以取到你屏幕内所有可以取到的颜色，可惜兼容性不太行，只有Chrome，Edge，Opera支持，<a href="https://developer.mozilla.org/en-US/docs/Web/API/EyeDropper">MDN文档</a><br>知道了这个API后我也有了一个想实现取色器的想法，工作摸鱼期间👻折腾了几天搞了出来，实现步骤大致以下几步</p>
<ol>
<li>所需页面创建实例，初始化所需属性</li>
<li>需开启时调用open方法开启取色器，网页截屏生成canvas，初始化监听事件和浮动元素(放大镜)</li>
<li>鼠标移动时根据坐标获取颜色数据修改放大镜颜色</li>
<li>鼠标点击或者按Esc键后销毁</li>
</ol>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>预览地址：<a href="https://songlh.top/page-color-picker/">https://songlh.top/page-color-picker/</a><br>github：<a href="https://github.com/LHRUN/page-color-picker">https://github.com/LHRUN/page-color-picker</a><br><img src="https://s1.ax1x.com/2022/11/05/xOoXo4.png"></p>
<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>初始化方法没什么说的，就是把需要的属性和方法赋值一遍初始值，然后接收一个鼠标点击时的回调</p>
<pre><code class="highlight ts"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ColorPicker</span> &#123;
  <span class="attr">canvasContainer</span>: <span class="title class_">HTMLDivElement</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">// canvas容器元素</span>
  <span class="attr">canvas</span>: <span class="title class_">HTMLCanvasElement</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">// 截屏canvas</span>
  <span class="attr">context</span>: <span class="title class_">CanvasRenderingContext2D</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">// 截屏canvas[context]</span>
  <span class="attr">floatContainer</span>: <span class="title class_">HTMLDivElement</span> | <span class="literal">null</span> = <span class="literal">null</span> <span class="comment">// 鼠标移动时的浮动容器元素</span>
  onChange?: <span class="function">(<span class="params">color: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> <span class="comment">// 点击鼠标后的回调</span>
  color = <span class="string">&#x27;&#x27;</span> <span class="comment">// 颜色值</span>
  elementId = <span class="string">&#x27;&#x27;</span> <span class="comment">// 元素唯一id</span>
  <span class="attr">colorArr</span>: &#123;
    <span class="attr">el</span>: <span class="title class_">HTMLDivElement</span>
    <span class="attr">row</span>: <span class="built_in">number</span>
    <span class="attr">col</span>: <span class="built_in">number</span>
  &#125;[] = [] <span class="comment">// 放大镜颜色数组</span>

  <span class="title function_">constructor</span>(<span class="params"></span>
<span class="params">    onChange?: (color: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span> <span class="comment">// 点击后回调</span></span>
<span class="params">  </span>) &#123;
    <span class="variable language_">this</span>.<span class="property">onChange</span> = onChange
  &#125;
  <span class="comment">// ...</span>
&#125;</code></pre>

<h2 id="开启取色器"><a href="#开启取色器" class="headerlink" title="开启取色器"></a>开启取色器</h2><p>开启取色器分为4步</p>
<ol>
<li>初始化canvas容器</li>
<li>生成canvas，我使用的是<a href="https://www.npmjs.com/package/html2canvas">html2canvas</a></li>
<li>初始化监听事件</li>
<li>创建浮动元素</li>
</ol>
<pre><code class="highlight js"><span class="comment">/**</span>
<span class="comment">* 开启取色器</span>
<span class="comment">*/</span>
<span class="title function_">open</span>(<span class="params"></span>) &#123;
  <span class="comment">// 获取随机id</span>
  <span class="variable language_">this</span>.<span class="property">elementId</span> = <span class="title function_">getId</span>()
  <span class="comment">// 初始化canvas容器</span>
  <span class="variable language_">this</span>.<span class="title function_">initContainer</span>()
  <span class="title function_">html2canvas</span>(<span class="variable language_">document</span>.<span class="property">body</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">canvas</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (canvas &amp;&amp; <span class="variable language_">this</span>.<span class="property">canvasContainer</span>) &#123;
      <span class="comment">// 初始化事件</span>
      <span class="variable language_">this</span>.<span class="title function_">initEvent</span>(canvas)
      <span class="variable language_">this</span>.<span class="property">canvasContainer</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>
      <span class="variable language_">this</span>.<span class="property">canvasContainer</span>.<span class="title function_">appendChild</span>(canvas)
      <span class="variable language_">this</span>.<span class="property">canvas</span> = canvas
      <span class="variable language_">this</span>.<span class="property">context</span> = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)
      <span class="comment">// 创建浮动元素</span>
      <span class="variable language_">this</span>.<span class="title function_">initFloatContainer</span>()
    &#125;
  &#125;)
&#125;</code></pre>
<ul>
<li><p>初始化canvas容器</p>
<pre><code class="highlight ts"><span class="title function_">initContainer</span>(<span class="params"></span>) &#123;
  <span class="comment">// 创建元素我封装了一个方法</span>
  <span class="keyword">const</span> canvasContainer = <span class="title function_">createDocument</span>(
    <span class="string">&#x27;div&#x27;</span>,
    styleObj.<span class="property">canvasContainer</span>,
    <span class="variable language_">document</span>.<span class="property">body</span>
  )
  <span class="variable language_">this</span>.<span class="property">canvasContainer</span> = canvasContainer
  <span class="keyword">return</span> canvasContainer
&#125;

<span class="comment">/**</span>
<span class="comment"> * 创建元素</span>
<span class="comment"> * <span class="doctag">@param</span> elType 元素类型</span>
<span class="comment"> * <span class="doctag">@param</span> styleObj 样式对象</span>
<span class="comment"> * <span class="doctag">@param</span> parent 父级元素</span>
<span class="comment"> * <span class="doctag">@returns</span> <span class="variable">element</span></span>
<span class="comment"> */</span>
<span class="keyword">export</span> <span class="keyword">const</span> createDocument = &lt;T <span class="keyword">extends</span> keyof <span class="title class_">HTMLElementTagNameMap</span>&gt;(
  <span class="attr">elType</span>: T,
  <span class="attr">styleObj</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span> | <span class="built_in">number</span>&gt;,
  <span class="attr">parent</span>: <span class="title class_">HTMLElement</span> | <span class="title class_">DocumentFragment</span>
): <span class="title class_">HTMLElementTagNameMap</span>[T] =&gt; &#123;
  <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(elType)
  <span class="title class_">Object</span>.<span class="title function_">keys</span>(styleObj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;
    <span class="keyword">if</span> (<span class="title function_">isValidKey</span>(key, styleObj)) &#123;
      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(el.<span class="property">style</span>, key, styleObj[key])
    &#125;
  &#125;)
  parent.<span class="title function_">appendChild</span>(el)
  <span class="keyword">return</span> el
&#125;</code></pre>
</li>
<li><p>初始化事件</p>
<pre><code class="highlight ts"><span class="comment">/**</span>
<span class="comment"> * 初始化事件</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">canvas</span></span>
<span class="comment"> */</span>
<span class="title function_">initEvent</span>(<span class="params">canvas: HTMLCanvasElement</span>) &#123;
  canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">canvasMouseMove</span>)
  canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">canvasMouseDown</span>)
  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onKeyDown</span>)
&#125;</code></pre>
</li>
<li><p>创建浮动元素容器</p>
<pre><code class="highlight js"><span class="title function_">initFloatCOntainer</span>(<span class="params"></span>) &#123;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">canvasContainer</span>) &#123;
    <span class="comment">// 创建浮动元素容器</span>
    <span class="keyword">const</span> floatContainer = <span class="title function_">createDocument</span>(
      <span class="string">&#x27;div&#x27;</span>,
      styleObj.<span class="property">floatContainer</span>,
      <span class="variable language_">this</span>.<span class="property">canvasContainer</span>
    )

    <span class="comment">// 创建放大镜的小颜色块</span>
    <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="variable constant_">COLOR_ITEM_SIZE</span> * <span class="variable constant_">COLOR_ITEM_SIZE</span>; i++) &#123;
      <span class="keyword">const</span> row = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(i / <span class="variable constant_">COLOR_ITEM_SIZE</span>)
      <span class="keyword">const</span> col = i - (row - <span class="number">1</span>) * <span class="variable constant_">COLOR_ITEM_SIZE</span>
      <span class="keyword">const</span> <span class="attr">style</span>: <span class="title class_">Record</span>&lt;string, string | number&gt; = &#123;
        ...styleObj.<span class="property">colorItem</span>
      &#125;

      <span class="keyword">if</span> (row === <span class="number">6</span> &amp;&amp; col === <span class="number">6</span>) &#123;
        style.<span class="property">borderColor</span> = <span class="string">&#x27;#000000&#x27;</span>
      &#125;
      <span class="keyword">const</span> itemEl = <span class="title function_">createDocument</span>(<span class="string">&#x27;div&#x27;</span>, style, fragment)
      itemEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.elementId&#125;</span><span class="subst">$&#123;i&#125;</span>`</span>)
      <span class="variable language_">this</span>.<span class="property">colorArr</span>.<span class="title function_">push</span>(&#123;
        <span class="attr">el</span>: itemEl,
        row,
        col
      &#125;)
    &#125;
    floatContainer.<span class="title function_">appendChild</span>(fragment)
    <span class="keyword">const</span> textEl = <span class="title function_">createDocument</span>(<span class="string">&#x27;div&#x27;</span>, styleObj.<span class="property">text</span>, floatContainer)
    textEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.elementId&#125;</span>text`</span>)
    <span class="variable language_">this</span>.<span class="property">floatContainer</span> = floatContainer
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="鼠标移动"><a href="#鼠标移动" class="headerlink" title="鼠标移动"></a>鼠标移动</h2><ul>
<li>根据鼠标移动时的坐标，计算需要处理的颜色区域，然后调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/getImageData">CanvasRenderingContext2D.getImageData()</a>方法，这个方法会返回一个ImageData对象，这个对象里就包含RGBA数据，然后把这些数据展示到放大镜元素上，就有了放大的效果<pre><code class="highlight ts">canvasMouseMove = <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> &#123;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">context</span>) &#123;
    <span class="keyword">const</span> x = e.<span class="property">pageX</span> * <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>
    <span class="keyword">const</span> y = e.<span class="property">pageY</span> * <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span>
    <span class="comment">// 获取放大镜所需区域颜色</span>
    <span class="keyword">const</span> colors = <span class="variable language_">this</span>.<span class="title function_">getColors</span>(x, y)
    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">floatContainer</span> &amp;&amp; colors) &#123;
      <span class="comment">// 根据坐标改变放大镜位置</span>
      <span class="variable language_">this</span>.<span class="property">floatContainer</span>.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate(<span class="subst">$&#123;e.pageX - <span class="number">82.5</span>&#125;</span>px, <span class="subst">$&#123;</span></span>
<span class="subst"><span class="string">        e.pageY - <span class="number">82.5</span></span></span>
<span class="subst"><span class="string">      &#125;</span>px )`</span>
      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">floatContainer</span>.<span class="property">style</span>.<span class="property">visibility</span> === <span class="string">&#x27;hidden&#x27;</span>) &#123;
        <span class="variable language_">this</span>.<span class="property">floatContainer</span>.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&#x27;visible&#x27;</span>
      &#125;
      <span class="keyword">const</span> textEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.elementId&#125;</span>text`</span>)

      <span class="comment">// 遍历每个颜色块，修改颜色</span>
      <span class="keyword">for</span> (
        <span class="keyword">let</span> i = <span class="number">0</span>;
        i &lt; <span class="variable constant_">COLOR_ITEM_SIZE</span> * <span class="variable constant_">COLOR_ITEM_SIZE</span>;
        i++
      ) &#123;
        <span class="keyword">const</span> &#123; el, row, col &#125; = <span class="variable language_">this</span>.<span class="property">colorArr</span>[i]
        <span class="keyword">const</span> [r, g, b, a] = colors[i]
        <span class="comment">// toHexString rgba转16进制</span>
        <span class="keyword">const</span> hexStr = <span class="title function_">toHexString</span>(&#123; r, g, b, <span class="attr">a</span>: a / <span class="number">255</span> &#125;)

        <span class="comment">//  最中间的颜色保存起来</span>
        <span class="keyword">if</span> (row === <span class="number">6</span> &amp;&amp; col === <span class="number">6</span> &amp;&amp; textEl) &#123;
          textEl.<span class="property">textContent</span> = hexStr
          textEl.<span class="property">style</span>.<span class="property">color</span> = hexStr
          <span class="variable language_">this</span>.<span class="property">color</span> = hexStr
        &#125;

        el.<span class="property">style</span>.<span class="property">backgroundColor</span> = hexStr
      &#125;
    &#125;
  &#125;
&#125;

<span class="comment">/**</span>
<span class="comment"> * 获取放大镜所需区域颜色</span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">x</span></span>
<span class="comment"> * <span class="doctag">@param</span> <span class="variable">y</span></span>
<span class="comment"> * <span class="doctag">@returns</span></span>
<span class="comment"> */</span>
<span class="title function_">getColors</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">context</span>) &#123;
    <span class="keyword">const</span> &#123; data &#125; = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">getImageData</span>(
      x - <span class="number">5</span>,
      y - <span class="number">5</span>,
      <span class="variable constant_">COLOR_ITEM_SIZE</span>,
      <span class="variable constant_">COLOR_ITEM_SIZE</span>
    )
    <span class="keyword">const</span> colors = []
    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;
      colors.<span class="title function_">push</span>([data[i], data[i + <span class="number">1</span>], data[i + <span class="number">2</span>], data[i + <span class="number">3</span>]])
    &#125;
    <span class="keyword">return</span> colors
  &#125;
&#125;</code></pre></li>
</ul>
<h2 id="鼠标点击"><a href="#鼠标点击" class="headerlink" title="鼠标点击"></a>鼠标点击</h2><ul>
<li>鼠标点击触发回调，销毁元素<pre><code class="highlight ts">canvasMouseDown = <span class="function">() =&gt;</span> &#123;
  <span class="variable language_">this</span>?.<span class="property">onChange</span>?.(<span class="variable language_">this</span>.<span class="property">color</span>)
  <span class="variable language_">this</span>.<span class="title function_">destroy</span>()
&#125;

<span class="title function_">destroy</span>(<span class="params"></span>) &#123;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">canvas</span>) &#123;
    <span class="variable language_">this</span>.<span class="property">canvas</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">canvasMouseMove</span>)
    <span class="variable language_">this</span>.<span class="property">canvas</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">canvasMouseDown</span>)
  &#125;
  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">canvasContainer</span>) &#123;
    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(<span class="variable language_">this</span>.<span class="property">canvasContainer</span>)
  &#125;
  <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onKeyDown</span>)
&#125;</code></pre></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有问题欢迎讨论👻</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>👋 Hello there, Here is LH’BLOG<br>👨‍💻 I’m a Frontend Developer. I like to try new technologies and develop some interesting open source projects<br>📜 I will write some tech blogs and life records<br>🌱 I’m currently learning english</p>
<h3 id="contact-me"><a href="#contact-me" class="headerlink" title="contact me"></a>contact me</h3><ul>
<li><a href="https://github.com/LHRUN">Github</a></li>
<li><a href="https://t.me/longhao_song">Telegram</a></li>
<li><a href="mailto:song.lhlh@gmail.com">song.lhlh@gmail.com</a><!-- + [SegmentFault](https://segmentfault.com/u/lh_s)</li>
<li><a href="https://blog.csdn.net/weixin_44719258">CSDN</a> </li>
<li><a href="https://juejin.cn/user/3949101499549518">掘金</a></li>
<li><a href="https://www.zhihu.com/people/wxae77cceaa49dcaf5">知乎</a> –&gt;</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>&#39;tag&#39;</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
